{"version":3,"sources":["../../../src/utils/dir.ts"],"sourcesContent":["import fs from 'fs';\nimport path from 'path';\n\nexport function fileExistsSync(file: string): boolean {\n  return !!fs\n    .statSync(file, {\n      throwIfNoEntry: false,\n    })\n    ?.isFile();\n}\n\nexport function directoryExistsSync(file: string): boolean {\n  return !!fs\n    .statSync(file, {\n      throwIfNoEntry: false,\n    })\n    ?.isDirectory();\n}\n\nexport async function directoryExistsAsync(file: string): Promise<boolean> {\n  return (await fs.promises.stat(file).catch(() => null))?.isDirectory() ?? false;\n}\n\nexport async function fileExistsAsync(file: string): Promise<boolean> {\n  return (await fs.promises.stat(file).catch(() => null))?.isFile() ?? false;\n}\n\nexport const ensureDirectoryAsync = (path: string) => fs.promises.mkdir(path, { recursive: true });\n\nexport const ensureDirectory = (path: string): void => {\n  fs.mkdirSync(path, {\n    recursive: true,\n  });\n};\n\nexport const copySync = (src: string, dest: string): void => {\n  const destParent = path.dirname(dest);\n  if (!fs.existsSync(destParent)) ensureDirectory(destParent);\n  fs.cpSync(src, dest, {\n    recursive: true,\n    force: true,\n  });\n};\n\nexport const copyAsync = async (src: string, dest: string): Promise<void> => {\n  const destParent = path.dirname(dest);\n  if (!fs.existsSync(destParent)) {\n    await fs.promises.mkdir(destParent, { recursive: true });\n  }\n  await fs.promises.cp(src, dest, {\n    recursive: true,\n    force: true,\n  });\n};\n\nexport const removeAsync = (path: string): Promise<void> => {\n  return fs.promises.rm(path, {\n    recursive: true,\n    force: true,\n  });\n};\n\nexport function isPathInside(child: string, parent: string): boolean {\n  const relative = path.relative(parent, child);\n  return !!relative && !relative.startsWith('..') && !path.isAbsolute(relative);\n}\n"],"names":["copyAsync","copySync","directoryExistsAsync","directoryExistsSync","ensureDirectory","ensureDirectoryAsync","fileExistsAsync","fileExistsSync","isPathInside","removeAsync","file","fs","statSync","throwIfNoEntry","isFile","isDirectory","promises","stat","catch","path","mkdir","recursive","mkdirSync","src","dest","destParent","dirname","existsSync","cpSync","force","cp","rm","child","parent","relative","startsWith","isAbsolute"],"mappings":";;;;;;;;;;;IA4CaA,SAAS;eAATA;;IATAC,QAAQ;eAARA;;IAhBSC,oBAAoB;eAApBA;;IARNC,mBAAmB;eAAnBA;;IAkBHC,eAAe;eAAfA;;IAFAC,oBAAoB;eAApBA;;IAJSC,eAAe;eAAfA;;IApBNC,cAAc;eAAdA;;IA2DAC,YAAY;eAAZA;;IAPHC,WAAW;eAAXA;;;;gEAvDE;;;;;;;gEACE;;;;;;;;;;;AAEV,SAASF,eAAeG,IAAY;QAChCC;IAAT,OAAO,CAAC,GAACA,eAAAA,aAAE,CACRC,QAAQ,CAACF,MAAM;QACdG,gBAAgB;IAClB,uBAHOF,aAILG,MAAM;AACZ;AAEO,SAASX,oBAAoBO,IAAY;QACrCC;IAAT,OAAO,CAAC,GAACA,eAAAA,aAAE,CACRC,QAAQ,CAACF,MAAM;QACdG,gBAAgB;IAClB,uBAHOF,aAILI,WAAW;AACjB;AAEO,eAAeb,qBAAqBQ,IAAY;QAC7C;IAAR,OAAO,EAAC,QAAA,MAAMC,aAAE,CAACK,QAAQ,CAACC,IAAI,CAACP,MAAMQ,KAAK,CAAC,IAAM,0BAA1C,AAAC,MAAiDH,WAAW,OAAM;AAC5E;AAEO,eAAeT,gBAAgBI,IAAY;QACxC;IAAR,OAAO,EAAC,QAAA,MAAMC,aAAE,CAACK,QAAQ,CAACC,IAAI,CAACP,MAAMQ,KAAK,CAAC,IAAM,0BAA1C,AAAC,MAAiDJ,MAAM,OAAM;AACvE;AAEO,MAAMT,uBAAuB,CAACc,OAAiBR,aAAE,CAACK,QAAQ,CAACI,KAAK,CAACD,MAAM;QAAEE,WAAW;IAAK;AAEzF,MAAMjB,kBAAkB,CAACe;IAC9BR,aAAE,CAACW,SAAS,CAACH,MAAM;QACjBE,WAAW;IACb;AACF;AAEO,MAAMpB,WAAW,CAACsB,KAAaC;IACpC,MAAMC,aAAaN,eAAI,CAACO,OAAO,CAACF;IAChC,IAAI,CAACb,aAAE,CAACgB,UAAU,CAACF,aAAarB,gBAAgBqB;IAChDd,aAAE,CAACiB,MAAM,CAACL,KAAKC,MAAM;QACnBH,WAAW;QACXQ,OAAO;IACT;AACF;AAEO,MAAM7B,YAAY,OAAOuB,KAAaC;IAC3C,MAAMC,aAAaN,eAAI,CAACO,OAAO,CAACF;IAChC,IAAI,CAACb,aAAE,CAACgB,UAAU,CAACF,aAAa;QAC9B,MAAMd,aAAE,CAACK,QAAQ,CAACI,KAAK,CAACK,YAAY;YAAEJ,WAAW;QAAK;IACxD;IACA,MAAMV,aAAE,CAACK,QAAQ,CAACc,EAAE,CAACP,KAAKC,MAAM;QAC9BH,WAAW;QACXQ,OAAO;IACT;AACF;AAEO,MAAMpB,cAAc,CAACU;IAC1B,OAAOR,aAAE,CAACK,QAAQ,CAACe,EAAE,CAACZ,MAAM;QAC1BE,WAAW;QACXQ,OAAO;IACT;AACF;AAEO,SAASrB,aAAawB,KAAa,EAAEC,MAAc;IACxD,MAAMC,WAAWf,eAAI,CAACe,QAAQ,CAACD,QAAQD;IACvC,OAAO,CAAC,CAACE,YAAY,CAACA,SAASC,UAAU,CAAC,SAAS,CAAChB,eAAI,CAACiB,UAAU,CAACF;AACtE"}