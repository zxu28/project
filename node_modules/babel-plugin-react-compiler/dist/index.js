/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @lightSyntaxTransform
 * @noflow
 * @nolint
 * @preventMunge
 * @preserve-invariant-messages
 */
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __pow = Math.pow;
var __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key2 of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key2) && key2 !== except)
        __defProp(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc(from, key2)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key2, value) => __defNormalProp(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet(obj, member, value, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var __await = function(promise, isYieldStar) {
  this[0] = promise;
  this[1] = isYieldStar;
};
var __yieldStar = (value) => {
  var obj = value[__knownSymbol("asyncIterator")], isAwait = false, method, it = {};
  if (obj == null) {
    obj = value[__knownSymbol("iterator")]();
    method = (k) => it[k] = (x) => obj[k](x);
  } else {
    obj = obj.call(value);
    method = (k) => it[k] = (v) => {
      if (isAwait) {
        isAwait = false;
        if (k === "throw") throw v;
        return v;
      }
      isAwait = true;
      return {
        done: false,
        value: new __await(new Promise((resolve) => {
          var x = obj[k](v);
          if (!(x instanceof Object)) __typeError("Object expected");
          resolve(x);
        }), 1)
      };
    };
  }
  return it[__knownSymbol("iterator")] = () => it, method("next"), "throw" in obj ? method("throw") : it.throw = (x) => {
    throw x;
  }, "return" in obj && method("return"), it;
};

// node_modules/@babel/helpers/node_modules/@babel/traverse/lib/path/lib/virtual-types.js
var require_virtual_types = __commonJS({
  "node_modules/@babel/helpers/node_modules/@babel/traverse/lib/path/lib/virtual-types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Var = exports2.User = exports2.Statement = exports2.SpreadProperty = exports2.Scope = exports2.RestProperty = exports2.ReferencedMemberExpression = exports2.ReferencedIdentifier = exports2.Referenced = exports2.Pure = exports2.NumericLiteralTypeAnnotation = exports2.Generated = exports2.ForAwaitStatement = exports2.Flow = exports2.Expression = exports2.ExistentialTypeParam = exports2.BlockScoped = exports2.BindingIdentifier = void 0;
    var ReferencedIdentifier = exports2.ReferencedIdentifier = ["Identifier", "JSXIdentifier"];
    var ReferencedMemberExpression = exports2.ReferencedMemberExpression = ["MemberExpression"];
    var BindingIdentifier = exports2.BindingIdentifier = ["Identifier"];
    var Statement = exports2.Statement = ["Statement"];
    var Expression = exports2.Expression = ["Expression"];
    var Scope = exports2.Scope = ["Scopable", "Pattern"];
    var Referenced = exports2.Referenced = null;
    var BlockScoped = exports2.BlockScoped = null;
    var Var = exports2.Var = ["VariableDeclaration"];
    var User = exports2.User = null;
    var Generated = exports2.Generated = null;
    var Pure = exports2.Pure = null;
    var Flow = exports2.Flow = ["Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier"];
    var RestProperty = exports2.RestProperty = ["RestElement"];
    var SpreadProperty = exports2.SpreadProperty = ["RestElement"];
    var ExistentialTypeParam = exports2.ExistentialTypeParam = ["ExistsTypeAnnotation"];
    var NumericLiteralTypeAnnotation = exports2.NumericLiteralTypeAnnotation = ["NumberLiteralTypeAnnotation"];
    var ForAwaitStatement = exports2.ForAwaitStatement = ["ForOfStatement"];
  }
});

// ../../node_modules/ms/index.js
var require_ms = __commonJS({
  "../../node_modules/ms/index.js"(exports2, module2) {
    "use strict";
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse4(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse4(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// ../../node_modules/debug/src/common.js
var require_common = __commonJS({
  "../../node_modules/debug/src/common.js"(exports2, module2) {
    "use strict";
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce2;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key2) => {
        createDebug[key2] = env[key2];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(" ", ",").split(",").filter(Boolean);
        for (const ns of split) {
          if (ns[0] === "-") {
            createDebug.skips.push(ns.slice(1));
          } else {
            createDebug.names.push(ns);
          }
        }
      }
      function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      function disable() {
        const namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        for (const skip of createDebug.skips) {
          if (matchesTemplate(name, skip)) {
            return false;
          }
        }
        for (const ns of createDebug.names) {
          if (matchesTemplate(name, ns)) {
            return true;
          }
        }
        return false;
      }
      function coerce2(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// ../../node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "../../node_modules/debug/src/browser.js"(exports2, module2) {
    "use strict";
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c2 = "color: " + this.color;
      args.splice(1, 0, c2, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c2);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// ../../node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "../../node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// ../../node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "../../node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag();
    var { env } = process;
    var flagForceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      flagForceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      flagForceColor = 1;
    }
    function envForceColor() {
      if ("FORCE_COLOR" in env) {
        if (env.FORCE_COLOR === "true") {
          return 1;
        }
        if (env.FORCE_COLOR === "false") {
          return 0;
        }
        return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
      const noFlagForceColor = envForceColor();
      if (noFlagForceColor !== void 0) {
        flagForceColor = noFlagForceColor;
      }
      const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
      if (forceColor === 0) {
        return 0;
      }
      if (sniffFlags) {
        if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
          return 3;
        }
        if (hasFlag("color=256")) {
          return 2;
        }
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE", "DRONE"].some((sign2) => sign2 in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version = Number.parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream, options = {}) {
      const level = supportsColor(stream, __spreadValues({
        streamIsTTY: stream && stream.isTTY
      }, options));
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: getSupportLevel({ isTTY: tty.isatty(1) }),
      stderr: getSupportLevel({ isTTY: tty.isatty(2) })
    };
  }
});

// ../../node_modules/debug/src/node.js
var require_node = __commonJS({
  "../../node_modules/debug/src/node.js"(exports2, module2) {
    "use strict";
    var tty = require("tty");
    var util3 = require("util");
    exports2.init = init;
    exports2.log = log2;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util3.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key2) => {
      return /^debug_/i.test(key2);
    }).reduce((obj, key2) => {
      const prop = key2.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key2];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c2 = this.color;
        const colorCode = "\x1B[3" + (c2 < 8 ? c2 : "8;5;" + c2);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log2(...args) {
      return process.stderr.write(util3.formatWithOptions(exports2.inspectOpts, ...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util3.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util3.inspect(v, this.inspectOpts);
    };
  }
});

// ../../node_modules/debug/src/index.js
var require_src = __commonJS({
  "../../node_modules/debug/src/index.js"(exports2, module2) {
    "use strict";
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// node_modules/@babel/helpers/node_modules/@babel/traverse/lib/path/lib/virtual-types-validator.js
var require_virtual_types_validator = __commonJS({
  "node_modules/@babel/helpers/node_modules/@babel/traverse/lib/path/lib/virtual-types-validator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isBindingIdentifier = isBindingIdentifier;
    exports2.isBlockScoped = isBlockScoped;
    exports2.isExpression = isExpression2;
    exports2.isFlow = isFlow;
    exports2.isForAwaitStatement = isForAwaitStatement;
    exports2.isGenerated = isGenerated;
    exports2.isPure = isPure;
    exports2.isReferenced = isReferenced;
    exports2.isReferencedIdentifier = isReferencedIdentifier;
    exports2.isReferencedMemberExpression = isReferencedMemberExpression;
    exports2.isRestProperty = isRestProperty;
    exports2.isScope = isScope;
    exports2.isSpreadProperty = isSpreadProperty;
    exports2.isStatement = isStatement2;
    exports2.isUser = isUser;
    exports2.isVar = isVar;
    var _t = require("@babel/types");
    var {
      isBinding,
      isBlockScoped: nodeIsBlockScoped,
      isExportDeclaration,
      isExpression: nodeIsExpression,
      isFlow: nodeIsFlow,
      isForStatement,
      isForXStatement,
      isIdentifier,
      isImportDeclaration,
      isImportSpecifier,
      isJSXIdentifier,
      isJSXMemberExpression,
      isMemberExpression: isMemberExpression2,
      isRestElement: nodeIsRestElement,
      isReferenced: nodeIsReferenced,
      isScope: nodeIsScope,
      isStatement: nodeIsStatement,
      isVar: nodeIsVar,
      isVariableDeclaration: isVariableDeclaration2,
      react,
      isForOfStatement
    } = _t;
    var {
      isCompatTag
    } = react;
    function isReferencedIdentifier(opts) {
      const {
        node,
        parent
      } = this;
      if (!isIdentifier(node, opts) && !isJSXMemberExpression(parent, opts)) {
        if (isJSXIdentifier(node, opts)) {
          if (isCompatTag(node.name)) return false;
        } else {
          return false;
        }
      }
      return nodeIsReferenced(node, parent, this.parentPath.parent);
    }
    function isReferencedMemberExpression() {
      const {
        node,
        parent
      } = this;
      return isMemberExpression2(node) && nodeIsReferenced(node, parent);
    }
    function isBindingIdentifier() {
      const {
        node,
        parent
      } = this;
      const grandparent = this.parentPath.parent;
      return isIdentifier(node) && isBinding(node, parent, grandparent);
    }
    function isStatement2() {
      const {
        node,
        parent
      } = this;
      if (nodeIsStatement(node)) {
        if (isVariableDeclaration2(node)) {
          if (isForXStatement(parent, {
            left: node
          })) return false;
          if (isForStatement(parent, {
            init: node
          })) return false;
        }
        return true;
      } else {
        return false;
      }
    }
    function isExpression2() {
      if (this.isIdentifier()) {
        return this.isReferencedIdentifier();
      } else {
        return nodeIsExpression(this.node);
      }
    }
    function isScope() {
      return nodeIsScope(this.node, this.parent);
    }
    function isReferenced() {
      return nodeIsReferenced(this.node, this.parent);
    }
    function isBlockScoped() {
      return nodeIsBlockScoped(this.node);
    }
    function isVar() {
      return nodeIsVar(this.node);
    }
    function isUser() {
      return this.node && !!this.node.loc;
    }
    function isGenerated() {
      return !this.isUser();
    }
    function isPure(constantsOnly) {
      return this.scope.isPure(this.node, constantsOnly);
    }
    function isFlow() {
      const {
        node
      } = this;
      if (nodeIsFlow(node)) {
        return true;
      } else if (isImportDeclaration(node)) {
        return node.importKind === "type" || node.importKind === "typeof";
      } else if (isExportDeclaration(node)) {
        return node.exportKind === "type";
      } else if (isImportSpecifier(node)) {
        return node.importKind === "type" || node.importKind === "typeof";
      } else {
        return false;
      }
    }
    function isRestProperty() {
      var _this$parentPath;
      return nodeIsRestElement(this.node) && ((_this$parentPath = this.parentPath) == null ? void 0 : _this$parentPath.isObjectPattern());
    }
    function isSpreadProperty() {
      var _this$parentPath2;
      return nodeIsRestElement(this.node) && ((_this$parentPath2 = this.parentPath) == null ? void 0 : _this$parentPath2.isObjectExpression());
    }
    function isForAwaitStatement() {
      return isForOfStatement(this.node, {
        await: true
      });
    }
    {
      exports2.isExistentialTypeParam = function isExistentialTypeParam() {
        throw new Error("`path.isExistentialTypeParam` has been renamed to `path.isExistsTypeAnnotation()` in Babel 7.");
      };
      exports2.isNumericLiteralTypeAnnotation = function isNumericLiteralTypeAnnotation() {
        throw new Error("`path.isNumericLiteralTypeAnnotation()` has been renamed to `path.isNumberLiteralTypeAnnotation()` in Babel 7.");
      };
    }
  }
});

// node_modules/@babel/helpers/node_modules/@babel/traverse/lib/visitors.js
var require_visitors = __commonJS({
  "node_modules/@babel/helpers/node_modules/@babel/traverse/lib/visitors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.environmentVisitor = environmentVisitor;
    exports2.explode = explode$1;
    exports2.isExplodedVisitor = isExplodedVisitor;
    exports2.merge = merge3;
    exports2.verify = verify$1;
    var virtualTypes = require_virtual_types();
    var virtualTypesValidators = require_virtual_types_validator();
    var _t = require("@babel/types");
    var _context3 = require_context2();
    var {
      DEPRECATED_KEYS,
      DEPRECATED_ALIASES,
      FLIPPED_ALIAS_KEYS,
      TYPES,
      __internal__deprecationWarning: deprecationWarning
    } = _t;
    function isVirtualType(type) {
      return type in virtualTypes;
    }
    function isExplodedVisitor(visitor) {
      return visitor == null ? void 0 : visitor._exploded;
    }
    function explode$1(visitor) {
      if (isExplodedVisitor(visitor)) return visitor;
      visitor._exploded = true;
      for (const nodeType of Object.keys(visitor)) {
        if (shouldIgnoreKey(nodeType)) continue;
        const parts = nodeType.split("|");
        if (parts.length === 1) continue;
        const fns = visitor[nodeType];
        delete visitor[nodeType];
        for (const part of parts) {
          visitor[part] = fns;
        }
      }
      verify$1(visitor);
      delete visitor.__esModule;
      ensureEntranceObjects(visitor);
      ensureCallbackArrays(visitor);
      for (const nodeType of Object.keys(visitor)) {
        if (shouldIgnoreKey(nodeType)) continue;
        if (!isVirtualType(nodeType)) continue;
        const fns = visitor[nodeType];
        for (const type of Object.keys(fns)) {
          fns[type] = wrapCheck(nodeType, fns[type]);
        }
        delete visitor[nodeType];
        const types = virtualTypes[nodeType];
        if (types !== null) {
          for (const type of types) {
            if (visitor[type]) {
              mergePair(visitor[type], fns);
            } else {
              visitor[type] = fns;
            }
          }
        } else {
          mergePair(visitor, fns);
        }
      }
      for (const nodeType of Object.keys(visitor)) {
        if (shouldIgnoreKey(nodeType)) continue;
        let aliases = FLIPPED_ALIAS_KEYS[nodeType];
        if (nodeType in DEPRECATED_KEYS) {
          const deprecatedKey = DEPRECATED_KEYS[nodeType];
          deprecationWarning(nodeType, deprecatedKey, "Visitor ");
          aliases = [deprecatedKey];
        } else if (nodeType in DEPRECATED_ALIASES) {
          const deprecatedAlias = DEPRECATED_ALIASES[nodeType];
          deprecationWarning(nodeType, deprecatedAlias, "Visitor ");
          aliases = FLIPPED_ALIAS_KEYS[deprecatedAlias];
        }
        if (!aliases) continue;
        const fns = visitor[nodeType];
        delete visitor[nodeType];
        for (const alias of aliases) {
          const existing = visitor[alias];
          if (existing) {
            mergePair(existing, fns);
          } else {
            visitor[alias] = Object.assign({}, fns);
          }
        }
      }
      for (const nodeType of Object.keys(visitor)) {
        if (shouldIgnoreKey(nodeType)) continue;
        ensureCallbackArrays(visitor[nodeType]);
      }
      return visitor;
    }
    function verify$1(visitor) {
      if (visitor._verified) return;
      if (typeof visitor === "function") {
        throw new Error("You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Function }`?");
      }
      for (const nodeType of Object.keys(visitor)) {
        if (nodeType === "enter" || nodeType === "exit") {
          validateVisitorMethods(nodeType, visitor[nodeType]);
        }
        if (shouldIgnoreKey(nodeType)) continue;
        if (!TYPES.includes(nodeType)) {
          throw new Error(`You gave us a visitor for the node type ${nodeType} but it's not a valid type in @babel/traverse ${"7.26.4"}`);
        }
        const visitors = visitor[nodeType];
        if (typeof visitors === "object") {
          for (const visitorKey of Object.keys(visitors)) {
            if (visitorKey === "enter" || visitorKey === "exit") {
              validateVisitorMethods(`${nodeType}.${visitorKey}`, visitors[visitorKey]);
            } else {
              throw new Error(`You passed \`traverse()\` a visitor object with the property ${nodeType} that has the invalid property ${visitorKey}`);
            }
          }
        }
      }
      visitor._verified = true;
    }
    function validateVisitorMethods(path, val) {
      const fns = [].concat(val);
      for (const fn of fns) {
        if (typeof fn !== "function") {
          throw new TypeError(`Non-function found defined in ${path} with type ${typeof fn}`);
        }
      }
    }
    function merge3(visitors, states = [], wrapper) {
      const mergedVisitor = {
        _verified: true,
        _exploded: true
      };
      {
        Object.defineProperty(mergedVisitor, "_exploded", {
          enumerable: false
        });
        Object.defineProperty(mergedVisitor, "_verified", {
          enumerable: false
        });
      }
      for (let i = 0; i < visitors.length; i++) {
        const visitor = explode$1(visitors[i]);
        const state = states[i];
        let topVisitor = visitor;
        if (state || wrapper) {
          topVisitor = wrapWithStateOrWrapper(topVisitor, state, wrapper);
        }
        mergePair(mergedVisitor, topVisitor);
        for (const key2 of Object.keys(visitor)) {
          if (shouldIgnoreKey(key2)) continue;
          let typeVisitor = visitor[key2];
          if (state || wrapper) {
            typeVisitor = wrapWithStateOrWrapper(typeVisitor, state, wrapper);
          }
          const nodeVisitor = mergedVisitor[key2] || (mergedVisitor[key2] = {});
          mergePair(nodeVisitor, typeVisitor);
        }
      }
      return mergedVisitor;
    }
    function wrapWithStateOrWrapper(oldVisitor, state, wrapper) {
      const newVisitor = {};
      for (const phase of ["enter", "exit"]) {
        let fns = oldVisitor[phase];
        if (!Array.isArray(fns)) continue;
        fns = fns.map(function(fn) {
          let newFn = fn;
          if (state) {
            newFn = function(path) {
              fn.call(state, path, state);
            };
          }
          if (wrapper) {
            newFn = wrapper(state == null ? void 0 : state.key, phase, newFn);
          }
          if (newFn !== fn) {
            newFn.toString = () => fn.toString();
          }
          return newFn;
        });
        newVisitor[phase] = fns;
      }
      return newVisitor;
    }
    function ensureEntranceObjects(obj) {
      for (const key2 of Object.keys(obj)) {
        if (shouldIgnoreKey(key2)) continue;
        const fns = obj[key2];
        if (typeof fns === "function") {
          obj[key2] = {
            enter: fns
          };
        }
      }
    }
    function ensureCallbackArrays(obj) {
      if (obj.enter && !Array.isArray(obj.enter)) obj.enter = [obj.enter];
      if (obj.exit && !Array.isArray(obj.exit)) obj.exit = [obj.exit];
    }
    function wrapCheck(nodeType, fn) {
      const fnKey = `is${nodeType}`;
      const validator = virtualTypesValidators[fnKey];
      const newFn = function(path) {
        if (validator.call(path)) {
          return fn.apply(this, arguments);
        }
      };
      newFn.toString = () => fn.toString();
      return newFn;
    }
    function shouldIgnoreKey(key2) {
      if (key2[0] === "_") return true;
      if (key2 === "enter" || key2 === "exit" || key2 === "shouldSkip") return true;
      if (key2 === "denylist" || key2 === "noScope" || key2 === "skipKeys") {
        return true;
      }
      {
        if (key2 === "blacklist") {
          return true;
        }
      }
      return false;
    }
    function mergePair(dest, src) {
      for (const phase of ["enter", "exit"]) {
        if (!src[phase]) continue;
        dest[phase] = [].concat(dest[phase] || [], src[phase]);
      }
    }
    var _environmentVisitor = {
      FunctionParent(path) {
        if (path.isArrowFunctionExpression()) return;
        path.skip();
        if (path.isMethod()) {
          if (!path.requeueComputedKeyAndDecorators) {
            _context3.requeueComputedKeyAndDecorators.call(path);
          } else {
            path.requeueComputedKeyAndDecorators();
          }
        }
      },
      Property(path) {
        if (path.isObjectProperty()) return;
        path.skip();
        if (!path.requeueComputedKeyAndDecorators) {
          _context3.requeueComputedKeyAndDecorators.call(path);
        } else {
          path.requeueComputedKeyAndDecorators();
        }
      }
    };
    function environmentVisitor(visitor) {
      return merge3([_environmentVisitor, visitor]);
    }
  }
});

// node_modules/@babel/helpers/node_modules/@babel/traverse/lib/scope/lib/renamer.js
var require_renamer = __commonJS({
  "node_modules/@babel/helpers/node_modules/@babel/traverse/lib/scope/lib/renamer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var t6 = require("@babel/types");
    var _t = t6;
    var _traverseNode = require_traverse_node();
    var _visitors = require_visitors();
    var _context3 = require_context2();
    var {
      getAssignmentIdentifiers
    } = _t;
    var renameVisitor = {
      ReferencedIdentifier({
        node
      }, state) {
        if (node.name === state.oldName) {
          node.name = state.newName;
        }
      },
      Scope(path, state) {
        if (!path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {
          path.skip();
          if (path.isMethod()) {
            if (!path.requeueComputedKeyAndDecorators) {
              _context3.requeueComputedKeyAndDecorators.call(path);
            } else {
              path.requeueComputedKeyAndDecorators();
            }
          }
        }
      },
      ObjectProperty({
        node,
        scope
      }, state) {
        const {
          name
        } = node.key;
        if (node.shorthand && (name === state.oldName || name === state.newName) && scope.getBindingIdentifier(name) === state.binding.identifier) {
          node.shorthand = false;
          {
            var _node$extra;
            if ((_node$extra = node.extra) != null && _node$extra.shorthand) node.extra.shorthand = false;
          }
        }
      },
      "AssignmentExpression|Declaration|VariableDeclarator"(path, state) {
        if (path.isVariableDeclaration()) return;
        const ids = path.isAssignmentExpression() ? getAssignmentIdentifiers(path.node) : path.getOuterBindingIdentifiers();
        for (const name in ids) {
          if (name === state.oldName) ids[name].name = state.newName;
        }
      }
    };
    var Renamer = class {
      constructor(binding, oldName, newName) {
        this.newName = newName;
        this.oldName = oldName;
        this.binding = binding;
      }
      maybeConvertFromExportDeclaration(parentDeclar) {
        const maybeExportDeclar = parentDeclar.parentPath;
        if (!maybeExportDeclar.isExportDeclaration()) {
          return;
        }
        if (maybeExportDeclar.isExportDefaultDeclaration()) {
          const {
            declaration
          } = maybeExportDeclar.node;
          if (t6.isDeclaration(declaration) && !declaration.id) {
            return;
          }
        }
        if (maybeExportDeclar.isExportAllDeclaration()) {
          return;
        }
        maybeExportDeclar.splitExportDeclaration();
      }
      maybeConvertFromClassFunctionDeclaration(path) {
        return path;
      }
      maybeConvertFromClassFunctionExpression(path) {
        return path;
      }
      rename() {
        const {
          binding,
          oldName,
          newName
        } = this;
        const {
          scope,
          path
        } = binding;
        const parentDeclar = path.find((path2) => path2.isDeclaration() || path2.isFunctionExpression() || path2.isClassExpression());
        if (parentDeclar) {
          const bindingIds = parentDeclar.getOuterBindingIdentifiers();
          if (bindingIds[oldName] === binding.identifier) {
            this.maybeConvertFromExportDeclaration(parentDeclar);
          }
        }
        const blockToTraverse = arguments[0] || scope.block;
        const skipKeys = {
          discriminant: true
        };
        if (t6.isMethod(blockToTraverse)) {
          if (blockToTraverse.computed) {
            skipKeys.key = true;
          }
          if (!t6.isObjectMethod(blockToTraverse)) {
            skipKeys.decorators = true;
          }
        }
        (0, _traverseNode.traverseNode)(blockToTraverse, (0, _visitors.explode)(renameVisitor), scope, this, scope.path, skipKeys);
        if (!arguments[0]) {
          scope.removeOwnBinding(oldName);
          scope.bindings[newName] = binding;
          this.binding.identifier.name = newName;
        }
        if (parentDeclar) {
          this.maybeConvertFromClassFunctionDeclaration(path);
          this.maybeConvertFromClassFunctionExpression(path);
        }
      }
    };
    exports2.default = Renamer;
  }
});

// node_modules/@babel/helpers/node_modules/@babel/traverse/lib/scope/binding.js
var require_binding = __commonJS({
  "node_modules/@babel/helpers/node_modules/@babel/traverse/lib/scope/binding.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var Binding = class {
      constructor({
        identifier: identifier4,
        scope,
        path,
        kind
      }) {
        this.identifier = void 0;
        this.scope = void 0;
        this.path = void 0;
        this.kind = void 0;
        this.constantViolations = [];
        this.constant = true;
        this.referencePaths = [];
        this.referenced = false;
        this.references = 0;
        this.identifier = identifier4;
        this.scope = scope;
        this.path = path;
        this.kind = kind;
        if ((kind === "var" || kind === "hoisted") && isDeclaredInLoop(path)) {
          this.reassign(path);
        }
        this.clearValue();
      }
      deoptValue() {
        this.clearValue();
        this.hasDeoptedValue = true;
      }
      setValue(value) {
        if (this.hasDeoptedValue) return;
        this.hasValue = true;
        this.value = value;
      }
      clearValue() {
        this.hasDeoptedValue = false;
        this.hasValue = false;
        this.value = null;
      }
      reassign(path) {
        this.constant = false;
        if (this.constantViolations.includes(path)) {
          return;
        }
        this.constantViolations.push(path);
      }
      reference(path) {
        if (this.referencePaths.includes(path)) {
          return;
        }
        this.referenced = true;
        this.references++;
        this.referencePaths.push(path);
      }
      dereference() {
        this.references--;
        this.referenced = !!this.references;
      }
    };
    exports2.default = Binding;
    function isDeclaredInLoop(path) {
      for (let {
        parentPath,
        key: key2
      } = path; parentPath; {
        parentPath,
        key: key2
      } = parentPath) {
        if (parentPath.isFunctionParent()) return false;
        if (parentPath.isWhile() || parentPath.isForXStatement() || parentPath.isForStatement() && key2 === "body") {
          return true;
        }
      }
      return false;
    }
  }
});

// ../../node_modules/globals/globals.json
var require_globals = __commonJS({
  "../../node_modules/globals/globals.json"(exports2, module2) {
    module2.exports = {
      builtin: {
        Array: false,
        ArrayBuffer: false,
        Atomics: false,
        BigInt: false,
        BigInt64Array: false,
        BigUint64Array: false,
        Boolean: false,
        constructor: false,
        DataView: false,
        Date: false,
        decodeURI: false,
        decodeURIComponent: false,
        encodeURI: false,
        encodeURIComponent: false,
        Error: false,
        escape: false,
        eval: false,
        EvalError: false,
        Float32Array: false,
        Float64Array: false,
        Function: false,
        globalThis: false,
        hasOwnProperty: false,
        Infinity: false,
        Int16Array: false,
        Int32Array: false,
        Int8Array: false,
        isFinite: false,
        isNaN: false,
        isPrototypeOf: false,
        JSON: false,
        Map: false,
        Math: false,
        NaN: false,
        Number: false,
        Object: false,
        parseFloat: false,
        parseInt: false,
        Promise: false,
        propertyIsEnumerable: false,
        Proxy: false,
        RangeError: false,
        ReferenceError: false,
        Reflect: false,
        RegExp: false,
        Set: false,
        SharedArrayBuffer: false,
        String: false,
        Symbol: false,
        SyntaxError: false,
        toLocaleString: false,
        toString: false,
        TypeError: false,
        Uint16Array: false,
        Uint32Array: false,
        Uint8Array: false,
        Uint8ClampedArray: false,
        undefined: false,
        unescape: false,
        URIError: false,
        valueOf: false,
        WeakMap: false,
        WeakSet: false
      },
      es5: {
        Array: false,
        Boolean: false,
        constructor: false,
        Date: false,
        decodeURI: false,
        decodeURIComponent: false,
        encodeURI: false,
        encodeURIComponent: false,
        Error: false,
        escape: false,
        eval: false,
        EvalError: false,
        Function: false,
        hasOwnProperty: false,
        Infinity: false,
        isFinite: false,
        isNaN: false,
        isPrototypeOf: false,
        JSON: false,
        Math: false,
        NaN: false,
        Number: false,
        Object: false,
        parseFloat: false,
        parseInt: false,
        propertyIsEnumerable: false,
        RangeError: false,
        ReferenceError: false,
        RegExp: false,
        String: false,
        SyntaxError: false,
        toLocaleString: false,
        toString: false,
        TypeError: false,
        undefined: false,
        unescape: false,
        URIError: false,
        valueOf: false
      },
      es2015: {
        Array: false,
        ArrayBuffer: false,
        Boolean: false,
        constructor: false,
        DataView: false,
        Date: false,
        decodeURI: false,
        decodeURIComponent: false,
        encodeURI: false,
        encodeURIComponent: false,
        Error: false,
        escape: false,
        eval: false,
        EvalError: false,
        Float32Array: false,
        Float64Array: false,
        Function: false,
        hasOwnProperty: false,
        Infinity: false,
        Int16Array: false,
        Int32Array: false,
        Int8Array: false,
        isFinite: false,
        isNaN: false,
        isPrototypeOf: false,
        JSON: false,
        Map: false,
        Math: false,
        NaN: false,
        Number: false,
        Object: false,
        parseFloat: false,
        parseInt: false,
        Promise: false,
        propertyIsEnumerable: false,
        Proxy: false,
        RangeError: false,
        ReferenceError: false,
        Reflect: false,
        RegExp: false,
        Set: false,
        String: false,
        Symbol: false,
        SyntaxError: false,
        toLocaleString: false,
        toString: false,
        TypeError: false,
        Uint16Array: false,
        Uint32Array: false,
        Uint8Array: false,
        Uint8ClampedArray: false,
        undefined: false,
        unescape: false,
        URIError: false,
        valueOf: false,
        WeakMap: false,
        WeakSet: false
      },
      es2017: {
        Array: false,
        ArrayBuffer: false,
        Atomics: false,
        Boolean: false,
        constructor: false,
        DataView: false,
        Date: false,
        decodeURI: false,
        decodeURIComponent: false,
        encodeURI: false,
        encodeURIComponent: false,
        Error: false,
        escape: false,
        eval: false,
        EvalError: false,
        Float32Array: false,
        Float64Array: false,
        Function: false,
        hasOwnProperty: false,
        Infinity: false,
        Int16Array: false,
        Int32Array: false,
        Int8Array: false,
        isFinite: false,
        isNaN: false,
        isPrototypeOf: false,
        JSON: false,
        Map: false,
        Math: false,
        NaN: false,
        Number: false,
        Object: false,
        parseFloat: false,
        parseInt: false,
        Promise: false,
        propertyIsEnumerable: false,
        Proxy: false,
        RangeError: false,
        ReferenceError: false,
        Reflect: false,
        RegExp: false,
        Set: false,
        SharedArrayBuffer: false,
        String: false,
        Symbol: false,
        SyntaxError: false,
        toLocaleString: false,
        toString: false,
        TypeError: false,
        Uint16Array: false,
        Uint32Array: false,
        Uint8Array: false,
        Uint8ClampedArray: false,
        undefined: false,
        unescape: false,
        URIError: false,
        valueOf: false,
        WeakMap: false,
        WeakSet: false
      },
      browser: {
        AbortController: false,
        AbortSignal: false,
        addEventListener: false,
        alert: false,
        AnalyserNode: false,
        Animation: false,
        AnimationEffectReadOnly: false,
        AnimationEffectTiming: false,
        AnimationEffectTimingReadOnly: false,
        AnimationEvent: false,
        AnimationPlaybackEvent: false,
        AnimationTimeline: false,
        applicationCache: false,
        ApplicationCache: false,
        ApplicationCacheErrorEvent: false,
        atob: false,
        Attr: false,
        Audio: false,
        AudioBuffer: false,
        AudioBufferSourceNode: false,
        AudioContext: false,
        AudioDestinationNode: false,
        AudioListener: false,
        AudioNode: false,
        AudioParam: false,
        AudioProcessingEvent: false,
        AudioScheduledSourceNode: false,
        "AudioWorkletGlobalScope ": false,
        AudioWorkletNode: false,
        AudioWorkletProcessor: false,
        BarProp: false,
        BaseAudioContext: false,
        BatteryManager: false,
        BeforeUnloadEvent: false,
        BiquadFilterNode: false,
        Blob: false,
        BlobEvent: false,
        blur: false,
        BroadcastChannel: false,
        btoa: false,
        BudgetService: false,
        ByteLengthQueuingStrategy: false,
        Cache: false,
        caches: false,
        CacheStorage: false,
        cancelAnimationFrame: false,
        cancelIdleCallback: false,
        CanvasCaptureMediaStreamTrack: false,
        CanvasGradient: false,
        CanvasPattern: false,
        CanvasRenderingContext2D: false,
        ChannelMergerNode: false,
        ChannelSplitterNode: false,
        CharacterData: false,
        clearInterval: false,
        clearTimeout: false,
        clientInformation: false,
        ClipboardEvent: false,
        close: false,
        closed: false,
        CloseEvent: false,
        Comment: false,
        CompositionEvent: false,
        confirm: false,
        console: false,
        ConstantSourceNode: false,
        ConvolverNode: false,
        CountQueuingStrategy: false,
        createImageBitmap: false,
        Credential: false,
        CredentialsContainer: false,
        crypto: false,
        Crypto: false,
        CryptoKey: false,
        CSS: false,
        CSSConditionRule: false,
        CSSFontFaceRule: false,
        CSSGroupingRule: false,
        CSSImportRule: false,
        CSSKeyframeRule: false,
        CSSKeyframesRule: false,
        CSSMediaRule: false,
        CSSNamespaceRule: false,
        CSSPageRule: false,
        CSSRule: false,
        CSSRuleList: false,
        CSSStyleDeclaration: false,
        CSSStyleRule: false,
        CSSStyleSheet: false,
        CSSSupportsRule: false,
        CustomElementRegistry: false,
        customElements: false,
        CustomEvent: false,
        DataTransfer: false,
        DataTransferItem: false,
        DataTransferItemList: false,
        defaultstatus: false,
        defaultStatus: false,
        DelayNode: false,
        DeviceMotionEvent: false,
        DeviceOrientationEvent: false,
        devicePixelRatio: false,
        dispatchEvent: false,
        document: false,
        Document: false,
        DocumentFragment: false,
        DocumentType: false,
        DOMError: false,
        DOMException: false,
        DOMImplementation: false,
        DOMMatrix: false,
        DOMMatrixReadOnly: false,
        DOMParser: false,
        DOMPoint: false,
        DOMPointReadOnly: false,
        DOMQuad: false,
        DOMRect: false,
        DOMRectReadOnly: false,
        DOMStringList: false,
        DOMStringMap: false,
        DOMTokenList: false,
        DragEvent: false,
        DynamicsCompressorNode: false,
        Element: false,
        ErrorEvent: false,
        event: false,
        Event: false,
        EventSource: false,
        EventTarget: false,
        external: false,
        fetch: false,
        File: false,
        FileList: false,
        FileReader: false,
        find: false,
        focus: false,
        FocusEvent: false,
        FontFace: false,
        FontFaceSetLoadEvent: false,
        FormData: false,
        frameElement: false,
        frames: false,
        GainNode: false,
        Gamepad: false,
        GamepadButton: false,
        GamepadEvent: false,
        getComputedStyle: false,
        getSelection: false,
        HashChangeEvent: false,
        Headers: false,
        history: false,
        History: false,
        HTMLAllCollection: false,
        HTMLAnchorElement: false,
        HTMLAreaElement: false,
        HTMLAudioElement: false,
        HTMLBaseElement: false,
        HTMLBodyElement: false,
        HTMLBRElement: false,
        HTMLButtonElement: false,
        HTMLCanvasElement: false,
        HTMLCollection: false,
        HTMLContentElement: false,
        HTMLDataElement: false,
        HTMLDataListElement: false,
        HTMLDetailsElement: false,
        HTMLDialogElement: false,
        HTMLDirectoryElement: false,
        HTMLDivElement: false,
        HTMLDListElement: false,
        HTMLDocument: false,
        HTMLElement: false,
        HTMLEmbedElement: false,
        HTMLFieldSetElement: false,
        HTMLFontElement: false,
        HTMLFormControlsCollection: false,
        HTMLFormElement: false,
        HTMLFrameElement: false,
        HTMLFrameSetElement: false,
        HTMLHeadElement: false,
        HTMLHeadingElement: false,
        HTMLHRElement: false,
        HTMLHtmlElement: false,
        HTMLIFrameElement: false,
        HTMLImageElement: false,
        HTMLInputElement: false,
        HTMLLabelElement: false,
        HTMLLegendElement: false,
        HTMLLIElement: false,
        HTMLLinkElement: false,
        HTMLMapElement: false,
        HTMLMarqueeElement: false,
        HTMLMediaElement: false,
        HTMLMenuElement: false,
        HTMLMetaElement: false,
        HTMLMeterElement: false,
        HTMLModElement: false,
        HTMLObjectElement: false,
        HTMLOListElement: false,
        HTMLOptGroupElement: false,
        HTMLOptionElement: false,
        HTMLOptionsCollection: false,
        HTMLOutputElement: false,
        HTMLParagraphElement: false,
        HTMLParamElement: false,
        HTMLPictureElement: false,
        HTMLPreElement: false,
        HTMLProgressElement: false,
        HTMLQuoteElement: false,
        HTMLScriptElement: false,
        HTMLSelectElement: false,
        HTMLShadowElement: false,
        HTMLSlotElement: false,
        HTMLSourceElement: false,
        HTMLSpanElement: false,
        HTMLStyleElement: false,
        HTMLTableCaptionElement: false,
        HTMLTableCellElement: false,
        HTMLTableColElement: false,
        HTMLTableElement: false,
        HTMLTableRowElement: false,
        HTMLTableSectionElement: false,
        HTMLTemplateElement: false,
        HTMLTextAreaElement: false,
        HTMLTimeElement: false,
        HTMLTitleElement: false,
        HTMLTrackElement: false,
        HTMLUListElement: false,
        HTMLUnknownElement: false,
        HTMLVideoElement: false,
        IDBCursor: false,
        IDBCursorWithValue: false,
        IDBDatabase: false,
        IDBFactory: false,
        IDBIndex: false,
        IDBKeyRange: false,
        IDBObjectStore: false,
        IDBOpenDBRequest: false,
        IDBRequest: false,
        IDBTransaction: false,
        IDBVersionChangeEvent: false,
        IdleDeadline: false,
        IIRFilterNode: false,
        Image: false,
        ImageBitmap: false,
        ImageBitmapRenderingContext: false,
        ImageCapture: false,
        ImageData: false,
        indexedDB: false,
        innerHeight: false,
        innerWidth: false,
        InputEvent: false,
        IntersectionObserver: false,
        IntersectionObserverEntry: false,
        Intl: false,
        isSecureContext: false,
        KeyboardEvent: false,
        KeyframeEffect: false,
        KeyframeEffectReadOnly: false,
        length: false,
        localStorage: false,
        location: true,
        Location: false,
        locationbar: false,
        matchMedia: false,
        MediaDeviceInfo: false,
        MediaDevices: false,
        MediaElementAudioSourceNode: false,
        MediaEncryptedEvent: false,
        MediaError: false,
        MediaKeyMessageEvent: false,
        MediaKeySession: false,
        MediaKeyStatusMap: false,
        MediaKeySystemAccess: false,
        MediaList: false,
        MediaQueryList: false,
        MediaQueryListEvent: false,
        MediaRecorder: false,
        MediaSettingsRange: false,
        MediaSource: false,
        MediaStream: false,
        MediaStreamAudioDestinationNode: false,
        MediaStreamAudioSourceNode: false,
        MediaStreamEvent: false,
        MediaStreamTrack: false,
        MediaStreamTrackEvent: false,
        menubar: false,
        MessageChannel: false,
        MessageEvent: false,
        MessagePort: false,
        MIDIAccess: false,
        MIDIConnectionEvent: false,
        MIDIInput: false,
        MIDIInputMap: false,
        MIDIMessageEvent: false,
        MIDIOutput: false,
        MIDIOutputMap: false,
        MIDIPort: false,
        MimeType: false,
        MimeTypeArray: false,
        MouseEvent: false,
        moveBy: false,
        moveTo: false,
        MutationEvent: false,
        MutationObserver: false,
        MutationRecord: false,
        name: false,
        NamedNodeMap: false,
        NavigationPreloadManager: false,
        navigator: false,
        Navigator: false,
        NetworkInformation: false,
        Node: false,
        NodeFilter: false,
        NodeIterator: false,
        NodeList: false,
        Notification: false,
        OfflineAudioCompletionEvent: false,
        OfflineAudioContext: false,
        offscreenBuffering: false,
        OffscreenCanvas: true,
        onabort: true,
        onafterprint: true,
        onanimationend: true,
        onanimationiteration: true,
        onanimationstart: true,
        onappinstalled: true,
        onauxclick: true,
        onbeforeinstallprompt: true,
        onbeforeprint: true,
        onbeforeunload: true,
        onblur: true,
        oncancel: true,
        oncanplay: true,
        oncanplaythrough: true,
        onchange: true,
        onclick: true,
        onclose: true,
        oncontextmenu: true,
        oncuechange: true,
        ondblclick: true,
        ondevicemotion: true,
        ondeviceorientation: true,
        ondeviceorientationabsolute: true,
        ondrag: true,
        ondragend: true,
        ondragenter: true,
        ondragleave: true,
        ondragover: true,
        ondragstart: true,
        ondrop: true,
        ondurationchange: true,
        onemptied: true,
        onended: true,
        onerror: true,
        onfocus: true,
        ongotpointercapture: true,
        onhashchange: true,
        oninput: true,
        oninvalid: true,
        onkeydown: true,
        onkeypress: true,
        onkeyup: true,
        onlanguagechange: true,
        onload: true,
        onloadeddata: true,
        onloadedmetadata: true,
        onloadstart: true,
        onlostpointercapture: true,
        onmessage: true,
        onmessageerror: true,
        onmousedown: true,
        onmouseenter: true,
        onmouseleave: true,
        onmousemove: true,
        onmouseout: true,
        onmouseover: true,
        onmouseup: true,
        onmousewheel: true,
        onoffline: true,
        ononline: true,
        onpagehide: true,
        onpageshow: true,
        onpause: true,
        onplay: true,
        onplaying: true,
        onpointercancel: true,
        onpointerdown: true,
        onpointerenter: true,
        onpointerleave: true,
        onpointermove: true,
        onpointerout: true,
        onpointerover: true,
        onpointerup: true,
        onpopstate: true,
        onprogress: true,
        onratechange: true,
        onrejectionhandled: true,
        onreset: true,
        onresize: true,
        onscroll: true,
        onsearch: true,
        onseeked: true,
        onseeking: true,
        onselect: true,
        onstalled: true,
        onstorage: true,
        onsubmit: true,
        onsuspend: true,
        ontimeupdate: true,
        ontoggle: true,
        ontransitionend: true,
        onunhandledrejection: true,
        onunload: true,
        onvolumechange: true,
        onwaiting: true,
        onwheel: true,
        open: false,
        openDatabase: false,
        opener: false,
        Option: false,
        origin: false,
        OscillatorNode: false,
        outerHeight: false,
        outerWidth: false,
        PageTransitionEvent: false,
        pageXOffset: false,
        pageYOffset: false,
        PannerNode: false,
        parent: false,
        Path2D: false,
        PaymentAddress: false,
        PaymentRequest: false,
        PaymentRequestUpdateEvent: false,
        PaymentResponse: false,
        performance: false,
        Performance: false,
        PerformanceEntry: false,
        PerformanceLongTaskTiming: false,
        PerformanceMark: false,
        PerformanceMeasure: false,
        PerformanceNavigation: false,
        PerformanceNavigationTiming: false,
        PerformanceObserver: false,
        PerformanceObserverEntryList: false,
        PerformancePaintTiming: false,
        PerformanceResourceTiming: false,
        PerformanceTiming: false,
        PeriodicWave: false,
        Permissions: false,
        PermissionStatus: false,
        personalbar: false,
        PhotoCapabilities: false,
        Plugin: false,
        PluginArray: false,
        PointerEvent: false,
        PopStateEvent: false,
        postMessage: false,
        Presentation: false,
        PresentationAvailability: false,
        PresentationConnection: false,
        PresentationConnectionAvailableEvent: false,
        PresentationConnectionCloseEvent: false,
        PresentationConnectionList: false,
        PresentationReceiver: false,
        PresentationRequest: false,
        print: false,
        ProcessingInstruction: false,
        ProgressEvent: false,
        PromiseRejectionEvent: false,
        prompt: false,
        PushManager: false,
        PushSubscription: false,
        PushSubscriptionOptions: false,
        queueMicrotask: false,
        RadioNodeList: false,
        Range: false,
        ReadableStream: false,
        registerProcessor: false,
        RemotePlayback: false,
        removeEventListener: false,
        Request: false,
        requestAnimationFrame: false,
        requestIdleCallback: false,
        resizeBy: false,
        ResizeObserver: false,
        ResizeObserverEntry: false,
        resizeTo: false,
        Response: false,
        RTCCertificate: false,
        RTCDataChannel: false,
        RTCDataChannelEvent: false,
        RTCDtlsTransport: false,
        RTCIceCandidate: false,
        RTCIceGatherer: false,
        RTCIceTransport: false,
        RTCPeerConnection: false,
        RTCPeerConnectionIceEvent: false,
        RTCRtpContributingSource: false,
        RTCRtpReceiver: false,
        RTCRtpSender: false,
        RTCSctpTransport: false,
        RTCSessionDescription: false,
        RTCStatsReport: false,
        RTCTrackEvent: false,
        screen: false,
        Screen: false,
        screenLeft: false,
        ScreenOrientation: false,
        screenTop: false,
        screenX: false,
        screenY: false,
        ScriptProcessorNode: false,
        scroll: false,
        scrollbars: false,
        scrollBy: false,
        scrollTo: false,
        scrollX: false,
        scrollY: false,
        SecurityPolicyViolationEvent: false,
        Selection: false,
        self: false,
        ServiceWorker: false,
        ServiceWorkerContainer: false,
        ServiceWorkerRegistration: false,
        sessionStorage: false,
        setInterval: false,
        setTimeout: false,
        ShadowRoot: false,
        SharedWorker: false,
        SourceBuffer: false,
        SourceBufferList: false,
        speechSynthesis: false,
        SpeechSynthesisEvent: false,
        SpeechSynthesisUtterance: false,
        StaticRange: false,
        status: false,
        statusbar: false,
        StereoPannerNode: false,
        stop: false,
        Storage: false,
        StorageEvent: false,
        StorageManager: false,
        styleMedia: false,
        StyleSheet: false,
        StyleSheetList: false,
        SubtleCrypto: false,
        SVGAElement: false,
        SVGAngle: false,
        SVGAnimatedAngle: false,
        SVGAnimatedBoolean: false,
        SVGAnimatedEnumeration: false,
        SVGAnimatedInteger: false,
        SVGAnimatedLength: false,
        SVGAnimatedLengthList: false,
        SVGAnimatedNumber: false,
        SVGAnimatedNumberList: false,
        SVGAnimatedPreserveAspectRatio: false,
        SVGAnimatedRect: false,
        SVGAnimatedString: false,
        SVGAnimatedTransformList: false,
        SVGAnimateElement: false,
        SVGAnimateMotionElement: false,
        SVGAnimateTransformElement: false,
        SVGAnimationElement: false,
        SVGCircleElement: false,
        SVGClipPathElement: false,
        SVGComponentTransferFunctionElement: false,
        SVGDefsElement: false,
        SVGDescElement: false,
        SVGDiscardElement: false,
        SVGElement: false,
        SVGEllipseElement: false,
        SVGFEBlendElement: false,
        SVGFEColorMatrixElement: false,
        SVGFEComponentTransferElement: false,
        SVGFECompositeElement: false,
        SVGFEConvolveMatrixElement: false,
        SVGFEDiffuseLightingElement: false,
        SVGFEDisplacementMapElement: false,
        SVGFEDistantLightElement: false,
        SVGFEDropShadowElement: false,
        SVGFEFloodElement: false,
        SVGFEFuncAElement: false,
        SVGFEFuncBElement: false,
        SVGFEFuncGElement: false,
        SVGFEFuncRElement: false,
        SVGFEGaussianBlurElement: false,
        SVGFEImageElement: false,
        SVGFEMergeElement: false,
        SVGFEMergeNodeElement: false,
        SVGFEMorphologyElement: false,
        SVGFEOffsetElement: false,
        SVGFEPointLightElement: false,
        SVGFESpecularLightingElement: false,
        SVGFESpotLightElement: false,
        SVGFETileElement: false,
        SVGFETurbulenceElement: false,
        SVGFilterElement: false,
        SVGForeignObjectElement: false,
        SVGGElement: false,
        SVGGeometryElement: false,
        SVGGradientElement: false,
        SVGGraphicsElement: false,
        SVGImageElement: false,
        SVGLength: false,
        SVGLengthList: false,
        SVGLinearGradientElement: false,
        SVGLineElement: false,
        SVGMarkerElement: false,
        SVGMaskElement: false,
        SVGMatrix: false,
        SVGMetadataElement: false,
        SVGMPathElement: false,
        SVGNumber: false,
        SVGNumberList: false,
        SVGPathElement: false,
        SVGPatternElement: false,
        SVGPoint: false,
        SVGPointList: false,
        SVGPolygonElement: false,
        SVGPolylineElement: false,
        SVGPreserveAspectRatio: false,
        SVGRadialGradientElement: false,
        SVGRect: false,
        SVGRectElement: false,
        SVGScriptElement: false,
        SVGSetElement: false,
        SVGStopElement: false,
        SVGStringList: false,
        SVGStyleElement: false,
        SVGSVGElement: false,
        SVGSwitchElement: false,
        SVGSymbolElement: false,
        SVGTextContentElement: false,
        SVGTextElement: false,
        SVGTextPathElement: false,
        SVGTextPositioningElement: false,
        SVGTitleElement: false,
        SVGTransform: false,
        SVGTransformList: false,
        SVGTSpanElement: false,
        SVGUnitTypes: false,
        SVGUseElement: false,
        SVGViewElement: false,
        TaskAttributionTiming: false,
        Text: false,
        TextDecoder: false,
        TextEncoder: false,
        TextEvent: false,
        TextMetrics: false,
        TextTrack: false,
        TextTrackCue: false,
        TextTrackCueList: false,
        TextTrackList: false,
        TimeRanges: false,
        toolbar: false,
        top: false,
        Touch: false,
        TouchEvent: false,
        TouchList: false,
        TrackEvent: false,
        TransitionEvent: false,
        TreeWalker: false,
        UIEvent: false,
        URL: false,
        URLSearchParams: false,
        ValidityState: false,
        visualViewport: false,
        VisualViewport: false,
        VTTCue: false,
        WaveShaperNode: false,
        WebAssembly: false,
        WebGL2RenderingContext: false,
        WebGLActiveInfo: false,
        WebGLBuffer: false,
        WebGLContextEvent: false,
        WebGLFramebuffer: false,
        WebGLProgram: false,
        WebGLQuery: false,
        WebGLRenderbuffer: false,
        WebGLRenderingContext: false,
        WebGLSampler: false,
        WebGLShader: false,
        WebGLShaderPrecisionFormat: false,
        WebGLSync: false,
        WebGLTexture: false,
        WebGLTransformFeedback: false,
        WebGLUniformLocation: false,
        WebGLVertexArrayObject: false,
        WebSocket: false,
        WheelEvent: false,
        window: false,
        Window: false,
        Worker: false,
        WritableStream: false,
        XMLDocument: false,
        XMLHttpRequest: false,
        XMLHttpRequestEventTarget: false,
        XMLHttpRequestUpload: false,
        XMLSerializer: false,
        XPathEvaluator: false,
        XPathExpression: false,
        XPathResult: false,
        XSLTProcessor: false
      },
      worker: {
        addEventListener: false,
        applicationCache: false,
        atob: false,
        Blob: false,
        BroadcastChannel: false,
        btoa: false,
        Cache: false,
        caches: false,
        clearInterval: false,
        clearTimeout: false,
        close: true,
        console: false,
        fetch: false,
        FileReaderSync: false,
        FormData: false,
        Headers: false,
        IDBCursor: false,
        IDBCursorWithValue: false,
        IDBDatabase: false,
        IDBFactory: false,
        IDBIndex: false,
        IDBKeyRange: false,
        IDBObjectStore: false,
        IDBOpenDBRequest: false,
        IDBRequest: false,
        IDBTransaction: false,
        IDBVersionChangeEvent: false,
        ImageData: false,
        importScripts: true,
        indexedDB: false,
        location: false,
        MessageChannel: false,
        MessagePort: false,
        name: false,
        navigator: false,
        Notification: false,
        onclose: true,
        onconnect: true,
        onerror: true,
        onlanguagechange: true,
        onmessage: true,
        onoffline: true,
        ononline: true,
        onrejectionhandled: true,
        onunhandledrejection: true,
        performance: false,
        Performance: false,
        PerformanceEntry: false,
        PerformanceMark: false,
        PerformanceMeasure: false,
        PerformanceNavigation: false,
        PerformanceResourceTiming: false,
        PerformanceTiming: false,
        postMessage: true,
        Promise: false,
        queueMicrotask: false,
        removeEventListener: false,
        Request: false,
        Response: false,
        self: true,
        ServiceWorkerRegistration: false,
        setInterval: false,
        setTimeout: false,
        TextDecoder: false,
        TextEncoder: false,
        URL: false,
        URLSearchParams: false,
        WebSocket: false,
        Worker: false,
        WorkerGlobalScope: false,
        XMLHttpRequest: false
      },
      node: {
        __dirname: false,
        __filename: false,
        Buffer: false,
        clearImmediate: false,
        clearInterval: false,
        clearTimeout: false,
        console: false,
        exports: true,
        global: false,
        Intl: false,
        module: false,
        process: false,
        queueMicrotask: false,
        require: false,
        setImmediate: false,
        setInterval: false,
        setTimeout: false,
        TextDecoder: false,
        TextEncoder: false,
        URL: false,
        URLSearchParams: false
      },
      commonjs: {
        exports: true,
        global: false,
        module: false,
        require: false
      },
      amd: {
        define: false,
        require: false
      },
      mocha: {
        after: false,
        afterEach: false,
        before: false,
        beforeEach: false,
        context: false,
        describe: false,
        it: false,
        mocha: false,
        run: false,
        setup: false,
        specify: false,
        suite: false,
        suiteSetup: false,
        suiteTeardown: false,
        teardown: false,
        test: false,
        xcontext: false,
        xdescribe: false,
        xit: false,
        xspecify: false
      },
      jasmine: {
        afterAll: false,
        afterEach: false,
        beforeAll: false,
        beforeEach: false,
        describe: false,
        expect: false,
        fail: false,
        fdescribe: false,
        fit: false,
        it: false,
        jasmine: false,
        pending: false,
        runs: false,
        spyOn: false,
        spyOnProperty: false,
        waits: false,
        waitsFor: false,
        xdescribe: false,
        xit: false
      },
      jest: {
        afterAll: false,
        afterEach: false,
        beforeAll: false,
        beforeEach: false,
        describe: false,
        expect: false,
        fdescribe: false,
        fit: false,
        it: false,
        jest: false,
        pit: false,
        require: false,
        test: false,
        xdescribe: false,
        xit: false,
        xtest: false
      },
      qunit: {
        asyncTest: false,
        deepEqual: false,
        equal: false,
        expect: false,
        module: false,
        notDeepEqual: false,
        notEqual: false,
        notOk: false,
        notPropEqual: false,
        notStrictEqual: false,
        ok: false,
        propEqual: false,
        QUnit: false,
        raises: false,
        start: false,
        stop: false,
        strictEqual: false,
        test: false,
        throws: false
      },
      phantomjs: {
        console: true,
        exports: true,
        phantom: true,
        require: true,
        WebPage: true
      },
      couch: {
        emit: false,
        exports: false,
        getRow: false,
        log: false,
        module: false,
        provides: false,
        require: false,
        respond: false,
        send: false,
        start: false,
        sum: false
      },
      rhino: {
        defineClass: false,
        deserialize: false,
        gc: false,
        help: false,
        importClass: false,
        importPackage: false,
        java: false,
        load: false,
        loadClass: false,
        Packages: false,
        print: false,
        quit: false,
        readFile: false,
        readUrl: false,
        runCommand: false,
        seal: false,
        serialize: false,
        spawn: false,
        sync: false,
        toint32: false,
        version: false
      },
      nashorn: {
        __DIR__: false,
        __FILE__: false,
        __LINE__: false,
        com: false,
        edu: false,
        exit: false,
        java: false,
        Java: false,
        javafx: false,
        JavaImporter: false,
        javax: false,
        JSAdapter: false,
        load: false,
        loadWithNewGlobal: false,
        org: false,
        Packages: false,
        print: false,
        quit: false
      },
      wsh: {
        ActiveXObject: true,
        Enumerator: true,
        GetObject: true,
        ScriptEngine: true,
        ScriptEngineBuildVersion: true,
        ScriptEngineMajorVersion: true,
        ScriptEngineMinorVersion: true,
        VBArray: true,
        WScript: true,
        WSH: true,
        XDomainRequest: true
      },
      jquery: {
        $: false,
        jQuery: false
      },
      yui: {
        YAHOO: false,
        YAHOO_config: false,
        YUI: false,
        YUI_config: false
      },
      shelljs: {
        cat: false,
        cd: false,
        chmod: false,
        config: false,
        cp: false,
        dirs: false,
        echo: false,
        env: false,
        error: false,
        exec: false,
        exit: false,
        find: false,
        grep: false,
        ln: false,
        ls: false,
        mkdir: false,
        mv: false,
        popd: false,
        pushd: false,
        pwd: false,
        rm: false,
        sed: false,
        set: false,
        target: false,
        tempdir: false,
        test: false,
        touch: false,
        which: false
      },
      prototypejs: {
        $: false,
        $$: false,
        $A: false,
        $break: false,
        $continue: false,
        $F: false,
        $H: false,
        $R: false,
        $w: false,
        Abstract: false,
        Ajax: false,
        Autocompleter: false,
        Builder: false,
        Class: false,
        Control: false,
        Draggable: false,
        Draggables: false,
        Droppables: false,
        Effect: false,
        Element: false,
        Enumerable: false,
        Event: false,
        Field: false,
        Form: false,
        Hash: false,
        Insertion: false,
        ObjectRange: false,
        PeriodicalExecuter: false,
        Position: false,
        Prototype: false,
        Scriptaculous: false,
        Selector: false,
        Sortable: false,
        SortableObserver: false,
        Sound: false,
        Template: false,
        Toggle: false,
        Try: false
      },
      meteor: {
        _: false,
        $: false,
        Accounts: false,
        AccountsClient: false,
        AccountsCommon: false,
        AccountsServer: false,
        App: false,
        Assets: false,
        Blaze: false,
        check: false,
        Cordova: false,
        DDP: false,
        DDPRateLimiter: false,
        DDPServer: false,
        Deps: false,
        EJSON: false,
        Email: false,
        HTTP: false,
        Log: false,
        Match: false,
        Meteor: false,
        Mongo: false,
        MongoInternals: false,
        Npm: false,
        Package: false,
        Plugin: false,
        process: false,
        Random: false,
        ReactiveDict: false,
        ReactiveVar: false,
        Router: false,
        ServiceConfiguration: false,
        Session: false,
        share: false,
        Spacebars: false,
        Template: false,
        Tinytest: false,
        Tracker: false,
        UI: false,
        Utils: false,
        WebApp: false,
        WebAppInternals: false
      },
      mongo: {
        _isWindows: false,
        _rand: false,
        BulkWriteResult: false,
        cat: false,
        cd: false,
        connect: false,
        db: false,
        getHostName: false,
        getMemInfo: false,
        hostname: false,
        ISODate: false,
        listFiles: false,
        load: false,
        ls: false,
        md5sumFile: false,
        mkdir: false,
        Mongo: false,
        NumberInt: false,
        NumberLong: false,
        ObjectId: false,
        PlanCache: false,
        print: false,
        printjson: false,
        pwd: false,
        quit: false,
        removeFile: false,
        rs: false,
        sh: false,
        UUID: false,
        version: false,
        WriteResult: false
      },
      applescript: {
        $: false,
        Application: false,
        Automation: false,
        console: false,
        delay: false,
        Library: false,
        ObjC: false,
        ObjectSpecifier: false,
        Path: false,
        Progress: false,
        Ref: false
      },
      serviceworker: {
        addEventListener: false,
        applicationCache: false,
        atob: false,
        Blob: false,
        BroadcastChannel: false,
        btoa: false,
        Cache: false,
        caches: false,
        CacheStorage: false,
        clearInterval: false,
        clearTimeout: false,
        Client: false,
        clients: false,
        Clients: false,
        close: true,
        console: false,
        ExtendableEvent: false,
        ExtendableMessageEvent: false,
        fetch: false,
        FetchEvent: false,
        FileReaderSync: false,
        FormData: false,
        Headers: false,
        IDBCursor: false,
        IDBCursorWithValue: false,
        IDBDatabase: false,
        IDBFactory: false,
        IDBIndex: false,
        IDBKeyRange: false,
        IDBObjectStore: false,
        IDBOpenDBRequest: false,
        IDBRequest: false,
        IDBTransaction: false,
        IDBVersionChangeEvent: false,
        ImageData: false,
        importScripts: false,
        indexedDB: false,
        location: false,
        MessageChannel: false,
        MessagePort: false,
        name: false,
        navigator: false,
        Notification: false,
        onclose: true,
        onconnect: true,
        onerror: true,
        onfetch: true,
        oninstall: true,
        onlanguagechange: true,
        onmessage: true,
        onmessageerror: true,
        onnotificationclick: true,
        onnotificationclose: true,
        onoffline: true,
        ononline: true,
        onpush: true,
        onpushsubscriptionchange: true,
        onrejectionhandled: true,
        onsync: true,
        onunhandledrejection: true,
        performance: false,
        Performance: false,
        PerformanceEntry: false,
        PerformanceMark: false,
        PerformanceMeasure: false,
        PerformanceNavigation: false,
        PerformanceResourceTiming: false,
        PerformanceTiming: false,
        postMessage: true,
        Promise: false,
        queueMicrotask: false,
        registration: false,
        removeEventListener: false,
        Request: false,
        Response: false,
        self: false,
        ServiceWorker: false,
        ServiceWorkerContainer: false,
        ServiceWorkerGlobalScope: false,
        ServiceWorkerMessageEvent: false,
        ServiceWorkerRegistration: false,
        setInterval: false,
        setTimeout: false,
        skipWaiting: false,
        TextDecoder: false,
        TextEncoder: false,
        URL: false,
        URLSearchParams: false,
        WebSocket: false,
        WindowClient: false,
        Worker: false,
        WorkerGlobalScope: false,
        XMLHttpRequest: false
      },
      atomtest: {
        advanceClock: false,
        fakeClearInterval: false,
        fakeClearTimeout: false,
        fakeSetInterval: false,
        fakeSetTimeout: false,
        resetTimeouts: false,
        waitsForPromise: false
      },
      embertest: {
        andThen: false,
        click: false,
        currentPath: false,
        currentRouteName: false,
        currentURL: false,
        fillIn: false,
        find: false,
        findAll: false,
        findWithAssert: false,
        keyEvent: false,
        pauseTest: false,
        resumeTest: false,
        triggerEvent: false,
        visit: false,
        wait: false
      },
      protractor: {
        $: false,
        $$: false,
        browser: false,
        by: false,
        By: false,
        DartObject: false,
        element: false,
        protractor: false
      },
      "shared-node-browser": {
        clearInterval: false,
        clearTimeout: false,
        console: false,
        setInterval: false,
        setTimeout: false,
        URL: false,
        URLSearchParams: false
      },
      webextensions: {
        browser: false,
        chrome: false,
        opr: false
      },
      greasemonkey: {
        cloneInto: false,
        createObjectIn: false,
        exportFunction: false,
        GM: false,
        GM_addStyle: false,
        GM_deleteValue: false,
        GM_getResourceText: false,
        GM_getResourceURL: false,
        GM_getValue: false,
        GM_info: false,
        GM_listValues: false,
        GM_log: false,
        GM_openInTab: false,
        GM_registerMenuCommand: false,
        GM_setClipboard: false,
        GM_setValue: false,
        GM_xmlhttpRequest: false,
        unsafeWindow: false
      },
      devtools: {
        $: false,
        $_: false,
        $$: false,
        $0: false,
        $1: false,
        $2: false,
        $3: false,
        $4: false,
        $x: false,
        chrome: false,
        clear: false,
        copy: false,
        debug: false,
        dir: false,
        dirxml: false,
        getEventListeners: false,
        inspect: false,
        keys: false,
        monitor: false,
        monitorEvents: false,
        profile: false,
        profileEnd: false,
        queryObjects: false,
        table: false,
        undebug: false,
        unmonitor: false,
        unmonitorEvents: false,
        values: false
      }
    };
  }
});

// ../../node_modules/globals/index.js
var require_globals2 = __commonJS({
  "../../node_modules/globals/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_globals();
  }
});

// node_modules/@babel/helpers/node_modules/@babel/traverse/lib/cache.js
var require_cache = __commonJS({
  "node_modules/@babel/helpers/node_modules/@babel/traverse/lib/cache.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.clear = clear;
    exports2.clearPath = clearPath;
    exports2.clearScope = clearScope;
    exports2.getCachedPaths = getCachedPaths;
    exports2.getOrCreateCachedPaths = getOrCreateCachedPaths;
    exports2.scope = exports2.path = void 0;
    var pathsCache = exports2.path = /* @__PURE__ */ new WeakMap();
    var scope = exports2.scope = /* @__PURE__ */ new WeakMap();
    function clear() {
      clearPath();
      clearScope();
    }
    function clearPath() {
      exports2.path = pathsCache = /* @__PURE__ */ new WeakMap();
    }
    function clearScope() {
      exports2.scope = scope = /* @__PURE__ */ new WeakMap();
    }
    var nullHub = Object.freeze({});
    function getCachedPaths(hub, parent) {
      var _pathsCache$get, _hub;
      {
        hub = null;
      }
      return (_pathsCache$get = pathsCache.get((_hub = hub) != null ? _hub : nullHub)) == null ? void 0 : _pathsCache$get.get(parent);
    }
    function getOrCreateCachedPaths(hub, parent) {
      var _hub2, _hub3;
      {
        hub = null;
      }
      let parents = pathsCache.get((_hub2 = hub) != null ? _hub2 : nullHub);
      if (!parents) pathsCache.set((_hub3 = hub) != null ? _hub3 : nullHub, parents = /* @__PURE__ */ new WeakMap());
      let paths = parents.get(parent);
      if (!paths) parents.set(parent, paths = /* @__PURE__ */ new Map());
      return paths;
    }
  }
});

// node_modules/@babel/helpers/node_modules/@babel/traverse/lib/scope/index.js
var require_scope = __commonJS({
  "node_modules/@babel/helpers/node_modules/@babel/traverse/lib/scope/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _renamer = require_renamer();
    var _index = require_lib6();
    var _binding = require_binding();
    var _globals4 = require_globals2();
    var _t = require("@babel/types");
    var t6 = _t;
    var _cache = require_cache();
    var _visitors = require_visitors();
    var {
      NOT_LOCAL_BINDING,
      assignmentExpression: assignmentExpression2,
      callExpression: callExpression3,
      cloneNode: cloneNode2,
      getBindingIdentifiers,
      identifier: identifier4,
      isArrayExpression,
      isBinary,
      isCallExpression,
      isClass,
      isClassBody,
      isClassDeclaration,
      isExportAllDeclaration,
      isExportDefaultDeclaration,
      isExportNamedDeclaration,
      isFunctionDeclaration,
      isIdentifier,
      isImportDeclaration,
      isLiteral,
      isMemberExpression: isMemberExpression2,
      isMethod,
      isModuleSpecifier,
      isNullLiteral,
      isObjectExpression,
      isProperty,
      isPureish,
      isRegExpLiteral,
      isSuper,
      isTaggedTemplateExpression,
      isTemplateLiteral,
      isThisExpression,
      isUnaryExpression,
      isVariableDeclaration: isVariableDeclaration2,
      expressionStatement: expressionStatement2,
      matchesPattern,
      memberExpression: memberExpression2,
      numericLiteral: numericLiteral2,
      toIdentifier,
      variableDeclaration: variableDeclaration3,
      variableDeclarator: variableDeclarator3,
      isRecordExpression,
      isTupleExpression,
      isObjectProperty,
      isTopicReference,
      isMetaProperty,
      isPrivateName,
      isExportDeclaration,
      buildUndefinedNode,
      sequenceExpression: sequenceExpression2
    } = _t;
    function gatherNodeParts(node, parts) {
      switch (node == null ? void 0 : node.type) {
        default:
          if (isImportDeclaration(node) || isExportDeclaration(node)) {
            var _node$specifiers;
            if ((isExportAllDeclaration(node) || isExportNamedDeclaration(node) || isImportDeclaration(node)) && node.source) {
              gatherNodeParts(node.source, parts);
            } else if ((isExportNamedDeclaration(node) || isImportDeclaration(node)) && (_node$specifiers = node.specifiers) != null && _node$specifiers.length) {
              for (const e of node.specifiers) gatherNodeParts(e, parts);
            } else if ((isExportDefaultDeclaration(node) || isExportNamedDeclaration(node)) && node.declaration) {
              gatherNodeParts(node.declaration, parts);
            }
          } else if (isModuleSpecifier(node)) {
            gatherNodeParts(node.local, parts);
          } else if (isLiteral(node) && !isNullLiteral(node) && !isRegExpLiteral(node) && !isTemplateLiteral(node)) {
            parts.push(node.value);
          }
          break;
        case "MemberExpression":
        case "OptionalMemberExpression":
        case "JSXMemberExpression":
          gatherNodeParts(node.object, parts);
          gatherNodeParts(node.property, parts);
          break;
        case "Identifier":
        case "JSXIdentifier":
          parts.push(node.name);
          break;
        case "CallExpression":
        case "OptionalCallExpression":
        case "NewExpression":
          gatherNodeParts(node.callee, parts);
          break;
        case "ObjectExpression":
        case "ObjectPattern":
          for (const e of node.properties) {
            gatherNodeParts(e, parts);
          }
          break;
        case "SpreadElement":
        case "RestElement":
          gatherNodeParts(node.argument, parts);
          break;
        case "ObjectProperty":
        case "ObjectMethod":
        case "ClassProperty":
        case "ClassMethod":
        case "ClassPrivateProperty":
        case "ClassPrivateMethod":
          gatherNodeParts(node.key, parts);
          break;
        case "ThisExpression":
          parts.push("this");
          break;
        case "Super":
          parts.push("super");
          break;
        case "Import":
          parts.push("import");
          break;
        case "DoExpression":
          parts.push("do");
          break;
        case "YieldExpression":
          parts.push("yield");
          gatherNodeParts(node.argument, parts);
          break;
        case "AwaitExpression":
          parts.push("await");
          gatherNodeParts(node.argument, parts);
          break;
        case "AssignmentExpression":
          gatherNodeParts(node.left, parts);
          break;
        case "VariableDeclarator":
          gatherNodeParts(node.id, parts);
          break;
        case "FunctionExpression":
        case "FunctionDeclaration":
        case "ClassExpression":
        case "ClassDeclaration":
          gatherNodeParts(node.id, parts);
          break;
        case "PrivateName":
          gatherNodeParts(node.id, parts);
          break;
        case "ParenthesizedExpression":
          gatherNodeParts(node.expression, parts);
          break;
        case "UnaryExpression":
        case "UpdateExpression":
          gatherNodeParts(node.argument, parts);
          break;
        case "MetaProperty":
          gatherNodeParts(node.meta, parts);
          gatherNodeParts(node.property, parts);
          break;
        case "JSXElement":
          gatherNodeParts(node.openingElement, parts);
          break;
        case "JSXOpeningElement":
          gatherNodeParts(node.name, parts);
          break;
        case "JSXFragment":
          gatherNodeParts(node.openingFragment, parts);
          break;
        case "JSXOpeningFragment":
          parts.push("Fragment");
          break;
        case "JSXNamespacedName":
          gatherNodeParts(node.namespace, parts);
          gatherNodeParts(node.name, parts);
          break;
      }
    }
    var collectorVisitor = {
      ForStatement(path) {
        const declar = path.get("init");
        if (declar.isVar()) {
          const {
            scope
          } = path;
          const parentScope = scope.getFunctionParent() || scope.getProgramParent();
          parentScope.registerBinding("var", declar);
        }
      },
      Declaration(path) {
        if (path.isBlockScoped()) return;
        if (path.isImportDeclaration()) return;
        if (path.isExportDeclaration()) return;
        const parent = path.scope.getFunctionParent() || path.scope.getProgramParent();
        parent.registerDeclaration(path);
      },
      ImportDeclaration(path) {
        const parent = path.scope.getBlockParent();
        parent.registerDeclaration(path);
      },
      ReferencedIdentifier(path, state) {
        state.references.push(path);
      },
      ForXStatement(path, state) {
        const left = path.get("left");
        if (left.isPattern() || left.isIdentifier()) {
          state.constantViolations.push(path);
        } else if (left.isVar()) {
          const {
            scope
          } = path;
          const parentScope = scope.getFunctionParent() || scope.getProgramParent();
          parentScope.registerBinding("var", left);
        }
      },
      ExportDeclaration: {
        exit(path) {
          const {
            node,
            scope
          } = path;
          if (isExportAllDeclaration(node)) return;
          const declar = node.declaration;
          if (isClassDeclaration(declar) || isFunctionDeclaration(declar)) {
            const id = declar.id;
            if (!id) return;
            const binding = scope.getBinding(id.name);
            binding == null || binding.reference(path);
          } else if (isVariableDeclaration2(declar)) {
            for (const decl of declar.declarations) {
              for (const name of Object.keys(getBindingIdentifiers(decl))) {
                const binding = scope.getBinding(name);
                binding == null || binding.reference(path);
              }
            }
          }
        }
      },
      LabeledStatement(path) {
        path.scope.getBlockParent().registerDeclaration(path);
      },
      AssignmentExpression(path, state) {
        state.assignments.push(path);
      },
      UpdateExpression(path, state) {
        state.constantViolations.push(path);
      },
      UnaryExpression(path, state) {
        if (path.node.operator === "delete") {
          state.constantViolations.push(path);
        }
      },
      BlockScoped(path) {
        let scope = path.scope;
        if (scope.path === path) scope = scope.parent;
        const parent = scope.getBlockParent();
        parent.registerDeclaration(path);
        if (path.isClassDeclaration() && path.node.id) {
          const id = path.node.id;
          const name = id.name;
          path.scope.bindings[name] = path.scope.parent.getBinding(name);
        }
      },
      CatchClause(path) {
        path.scope.registerBinding("let", path);
      },
      Function(path) {
        const params = path.get("params");
        for (const param of params) {
          path.scope.registerBinding("param", param);
        }
        if (path.isFunctionExpression() && path.node.id && !path.node.id[NOT_LOCAL_BINDING]) {
          path.scope.registerBinding("local", path.get("id"), path);
        }
      },
      ClassExpression(path) {
        if (path.node.id && !path.node.id[NOT_LOCAL_BINDING]) {
          path.scope.registerBinding("local", path.get("id"), path);
        }
      },
      TSTypeAnnotation(path) {
        path.skip();
      }
    };
    var uid = 0;
    var Scope = class _Scope {
      constructor(path) {
        this.uid = void 0;
        this.path = void 0;
        this.block = void 0;
        this.inited = void 0;
        this.labels = void 0;
        this.bindings = void 0;
        this.references = void 0;
        this.globals = void 0;
        this.uids = void 0;
        this.data = void 0;
        this.crawling = void 0;
        const {
          node
        } = path;
        const cached = _cache.scope.get(node);
        if ((cached == null ? void 0 : cached.path) === path) {
          return cached;
        }
        _cache.scope.set(node, this);
        this.uid = uid++;
        this.block = node;
        this.path = path;
        this.labels = /* @__PURE__ */ new Map();
        this.inited = false;
      }
      get parent() {
        var _parent;
        let parent, path = this.path;
        do {
          var _path;
          const shouldSkip = path.key === "key" || path.listKey === "decorators";
          path = path.parentPath;
          if (shouldSkip && path.isMethod()) path = path.parentPath;
          if ((_path = path) != null && _path.isScope()) parent = path;
        } while (path && !parent);
        return (_parent = parent) == null ? void 0 : _parent.scope;
      }
      generateDeclaredUidIdentifier(name) {
        const id = this.generateUidIdentifier(name);
        this.push({
          id
        });
        return cloneNode2(id);
      }
      generateUidIdentifier(name) {
        return identifier4(this.generateUid(name));
      }
      generateUid(name = "temp") {
        name = toIdentifier(name).replace(/^_+/, "").replace(/\d+$/g, "");
        let uid2;
        let i = 1;
        do {
          uid2 = `_${name}`;
          if (i > 1) uid2 += i;
          i++;
        } while (this.hasLabel(uid2) || this.hasBinding(uid2) || this.hasGlobal(uid2) || this.hasReference(uid2));
        const program = this.getProgramParent();
        program.references[uid2] = true;
        program.uids[uid2] = true;
        return uid2;
      }
      generateUidBasedOnNode(node, defaultName) {
        const parts = [];
        gatherNodeParts(node, parts);
        let id = parts.join("$");
        id = id.replace(/^_/, "") || defaultName || "ref";
        return this.generateUid(id.slice(0, 20));
      }
      generateUidIdentifierBasedOnNode(node, defaultName) {
        return identifier4(this.generateUidBasedOnNode(node, defaultName));
      }
      isStatic(node) {
        if (isThisExpression(node) || isSuper(node) || isTopicReference(node)) {
          return true;
        }
        if (isIdentifier(node)) {
          const binding = this.getBinding(node.name);
          if (binding) {
            return binding.constant;
          } else {
            return this.hasBinding(node.name);
          }
        }
        return false;
      }
      maybeGenerateMemoised(node, dontPush) {
        if (this.isStatic(node)) {
          return null;
        } else {
          const id = this.generateUidIdentifierBasedOnNode(node);
          if (!dontPush) {
            this.push({
              id
            });
            return cloneNode2(id);
          }
          return id;
        }
      }
      checkBlockScopedCollisions(local, kind, name, id) {
        if (kind === "param") return;
        if (local.kind === "local") return;
        const duplicate = kind === "let" || local.kind === "let" || local.kind === "const" || local.kind === "module" || local.kind === "param" && kind === "const";
        if (duplicate) {
          throw this.path.hub.buildError(id, `Duplicate declaration "${name}"`, TypeError);
        }
      }
      rename(oldName, newName) {
        const binding = this.getBinding(oldName);
        if (binding) {
          newName || (newName = this.generateUidIdentifier(oldName).name);
          const renamer = new _renamer.default(binding, oldName, newName);
          {
            renamer.rename(arguments[2]);
          }
        }
      }
      dump() {
        const sep = "-".repeat(60);
        console.log(sep);
        let scope = this;
        do {
          console.log("#", scope.block.type);
          for (const name of Object.keys(scope.bindings)) {
            const binding = scope.bindings[name];
            console.log(" -", name, {
              constant: binding.constant,
              references: binding.references,
              violations: binding.constantViolations.length,
              kind: binding.kind
            });
          }
        } while (scope = scope.parent);
        console.log(sep);
      }
      hasLabel(name) {
        return !!this.getLabel(name);
      }
      getLabel(name) {
        return this.labels.get(name);
      }
      registerLabel(path) {
        this.labels.set(path.node.label.name, path);
      }
      registerDeclaration(path) {
        if (path.isLabeledStatement()) {
          this.registerLabel(path);
        } else if (path.isFunctionDeclaration()) {
          this.registerBinding("hoisted", path.get("id"), path);
        } else if (path.isVariableDeclaration()) {
          const declarations = path.get("declarations");
          const {
            kind
          } = path.node;
          for (const declar of declarations) {
            this.registerBinding(kind === "using" || kind === "await using" ? "const" : kind, declar);
          }
        } else if (path.isClassDeclaration()) {
          if (path.node.declare) return;
          this.registerBinding("let", path);
        } else if (path.isImportDeclaration()) {
          const isTypeDeclaration = path.node.importKind === "type" || path.node.importKind === "typeof";
          const specifiers = path.get("specifiers");
          for (const specifier of specifiers) {
            const isTypeSpecifier = isTypeDeclaration || specifier.isImportSpecifier() && (specifier.node.importKind === "type" || specifier.node.importKind === "typeof");
            this.registerBinding(isTypeSpecifier ? "unknown" : "module", specifier);
          }
        } else if (path.isExportDeclaration()) {
          const declar = path.get("declaration");
          if (declar.isClassDeclaration() || declar.isFunctionDeclaration() || declar.isVariableDeclaration()) {
            this.registerDeclaration(declar);
          }
        } else {
          this.registerBinding("unknown", path);
        }
      }
      buildUndefinedNode() {
        return buildUndefinedNode();
      }
      registerConstantViolation(path) {
        const ids = path.getAssignmentIdentifiers();
        for (const name of Object.keys(ids)) {
          var _this$getBinding;
          (_this$getBinding = this.getBinding(name)) == null || _this$getBinding.reassign(path);
        }
      }
      registerBinding(kind, path, bindingPath = path) {
        if (!kind) throw new ReferenceError("no `kind`");
        if (path.isVariableDeclaration()) {
          const declarators = path.get("declarations");
          for (const declar of declarators) {
            this.registerBinding(kind, declar);
          }
          return;
        }
        const parent = this.getProgramParent();
        const ids = path.getOuterBindingIdentifiers(true);
        for (const name of Object.keys(ids)) {
          parent.references[name] = true;
          for (const id of ids[name]) {
            const local = this.getOwnBinding(name);
            if (local) {
              if (local.identifier === id) continue;
              this.checkBlockScopedCollisions(local, kind, name, id);
            }
            if (local) {
              local.reassign(bindingPath);
            } else {
              this.bindings[name] = new _binding.default({
                identifier: id,
                scope: this,
                path: bindingPath,
                kind
              });
            }
          }
        }
      }
      addGlobal(node) {
        this.globals[node.name] = node;
      }
      hasUid(name) {
        let scope = this;
        do {
          if (scope.uids[name]) return true;
        } while (scope = scope.parent);
        return false;
      }
      hasGlobal(name) {
        let scope = this;
        do {
          if (scope.globals[name]) return true;
        } while (scope = scope.parent);
        return false;
      }
      hasReference(name) {
        return !!this.getProgramParent().references[name];
      }
      isPure(node, constantsOnly) {
        if (isIdentifier(node)) {
          const binding = this.getBinding(node.name);
          if (!binding) return false;
          if (constantsOnly) return binding.constant;
          return true;
        } else if (isThisExpression(node) || isMetaProperty(node) || isTopicReference(node) || isPrivateName(node)) {
          return true;
        } else if (isClass(node)) {
          var _node$decorators;
          if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {
            return false;
          }
          if (((_node$decorators = node.decorators) == null ? void 0 : _node$decorators.length) > 0) {
            return false;
          }
          return this.isPure(node.body, constantsOnly);
        } else if (isClassBody(node)) {
          for (const method of node.body) {
            if (!this.isPure(method, constantsOnly)) return false;
          }
          return true;
        } else if (isBinary(node)) {
          return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);
        } else if (isArrayExpression(node) || isTupleExpression(node)) {
          for (const elem of node.elements) {
            if (elem !== null && !this.isPure(elem, constantsOnly)) return false;
          }
          return true;
        } else if (isObjectExpression(node) || isRecordExpression(node)) {
          for (const prop of node.properties) {
            if (!this.isPure(prop, constantsOnly)) return false;
          }
          return true;
        } else if (isMethod(node)) {
          var _node$decorators2;
          if (node.computed && !this.isPure(node.key, constantsOnly)) return false;
          if (((_node$decorators2 = node.decorators) == null ? void 0 : _node$decorators2.length) > 0) {
            return false;
          }
          return true;
        } else if (isProperty(node)) {
          var _node$decorators3;
          if (node.computed && !this.isPure(node.key, constantsOnly)) return false;
          if (((_node$decorators3 = node.decorators) == null ? void 0 : _node$decorators3.length) > 0) {
            return false;
          }
          if (isObjectProperty(node) || node.static) {
            if (node.value !== null && !this.isPure(node.value, constantsOnly)) {
              return false;
            }
          }
          return true;
        } else if (isUnaryExpression(node)) {
          return this.isPure(node.argument, constantsOnly);
        } else if (isTemplateLiteral(node)) {
          for (const expression of node.expressions) {
            if (!this.isPure(expression, constantsOnly)) return false;
          }
          return true;
        } else if (isTaggedTemplateExpression(node)) {
          return matchesPattern(node.tag, "String.raw") && !this.hasBinding("String", {
            noGlobals: true
          }) && this.isPure(node.quasi, constantsOnly);
        } else if (isMemberExpression2(node)) {
          return !node.computed && isIdentifier(node.object) && node.object.name === "Symbol" && isIdentifier(node.property) && node.property.name !== "for" && !this.hasBinding("Symbol", {
            noGlobals: true
          });
        } else if (isCallExpression(node)) {
          return matchesPattern(node.callee, "Symbol.for") && !this.hasBinding("Symbol", {
            noGlobals: true
          }) && node.arguments.length === 1 && t6.isStringLiteral(node.arguments[0]);
        } else {
          return isPureish(node);
        }
      }
      setData(key2, val) {
        return this.data[key2] = val;
      }
      getData(key2) {
        let scope = this;
        do {
          const data = scope.data[key2];
          if (data != null) return data;
        } while (scope = scope.parent);
      }
      removeData(key2) {
        let scope = this;
        do {
          const data = scope.data[key2];
          if (data != null) scope.data[key2] = null;
        } while (scope = scope.parent);
      }
      init() {
        if (!this.inited) {
          this.inited = true;
          this.crawl();
        }
      }
      crawl() {
        const path = this.path;
        this.references = /* @__PURE__ */ Object.create(null);
        this.bindings = /* @__PURE__ */ Object.create(null);
        this.globals = /* @__PURE__ */ Object.create(null);
        this.uids = /* @__PURE__ */ Object.create(null);
        this.data = /* @__PURE__ */ Object.create(null);
        let scope = this;
        do {
          if (scope.crawling) return;
          if (scope.path.isProgram()) {
            break;
          }
        } while (scope = scope.parent);
        const programParent = scope;
        const state = {
          references: [],
          constantViolations: [],
          assignments: []
        };
        this.crawling = true;
        if (path.type !== "Program" && (0, _visitors.isExplodedVisitor)(collectorVisitor)) {
          for (const visit4 of collectorVisitor.enter) {
            visit4.call(state, path, state);
          }
          const typeVisitors = collectorVisitor[path.type];
          if (typeVisitors) {
            for (const visit4 of typeVisitors.enter) {
              visit4.call(state, path, state);
            }
          }
        }
        path.traverse(collectorVisitor, state);
        this.crawling = false;
        for (const path2 of state.assignments) {
          const ids = path2.getAssignmentIdentifiers();
          for (const name of Object.keys(ids)) {
            if (path2.scope.getBinding(name)) continue;
            programParent.addGlobal(ids[name]);
          }
          path2.scope.registerConstantViolation(path2);
        }
        for (const ref of state.references) {
          const binding = ref.scope.getBinding(ref.node.name);
          if (binding) {
            binding.reference(ref);
          } else {
            programParent.addGlobal(ref.node);
          }
        }
        for (const path2 of state.constantViolations) {
          path2.scope.registerConstantViolation(path2);
        }
      }
      push(opts) {
        let path = this.path;
        if (path.isPattern()) {
          path = this.getPatternParent().path;
        } else if (!path.isBlockStatement() && !path.isProgram()) {
          path = this.getBlockParent().path;
        }
        if (path.isSwitchStatement()) {
          path = (this.getFunctionParent() || this.getProgramParent()).path;
        }
        const {
          init,
          unique,
          kind = "var",
          id
        } = opts;
        if (!init && !unique && (kind === "var" || kind === "let") && path.isFunction() && !path.node.name && isCallExpression(path.parent, {
          callee: path.node
        }) && path.parent.arguments.length <= path.node.params.length && isIdentifier(id)) {
          path.pushContainer("params", id);
          path.scope.registerBinding("param", path.get("params")[path.node.params.length - 1]);
          return;
        }
        if (path.isLoop() || path.isCatchClause() || path.isFunction()) {
          path.ensureBlock();
          path = path.get("body");
        }
        const blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;
        const dataKey = `declaration:${kind}:${blockHoist}`;
        let declarPath = !unique && path.getData(dataKey);
        if (!declarPath) {
          const declar = variableDeclaration3(kind, []);
          declar._blockHoist = blockHoist;
          [declarPath] = path.unshiftContainer("body", [declar]);
          if (!unique) path.setData(dataKey, declarPath);
        }
        const declarator = variableDeclarator3(id, init);
        const len = declarPath.node.declarations.push(declarator);
        path.scope.registerBinding(kind, declarPath.get("declarations")[len - 1]);
      }
      getProgramParent() {
        let scope = this;
        do {
          if (scope.path.isProgram()) {
            return scope;
          }
        } while (scope = scope.parent);
        throw new Error("Couldn't find a Program");
      }
      getFunctionParent() {
        let scope = this;
        do {
          if (scope.path.isFunctionParent()) {
            return scope;
          }
        } while (scope = scope.parent);
        return null;
      }
      getBlockParent() {
        let scope = this;
        do {
          if (scope.path.isBlockParent()) {
            return scope;
          }
        } while (scope = scope.parent);
        throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
      }
      getPatternParent() {
        let scope = this;
        do {
          if (!scope.path.isPattern()) {
            return scope.getBlockParent();
          }
        } while (scope = scope.parent.parent);
        throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
      }
      getAllBindings() {
        const ids = /* @__PURE__ */ Object.create(null);
        let scope = this;
        do {
          for (const key2 of Object.keys(scope.bindings)) {
            if (key2 in ids === false) {
              ids[key2] = scope.bindings[key2];
            }
          }
          scope = scope.parent;
        } while (scope);
        return ids;
      }
      bindingIdentifierEquals(name, node) {
        return this.getBindingIdentifier(name) === node;
      }
      getBinding(name) {
        let scope = this;
        let previousPath;
        do {
          const binding = scope.getOwnBinding(name);
          if (binding) {
            var _previousPath;
            if ((_previousPath = previousPath) != null && _previousPath.isPattern() && binding.kind !== "param" && binding.kind !== "local") {
            } else {
              return binding;
            }
          } else if (!binding && name === "arguments" && scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {
            break;
          }
          previousPath = scope.path;
        } while (scope = scope.parent);
      }
      getOwnBinding(name) {
        return this.bindings[name];
      }
      getBindingIdentifier(name) {
        var _this$getBinding2;
        return (_this$getBinding2 = this.getBinding(name)) == null ? void 0 : _this$getBinding2.identifier;
      }
      getOwnBindingIdentifier(name) {
        const binding = this.bindings[name];
        return binding == null ? void 0 : binding.identifier;
      }
      hasOwnBinding(name) {
        return !!this.getOwnBinding(name);
      }
      hasBinding(name, opts) {
        if (!name) return false;
        let scope = this;
        do {
          if (scope.hasOwnBinding(name)) {
            return true;
          }
        } while (scope = scope.parent);
        let noGlobals;
        let noUids;
        if (typeof opts === "object") {
          noGlobals = opts.noGlobals;
          noUids = opts.noUids;
        } else if (typeof opts === "boolean") {
          noGlobals = opts;
        }
        if (!noUids && this.hasUid(name)) return true;
        if (!noGlobals && _Scope.globals.includes(name)) return true;
        if (!noGlobals && _Scope.contextVariables.includes(name)) return true;
        return false;
      }
      parentHasBinding(name, opts) {
        var _this$parent;
        return (_this$parent = this.parent) == null ? void 0 : _this$parent.hasBinding(name, opts);
      }
      moveBindingTo(name, scope) {
        const info = this.getBinding(name);
        if (info) {
          info.scope.removeOwnBinding(name);
          info.scope = scope;
          scope.bindings[name] = info;
        }
      }
      removeOwnBinding(name) {
        delete this.bindings[name];
      }
      removeBinding(name) {
        var _this$getBinding3;
        (_this$getBinding3 = this.getBinding(name)) == null || _this$getBinding3.scope.removeOwnBinding(name);
        let scope = this;
        do {
          if (scope.uids[name]) {
            scope.uids[name] = false;
          }
        } while (scope = scope.parent);
      }
      hoistVariables(emit2 = (id) => this.push({
        id
      })) {
        this.crawl();
        const seen = /* @__PURE__ */ new Set();
        for (const name of Object.keys(this.bindings)) {
          const binding = this.bindings[name];
          if (!binding) continue;
          const {
            path
          } = binding;
          if (!path.isVariableDeclarator()) continue;
          const {
            parent,
            parentPath
          } = path;
          if (parent.kind !== "var" || seen.has(parent)) continue;
          seen.add(path.parent);
          let firstId;
          const init = [];
          for (const decl of parent.declarations) {
            var _firstId;
            (_firstId = firstId) != null ? _firstId : firstId = decl.id;
            if (decl.init) {
              init.push(assignmentExpression2("=", decl.id, decl.init));
            }
            const ids = Object.keys(getBindingIdentifiers(decl, false, true, true));
            for (const name2 of ids) {
              emit2(identifier4(name2), decl.init != null);
            }
          }
          if (parentPath.parentPath.isFor({
            left: parent
          })) {
            parentPath.replaceWith(firstId);
          } else if (init.length === 0) {
            parentPath.remove();
          } else {
            const expr = init.length === 1 ? init[0] : sequenceExpression2(init);
            if (parentPath.parentPath.isForStatement({
              init: parent
            })) {
              parentPath.replaceWith(expr);
            } else {
              parentPath.replaceWith(expressionStatement2(expr));
            }
          }
        }
      }
    };
    exports2.default = Scope;
    Scope.globals = Object.keys(_globals4.builtin);
    Scope.contextVariables = ["arguments", "undefined", "Infinity", "NaN"];
    {
      Scope.prototype._renameFromMap = function _renameFromMap(map, oldName, newName, value) {
        if (map[oldName]) {
          map[newName] = value;
          map[oldName] = null;
        }
      };
      Scope.prototype.traverse = function(node, opts, state) {
        (0, _index.default)(node, opts, this, state, this.path);
      };
      Scope.prototype._generateUid = function _generateUid(name, i) {
        let id = name;
        if (i > 1) id += i;
        return `_${id}`;
      };
      Scope.prototype.toArray = function toArray(node, i, arrayLikeIsIterable) {
        if (isIdentifier(node)) {
          const binding = this.getBinding(node.name);
          if (binding != null && binding.constant && binding.path.isGenericType("Array")) {
            return node;
          }
        }
        if (isArrayExpression(node)) {
          return node;
        }
        if (isIdentifier(node, {
          name: "arguments"
        })) {
          return callExpression3(memberExpression2(memberExpression2(memberExpression2(identifier4("Array"), identifier4("prototype")), identifier4("slice")), identifier4("call")), [node]);
        }
        let helperName;
        const args = [node];
        if (i === true) {
          helperName = "toConsumableArray";
        } else if (typeof i === "number") {
          args.push(numericLiteral2(i));
          helperName = "slicedToArray";
        } else {
          helperName = "toArray";
        }
        if (arrayLikeIsIterable) {
          args.unshift(this.path.hub.addHelper(helperName));
          helperName = "maybeArrayLike";
        }
        return callExpression3(this.path.hub.addHelper(helperName), args);
      };
      Scope.prototype.getAllBindingsOfKind = function getAllBindingsOfKind(...kinds) {
        const ids = /* @__PURE__ */ Object.create(null);
        for (const kind of kinds) {
          let scope = this;
          do {
            for (const name of Object.keys(scope.bindings)) {
              const binding = scope.bindings[name];
              if (binding.kind === kind) ids[name] = binding;
            }
            scope = scope.parent;
          } while (scope);
        }
        return ids;
      };
      Object.defineProperties(Scope.prototype, {
        parentBlock: {
          configurable: true,
          enumerable: true,
          get() {
            return this.path.parent;
          }
        },
        hub: {
          configurable: true,
          enumerable: true,
          get() {
            return this.path.hub;
          }
        }
      });
    }
  }
});

// ../../node_modules/@jridgewell/set-array/dist/set-array.umd.js
var require_set_array_umd = __commonJS({
  "../../node_modules/@jridgewell/set-array/dist/set-array.umd.js"(exports2, module2) {
    "use strict";
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.setArray = {}));
    })(exports2, function(exports3) {
      "use strict";
      class SetArray {
        constructor() {
          this._indexes = { __proto__: null };
          this.array = [];
        }
      }
      function cast(set) {
        return set;
      }
      function get(setarr, key2) {
        return cast(setarr)._indexes[key2];
      }
      function put(setarr, key2) {
        const index = get(setarr, key2);
        if (index !== void 0)
          return index;
        const { array, _indexes: indexes } = cast(setarr);
        const length = array.push(key2);
        return indexes[key2] = length - 1;
      }
      function pop2(setarr) {
        const { array, _indexes: indexes } = cast(setarr);
        if (array.length === 0)
          return;
        const last = array.pop();
        indexes[last] = void 0;
      }
      function remove(setarr, key2) {
        const index = get(setarr, key2);
        if (index === void 0)
          return;
        const { array, _indexes: indexes } = cast(setarr);
        for (let i = index + 1; i < array.length; i++) {
          const k = array[i];
          array[i - 1] = k;
          indexes[k]--;
        }
        indexes[key2] = void 0;
        array.pop();
      }
      exports3.SetArray = SetArray;
      exports3.get = get;
      exports3.pop = pop2;
      exports3.put = put;
      exports3.remove = remove;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  }
});

// ../../node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js
var require_sourcemap_codec_umd = __commonJS({
  "../../node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js"(exports2, module2) {
    "use strict";
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.sourcemapCodec = {}));
    })(exports2, function(exports3) {
      "use strict";
      const comma = ",".charCodeAt(0);
      const semicolon = ";".charCodeAt(0);
      const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      const intToChar = new Uint8Array(64);
      const charToInt = new Uint8Array(128);
      for (let i = 0; i < chars.length; i++) {
        const c2 = chars.charCodeAt(i);
        intToChar[i] = c2;
        charToInt[c2] = i;
      }
      const td = typeof TextDecoder !== "undefined" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer !== "undefined" ? {
        decode(buf) {
          const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
          return out.toString();
        }
      } : {
        decode(buf) {
          let out = "";
          for (let i = 0; i < buf.length; i++) {
            out += String.fromCharCode(buf[i]);
          }
          return out;
        }
      };
      function decode(mappings) {
        const state = new Int32Array(5);
        const decoded = [];
        let index = 0;
        do {
          const semi = indexOf(mappings, index);
          const line2 = [];
          let sorted = true;
          let lastCol = 0;
          state[0] = 0;
          for (let i = index; i < semi; i++) {
            let seg;
            i = decodeInteger(mappings, i, state, 0);
            const col = state[0];
            if (col < lastCol)
              sorted = false;
            lastCol = col;
            if (hasMoreVlq(mappings, i, semi)) {
              i = decodeInteger(mappings, i, state, 1);
              i = decodeInteger(mappings, i, state, 2);
              i = decodeInteger(mappings, i, state, 3);
              if (hasMoreVlq(mappings, i, semi)) {
                i = decodeInteger(mappings, i, state, 4);
                seg = [col, state[1], state[2], state[3], state[4]];
              } else {
                seg = [col, state[1], state[2], state[3]];
              }
            } else {
              seg = [col];
            }
            line2.push(seg);
          }
          if (!sorted)
            sort(line2);
          decoded.push(line2);
          index = semi + 1;
        } while (index <= mappings.length);
        return decoded;
      }
      function indexOf(mappings, index) {
        const idx = mappings.indexOf(";", index);
        return idx === -1 ? mappings.length : idx;
      }
      function decodeInteger(mappings, pos2, state, j) {
        let value = 0;
        let shift = 0;
        let integer = 0;
        do {
          const c2 = mappings.charCodeAt(pos2++);
          integer = charToInt[c2];
          value |= (integer & 31) << shift;
          shift += 5;
        } while (integer & 32);
        const shouldNegate = value & 1;
        value >>>= 1;
        if (shouldNegate) {
          value = -2147483648 | -value;
        }
        state[j] += value;
        return pos2;
      }
      function hasMoreVlq(mappings, i, length) {
        if (i >= length)
          return false;
        return mappings.charCodeAt(i) !== comma;
      }
      function sort(line2) {
        line2.sort(sortComparator);
      }
      function sortComparator(a, b) {
        return a[0] - b[0];
      }
      function encode(decoded) {
        const state = new Int32Array(5);
        const bufLength = 1024 * 16;
        const subLength = bufLength - 36;
        const buf = new Uint8Array(bufLength);
        const sub = buf.subarray(0, subLength);
        let pos2 = 0;
        let out = "";
        for (let i = 0; i < decoded.length; i++) {
          const line2 = decoded[i];
          if (i > 0) {
            if (pos2 === bufLength) {
              out += td.decode(buf);
              pos2 = 0;
            }
            buf[pos2++] = semicolon;
          }
          if (line2.length === 0)
            continue;
          state[0] = 0;
          for (let j = 0; j < line2.length; j++) {
            const segment = line2[j];
            if (pos2 > subLength) {
              out += td.decode(sub);
              buf.copyWithin(0, subLength, pos2);
              pos2 -= subLength;
            }
            if (j > 0)
              buf[pos2++] = comma;
            pos2 = encodeInteger(buf, pos2, state, segment, 0);
            if (segment.length === 1)
              continue;
            pos2 = encodeInteger(buf, pos2, state, segment, 1);
            pos2 = encodeInteger(buf, pos2, state, segment, 2);
            pos2 = encodeInteger(buf, pos2, state, segment, 3);
            if (segment.length === 4)
              continue;
            pos2 = encodeInteger(buf, pos2, state, segment, 4);
          }
        }
        return out + td.decode(buf.subarray(0, pos2));
      }
      function encodeInteger(buf, pos2, state, segment, j) {
        const next = segment[j];
        let num = next - state[j];
        state[j] = next;
        num = num < 0 ? -num << 1 | 1 : num << 1;
        do {
          let clamped = num & 31;
          num >>>= 5;
          if (num > 0)
            clamped |= 32;
          buf[pos2++] = intToChar[clamped];
        } while (num > 0);
        return pos2;
      }
      exports3.decode = decode;
      exports3.encode = encode;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  }
});

// ../../node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js
var require_resolve_uri_umd = __commonJS({
  "../../node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js"(exports2, module2) {
    "use strict";
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.resolveURI = factory());
    })(exports2, function() {
      "use strict";
      const schemeRegex = /^[\w+.-]+:\/\//;
      const urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/;
      const fileRegex = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
      var UrlType;
      (function(UrlType2) {
        UrlType2[UrlType2["Empty"] = 1] = "Empty";
        UrlType2[UrlType2["Hash"] = 2] = "Hash";
        UrlType2[UrlType2["Query"] = 3] = "Query";
        UrlType2[UrlType2["RelativePath"] = 4] = "RelativePath";
        UrlType2[UrlType2["AbsolutePath"] = 5] = "AbsolutePath";
        UrlType2[UrlType2["SchemeRelative"] = 6] = "SchemeRelative";
        UrlType2[UrlType2["Absolute"] = 7] = "Absolute";
      })(UrlType || (UrlType = {}));
      function isAbsoluteUrl(input) {
        return schemeRegex.test(input);
      }
      function isSchemeRelativeUrl(input) {
        return input.startsWith("//");
      }
      function isAbsolutePath(input) {
        return input.startsWith("/");
      }
      function isFileUrl(input) {
        return input.startsWith("file:");
      }
      function isRelative(input) {
        return /^[.?#]/.test(input);
      }
      function parseAbsoluteUrl(input) {
        const match = urlRegex.exec(input);
        return makeUrl(match[1], match[2] || "", match[3], match[4] || "", match[5] || "/", match[6] || "", match[7] || "");
      }
      function parseFileUrl(input) {
        const match = fileRegex.exec(input);
        const path = match[2];
        return makeUrl("file:", "", match[1] || "", "", isAbsolutePath(path) ? path : "/" + path, match[3] || "", match[4] || "");
      }
      function makeUrl(scheme, user, host, port, path, query, hash) {
        return {
          scheme,
          user,
          host,
          port,
          path,
          query,
          hash,
          type: UrlType.Absolute
        };
      }
      function parseUrl(input) {
        if (isSchemeRelativeUrl(input)) {
          const url2 = parseAbsoluteUrl("http:" + input);
          url2.scheme = "";
          url2.type = UrlType.SchemeRelative;
          return url2;
        }
        if (isAbsolutePath(input)) {
          const url2 = parseAbsoluteUrl("http://foo.com" + input);
          url2.scheme = "";
          url2.host = "";
          url2.type = UrlType.AbsolutePath;
          return url2;
        }
        if (isFileUrl(input))
          return parseFileUrl(input);
        if (isAbsoluteUrl(input))
          return parseAbsoluteUrl(input);
        const url = parseAbsoluteUrl("http://foo.com/" + input);
        url.scheme = "";
        url.host = "";
        url.type = input ? input.startsWith("?") ? UrlType.Query : input.startsWith("#") ? UrlType.Hash : UrlType.RelativePath : UrlType.Empty;
        return url;
      }
      function stripPathFilename(path) {
        if (path.endsWith("/.."))
          return path;
        const index = path.lastIndexOf("/");
        return path.slice(0, index + 1);
      }
      function mergePaths(url, base) {
        normalizePath(base, base.type);
        if (url.path === "/") {
          url.path = base.path;
        } else {
          url.path = stripPathFilename(base.path) + url.path;
        }
      }
      function normalizePath(url, type) {
        const rel = type <= UrlType.RelativePath;
        const pieces = url.path.split("/");
        let pointer = 1;
        let positive = 0;
        let addTrailingSlash = false;
        for (let i = 1; i < pieces.length; i++) {
          const piece = pieces[i];
          if (!piece) {
            addTrailingSlash = true;
            continue;
          }
          addTrailingSlash = false;
          if (piece === ".")
            continue;
          if (piece === "..") {
            if (positive) {
              addTrailingSlash = true;
              positive--;
              pointer--;
            } else if (rel) {
              pieces[pointer++] = piece;
            }
            continue;
          }
          pieces[pointer++] = piece;
          positive++;
        }
        let path = "";
        for (let i = 1; i < pointer; i++) {
          path += "/" + pieces[i];
        }
        if (!path || addTrailingSlash && !path.endsWith("/..")) {
          path += "/";
        }
        url.path = path;
      }
      function resolve(input, base) {
        if (!input && !base)
          return "";
        const url = parseUrl(input);
        let inputType = url.type;
        if (base && inputType !== UrlType.Absolute) {
          const baseUrl = parseUrl(base);
          const baseType = baseUrl.type;
          switch (inputType) {
            case UrlType.Empty:
              url.hash = baseUrl.hash;
            // fall through
            case UrlType.Hash:
              url.query = baseUrl.query;
            // fall through
            case UrlType.Query:
            case UrlType.RelativePath:
              mergePaths(url, baseUrl);
            // fall through
            case UrlType.AbsolutePath:
              url.user = baseUrl.user;
              url.host = baseUrl.host;
              url.port = baseUrl.port;
            // fall through
            case UrlType.SchemeRelative:
              url.scheme = baseUrl.scheme;
          }
          if (baseType > inputType)
            inputType = baseType;
        }
        normalizePath(url, inputType);
        const queryHash = url.query + url.hash;
        switch (inputType) {
          // This is impossible, because of the empty checks at the start of the function.
          // case UrlType.Empty:
          case UrlType.Hash:
          case UrlType.Query:
            return queryHash;
          case UrlType.RelativePath: {
            const path = url.path.slice(1);
            if (!path)
              return queryHash || ".";
            if (isRelative(base || input) && !isRelative(path)) {
              return "./" + path + queryHash;
            }
            return path + queryHash;
          }
          case UrlType.AbsolutePath:
            return url.path + queryHash;
          default:
            return url.scheme + "//" + url.user + url.host + url.port + url.path + queryHash;
        }
      }
      return resolve;
    });
  }
});

// ../../node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js
var require_trace_mapping_umd = __commonJS({
  "../../node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js"(exports2, module2) {
    "use strict";
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2, require_sourcemap_codec_umd(), require_resolve_uri_umd()) : typeof define === "function" && define.amd ? define(["exports", "@jridgewell/sourcemap-codec", "@jridgewell/resolve-uri"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.traceMapping = {}, global2.sourcemapCodec, global2.resolveURI));
    })(exports2, function(exports3, sourcemapCodec, resolveUri) {
      "use strict";
      function resolve(input, base) {
        if (base && !base.endsWith("/"))
          base += "/";
        return resolveUri(input, base);
      }
      function stripFilename(path) {
        if (!path)
          return "";
        const index = path.lastIndexOf("/");
        return path.slice(0, index + 1);
      }
      const COLUMN = 0;
      const SOURCES_INDEX = 1;
      const SOURCE_LINE = 2;
      const SOURCE_COLUMN = 3;
      const NAMES_INDEX = 4;
      const REV_GENERATED_LINE = 1;
      const REV_GENERATED_COLUMN = 2;
      function maybeSort(mappings, owned) {
        const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);
        if (unsortedIndex === mappings.length)
          return mappings;
        if (!owned)
          mappings = mappings.slice();
        for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {
          mappings[i] = sortSegments(mappings[i], owned);
        }
        return mappings;
      }
      function nextUnsortedSegmentLine(mappings, start) {
        for (let i = start; i < mappings.length; i++) {
          if (!isSorted(mappings[i]))
            return i;
        }
        return mappings.length;
      }
      function isSorted(line2) {
        for (let j = 1; j < line2.length; j++) {
          if (line2[j][COLUMN] < line2[j - 1][COLUMN]) {
            return false;
          }
        }
        return true;
      }
      function sortSegments(line2, owned) {
        if (!owned)
          line2 = line2.slice();
        return line2.sort(sortComparator);
      }
      function sortComparator(a, b) {
        return a[COLUMN] - b[COLUMN];
      }
      let found = false;
      function binarySearch(haystack, needle, low, high) {
        while (low <= high) {
          const mid = low + (high - low >> 1);
          const cmp = haystack[mid][COLUMN] - needle;
          if (cmp === 0) {
            found = true;
            return mid;
          }
          if (cmp < 0) {
            low = mid + 1;
          } else {
            high = mid - 1;
          }
        }
        found = false;
        return low - 1;
      }
      function upperBound(haystack, needle, index) {
        for (let i = index + 1; i < haystack.length; index = i++) {
          if (haystack[i][COLUMN] !== needle)
            break;
        }
        return index;
      }
      function lowerBound(haystack, needle, index) {
        for (let i = index - 1; i >= 0; index = i--) {
          if (haystack[i][COLUMN] !== needle)
            break;
        }
        return index;
      }
      function memoizedState() {
        return {
          lastKey: -1,
          lastNeedle: -1,
          lastIndex: -1
        };
      }
      function memoizedBinarySearch(haystack, needle, state, key2) {
        const { lastKey, lastNeedle, lastIndex } = state;
        let low = 0;
        let high = haystack.length - 1;
        if (key2 === lastKey) {
          if (needle === lastNeedle) {
            found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;
            return lastIndex;
          }
          if (needle >= lastNeedle) {
            low = lastIndex === -1 ? 0 : lastIndex;
          } else {
            high = lastIndex;
          }
        }
        state.lastKey = key2;
        state.lastNeedle = needle;
        return state.lastIndex = binarySearch(haystack, needle, low, high);
      }
      function buildBySources(decoded, memos) {
        const sources = memos.map(buildNullArray);
        for (let i = 0; i < decoded.length; i++) {
          const line2 = decoded[i];
          for (let j = 0; j < line2.length; j++) {
            const seg = line2[j];
            if (seg.length === 1)
              continue;
            const sourceIndex2 = seg[SOURCES_INDEX];
            const sourceLine = seg[SOURCE_LINE];
            const sourceColumn = seg[SOURCE_COLUMN];
            const originalSource = sources[sourceIndex2];
            const originalLine = originalSource[sourceLine] || (originalSource[sourceLine] = []);
            const memo = memos[sourceIndex2];
            let index = upperBound(originalLine, sourceColumn, memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine));
            memo.lastIndex = ++index;
            insert(originalLine, index, [sourceColumn, i, seg[COLUMN]]);
          }
        }
        return sources;
      }
      function insert(array, index, value) {
        for (let i = array.length; i > index; i--) {
          array[i] = array[i - 1];
        }
        array[index] = value;
      }
      function buildNullArray() {
        return { __proto__: null };
      }
      const AnyMap = function(map, mapUrl) {
        const parsed = parse4(map);
        if (!("sections" in parsed)) {
          return new TraceMap(parsed, mapUrl);
        }
        const mappings = [];
        const sources = [];
        const sourcesContent = [];
        const names = [];
        const ignoreList = [];
        recurse(parsed, mapUrl, mappings, sources, sourcesContent, names, ignoreList, 0, 0, Infinity, Infinity);
        const joined = {
          version: 3,
          file: parsed.file,
          names,
          sources,
          sourcesContent,
          mappings,
          ignoreList
        };
        return presortedDecodedMap(joined);
      };
      function parse4(map) {
        return typeof map === "string" ? JSON.parse(map) : map;
      }
      function recurse(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {
        const { sections } = input;
        for (let i = 0; i < sections.length; i++) {
          const { map, offset } = sections[i];
          let sl = stopLine;
          let sc = stopColumn;
          if (i + 1 < sections.length) {
            const nextOffset = sections[i + 1].offset;
            sl = Math.min(stopLine, lineOffset + nextOffset.line);
            if (sl === stopLine) {
              sc = Math.min(stopColumn, columnOffset + nextOffset.column);
            } else if (sl < stopLine) {
              sc = columnOffset + nextOffset.column;
            }
          }
          addSection(map, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset + offset.line, columnOffset + offset.column, sl, sc);
        }
      }
      function addSection(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {
        const parsed = parse4(input);
        if ("sections" in parsed)
          return recurse(...arguments);
        const map = new TraceMap(parsed, mapUrl);
        const sourcesOffset = sources.length;
        const namesOffset = names.length;
        const decoded = decodedMappings(map);
        const { resolvedSources, sourcesContent: contents, ignoreList: ignores } = map;
        append(sources, resolvedSources);
        append(names, map.names);
        if (contents)
          append(sourcesContent, contents);
        else
          for (let i = 0; i < resolvedSources.length; i++)
            sourcesContent.push(null);
        if (ignores)
          for (let i = 0; i < ignores.length; i++)
            ignoreList.push(ignores[i] + sourcesOffset);
        for (let i = 0; i < decoded.length; i++) {
          const lineI = lineOffset + i;
          if (lineI > stopLine)
            return;
          const out = getLine(mappings, lineI);
          const cOffset = i === 0 ? columnOffset : 0;
          const line2 = decoded[i];
          for (let j = 0; j < line2.length; j++) {
            const seg = line2[j];
            const column2 = cOffset + seg[COLUMN];
            if (lineI === stopLine && column2 >= stopColumn)
              return;
            if (seg.length === 1) {
              out.push([column2]);
              continue;
            }
            const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];
            const sourceLine = seg[SOURCE_LINE];
            const sourceColumn = seg[SOURCE_COLUMN];
            out.push(seg.length === 4 ? [column2, sourcesIndex, sourceLine, sourceColumn] : [column2, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]]);
          }
        }
      }
      function append(arr, other) {
        for (let i = 0; i < other.length; i++)
          arr.push(other[i]);
      }
      function getLine(arr, index) {
        for (let i = arr.length; i <= index; i++)
          arr[i] = [];
        return arr[index];
      }
      const LINE_GTR_ZERO = "`line` must be greater than 0 (lines start at line 1)";
      const COL_GTR_EQ_ZERO = "`column` must be greater than or equal to 0 (columns start at column 0)";
      const LEAST_UPPER_BOUND = -1;
      const GREATEST_LOWER_BOUND = 1;
      class TraceMap {
        constructor(map, mapUrl) {
          const isString = typeof map === "string";
          if (!isString && map._decodedMemo)
            return map;
          const parsed = isString ? JSON.parse(map) : map;
          const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;
          this.version = version;
          this.file = file;
          this.names = names || [];
          this.sourceRoot = sourceRoot;
          this.sources = sources;
          this.sourcesContent = sourcesContent;
          this.ignoreList = parsed.ignoreList || parsed.x_google_ignoreList || void 0;
          const from = resolve(sourceRoot || "", stripFilename(mapUrl));
          this.resolvedSources = sources.map((s) => resolve(s || "", from));
          const { mappings } = parsed;
          if (typeof mappings === "string") {
            this._encoded = mappings;
            this._decoded = void 0;
          } else {
            this._encoded = void 0;
            this._decoded = maybeSort(mappings, isString);
          }
          this._decodedMemo = memoizedState();
          this._bySources = void 0;
          this._bySourceMemos = void 0;
        }
      }
      function cast(map) {
        return map;
      }
      function encodedMappings(map) {
        var _a;
        var _b;
        return (_a = (_b = cast(map))._encoded) !== null && _a !== void 0 ? _a : _b._encoded = sourcemapCodec.encode(cast(map)._decoded);
      }
      function decodedMappings(map) {
        var _a;
        return (_a = cast(map))._decoded || (_a._decoded = sourcemapCodec.decode(cast(map)._encoded));
      }
      function traceSegment(map, line2, column2) {
        const decoded = decodedMappings(map);
        if (line2 >= decoded.length)
          return null;
        const segments = decoded[line2];
        const index = traceSegmentInternal(segments, cast(map)._decodedMemo, line2, column2, GREATEST_LOWER_BOUND);
        return index === -1 ? null : segments[index];
      }
      function originalPositionFor(map, needle) {
        let { line: line2, column: column2, bias } = needle;
        line2--;
        if (line2 < 0)
          throw new Error(LINE_GTR_ZERO);
        if (column2 < 0)
          throw new Error(COL_GTR_EQ_ZERO);
        const decoded = decodedMappings(map);
        if (line2 >= decoded.length)
          return OMapping(null, null, null, null);
        const segments = decoded[line2];
        const index = traceSegmentInternal(segments, cast(map)._decodedMemo, line2, column2, bias || GREATEST_LOWER_BOUND);
        if (index === -1)
          return OMapping(null, null, null, null);
        const segment = segments[index];
        if (segment.length === 1)
          return OMapping(null, null, null, null);
        const { names, resolvedSources } = map;
        return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], segment.length === 5 ? names[segment[NAMES_INDEX]] : null);
      }
      function generatedPositionFor(map, needle) {
        const { source: source2, line: line2, column: column2, bias } = needle;
        return generatedPosition(map, source2, line2, column2, bias || GREATEST_LOWER_BOUND, false);
      }
      function allGeneratedPositionsFor(map, needle) {
        const { source: source2, line: line2, column: column2, bias } = needle;
        return generatedPosition(map, source2, line2, column2, bias || LEAST_UPPER_BOUND, true);
      }
      function eachMapping(map, cb) {
        const decoded = decodedMappings(map);
        const { names, resolvedSources } = map;
        for (let i = 0; i < decoded.length; i++) {
          const line2 = decoded[i];
          for (let j = 0; j < line2.length; j++) {
            const seg = line2[j];
            const generatedLine = i + 1;
            const generatedColumn = seg[0];
            let source2 = null;
            let originalLine = null;
            let originalColumn = null;
            let name = null;
            if (seg.length !== 1) {
              source2 = resolvedSources[seg[1]];
              originalLine = seg[2] + 1;
              originalColumn = seg[3];
            }
            if (seg.length === 5)
              name = names[seg[4]];
            cb({
              generatedLine,
              generatedColumn,
              source: source2,
              originalLine,
              originalColumn,
              name
            });
          }
        }
      }
      function sourceIndex(map, source2) {
        const { sources, resolvedSources } = map;
        let index = sources.indexOf(source2);
        if (index === -1)
          index = resolvedSources.indexOf(source2);
        return index;
      }
      function sourceContentFor(map, source2) {
        const { sourcesContent } = map;
        if (sourcesContent == null)
          return null;
        const index = sourceIndex(map, source2);
        return index === -1 ? null : sourcesContent[index];
      }
      function isIgnored(map, source2) {
        const { ignoreList } = map;
        if (ignoreList == null)
          return false;
        const index = sourceIndex(map, source2);
        return index === -1 ? false : ignoreList.includes(index);
      }
      function presortedDecodedMap(map, mapUrl) {
        const tracer = new TraceMap(clone(map, []), mapUrl);
        cast(tracer)._decoded = map.mappings;
        return tracer;
      }
      function decodedMap(map) {
        return clone(map, decodedMappings(map));
      }
      function encodedMap(map) {
        return clone(map, encodedMappings(map));
      }
      function clone(map, mappings) {
        return {
          version: map.version,
          file: map.file,
          names: map.names,
          sourceRoot: map.sourceRoot,
          sources: map.sources,
          sourcesContent: map.sourcesContent,
          mappings,
          ignoreList: map.ignoreList || map.x_google_ignoreList
        };
      }
      function OMapping(source2, line2, column2, name) {
        return { source: source2, line: line2, column: column2, name };
      }
      function GMapping(line2, column2) {
        return { line: line2, column: column2 };
      }
      function traceSegmentInternal(segments, memo, line2, column2, bias) {
        let index = memoizedBinarySearch(segments, column2, memo, line2);
        if (found) {
          index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column2, index);
        } else if (bias === LEAST_UPPER_BOUND)
          index++;
        if (index === -1 || index === segments.length)
          return -1;
        return index;
      }
      function sliceGeneratedPositions(segments, memo, line2, column2, bias) {
        let min = traceSegmentInternal(segments, memo, line2, column2, GREATEST_LOWER_BOUND);
        if (!found && bias === LEAST_UPPER_BOUND)
          min++;
        if (min === -1 || min === segments.length)
          return [];
        const matchedColumn = found ? column2 : segments[min][COLUMN];
        if (!found)
          min = lowerBound(segments, matchedColumn, min);
        const max = upperBound(segments, matchedColumn, min);
        const result = [];
        for (; min <= max; min++) {
          const segment = segments[min];
          result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));
        }
        return result;
      }
      function generatedPosition(map, source2, line2, column2, bias, all) {
        var _a;
        line2--;
        if (line2 < 0)
          throw new Error(LINE_GTR_ZERO);
        if (column2 < 0)
          throw new Error(COL_GTR_EQ_ZERO);
        const { sources, resolvedSources } = map;
        let sourceIndex2 = sources.indexOf(source2);
        if (sourceIndex2 === -1)
          sourceIndex2 = resolvedSources.indexOf(source2);
        if (sourceIndex2 === -1)
          return all ? [] : GMapping(null, null);
        const generated = (_a = cast(map))._bySources || (_a._bySources = buildBySources(decodedMappings(map), cast(map)._bySourceMemos = sources.map(memoizedState)));
        const segments = generated[sourceIndex2][line2];
        if (segments == null)
          return all ? [] : GMapping(null, null);
        const memo = cast(map)._bySourceMemos[sourceIndex2];
        if (all)
          return sliceGeneratedPositions(segments, memo, line2, column2, bias);
        const index = traceSegmentInternal(segments, memo, line2, column2, bias);
        if (index === -1)
          return GMapping(null, null);
        const segment = segments[index];
        return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);
      }
      exports3.AnyMap = AnyMap;
      exports3.GREATEST_LOWER_BOUND = GREATEST_LOWER_BOUND;
      exports3.LEAST_UPPER_BOUND = LEAST_UPPER_BOUND;
      exports3.TraceMap = TraceMap;
      exports3.allGeneratedPositionsFor = allGeneratedPositionsFor;
      exports3.decodedMap = decodedMap;
      exports3.decodedMappings = decodedMappings;
      exports3.eachMapping = eachMapping;
      exports3.encodedMap = encodedMap;
      exports3.encodedMappings = encodedMappings;
      exports3.generatedPositionFor = generatedPositionFor;
      exports3.isIgnored = isIgnored;
      exports3.originalPositionFor = originalPositionFor;
      exports3.presortedDecodedMap = presortedDecodedMap;
      exports3.sourceContentFor = sourceContentFor;
      exports3.traceSegment = traceSegment;
    });
  }
});

// ../../node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js
var require_gen_mapping_umd = __commonJS({
  "../../node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js"(exports2, module2) {
    "use strict";
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2, require_set_array_umd(), require_sourcemap_codec_umd(), require_trace_mapping_umd()) : typeof define === "function" && define.amd ? define(["exports", "@jridgewell/set-array", "@jridgewell/sourcemap-codec", "@jridgewell/trace-mapping"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.genMapping = {}, global2.setArray, global2.sourcemapCodec, global2.traceMapping));
    })(exports2, function(exports3, setArray, sourcemapCodec, traceMapping) {
      "use strict";
      const COLUMN = 0;
      const SOURCES_INDEX = 1;
      const SOURCE_LINE = 2;
      const SOURCE_COLUMN = 3;
      const NAMES_INDEX = 4;
      const NO_NAME = -1;
      class GenMapping {
        constructor({ file, sourceRoot } = {}) {
          this._names = new setArray.SetArray();
          this._sources = new setArray.SetArray();
          this._sourcesContent = [];
          this._mappings = [];
          this.file = file;
          this.sourceRoot = sourceRoot;
          this._ignoreList = new setArray.SetArray();
        }
      }
      function cast(map) {
        return map;
      }
      function addSegment(map, genLine, genColumn, source2, sourceLine, sourceColumn, name, content) {
        return addSegmentInternal(false, map, genLine, genColumn, source2, sourceLine, sourceColumn, name, content);
      }
      function addMapping(map, mapping) {
        return addMappingInternal(false, map, mapping);
      }
      const maybeAddSegment = (map, genLine, genColumn, source2, sourceLine, sourceColumn, name, content) => {
        return addSegmentInternal(true, map, genLine, genColumn, source2, sourceLine, sourceColumn, name, content);
      };
      const maybeAddMapping = (map, mapping) => {
        return addMappingInternal(true, map, mapping);
      };
      function setSourceContent(map, source2, content) {
        const { _sources: sources, _sourcesContent: sourcesContent } = cast(map);
        const index = setArray.put(sources, source2);
        sourcesContent[index] = content;
      }
      function setIgnore(map, source2, ignore = true) {
        const { _sources: sources, _sourcesContent: sourcesContent, _ignoreList: ignoreList } = cast(map);
        const index = setArray.put(sources, source2);
        if (index === sourcesContent.length)
          sourcesContent[index] = null;
        if (ignore)
          setArray.put(ignoreList, index);
        else
          setArray.remove(ignoreList, index);
      }
      function toDecodedMap(map) {
        const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names, _ignoreList: ignoreList } = cast(map);
        removeEmptyFinalLines(mappings);
        return {
          version: 3,
          file: map.file || void 0,
          names: names.array,
          sourceRoot: map.sourceRoot || void 0,
          sources: sources.array,
          sourcesContent,
          mappings,
          ignoreList: ignoreList.array
        };
      }
      function toEncodedMap(map) {
        const decoded = toDecodedMap(map);
        return Object.assign(Object.assign({}, decoded), { mappings: sourcemapCodec.encode(decoded.mappings) });
      }
      function fromMap(input) {
        const map = new traceMapping.TraceMap(input);
        const gen = new GenMapping({ file: map.file, sourceRoot: map.sourceRoot });
        putAll(cast(gen)._names, map.names);
        putAll(cast(gen)._sources, map.sources);
        cast(gen)._sourcesContent = map.sourcesContent || map.sources.map(() => null);
        cast(gen)._mappings = traceMapping.decodedMappings(map);
        if (map.ignoreList)
          putAll(cast(gen)._ignoreList, map.ignoreList);
        return gen;
      }
      function allMappings(map) {
        const out = [];
        const { _mappings: mappings, _sources: sources, _names: names } = cast(map);
        for (let i = 0; i < mappings.length; i++) {
          const line2 = mappings[i];
          for (let j = 0; j < line2.length; j++) {
            const seg = line2[j];
            const generated = { line: i + 1, column: seg[COLUMN] };
            let source2 = void 0;
            let original = void 0;
            let name = void 0;
            if (seg.length !== 1) {
              source2 = sources.array[seg[SOURCES_INDEX]];
              original = { line: seg[SOURCE_LINE] + 1, column: seg[SOURCE_COLUMN] };
              if (seg.length === 5)
                name = names.array[seg[NAMES_INDEX]];
            }
            out.push({ generated, source: source2, original, name });
          }
        }
        return out;
      }
      function addSegmentInternal(skipable, map, genLine, genColumn, source2, sourceLine, sourceColumn, name, content) {
        const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names } = cast(map);
        const line2 = getLine(mappings, genLine);
        const index = getColumnIndex(line2, genColumn);
        if (!source2) {
          if (skipable && skipSourceless(line2, index))
            return;
          return insert(line2, index, [genColumn]);
        }
        const sourcesIndex = setArray.put(sources, source2);
        const namesIndex = name ? setArray.put(names, name) : NO_NAME;
        if (sourcesIndex === sourcesContent.length)
          sourcesContent[sourcesIndex] = content !== null && content !== void 0 ? content : null;
        if (skipable && skipSource(line2, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {
          return;
        }
        return insert(line2, index, name ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex] : [genColumn, sourcesIndex, sourceLine, sourceColumn]);
      }
      function getLine(mappings, index) {
        for (let i = mappings.length; i <= index; i++) {
          mappings[i] = [];
        }
        return mappings[index];
      }
      function getColumnIndex(line2, genColumn) {
        let index = line2.length;
        for (let i = index - 1; i >= 0; index = i--) {
          const current = line2[i];
          if (genColumn >= current[COLUMN])
            break;
        }
        return index;
      }
      function insert(array, index, value) {
        for (let i = array.length; i > index; i--) {
          array[i] = array[i - 1];
        }
        array[index] = value;
      }
      function removeEmptyFinalLines(mappings) {
        const { length } = mappings;
        let len = length;
        for (let i = len - 1; i >= 0; len = i, i--) {
          if (mappings[i].length > 0)
            break;
        }
        if (len < length)
          mappings.length = len;
      }
      function putAll(setarr, array) {
        for (let i = 0; i < array.length; i++)
          setArray.put(setarr, array[i]);
      }
      function skipSourceless(line2, index) {
        if (index === 0)
          return true;
        const prev = line2[index - 1];
        return prev.length === 1;
      }
      function skipSource(line2, index, sourcesIndex, sourceLine, sourceColumn, namesIndex) {
        if (index === 0)
          return false;
        const prev = line2[index - 1];
        if (prev.length === 1)
          return false;
        return sourcesIndex === prev[SOURCES_INDEX] && sourceLine === prev[SOURCE_LINE] && sourceColumn === prev[SOURCE_COLUMN] && namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME);
      }
      function addMappingInternal(skipable, map, mapping) {
        const { generated, source: source2, original, name, content } = mapping;
        if (!source2) {
          return addSegmentInternal(skipable, map, generated.line - 1, generated.column, null, null, null, null, null);
        }
        return addSegmentInternal(skipable, map, generated.line - 1, generated.column, source2, original.line - 1, original.column, name, content);
      }
      exports3.GenMapping = GenMapping;
      exports3.addMapping = addMapping;
      exports3.addSegment = addSegment;
      exports3.allMappings = allMappings;
      exports3.fromMap = fromMap;
      exports3.maybeAddMapping = maybeAddMapping;
      exports3.maybeAddSegment = maybeAddSegment;
      exports3.setIgnore = setIgnore;
      exports3.setSourceContent = setSourceContent;
      exports3.toDecodedMap = toDecodedMap;
      exports3.toEncodedMap = toEncodedMap;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  }
});

// node_modules/@babel/helpers/node_modules/@babel/generator/lib/source-map.js
var require_source_map = __commonJS({
  "node_modules/@babel/helpers/node_modules/@babel/generator/lib/source-map.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _genMapping = require_gen_mapping_umd();
    var _traceMapping = require_trace_mapping_umd();
    var SourceMap = class {
      constructor(opts, code) {
        var _opts$sourceFileName;
        this._map = void 0;
        this._rawMappings = void 0;
        this._sourceFileName = void 0;
        this._lastGenLine = 0;
        this._lastSourceLine = 0;
        this._lastSourceColumn = 0;
        this._inputMap = void 0;
        const map = this._map = new _genMapping.GenMapping({
          sourceRoot: opts.sourceRoot
        });
        this._sourceFileName = (_opts$sourceFileName = opts.sourceFileName) == null ? void 0 : _opts$sourceFileName.replace(/\\/g, "/");
        this._rawMappings = void 0;
        if (opts.inputSourceMap) {
          this._inputMap = new _traceMapping.TraceMap(opts.inputSourceMap);
          const resolvedSources = this._inputMap.resolvedSources;
          if (resolvedSources.length) {
            for (let i = 0; i < resolvedSources.length; i++) {
              var _this$_inputMap$sourc;
              (0, _genMapping.setSourceContent)(map, resolvedSources[i], (_this$_inputMap$sourc = this._inputMap.sourcesContent) == null ? void 0 : _this$_inputMap$sourc[i]);
            }
          }
        }
        if (typeof code === "string" && !opts.inputSourceMap) {
          (0, _genMapping.setSourceContent)(map, this._sourceFileName, code);
        } else if (typeof code === "object") {
          for (const sourceFileName of Object.keys(code)) {
            (0, _genMapping.setSourceContent)(map, sourceFileName.replace(/\\/g, "/"), code[sourceFileName]);
          }
        }
      }
      get() {
        return (0, _genMapping.toEncodedMap)(this._map);
      }
      getDecoded() {
        return (0, _genMapping.toDecodedMap)(this._map);
      }
      getRawMappings() {
        return this._rawMappings || (this._rawMappings = (0, _genMapping.allMappings)(this._map));
      }
      mark(generated, line2, column2, identifierName, identifierNamePos, filename) {
        var _originalMapping;
        this._rawMappings = void 0;
        let originalMapping;
        if (line2 != null) {
          if (this._inputMap) {
            originalMapping = (0, _traceMapping.originalPositionFor)(this._inputMap, {
              line: line2,
              column: column2
            });
            if (!originalMapping.name && identifierNamePos) {
              const originalIdentifierMapping = (0, _traceMapping.originalPositionFor)(this._inputMap, identifierNamePos);
              if (originalIdentifierMapping.name) {
                identifierName = originalIdentifierMapping.name;
              }
            }
          } else {
            originalMapping = {
              source: (filename == null ? void 0 : filename.replace(/\\/g, "/")) || this._sourceFileName,
              line: line2,
              column: column2
            };
          }
        }
        (0, _genMapping.maybeAddMapping)(this._map, {
          name: identifierName,
          generated,
          source: (_originalMapping = originalMapping) == null ? void 0 : _originalMapping.source,
          original: originalMapping
        });
      }
    };
    exports2.default = SourceMap;
  }
});

// node_modules/@babel/helpers/node_modules/@babel/generator/lib/buffer.js
var require_buffer = __commonJS({
  "node_modules/@babel/helpers/node_modules/@babel/generator/lib/buffer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var Buffer2 = class {
      constructor(map, indentChar) {
        this._map = null;
        this._buf = "";
        this._str = "";
        this._appendCount = 0;
        this._last = 0;
        this._queue = [];
        this._queueCursor = 0;
        this._canMarkIdName = true;
        this._indentChar = "";
        this._fastIndentations = [];
        this._position = {
          line: 1,
          column: 0
        };
        this._sourcePosition = {
          identifierName: void 0,
          identifierNamePos: void 0,
          line: void 0,
          column: void 0,
          filename: void 0
        };
        this._map = map;
        this._indentChar = indentChar;
        for (let i = 0; i < 64; i++) {
          this._fastIndentations.push(indentChar.repeat(i));
        }
        this._allocQueue();
      }
      _allocQueue() {
        const queue = this._queue;
        for (let i = 0; i < 16; i++) {
          queue.push({
            char: 0,
            repeat: 1,
            line: void 0,
            column: void 0,
            identifierName: void 0,
            identifierNamePos: void 0,
            filename: ""
          });
        }
      }
      _pushQueue(char, repeat, line2, column2, filename) {
        const cursor = this._queueCursor;
        if (cursor === this._queue.length) {
          this._allocQueue();
        }
        const item = this._queue[cursor];
        item.char = char;
        item.repeat = repeat;
        item.line = line2;
        item.column = column2;
        item.filename = filename;
        this._queueCursor++;
      }
      _popQueue() {
        if (this._queueCursor === 0) {
          throw new Error("Cannot pop from empty queue");
        }
        return this._queue[--this._queueCursor];
      }
      get() {
        this._flush();
        const map = this._map;
        const result = {
          code: (this._buf + this._str).trimRight(),
          decodedMap: map == null ? void 0 : map.getDecoded(),
          get __mergedMap() {
            return this.map;
          },
          get map() {
            const resultMap = map ? map.get() : null;
            result.map = resultMap;
            return resultMap;
          },
          set map(value) {
            Object.defineProperty(result, "map", {
              value,
              writable: true
            });
          },
          get rawMappings() {
            const mappings = map == null ? void 0 : map.getRawMappings();
            result.rawMappings = mappings;
            return mappings;
          },
          set rawMappings(value) {
            Object.defineProperty(result, "rawMappings", {
              value,
              writable: true
            });
          }
        };
        return result;
      }
      append(str, maybeNewline) {
        this._flush();
        this._append(str, this._sourcePosition, maybeNewline);
      }
      appendChar(char) {
        this._flush();
        this._appendChar(char, 1, this._sourcePosition);
      }
      queue(char) {
        if (char === 10) {
          while (this._queueCursor !== 0) {
            const char2 = this._queue[this._queueCursor - 1].char;
            if (char2 !== 32 && char2 !== 9) {
              break;
            }
            this._queueCursor--;
          }
        }
        const sourcePosition = this._sourcePosition;
        this._pushQueue(char, 1, sourcePosition.line, sourcePosition.column, sourcePosition.filename);
      }
      queueIndentation(repeat) {
        if (repeat === 0) return;
        this._pushQueue(-1, repeat, void 0, void 0, void 0);
      }
      _flush() {
        const queueCursor = this._queueCursor;
        const queue = this._queue;
        for (let i = 0; i < queueCursor; i++) {
          const item = queue[i];
          this._appendChar(item.char, item.repeat, item);
        }
        this._queueCursor = 0;
      }
      _appendChar(char, repeat, sourcePos) {
        this._last = char;
        if (char === -1) {
          const fastIndentation = this._fastIndentations[repeat];
          if (fastIndentation !== void 0) {
            this._str += fastIndentation;
          } else {
            this._str += repeat > 1 ? this._indentChar.repeat(repeat) : this._indentChar;
          }
        } else {
          this._str += repeat > 1 ? String.fromCharCode(char).repeat(repeat) : String.fromCharCode(char);
        }
        if (char !== 10) {
          this._mark(sourcePos.line, sourcePos.column, sourcePos.identifierName, sourcePos.identifierNamePos, sourcePos.filename);
          this._position.column += repeat;
        } else {
          this._position.line++;
          this._position.column = 0;
        }
        if (this._canMarkIdName) {
          sourcePos.identifierName = void 0;
          sourcePos.identifierNamePos = void 0;
        }
      }
      _append(str, sourcePos, maybeNewline) {
        const len = str.length;
        const position = this._position;
        this._last = str.charCodeAt(len - 1);
        if (++this._appendCount > 4096) {
          +this._str;
          this._buf += this._str;
          this._str = str;
          this._appendCount = 0;
        } else {
          this._str += str;
        }
        if (!maybeNewline && !this._map) {
          position.column += len;
          return;
        }
        const {
          column: column2,
          identifierName,
          identifierNamePos,
          filename
        } = sourcePos;
        let line2 = sourcePos.line;
        if ((identifierName != null || identifierNamePos != null) && this._canMarkIdName) {
          sourcePos.identifierName = void 0;
          sourcePos.identifierNamePos = void 0;
        }
        let i = str.indexOf("\n");
        let last = 0;
        if (i !== 0) {
          this._mark(line2, column2, identifierName, identifierNamePos, filename);
        }
        while (i !== -1) {
          position.line++;
          position.column = 0;
          last = i + 1;
          if (last < len && line2 !== void 0) {
            this._mark(++line2, 0, null, null, filename);
          }
          i = str.indexOf("\n", last);
        }
        position.column += len - last;
      }
      _mark(line2, column2, identifierName, identifierNamePos, filename) {
        var _this$_map;
        (_this$_map = this._map) == null || _this$_map.mark(this._position, line2, column2, identifierName, identifierNamePos, filename);
      }
      removeTrailingNewline() {
        const queueCursor = this._queueCursor;
        if (queueCursor !== 0 && this._queue[queueCursor - 1].char === 10) {
          this._queueCursor--;
        }
      }
      removeLastSemicolon() {
        const queueCursor = this._queueCursor;
        if (queueCursor !== 0 && this._queue[queueCursor - 1].char === 59) {
          this._queueCursor--;
        }
      }
      getLastChar() {
        const queueCursor = this._queueCursor;
        return queueCursor !== 0 ? this._queue[queueCursor - 1].char : this._last;
      }
      getNewlineCount() {
        const queueCursor = this._queueCursor;
        let count = 0;
        if (queueCursor === 0) return this._last === 10 ? 1 : 0;
        for (let i = queueCursor - 1; i >= 0; i--) {
          if (this._queue[i].char !== 10) {
            break;
          }
          count++;
        }
        return count === queueCursor && this._last === 10 ? count + 1 : count;
      }
      endsWithCharAndNewline() {
        const queue = this._queue;
        const queueCursor = this._queueCursor;
        if (queueCursor !== 0) {
          const lastCp = queue[queueCursor - 1].char;
          if (lastCp !== 10) return;
          if (queueCursor > 1) {
            return queue[queueCursor - 2].char;
          } else {
            return this._last;
          }
        }
      }
      hasContent() {
        return this._queueCursor !== 0 || !!this._last;
      }
      exactSource(loc, cb) {
        if (!this._map) {
          cb();
          return;
        }
        this.source("start", loc);
        const identifierName = loc.identifierName;
        const sourcePos = this._sourcePosition;
        if (identifierName) {
          this._canMarkIdName = false;
          sourcePos.identifierName = identifierName;
        }
        cb();
        if (identifierName) {
          this._canMarkIdName = true;
          sourcePos.identifierName = void 0;
          sourcePos.identifierNamePos = void 0;
        }
        this.source("end", loc);
      }
      source(prop, loc) {
        if (!this._map) return;
        this._normalizePosition(prop, loc, 0);
      }
      sourceWithOffset(prop, loc, columnOffset) {
        if (!this._map) return;
        this._normalizePosition(prop, loc, columnOffset);
      }
      _normalizePosition(prop, loc, columnOffset) {
        const pos2 = loc[prop];
        const target = this._sourcePosition;
        if (pos2) {
          target.line = pos2.line;
          target.column = Math.max(pos2.column + columnOffset, 0);
          target.filename = loc.filename;
        }
      }
      getCurrentColumn() {
        const queue = this._queue;
        const queueCursor = this._queueCursor;
        let lastIndex = -1;
        let len = 0;
        for (let i = 0; i < queueCursor; i++) {
          const item = queue[i];
          if (item.char === 10) {
            lastIndex = len;
          }
          len += item.repeat;
        }
        return lastIndex === -1 ? this._position.column + len : len - 1 - lastIndex;
      }
      getCurrentLine() {
        let count = 0;
        const queue = this._queue;
        for (let i = 0; i < this._queueCursor; i++) {
          if (queue[i].char === 10) {
            count++;
          }
        }
        return this._position.line + count;
      }
    };
    exports2.default = Buffer2;
  }
});

// node_modules/@babel/helpers/node_modules/@babel/generator/lib/node/whitespace.js
var require_whitespace = __commonJS({
  "node_modules/@babel/helpers/node_modules/@babel/generator/lib/node/whitespace.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.nodes = void 0;
    var _t = require("@babel/types");
    var {
      FLIPPED_ALIAS_KEYS,
      isArrayExpression,
      isAssignmentExpression,
      isBinary,
      isBlockStatement,
      isCallExpression,
      isFunction,
      isIdentifier,
      isLiteral,
      isMemberExpression: isMemberExpression2,
      isObjectExpression,
      isOptionalCallExpression,
      isOptionalMemberExpression: isOptionalMemberExpression2,
      isStringLiteral
    } = _t;
    function crawlInternal(node, state) {
      if (!node) return state;
      if (isMemberExpression2(node) || isOptionalMemberExpression2(node)) {
        crawlInternal(node.object, state);
        if (node.computed) crawlInternal(node.property, state);
      } else if (isBinary(node) || isAssignmentExpression(node)) {
        crawlInternal(node.left, state);
        crawlInternal(node.right, state);
      } else if (isCallExpression(node) || isOptionalCallExpression(node)) {
        state.hasCall = true;
        crawlInternal(node.callee, state);
      } else if (isFunction(node)) {
        state.hasFunction = true;
      } else if (isIdentifier(node)) {
        state.hasHelper = state.hasHelper || node.callee && isHelper(node.callee);
      }
      return state;
    }
    function crawl(node) {
      return crawlInternal(node, {
        hasCall: false,
        hasFunction: false,
        hasHelper: false
      });
    }
    function isHelper(node) {
      if (!node) return false;
      if (isMemberExpression2(node)) {
        return isHelper(node.object) || isHelper(node.property);
      } else if (isIdentifier(node)) {
        return node.name === "require" || node.name.charCodeAt(0) === 95;
      } else if (isCallExpression(node)) {
        return isHelper(node.callee);
      } else if (isBinary(node) || isAssignmentExpression(node)) {
        return isIdentifier(node.left) && isHelper(node.left) || isHelper(node.right);
      } else {
        return false;
      }
    }
    function isType(node) {
      return isLiteral(node) || isObjectExpression(node) || isArrayExpression(node) || isIdentifier(node) || isMemberExpression2(node);
    }
    var nodes = exports2.nodes = {
      AssignmentExpression(node) {
        const state = crawl(node.right);
        if (state.hasCall && state.hasHelper || state.hasFunction) {
          return state.hasFunction ? 1 | 2 : 2;
        }
      },
      SwitchCase(node, parent) {
        return (!!node.consequent.length || parent.cases[0] === node ? 1 : 0) | (!node.consequent.length && parent.cases[parent.cases.length - 1] === node ? 2 : 0);
      },
      LogicalExpression(node) {
        if (isFunction(node.left) || isFunction(node.right)) {
          return 2;
        }
      },
      Literal(node) {
        if (isStringLiteral(node) && node.value === "use strict") {
          return 2;
        }
      },
      CallExpression(node) {
        if (isFunction(node.callee) || isHelper(node)) {
          return 1 | 2;
        }
      },
      OptionalCallExpression(node) {
        if (isFunction(node.callee)) {
          return 1 | 2;
        }
      },
      VariableDeclaration(node) {
        for (let i = 0; i < node.declarations.length; i++) {
          const declar = node.declarations[i];
          let enabled = isHelper(declar.id) && !isType(declar.init);
          if (!enabled && declar.init) {
            const state = crawl(declar.init);
            enabled = isHelper(declar.init) && state.hasCall || state.hasFunction;
          }
          if (enabled) {
            return 1 | 2;
          }
        }
      },
      IfStatement(node) {
        if (isBlockStatement(node.consequent)) {
          return 1 | 2;
        }
      }
    };
    nodes.ObjectProperty = nodes.ObjectTypeProperty = nodes.ObjectMethod = function(node, parent) {
      if (parent.properties[0] === node) {
        return 1;
      }
    };
    nodes.ObjectTypeCallProperty = function(node, parent) {
      var _parent$properties;
      if (parent.callProperties[0] === node && !((_parent$properties = parent.properties) != null && _parent$properties.length)) {
        return 1;
      }
    };
    nodes.ObjectTypeIndexer = function(node, parent) {
      var _parent$properties2, _parent$callPropertie;
      if (parent.indexers[0] === node && !((_parent$properties2 = parent.properties) != null && _parent$properties2.length) && !((_parent$callPropertie = parent.callProperties) != null && _parent$callPropertie.length)) {
        return 1;
      }
    };
    nodes.ObjectTypeInternalSlot = function(node, parent) {
      var _parent$properties3, _parent$callPropertie2, _parent$indexers;
      if (parent.internalSlots[0] === node && !((_parent$properties3 = parent.properties) != null && _parent$properties3.length) && !((_parent$callPropertie2 = parent.callProperties) != null && _parent$callPropertie2.length) && !((_parent$indexers = parent.indexers) != null && _parent$indexers.length)) {
        return 1;
      }
    };
    [["Function", true], ["Class", true], ["Loop", true], ["LabeledStatement", true], ["SwitchStatement", true], ["TryStatement", true]].forEach(function([type, amounts]) {
      [type].concat(FLIPPED_ALIAS_KEYS[type] || []).forEach(function(type2) {
        const ret = amounts ? 1 | 2 : 0;
        nodes[type2] = () => ret;
      });
    });
  }
});

// node_modules/@babel/helpers/node_modules/@babel/generator/lib/node/parentheses.js
var require_parentheses = __commonJS({
  "node_modules/@babel/helpers/node_modules/@babel/generator/lib/node/parentheses.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.AssignmentExpression = AssignmentExpression;
    exports2.Binary = Binary;
    exports2.BinaryExpression = BinaryExpression;
    exports2.ClassExpression = ClassExpression;
    exports2.ArrowFunctionExpression = exports2.ConditionalExpression = ConditionalExpression;
    exports2.DoExpression = DoExpression;
    exports2.FunctionExpression = FunctionExpression10;
    exports2.FunctionTypeAnnotation = FunctionTypeAnnotation;
    exports2.Identifier = Identifier25;
    exports2.LogicalExpression = LogicalExpression;
    exports2.NullableTypeAnnotation = NullableTypeAnnotation;
    exports2.ObjectExpression = ObjectExpression;
    exports2.OptionalIndexedAccessType = OptionalIndexedAccessType;
    exports2.OptionalCallExpression = exports2.OptionalMemberExpression = OptionalMemberExpression;
    exports2.SequenceExpression = SequenceExpression;
    exports2.TSSatisfiesExpression = exports2.TSAsExpression = TSAsExpression;
    exports2.TSConditionalType = TSConditionalType;
    exports2.TSConstructorType = exports2.TSFunctionType = TSFunctionType;
    exports2.TSInferType = TSInferType;
    exports2.TSInstantiationExpression = TSInstantiationExpression;
    exports2.TSIntersectionType = TSIntersectionType;
    exports2.UnaryLike = exports2.TSTypeAssertion = UnaryLike;
    exports2.TSTypeOperator = TSTypeOperator;
    exports2.TSUnionType = TSUnionType;
    exports2.IntersectionTypeAnnotation = exports2.UnionTypeAnnotation = UnionTypeAnnotation;
    exports2.UpdateExpression = UpdateExpression;
    exports2.AwaitExpression = exports2.YieldExpression = YieldExpression;
    var _t = require("@babel/types");
    var _index = require_node2();
    var {
      isArrayTypeAnnotation,
      isBinaryExpression,
      isCallExpression,
      isForOfStatement,
      isIndexedAccessType,
      isMemberExpression: isMemberExpression2,
      isObjectPattern,
      isOptionalMemberExpression: isOptionalMemberExpression2,
      isYieldExpression,
      isStatement: isStatement2
    } = _t;
    var PRECEDENCE = /* @__PURE__ */ new Map([["||", 0], ["??", 0], ["|>", 0], ["&&", 1], ["|", 2], ["^", 3], ["&", 4], ["==", 5], ["===", 5], ["!=", 5], ["!==", 5], ["<", 6], [">", 6], ["<=", 6], [">=", 6], ["in", 6], ["instanceof", 6], [">>", 7], ["<<", 7], [">>>", 7], ["+", 8], ["-", 8], ["*", 9], ["/", 9], ["%", 9], ["**", 10]]);
    function getBinaryPrecedence(node, nodeType) {
      if (nodeType === "BinaryExpression" || nodeType === "LogicalExpression") {
        return PRECEDENCE.get(node.operator);
      }
      if (nodeType === "TSAsExpression" || nodeType === "TSSatisfiesExpression") {
        return PRECEDENCE.get("in");
      }
    }
    function isTSTypeExpression(nodeType) {
      return nodeType === "TSAsExpression" || nodeType === "TSSatisfiesExpression" || nodeType === "TSTypeAssertion";
    }
    var isClassExtendsClause = (node, parent) => {
      const parentType = parent.type;
      return (parentType === "ClassDeclaration" || parentType === "ClassExpression") && parent.superClass === node;
    };
    var hasPostfixPart = (node, parent) => {
      const parentType = parent.type;
      return (parentType === "MemberExpression" || parentType === "OptionalMemberExpression") && parent.object === node || (parentType === "CallExpression" || parentType === "OptionalCallExpression" || parentType === "NewExpression") && parent.callee === node || parentType === "TaggedTemplateExpression" && parent.tag === node || parentType === "TSNonNullExpression";
    };
    function NullableTypeAnnotation(node, parent) {
      return isArrayTypeAnnotation(parent);
    }
    function FunctionTypeAnnotation(node, parent, tokenContext) {
      const parentType = parent.type;
      return parentType === "UnionTypeAnnotation" || parentType === "IntersectionTypeAnnotation" || parentType === "ArrayTypeAnnotation" || Boolean(tokenContext & _index.TokenContext.arrowFlowReturnType);
    }
    function UpdateExpression(node, parent) {
      return hasPostfixPart(node, parent) || isClassExtendsClause(node, parent);
    }
    function needsParenBeforeExpressionBrace(tokenContext) {
      return Boolean(tokenContext & (_index.TokenContext.expressionStatement | _index.TokenContext.arrowBody));
    }
    function ObjectExpression(node, parent, tokenContext) {
      return needsParenBeforeExpressionBrace(tokenContext);
    }
    function DoExpression(node, parent, tokenContext) {
      return !node.async && Boolean(tokenContext & _index.TokenContext.expressionStatement);
    }
    function Binary(node, parent) {
      const parentType = parent.type;
      if (node.type === "BinaryExpression" && node.operator === "**" && parentType === "BinaryExpression" && parent.operator === "**") {
        return parent.left === node;
      }
      if (isClassExtendsClause(node, parent)) {
        return true;
      }
      if (hasPostfixPart(node, parent) || parentType === "UnaryExpression" || parentType === "SpreadElement" || parentType === "AwaitExpression") {
        return true;
      }
      const parentPos = getBinaryPrecedence(parent, parentType);
      if (parentPos != null) {
        const nodePos = getBinaryPrecedence(node, node.type);
        if (parentPos === nodePos && parentType === "BinaryExpression" && parent.right === node || parentPos > nodePos) {
          return true;
        }
      }
      return void 0;
    }
    function UnionTypeAnnotation(node, parent) {
      const parentType = parent.type;
      return parentType === "ArrayTypeAnnotation" || parentType === "NullableTypeAnnotation" || parentType === "IntersectionTypeAnnotation" || parentType === "UnionTypeAnnotation";
    }
    function OptionalIndexedAccessType(node, parent) {
      return isIndexedAccessType(parent) && parent.objectType === node;
    }
    function TSAsExpression(node, parent) {
      if ((parent.type === "AssignmentExpression" || parent.type === "AssignmentPattern") && parent.left === node) {
        return true;
      }
      if (parent.type === "BinaryExpression" && (parent.operator === "|" || parent.operator === "&") && node === parent.left) {
        return true;
      }
      return Binary(node, parent);
    }
    function TSConditionalType(node, parent) {
      const parentType = parent.type;
      if (parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node || parentType === "TSOptionalType" || parentType === "TSTypeOperator" || parentType === "TSTypeParameter") {
        return true;
      }
      if ((parentType === "TSIntersectionType" || parentType === "TSUnionType") && parent.types[0] === node) {
        return true;
      }
      if (parentType === "TSConditionalType" && (parent.checkType === node || parent.extendsType === node)) {
        return true;
      }
      return false;
    }
    function TSUnionType(node, parent) {
      const parentType = parent.type;
      return parentType === "TSIntersectionType" || parentType === "TSTypeOperator" || parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node || parentType === "TSOptionalType";
    }
    function TSIntersectionType(node, parent) {
      const parentType = parent.type;
      return parentType === "TSTypeOperator" || parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node || parentType === "TSOptionalType";
    }
    function TSInferType(node, parent) {
      const parentType = parent.type;
      if (parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node || parentType === "TSOptionalType") {
        return true;
      }
      if (node.typeParameter.constraint) {
        if ((parentType === "TSIntersectionType" || parentType === "TSUnionType") && parent.types[0] === node) {
          return true;
        }
      }
      return false;
    }
    function TSTypeOperator(node, parent) {
      const parentType = parent.type;
      return parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node || parentType === "TSOptionalType";
    }
    function TSInstantiationExpression(node, parent) {
      const parentType = parent.type;
      return (parentType === "CallExpression" || parentType === "OptionalCallExpression" || parentType === "NewExpression" || parentType === "TSInstantiationExpression") && !!parent.typeParameters;
    }
    function TSFunctionType(node, parent) {
      const parentType = parent.type;
      return parentType === "TSIntersectionType" || parentType === "TSUnionType" || parentType === "TSTypeOperator" || parentType === "TSOptionalType" || parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node || parentType === "TSConditionalType" && (parent.checkType === node || parent.extendsType === node);
    }
    function BinaryExpression(node, parent, tokenContext, inForStatementInit) {
      return node.operator === "in" && inForStatementInit;
    }
    function SequenceExpression(node, parent) {
      const parentType = parent.type;
      if (parentType === "SequenceExpression" || parentType === "ParenthesizedExpression" || parentType === "MemberExpression" && parent.property === node || parentType === "OptionalMemberExpression" && parent.property === node || parentType === "TemplateLiteral") {
        return false;
      }
      if (parentType === "ClassDeclaration") {
        return true;
      }
      if (parentType === "ForOfStatement") {
        return parent.right === node;
      }
      if (parentType === "ExportDefaultDeclaration") {
        return true;
      }
      return !isStatement2(parent);
    }
    function YieldExpression(node, parent) {
      const parentType = parent.type;
      return parentType === "BinaryExpression" || parentType === "LogicalExpression" || parentType === "UnaryExpression" || parentType === "SpreadElement" || hasPostfixPart(node, parent) || parentType === "AwaitExpression" && isYieldExpression(node) || parentType === "ConditionalExpression" && node === parent.test || isClassExtendsClause(node, parent) || isTSTypeExpression(parentType);
    }
    function ClassExpression(node, parent, tokenContext) {
      return Boolean(tokenContext & (_index.TokenContext.expressionStatement | _index.TokenContext.exportDefault));
    }
    function UnaryLike(node, parent) {
      return hasPostfixPart(node, parent) || isBinaryExpression(parent) && parent.operator === "**" && parent.left === node || isClassExtendsClause(node, parent);
    }
    function FunctionExpression10(node, parent, tokenContext) {
      return Boolean(tokenContext & (_index.TokenContext.expressionStatement | _index.TokenContext.exportDefault));
    }
    function ConditionalExpression(node, parent) {
      const parentType = parent.type;
      if (parentType === "UnaryExpression" || parentType === "SpreadElement" || parentType === "BinaryExpression" || parentType === "LogicalExpression" || parentType === "ConditionalExpression" && parent.test === node || parentType === "AwaitExpression" || isTSTypeExpression(parentType)) {
        return true;
      }
      return UnaryLike(node, parent);
    }
    function OptionalMemberExpression(node, parent) {
      return isCallExpression(parent) && parent.callee === node || isMemberExpression2(parent) && parent.object === node;
    }
    function AssignmentExpression(node, parent, tokenContext) {
      if (needsParenBeforeExpressionBrace(tokenContext) && isObjectPattern(node.left)) {
        return true;
      } else {
        return ConditionalExpression(node, parent);
      }
    }
    function LogicalExpression(node, parent) {
      const parentType = parent.type;
      if (isTSTypeExpression(parentType)) return true;
      if (parentType !== "LogicalExpression") return false;
      switch (node.operator) {
        case "||":
          return parent.operator === "??" || parent.operator === "&&";
        case "&&":
          return parent.operator === "??";
        case "??":
          return parent.operator !== "??";
      }
    }
    function Identifier25(node, parent, tokenContext, _inForInit, getRawIdentifier) {
      var _node$extra;
      const parentType = parent.type;
      if ((_node$extra = node.extra) != null && _node$extra.parenthesized && parentType === "AssignmentExpression" && parent.left === node) {
        const rightType = parent.right.type;
        if ((rightType === "FunctionExpression" || rightType === "ClassExpression") && parent.right.id == null) {
          return true;
        }
      }
      if (getRawIdentifier && getRawIdentifier(node) !== node.name) {
        return false;
      }
      if (node.name === "let") {
        const isFollowedByBracket = isMemberExpression2(parent, {
          object: node,
          computed: true
        }) || isOptionalMemberExpression2(parent, {
          object: node,
          computed: true,
          optional: false
        });
        if (isFollowedByBracket && tokenContext & (_index.TokenContext.expressionStatement | _index.TokenContext.forHead | _index.TokenContext.forInHead)) {
          return true;
        }
        return Boolean(tokenContext & _index.TokenContext.forOfHead);
      }
      return node.name === "async" && isForOfStatement(parent, {
        left: node,
        await: false
      });
    }
  }
});

// node_modules/@babel/helpers/node_modules/@babel/generator/lib/node/index.js
var require_node2 = __commonJS({
  "node_modules/@babel/helpers/node_modules/@babel/generator/lib/node/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.TokenContext = void 0;
    exports2.isLastChild = isLastChild;
    exports2.needsParens = needsParens;
    exports2.needsWhitespace = needsWhitespace;
    exports2.needsWhitespaceAfter = needsWhitespaceAfter;
    exports2.needsWhitespaceBefore = needsWhitespaceBefore;
    var whitespace = require_whitespace();
    var parens = require_parentheses();
    var _t = require("@babel/types");
    var {
      FLIPPED_ALIAS_KEYS,
      VISITOR_KEYS,
      isCallExpression,
      isDecorator,
      isExpressionStatement,
      isMemberExpression: isMemberExpression2,
      isNewExpression,
      isParenthesizedExpression
    } = _t;
    var TokenContext = exports2.TokenContext = {
      expressionStatement: 1,
      arrowBody: 2,
      exportDefault: 4,
      forHead: 8,
      forInHead: 16,
      forOfHead: 32,
      arrowFlowReturnType: 64
    };
    function expandAliases(obj) {
      const map = /* @__PURE__ */ new Map();
      function add(type, func) {
        const fn = map.get(type);
        map.set(type, fn ? function(node, parent, stack2, inForInit, getRawIdentifier) {
          var _fn;
          return (_fn = fn(node, parent, stack2, inForInit, getRawIdentifier)) != null ? _fn : func(node, parent, stack2, inForInit, getRawIdentifier);
        } : func);
      }
      for (const type of Object.keys(obj)) {
        const aliases = FLIPPED_ALIAS_KEYS[type];
        if (aliases) {
          for (const alias of aliases) {
            add(alias, obj[type]);
          }
        } else {
          add(type, obj[type]);
        }
      }
      return map;
    }
    var expandedParens = expandAliases(parens);
    var expandedWhitespaceNodes = expandAliases(whitespace.nodes);
    function isOrHasCallExpression(node) {
      if (isCallExpression(node)) {
        return true;
      }
      return isMemberExpression2(node) && isOrHasCallExpression(node.object);
    }
    function needsWhitespace(node, parent, type) {
      var _expandedWhitespaceNo;
      if (!node) return false;
      if (isExpressionStatement(node)) {
        node = node.expression;
      }
      const flag = (_expandedWhitespaceNo = expandedWhitespaceNodes.get(node.type)) == null ? void 0 : _expandedWhitespaceNo(node, parent);
      if (typeof flag === "number") {
        return (flag & type) !== 0;
      }
      return false;
    }
    function needsWhitespaceBefore(node, parent) {
      return needsWhitespace(node, parent, 1);
    }
    function needsWhitespaceAfter(node, parent) {
      return needsWhitespace(node, parent, 2);
    }
    function needsParens(node, parent, tokenContext, inForInit, getRawIdentifier) {
      var _expandedParens$get;
      if (!parent) return false;
      if (isNewExpression(parent) && parent.callee === node) {
        if (isOrHasCallExpression(node)) return true;
      }
      if (isDecorator(parent)) {
        return !isDecoratorMemberExpression(node) && !(isCallExpression(node) && isDecoratorMemberExpression(node.callee)) && !isParenthesizedExpression(node);
      }
      return (_expandedParens$get = expandedParens.get(node.type)) == null ? void 0 : _expandedParens$get(node, parent, tokenContext, inForInit, getRawIdentifier);
    }
    function isDecoratorMemberExpression(node) {
      switch (node.type) {
        case "Identifier":
          return true;
        case "MemberExpression":
          return !node.computed && node.property.type === "Identifier" && isDecoratorMemberExpression(node.object);
        default:
          return false;
      }
    }
    function isLastChild(parent, child) {
      const visitorKeys = VISITOR_KEYS[parent.type];
      for (let i = visitorKeys.length - 1; i >= 0; i--) {
        const val = parent[visitorKeys[i]];
        if (val === child) {
          return true;
        } else if (Array.isArray(val)) {
          let j = val.length - 1;
          while (j >= 0 && val[j] === null) j--;
          return j >= 0 && val[j] === child;
        } else if (val) {
          return false;
        }
      }
      return false;
    }
  }
});

// node_modules/@babel/helpers/node_modules/@babel/generator/lib/token-map.js
var require_token_map = __commonJS({
  "node_modules/@babel/helpers/node_modules/@babel/generator/lib/token-map.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.TokenMap = void 0;
    var _t = require("@babel/types");
    var {
      traverseFast,
      VISITOR_KEYS
    } = _t;
    var TokenMap = class {
      constructor(ast, tokens, source2) {
        this._tokens = void 0;
        this._source = void 0;
        this._nodesToTokenIndexes = /* @__PURE__ */ new Map();
        this._nodesOccurrencesCountCache = /* @__PURE__ */ new Map();
        this._tokensCache = /* @__PURE__ */ new Map();
        this._tokens = tokens;
        this._source = source2;
        traverseFast(ast, (node) => {
          const indexes = this._getTokensIndexesOfNode(node);
          if (indexes.length > 0) this._nodesToTokenIndexes.set(node, indexes);
        });
        this._tokensCache = null;
      }
      has(node) {
        return this._nodesToTokenIndexes.has(node);
      }
      getIndexes(node) {
        return this._nodesToTokenIndexes.get(node);
      }
      find(node, condition) {
        const indexes = this._nodesToTokenIndexes.get(node);
        if (indexes) {
          for (let k = 0; k < indexes.length; k++) {
            const index = indexes[k];
            const tok = this._tokens[index];
            if (condition(tok, index)) return tok;
          }
        }
        return null;
      }
      findLastIndex(node, condition) {
        const indexes = this._nodesToTokenIndexes.get(node);
        if (indexes) {
          for (let k = indexes.length - 1; k >= 0; k--) {
            const index = indexes[k];
            const tok = this._tokens[index];
            if (condition(tok, index)) return index;
          }
        }
        return -1;
      }
      findMatching(node, test, occurrenceCount = 0) {
        const indexes = this._nodesToTokenIndexes.get(node);
        if (indexes) {
          let i = 0;
          const count = occurrenceCount;
          if (count > 1) {
            const cache = this._nodesOccurrencesCountCache.get(node);
            if (cache && cache.test === test && cache.count < count) {
              i = cache.i + 1;
              occurrenceCount -= cache.count + 1;
            }
          }
          for (; i < indexes.length; i++) {
            const tok = this._tokens[indexes[i]];
            if (this.matchesOriginal(tok, test)) {
              if (occurrenceCount === 0) {
                if (count > 0) {
                  this._nodesOccurrencesCountCache.set(node, {
                    test,
                    count,
                    i
                  });
                }
                return tok;
              }
              occurrenceCount--;
            }
          }
        }
        return null;
      }
      matchesOriginal(token2, test) {
        if (token2.end - token2.start !== test.length) return false;
        if (token2.value != null) return token2.value === test;
        return this._source.startsWith(test, token2.start);
      }
      startMatches(node, test) {
        const indexes = this._nodesToTokenIndexes.get(node);
        if (!indexes) return false;
        const tok = this._tokens[indexes[0]];
        if (tok.start !== node.start) return false;
        return this.matchesOriginal(tok, test);
      }
      endMatches(node, test) {
        const indexes = this._nodesToTokenIndexes.get(node);
        if (!indexes) return false;
        const tok = this._tokens[indexes[indexes.length - 1]];
        if (tok.end !== node.end) return false;
        return this.matchesOriginal(tok, test);
      }
      _getTokensIndexesOfNode(node) {
        if (node.start == null || node.end == null) return [];
        const {
          first,
          last
        } = this._findTokensOfNode(node, 0, this._tokens.length - 1);
        let low = first;
        const children = childrenIterator(node);
        if ((node.type === "ExportNamedDeclaration" || node.type === "ExportDefaultDeclaration") && node.declaration && node.declaration.type === "ClassDeclaration") {
          children.next();
        }
        const indexes = [];
        for (const child of children) {
          if (child == null) continue;
          if (child.start == null || child.end == null) continue;
          const childTok = this._findTokensOfNode(child, low, last);
          const high = childTok.first;
          for (let k = low; k < high; k++) indexes.push(k);
          low = childTok.last + 1;
        }
        for (let k = low; k <= last; k++) indexes.push(k);
        return indexes;
      }
      _findTokensOfNode(node, low, high) {
        const cached = this._tokensCache.get(node);
        if (cached) return cached;
        const first = this._findFirstTokenOfNode(node.start, low, high);
        const last = this._findLastTokenOfNode(node.end, first, high);
        this._tokensCache.set(node, {
          first,
          last
        });
        return {
          first,
          last
        };
      }
      _findFirstTokenOfNode(start, low, high) {
        while (low <= high) {
          const mid = high + low >> 1;
          if (start < this._tokens[mid].start) {
            high = mid - 1;
          } else if (start > this._tokens[mid].start) {
            low = mid + 1;
          } else {
            return mid;
          }
        }
        return low;
      }
      _findLastTokenOfNode(end, low, high) {
        while (low <= high) {
          const mid = high + low >> 1;
          if (end < this._tokens[mid].end) {
            high = mid - 1;
          } else if (end > this._tokens[mid].end) {
            low = mid + 1;
          } else {
            return mid;
          }
        }
        return high;
      }
    };
    exports2.TokenMap = TokenMap;
    function* childrenIterator(node) {
      if (node.type === "TemplateLiteral") {
        yield node.quasis[0];
        for (let i = 1; i < node.quasis.length; i++) {
          yield node.expressions[i - 1];
          yield node.quasis[i];
        }
        return;
      }
      const keys = VISITOR_KEYS[node.type];
      for (const key2 of keys) {
        const child = node[key2];
        if (!child) continue;
        if (Array.isArray(child)) {
          yield* __yieldStar(child);
        } else {
          yield child;
        }
      }
    }
  }
});

// node_modules/@babel/helpers/node_modules/@babel/generator/lib/generators/template-literals.js
var require_template_literals = __commonJS({
  "node_modules/@babel/helpers/node_modules/@babel/generator/lib/generators/template-literals.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.TaggedTemplateExpression = TaggedTemplateExpression;
    exports2.TemplateElement = TemplateElement;
    exports2.TemplateLiteral = TemplateLiteral;
    exports2._printTemplate = _printTemplate;
    function TaggedTemplateExpression(node) {
      this.print(node.tag);
      {
        this.print(node.typeParameters);
      }
      this.print(node.quasi);
    }
    function TemplateElement() {
      throw new Error("TemplateElement printing is handled in TemplateLiteral");
    }
    function _printTemplate(node, substitutions) {
      const quasis = node.quasis;
      let partRaw = "`";
      for (let i = 0; i < quasis.length - 1; i++) {
        partRaw += quasis[i].value.raw;
        this.token(partRaw + "${", true);
        this.print(substitutions[i]);
        partRaw = "}";
        if (this.tokenMap) {
          const token2 = this.tokenMap.findMatching(node, "}", i);
          if (token2) this._catchUpTo(token2.loc.start);
        }
      }
      partRaw += quasis[quasis.length - 1].value.raw;
      this.token(partRaw + "`", true);
    }
    function TemplateLiteral(node) {
      this._printTemplate(node, node.expressions);
    }
  }
});

// node_modules/@babel/helpers/node_modules/@babel/generator/lib/generators/expressions.js
var require_expressions = __commonJS({
  "node_modules/@babel/helpers/node_modules/@babel/generator/lib/generators/expressions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.LogicalExpression = exports2.BinaryExpression = exports2.AssignmentExpression = AssignmentExpression;
    exports2.AssignmentPattern = AssignmentPattern;
    exports2.AwaitExpression = AwaitExpression;
    exports2.BindExpression = BindExpression;
    exports2.CallExpression = CallExpression4;
    exports2.ConditionalExpression = ConditionalExpression;
    exports2.Decorator = Decorator;
    exports2.DoExpression = DoExpression;
    exports2.EmptyStatement = EmptyStatement;
    exports2.ExpressionStatement = ExpressionStatement;
    exports2.Import = Import;
    exports2.MemberExpression = MemberExpression;
    exports2.MetaProperty = MetaProperty;
    exports2.ModuleExpression = ModuleExpression;
    exports2.NewExpression = NewExpression;
    exports2.OptionalCallExpression = OptionalCallExpression;
    exports2.OptionalMemberExpression = OptionalMemberExpression;
    exports2.ParenthesizedExpression = ParenthesizedExpression;
    exports2.PrivateName = PrivateName;
    exports2.SequenceExpression = SequenceExpression;
    exports2.Super = Super;
    exports2.ThisExpression = ThisExpression;
    exports2.UnaryExpression = UnaryExpression;
    exports2.UpdateExpression = UpdateExpression;
    exports2.V8IntrinsicIdentifier = V8IntrinsicIdentifier;
    exports2.YieldExpression = YieldExpression;
    exports2._shouldPrintDecoratorsBeforeExport = _shouldPrintDecoratorsBeforeExport;
    var _t = require("@babel/types");
    var _index = require_node2();
    var {
      isCallExpression,
      isLiteral,
      isMemberExpression: isMemberExpression2,
      isNewExpression,
      isPattern
    } = _t;
    function UnaryExpression(node) {
      const {
        operator
      } = node;
      if (operator === "void" || operator === "delete" || operator === "typeof" || operator === "throw") {
        this.word(operator);
        this.space();
      } else {
        this.token(operator);
      }
      this.print(node.argument);
    }
    function DoExpression(node) {
      if (node.async) {
        this.word("async", true);
        this.space();
      }
      this.word("do");
      this.space();
      this.print(node.body);
    }
    function ParenthesizedExpression(node) {
      this.tokenChar(40);
      const exit = this.enterDelimited();
      this.print(node.expression);
      exit();
      this.rightParens(node);
    }
    function UpdateExpression(node) {
      if (node.prefix) {
        this.token(node.operator);
        this.print(node.argument);
      } else {
        this.print(node.argument, true);
        this.token(node.operator);
      }
    }
    function ConditionalExpression(node) {
      this.print(node.test);
      this.space();
      this.tokenChar(63);
      this.space();
      this.print(node.consequent);
      this.space();
      this.tokenChar(58);
      this.space();
      this.print(node.alternate);
    }
    function NewExpression(node, parent) {
      this.word("new");
      this.space();
      this.print(node.callee);
      if (this.format.minified && node.arguments.length === 0 && !node.optional && !isCallExpression(parent, {
        callee: node
      }) && !isMemberExpression2(parent) && !isNewExpression(parent)) {
        return;
      }
      this.print(node.typeArguments);
      {
        this.print(node.typeParameters);
      }
      if (node.optional) {
        this.token("?.");
      }
      if (node.arguments.length === 0 && this.tokenMap && !this.tokenMap.endMatches(node, ")")) {
        return;
      }
      this.tokenChar(40);
      const exit = this.enterDelimited();
      this.printList(node.arguments, this.shouldPrintTrailingComma(")"));
      exit();
      this.rightParens(node);
    }
    function SequenceExpression(node) {
      this.printList(node.expressions);
    }
    function ThisExpression() {
      this.word("this");
    }
    function Super() {
      this.word("super");
    }
    function _shouldPrintDecoratorsBeforeExport(node) {
      if (typeof this.format.decoratorsBeforeExport === "boolean") {
        return this.format.decoratorsBeforeExport;
      }
      return typeof node.start === "number" && node.start === node.declaration.start;
    }
    function Decorator(node) {
      this.tokenChar(64);
      this.print(node.expression);
      this.newline();
    }
    function OptionalMemberExpression(node) {
      let {
        computed
      } = node;
      const {
        optional,
        property
      } = node;
      this.print(node.object);
      if (!computed && isMemberExpression2(property)) {
        throw new TypeError("Got a MemberExpression for MemberExpression property");
      }
      if (isLiteral(property) && typeof property.value === "number") {
        computed = true;
      }
      if (optional) {
        this.token("?.");
      }
      if (computed) {
        this.tokenChar(91);
        this.print(property);
        this.tokenChar(93);
      } else {
        if (!optional) {
          this.tokenChar(46);
        }
        this.print(property);
      }
    }
    function OptionalCallExpression(node) {
      this.print(node.callee);
      {
        this.print(node.typeParameters);
      }
      if (node.optional) {
        this.token("?.");
      }
      this.print(node.typeArguments);
      this.tokenChar(40);
      const exit = this.enterDelimited();
      this.printList(node.arguments);
      exit();
      this.rightParens(node);
    }
    function CallExpression4(node) {
      this.print(node.callee);
      this.print(node.typeArguments);
      {
        this.print(node.typeParameters);
      }
      this.tokenChar(40);
      const exit = this.enterDelimited();
      this.printList(node.arguments, this.shouldPrintTrailingComma(")"));
      exit();
      this.rightParens(node);
    }
    function Import() {
      this.word("import");
    }
    function AwaitExpression(node) {
      this.word("await");
      if (node.argument) {
        this.space();
        this.printTerminatorless(node.argument);
      }
    }
    function YieldExpression(node) {
      this.word("yield", true);
      if (node.delegate) {
        this.tokenChar(42);
        if (node.argument) {
          this.space();
          this.print(node.argument);
        }
      } else {
        if (node.argument) {
          this.space();
          this.printTerminatorless(node.argument);
        }
      }
    }
    function EmptyStatement() {
      this.semicolon(true);
    }
    function ExpressionStatement(node) {
      this.tokenContext |= _index.TokenContext.expressionStatement;
      this.print(node.expression);
      this.semicolon();
    }
    function AssignmentPattern(node) {
      this.print(node.left);
      if (node.left.type === "Identifier" || isPattern(node.left)) {
        if (node.left.optional) this.tokenChar(63);
        this.print(node.left.typeAnnotation);
      }
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node.right);
    }
    function AssignmentExpression(node) {
      this.print(node.left);
      this.space();
      if (node.operator === "in" || node.operator === "instanceof") {
        this.word(node.operator);
      } else {
        this.token(node.operator);
        this._endsWithDiv = node.operator === "/";
      }
      this.space();
      this.print(node.right);
    }
    function BindExpression(node) {
      this.print(node.object);
      this.token("::");
      this.print(node.callee);
    }
    function MemberExpression(node) {
      this.print(node.object);
      if (!node.computed && isMemberExpression2(node.property)) {
        throw new TypeError("Got a MemberExpression for MemberExpression property");
      }
      let computed = node.computed;
      if (isLiteral(node.property) && typeof node.property.value === "number") {
        computed = true;
      }
      if (computed) {
        const exit = this.enterDelimited();
        this.tokenChar(91);
        this.print(node.property);
        this.tokenChar(93);
        exit();
      } else {
        this.tokenChar(46);
        this.print(node.property);
      }
    }
    function MetaProperty(node) {
      this.print(node.meta);
      this.tokenChar(46);
      this.print(node.property);
    }
    function PrivateName(node) {
      this.tokenChar(35);
      this.print(node.id);
    }
    function V8IntrinsicIdentifier(node) {
      this.tokenChar(37);
      this.word(node.name);
    }
    function ModuleExpression(node) {
      this.word("module", true);
      this.space();
      this.tokenChar(123);
      this.indent();
      const {
        body
      } = node;
      if (body.body.length || body.directives.length) {
        this.newline();
      }
      this.print(body);
      this.dedent();
      this.rightBrace(node);
    }
  }
});

// node_modules/@babel/helpers/node_modules/@babel/generator/lib/generators/statements.js
var require_statements = __commonJS({
  "node_modules/@babel/helpers/node_modules/@babel/generator/lib/generators/statements.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.BreakStatement = BreakStatement;
    exports2.CatchClause = CatchClause;
    exports2.ContinueStatement = ContinueStatement;
    exports2.DebuggerStatement = DebuggerStatement;
    exports2.DoWhileStatement = DoWhileStatement;
    exports2.ForOfStatement = exports2.ForInStatement = void 0;
    exports2.ForStatement = ForStatement;
    exports2.IfStatement = IfStatement;
    exports2.LabeledStatement = LabeledStatement;
    exports2.ReturnStatement = ReturnStatement;
    exports2.SwitchCase = SwitchCase;
    exports2.SwitchStatement = SwitchStatement;
    exports2.ThrowStatement = ThrowStatement;
    exports2.TryStatement = TryStatement;
    exports2.VariableDeclaration = VariableDeclaration;
    exports2.VariableDeclarator = VariableDeclarator;
    exports2.WhileStatement = WhileStatement;
    exports2.WithStatement = WithStatement;
    var _t = require("@babel/types");
    var _index = require_node2();
    var {
      isFor,
      isForStatement,
      isIfStatement,
      isStatement: isStatement2
    } = _t;
    function WithStatement(node) {
      this.word("with");
      this.space();
      this.tokenChar(40);
      this.print(node.object);
      this.tokenChar(41);
      this.printBlock(node);
    }
    function IfStatement(node) {
      this.word("if");
      this.space();
      this.tokenChar(40);
      this.print(node.test);
      this.tokenChar(41);
      this.space();
      const needsBlock = node.alternate && isIfStatement(getLastStatement(node.consequent));
      if (needsBlock) {
        this.tokenChar(123);
        this.newline();
        this.indent();
      }
      this.printAndIndentOnComments(node.consequent);
      if (needsBlock) {
        this.dedent();
        this.newline();
        this.tokenChar(125);
      }
      if (node.alternate) {
        if (this.endsWith(125)) this.space();
        this.word("else");
        this.space();
        this.printAndIndentOnComments(node.alternate);
      }
    }
    function getLastStatement(statement) {
      const {
        body
      } = statement;
      if (isStatement2(body) === false) {
        return statement;
      }
      return getLastStatement(body);
    }
    function ForStatement(node) {
      this.word("for");
      this.space();
      this.tokenChar(40);
      {
        const exit = this.enterForStatementInit();
        this.tokenContext |= _index.TokenContext.forHead;
        this.print(node.init);
        exit();
      }
      this.tokenChar(59);
      if (node.test) {
        this.space();
        this.print(node.test);
      }
      this.token(";", false, 1);
      if (node.update) {
        this.space();
        this.print(node.update);
      }
      this.tokenChar(41);
      this.printBlock(node);
    }
    function WhileStatement(node) {
      this.word("while");
      this.space();
      this.tokenChar(40);
      this.print(node.test);
      this.tokenChar(41);
      this.printBlock(node);
    }
    function ForXStatement(node) {
      this.word("for");
      this.space();
      const isForOf = node.type === "ForOfStatement";
      if (isForOf && node.await) {
        this.word("await");
        this.space();
      }
      this.noIndentInnerCommentsHere();
      this.tokenChar(40);
      {
        const exit = isForOf ? null : this.enterForStatementInit();
        this.tokenContext |= isForOf ? _index.TokenContext.forOfHead : _index.TokenContext.forInHead;
        this.print(node.left);
        exit == null || exit();
      }
      this.space();
      this.word(isForOf ? "of" : "in");
      this.space();
      this.print(node.right);
      this.tokenChar(41);
      this.printBlock(node);
    }
    var ForInStatement = exports2.ForInStatement = ForXStatement;
    var ForOfStatement = exports2.ForOfStatement = ForXStatement;
    function DoWhileStatement(node) {
      this.word("do");
      this.space();
      this.print(node.body);
      this.space();
      this.word("while");
      this.space();
      this.tokenChar(40);
      this.print(node.test);
      this.tokenChar(41);
      this.semicolon();
    }
    function printStatementAfterKeyword(printer, node) {
      if (node) {
        printer.space();
        printer.printTerminatorless(node);
      }
      printer.semicolon();
    }
    function BreakStatement(node) {
      this.word("break");
      printStatementAfterKeyword(this, node.label);
    }
    function ContinueStatement(node) {
      this.word("continue");
      printStatementAfterKeyword(this, node.label);
    }
    function ReturnStatement(node) {
      this.word("return");
      printStatementAfterKeyword(this, node.argument);
    }
    function ThrowStatement(node) {
      this.word("throw");
      printStatementAfterKeyword(this, node.argument);
    }
    function LabeledStatement(node) {
      this.print(node.label);
      this.tokenChar(58);
      this.space();
      this.print(node.body);
    }
    function TryStatement(node) {
      this.word("try");
      this.space();
      this.print(node.block);
      this.space();
      if (node.handlers) {
        this.print(node.handlers[0]);
      } else {
        this.print(node.handler);
      }
      if (node.finalizer) {
        this.space();
        this.word("finally");
        this.space();
        this.print(node.finalizer);
      }
    }
    function CatchClause(node) {
      this.word("catch");
      this.space();
      if (node.param) {
        this.tokenChar(40);
        this.print(node.param);
        this.print(node.param.typeAnnotation);
        this.tokenChar(41);
        this.space();
      }
      this.print(node.body);
    }
    function SwitchStatement(node) {
      this.word("switch");
      this.space();
      this.tokenChar(40);
      this.print(node.discriminant);
      this.tokenChar(41);
      this.space();
      this.tokenChar(123);
      this.printSequence(node.cases, true, void 0, function addNewlines(leading, cas) {
        if (!leading && node.cases[node.cases.length - 1] === cas) return -1;
      });
      this.rightBrace(node);
    }
    function SwitchCase(node) {
      if (node.test) {
        this.word("case");
        this.space();
        this.print(node.test);
        this.tokenChar(58);
      } else {
        this.word("default");
        this.tokenChar(58);
      }
      if (node.consequent.length) {
        this.newline();
        this.printSequence(node.consequent, true);
      }
    }
    function DebuggerStatement() {
      this.word("debugger");
      this.semicolon();
    }
    function VariableDeclaration(node, parent) {
      if (node.declare) {
        this.word("declare");
        this.space();
      }
      const {
        kind
      } = node;
      if (kind === "await using") {
        this.word("await");
        this.space();
        this.word("using", true);
      } else {
        this.word(kind, kind === "using");
      }
      this.space();
      let hasInits = false;
      if (!isFor(parent)) {
        for (const declar of node.declarations) {
          if (declar.init) {
            hasInits = true;
          }
        }
      }
      this.printList(node.declarations, void 0, void 0, node.declarations.length > 1, hasInits ? function(occurrenceCount) {
        this.token(",", false, occurrenceCount);
        this.newline();
      } : void 0);
      if (isFor(parent)) {
        if (isForStatement(parent)) {
          if (parent.init === node) return;
        } else {
          if (parent.left === node) return;
        }
      }
      this.semicolon();
    }
    function VariableDeclarator(node) {
      this.print(node.id);
      if (node.definite) this.tokenChar(33);
      this.print(node.id.typeAnnotation);
      if (node.init) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node.init);
      }
    }
  }
});

// node_modules/@babel/helpers/node_modules/@babel/generator/lib/generators/classes.js
var require_classes = __commonJS({
  "node_modules/@babel/helpers/node_modules/@babel/generator/lib/generators/classes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ClassAccessorProperty = ClassAccessorProperty;
    exports2.ClassBody = ClassBody;
    exports2.ClassExpression = exports2.ClassDeclaration = ClassDeclaration;
    exports2.ClassMethod = ClassMethod;
    exports2.ClassPrivateMethod = ClassPrivateMethod;
    exports2.ClassPrivateProperty = ClassPrivateProperty;
    exports2.ClassProperty = ClassProperty;
    exports2.StaticBlock = StaticBlock;
    exports2._classMethodHead = _classMethodHead;
    var _t = require("@babel/types");
    var {
      isExportDefaultDeclaration,
      isExportNamedDeclaration
    } = _t;
    function ClassDeclaration(node, parent) {
      const inExport = isExportDefaultDeclaration(parent) || isExportNamedDeclaration(parent);
      if (!inExport || !this._shouldPrintDecoratorsBeforeExport(parent)) {
        this.printJoin(node.decorators);
      }
      if (node.declare) {
        this.word("declare");
        this.space();
      }
      if (node.abstract) {
        this.word("abstract");
        this.space();
      }
      this.word("class");
      if (node.id) {
        this.space();
        this.print(node.id);
      }
      this.print(node.typeParameters);
      if (node.superClass) {
        this.space();
        this.word("extends");
        this.space();
        this.print(node.superClass);
        this.print(node.superTypeParameters);
      }
      if (node.implements) {
        this.space();
        this.word("implements");
        this.space();
        this.printList(node.implements);
      }
      this.space();
      this.print(node.body);
    }
    function ClassBody(node) {
      this.tokenChar(123);
      if (node.body.length === 0) {
        this.tokenChar(125);
      } else {
        this.newline();
        const separator = classBodyEmptySemicolonsPrinter(this, node);
        separator == null || separator(-1);
        const exit = this.enterDelimited();
        this.printJoin(node.body, true, true, separator, true);
        exit();
        if (!this.endsWith(10)) this.newline();
        this.rightBrace(node);
      }
    }
    function classBodyEmptySemicolonsPrinter(printer, node) {
      if (!printer.tokenMap || node.start == null || node.end == null) {
        return null;
      }
      const indexes = printer.tokenMap.getIndexes(node);
      if (!indexes) return null;
      let k = 1;
      let occurrenceCount = 0;
      let nextLocIndex = 0;
      const advanceNextLocIndex = () => {
        while (nextLocIndex < node.body.length && node.body[nextLocIndex].start == null) {
          nextLocIndex++;
        }
      };
      advanceNextLocIndex();
      return (i) => {
        if (nextLocIndex <= i) {
          nextLocIndex = i + 1;
          advanceNextLocIndex();
        }
        const end = nextLocIndex === node.body.length ? node.end : node.body[nextLocIndex].start;
        let tok;
        while (k < indexes.length && printer.tokenMap.matchesOriginal(tok = printer._tokens[indexes[k]], ";") && tok.start < end) {
          printer.token(";", void 0, occurrenceCount++);
          k++;
        }
      };
    }
    function ClassProperty(node) {
      this.printJoin(node.decorators);
      if (!node.static && !this.format.preserveFormat) {
        var _node$key$loc;
        const endLine = (_node$key$loc = node.key.loc) == null || (_node$key$loc = _node$key$loc.end) == null ? void 0 : _node$key$loc.line;
        if (endLine) this.catchUp(endLine);
      }
      this.tsPrintClassMemberModifiers(node);
      if (node.computed) {
        this.tokenChar(91);
        this.print(node.key);
        this.tokenChar(93);
      } else {
        this._variance(node);
        this.print(node.key);
      }
      if (node.optional) {
        this.tokenChar(63);
      }
      if (node.definite) {
        this.tokenChar(33);
      }
      this.print(node.typeAnnotation);
      if (node.value) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node.value);
      }
      this.semicolon();
    }
    function ClassAccessorProperty(node) {
      var _node$key$loc2;
      this.printJoin(node.decorators);
      const endLine = (_node$key$loc2 = node.key.loc) == null || (_node$key$loc2 = _node$key$loc2.end) == null ? void 0 : _node$key$loc2.line;
      if (endLine) this.catchUp(endLine);
      this.tsPrintClassMemberModifiers(node);
      this.word("accessor", true);
      this.space();
      if (node.computed) {
        this.tokenChar(91);
        this.print(node.key);
        this.tokenChar(93);
      } else {
        this._variance(node);
        this.print(node.key);
      }
      if (node.optional) {
        this.tokenChar(63);
      }
      if (node.definite) {
        this.tokenChar(33);
      }
      this.print(node.typeAnnotation);
      if (node.value) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node.value);
      }
      this.semicolon();
    }
    function ClassPrivateProperty(node) {
      this.printJoin(node.decorators);
      this.tsPrintClassMemberModifiers(node);
      this.print(node.key);
      if (node.optional) {
        this.tokenChar(63);
      }
      if (node.definite) {
        this.tokenChar(33);
      }
      this.print(node.typeAnnotation);
      if (node.value) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node.value);
      }
      this.semicolon();
    }
    function ClassMethod(node) {
      this._classMethodHead(node);
      this.space();
      this.print(node.body);
    }
    function ClassPrivateMethod(node) {
      this._classMethodHead(node);
      this.space();
      this.print(node.body);
    }
    function _classMethodHead(node) {
      this.printJoin(node.decorators);
      if (!this.format.preserveFormat) {
        var _node$key$loc3;
        const endLine = (_node$key$loc3 = node.key.loc) == null || (_node$key$loc3 = _node$key$loc3.end) == null ? void 0 : _node$key$loc3.line;
        if (endLine) this.catchUp(endLine);
      }
      this.tsPrintClassMemberModifiers(node);
      this._methodHead(node);
    }
    function StaticBlock(node) {
      this.word("static");
      this.space();
      this.tokenChar(123);
      if (node.body.length === 0) {
        this.tokenChar(125);
      } else {
        this.newline();
        this.printSequence(node.body, true);
        this.rightBrace(node);
      }
    }
  }
});

// node_modules/@babel/helpers/node_modules/@babel/generator/lib/generators/methods.js
var require_methods = __commonJS({
  "node_modules/@babel/helpers/node_modules/@babel/generator/lib/generators/methods.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ArrowFunctionExpression = ArrowFunctionExpression;
    exports2.FunctionDeclaration = exports2.FunctionExpression = FunctionExpression10;
    exports2._functionHead = _functionHead;
    exports2._methodHead = _methodHead;
    exports2._param = _param;
    exports2._parameters = _parameters;
    exports2._params = _params;
    exports2._predicate = _predicate;
    exports2._shouldPrintArrowParamsParens = _shouldPrintArrowParamsParens;
    var _t = require("@babel/types");
    var _index = require_node2();
    var {
      isIdentifier
    } = _t;
    function _params(node, idNode, parentNode) {
      this.print(node.typeParameters);
      const nameInfo = _getFuncIdName.call(this, idNode, parentNode);
      if (nameInfo) {
        this.sourceIdentifierName(nameInfo.name, nameInfo.pos);
      }
      this.tokenChar(40);
      this._parameters(node.params, ")");
      const noLineTerminator = node.type === "ArrowFunctionExpression";
      this.print(node.returnType, noLineTerminator);
      this._noLineTerminator = noLineTerminator;
    }
    function _parameters(parameters, endToken) {
      const exit = this.enterDelimited();
      const trailingComma = this.shouldPrintTrailingComma(endToken);
      const paramLength = parameters.length;
      for (let i = 0; i < paramLength; i++) {
        this._param(parameters[i]);
        if (trailingComma || i < paramLength - 1) {
          this.token(",", null, i);
          this.space();
        }
      }
      this.token(endToken);
      exit();
    }
    function _param(parameter) {
      this.printJoin(parameter.decorators);
      this.print(parameter);
      if (parameter.optional) {
        this.tokenChar(63);
      }
      this.print(parameter.typeAnnotation);
    }
    function _methodHead(node) {
      const kind = node.kind;
      const key2 = node.key;
      if (kind === "get" || kind === "set") {
        this.word(kind);
        this.space();
      }
      if (node.async) {
        this.word("async", true);
        this.space();
      }
      if (kind === "method" || kind === "init") {
        if (node.generator) {
          this.tokenChar(42);
        }
      }
      if (node.computed) {
        this.tokenChar(91);
        this.print(key2);
        this.tokenChar(93);
      } else {
        this.print(key2);
      }
      if (node.optional) {
        this.tokenChar(63);
      }
      this._params(node, node.computed && node.key.type !== "StringLiteral" ? void 0 : node.key, void 0);
    }
    function _predicate(node, noLineTerminatorAfter) {
      if (node.predicate) {
        if (!node.returnType) {
          this.tokenChar(58);
        }
        this.space();
        this.print(node.predicate, noLineTerminatorAfter);
      }
    }
    function _functionHead(node, parent) {
      if (node.async) {
        this.word("async");
        if (!this.format.preserveFormat) {
          this._endsWithInnerRaw = false;
        }
        this.space();
      }
      this.word("function");
      if (node.generator) {
        if (!this.format.preserveFormat) {
          this._endsWithInnerRaw = false;
        }
        this.tokenChar(42);
      }
      this.space();
      if (node.id) {
        this.print(node.id);
      }
      this._params(node, node.id, parent);
      if (node.type !== "TSDeclareFunction") {
        this._predicate(node);
      }
    }
    function FunctionExpression10(node, parent) {
      this._functionHead(node, parent);
      this.space();
      this.print(node.body);
    }
    function ArrowFunctionExpression(node, parent) {
      if (node.async) {
        this.word("async", true);
        this.space();
      }
      if (this._shouldPrintArrowParamsParens(node)) {
        this._params(node, void 0, parent);
      } else {
        this.print(node.params[0], true);
      }
      this._predicate(node, true);
      this.space();
      this.printInnerComments();
      this.token("=>");
      this.space();
      this.tokenContext |= _index.TokenContext.arrowBody;
      this.print(node.body);
    }
    function _shouldPrintArrowParamsParens(node) {
      var _firstParam$leadingCo, _firstParam$trailingC;
      if (node.params.length !== 1) return true;
      if (node.typeParameters || node.returnType || node.predicate) {
        return true;
      }
      const firstParam = node.params[0];
      if (!isIdentifier(firstParam) || firstParam.typeAnnotation || firstParam.optional || (_firstParam$leadingCo = firstParam.leadingComments) != null && _firstParam$leadingCo.length || (_firstParam$trailingC = firstParam.trailingComments) != null && _firstParam$trailingC.length) {
        return true;
      }
      if (this.tokenMap) {
        if (node.loc == null) return true;
        if (this.tokenMap.findMatching(node, "(") !== null) return true;
        const arrowToken = this.tokenMap.findMatching(node, "=>");
        if ((arrowToken == null ? void 0 : arrowToken.loc) == null) return true;
        return arrowToken.loc.start.line !== node.loc.start.line;
      }
      if (this.format.retainLines) return true;
      return false;
    }
    function _getFuncIdName(idNode, parent) {
      let id = idNode;
      if (!id && parent) {
        const parentType = parent.type;
        if (parentType === "VariableDeclarator") {
          id = parent.id;
        } else if (parentType === "AssignmentExpression" || parentType === "AssignmentPattern") {
          id = parent.left;
        } else if (parentType === "ObjectProperty" || parentType === "ClassProperty") {
          if (!parent.computed || parent.key.type === "StringLiteral") {
            id = parent.key;
          }
        } else if (parentType === "ClassPrivateProperty" || parentType === "ClassAccessorProperty") {
          id = parent.key;
        }
      }
      if (!id) return;
      let nameInfo;
      if (id.type === "Identifier") {
        var _id$loc, _id$loc2;
        nameInfo = {
          pos: (_id$loc = id.loc) == null ? void 0 : _id$loc.start,
          name: ((_id$loc2 = id.loc) == null ? void 0 : _id$loc2.identifierName) || id.name
        };
      } else if (id.type === "PrivateName") {
        var _id$loc3;
        nameInfo = {
          pos: (_id$loc3 = id.loc) == null ? void 0 : _id$loc3.start,
          name: "#" + id.id.name
        };
      } else if (id.type === "StringLiteral") {
        var _id$loc4;
        nameInfo = {
          pos: (_id$loc4 = id.loc) == null ? void 0 : _id$loc4.start,
          name: id.value
        };
      }
      return nameInfo;
    }
  }
});

// node_modules/@babel/helpers/node_modules/@babel/generator/lib/generators/modules.js
var require_modules = __commonJS({
  "node_modules/@babel/helpers/node_modules/@babel/generator/lib/generators/modules.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ExportAllDeclaration = ExportAllDeclaration;
    exports2.ExportDefaultDeclaration = ExportDefaultDeclaration;
    exports2.ExportDefaultSpecifier = ExportDefaultSpecifier;
    exports2.ExportNamedDeclaration = ExportNamedDeclaration;
    exports2.ExportNamespaceSpecifier = ExportNamespaceSpecifier;
    exports2.ExportSpecifier = ExportSpecifier;
    exports2.ImportAttribute = ImportAttribute;
    exports2.ImportDeclaration = ImportDeclaration;
    exports2.ImportDefaultSpecifier = ImportDefaultSpecifier;
    exports2.ImportExpression = ImportExpression;
    exports2.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
    exports2.ImportSpecifier = ImportSpecifier;
    exports2._printAttributes = _printAttributes;
    var _t = require("@babel/types");
    var _index = require_node2();
    var {
      isClassDeclaration,
      isExportDefaultSpecifier,
      isExportNamespaceSpecifier,
      isImportDefaultSpecifier,
      isImportNamespaceSpecifier,
      isStatement: isStatement2
    } = _t;
    function ImportSpecifier(node) {
      if (node.importKind === "type" || node.importKind === "typeof") {
        this.word(node.importKind);
        this.space();
      }
      this.print(node.imported);
      if (node.local && node.local.name !== node.imported.name) {
        this.space();
        this.word("as");
        this.space();
        this.print(node.local);
      }
    }
    function ImportDefaultSpecifier(node) {
      this.print(node.local);
    }
    function ExportDefaultSpecifier(node) {
      this.print(node.exported);
    }
    function ExportSpecifier(node) {
      if (node.exportKind === "type") {
        this.word("type");
        this.space();
      }
      this.print(node.local);
      if (node.exported && node.local.name !== node.exported.name) {
        this.space();
        this.word("as");
        this.space();
        this.print(node.exported);
      }
    }
    function ExportNamespaceSpecifier(node) {
      this.tokenChar(42);
      this.space();
      this.word("as");
      this.space();
      this.print(node.exported);
    }
    var warningShown = false;
    function _printAttributes(node, hasPreviousBrace) {
      var _node$extra;
      const {
        importAttributesKeyword
      } = this.format;
      const {
        attributes,
        assertions
      } = node;
      if (attributes && !importAttributesKeyword && node.extra && (node.extra.deprecatedAssertSyntax || node.extra.deprecatedWithLegacySyntax) && !warningShown) {
        warningShown = true;
        console.warn(`You are using import attributes, without specifying the desired output syntax.
Please specify the "importAttributesKeyword" generator option, whose value can be one of:
 - "with"        : \`import { a } from "b" with { type: "json" };\`
 - "assert"      : \`import { a } from "b" assert { type: "json" };\`
 - "with-legacy" : \`import { a } from "b" with type: "json";\`
`);
      }
      const useAssertKeyword = importAttributesKeyword === "assert" || !importAttributesKeyword && assertions;
      this.word(useAssertKeyword ? "assert" : "with");
      this.space();
      if (!useAssertKeyword && (importAttributesKeyword === "with-legacy" || !importAttributesKeyword && (_node$extra = node.extra) != null && _node$extra.deprecatedWithLegacySyntax)) {
        this.printList(attributes || assertions);
        return;
      }
      const occurrenceCount = hasPreviousBrace ? 1 : 0;
      this.token("{", null, occurrenceCount);
      this.space();
      this.printList(attributes || assertions, this.shouldPrintTrailingComma("}"));
      this.space();
      this.token("}", null, occurrenceCount);
    }
    function ExportAllDeclaration(node) {
      var _node$attributes, _node$assertions;
      this.word("export");
      this.space();
      if (node.exportKind === "type") {
        this.word("type");
        this.space();
      }
      this.tokenChar(42);
      this.space();
      this.word("from");
      this.space();
      if ((_node$attributes = node.attributes) != null && _node$attributes.length || (_node$assertions = node.assertions) != null && _node$assertions.length) {
        this.print(node.source, true);
        this.space();
        this._printAttributes(node, false);
      } else {
        this.print(node.source);
      }
      this.semicolon();
    }
    function maybePrintDecoratorsBeforeExport(printer, node) {
      if (isClassDeclaration(node.declaration) && printer._shouldPrintDecoratorsBeforeExport(node)) {
        printer.printJoin(node.declaration.decorators);
      }
    }
    function ExportNamedDeclaration(node) {
      maybePrintDecoratorsBeforeExport(this, node);
      this.word("export");
      this.space();
      if (node.declaration) {
        const declar = node.declaration;
        this.print(declar);
        if (!isStatement2(declar)) this.semicolon();
      } else {
        if (node.exportKind === "type") {
          this.word("type");
          this.space();
        }
        const specifiers = node.specifiers.slice(0);
        let hasSpecial = false;
        for (; ; ) {
          const first = specifiers[0];
          if (isExportDefaultSpecifier(first) || isExportNamespaceSpecifier(first)) {
            hasSpecial = true;
            this.print(specifiers.shift());
            if (specifiers.length) {
              this.tokenChar(44);
              this.space();
            }
          } else {
            break;
          }
        }
        let hasBrace = false;
        if (specifiers.length || !specifiers.length && !hasSpecial) {
          hasBrace = true;
          this.tokenChar(123);
          if (specifiers.length) {
            this.space();
            this.printList(specifiers, this.shouldPrintTrailingComma("}"));
            this.space();
          }
          this.tokenChar(125);
        }
        if (node.source) {
          var _node$attributes2, _node$assertions2;
          this.space();
          this.word("from");
          this.space();
          if ((_node$attributes2 = node.attributes) != null && _node$attributes2.length || (_node$assertions2 = node.assertions) != null && _node$assertions2.length) {
            this.print(node.source, true);
            this.space();
            this._printAttributes(node, hasBrace);
          } else {
            this.print(node.source);
          }
        }
        this.semicolon();
      }
    }
    function ExportDefaultDeclaration(node) {
      maybePrintDecoratorsBeforeExport(this, node);
      this.word("export");
      this.noIndentInnerCommentsHere();
      this.space();
      this.word("default");
      this.space();
      this.tokenContext |= _index.TokenContext.exportDefault;
      const declar = node.declaration;
      this.print(declar);
      if (!isStatement2(declar)) this.semicolon();
    }
    function ImportDeclaration(node) {
      var _node$attributes3, _node$assertions3;
      this.word("import");
      this.space();
      const isTypeKind = node.importKind === "type" || node.importKind === "typeof";
      if (isTypeKind) {
        this.noIndentInnerCommentsHere();
        this.word(node.importKind);
        this.space();
      } else if (node.module) {
        this.noIndentInnerCommentsHere();
        this.word("module");
        this.space();
      } else if (node.phase) {
        this.noIndentInnerCommentsHere();
        this.word(node.phase);
        this.space();
      }
      const specifiers = node.specifiers.slice(0);
      const hasSpecifiers = !!specifiers.length;
      while (hasSpecifiers) {
        const first = specifiers[0];
        if (isImportDefaultSpecifier(first) || isImportNamespaceSpecifier(first)) {
          this.print(specifiers.shift());
          if (specifiers.length) {
            this.tokenChar(44);
            this.space();
          }
        } else {
          break;
        }
      }
      let hasBrace = false;
      if (specifiers.length) {
        hasBrace = true;
        this.tokenChar(123);
        this.space();
        this.printList(specifiers, this.shouldPrintTrailingComma("}"));
        this.space();
        this.tokenChar(125);
      } else if (isTypeKind && !hasSpecifiers) {
        hasBrace = true;
        this.tokenChar(123);
        this.tokenChar(125);
      }
      if (hasSpecifiers || isTypeKind) {
        this.space();
        this.word("from");
        this.space();
      }
      if ((_node$attributes3 = node.attributes) != null && _node$attributes3.length || (_node$assertions3 = node.assertions) != null && _node$assertions3.length) {
        this.print(node.source, true);
        this.space();
        this._printAttributes(node, hasBrace);
      } else {
        this.print(node.source);
      }
      this.semicolon();
    }
    function ImportAttribute(node) {
      this.print(node.key);
      this.tokenChar(58);
      this.space();
      this.print(node.value);
    }
    function ImportNamespaceSpecifier(node) {
      this.tokenChar(42);
      this.space();
      this.word("as");
      this.space();
      this.print(node.local);
    }
    function ImportExpression(node) {
      this.word("import");
      if (node.phase) {
        this.tokenChar(46);
        this.word(node.phase);
      }
      this.tokenChar(40);
      this.print(node.source);
      if (node.options != null) {
        this.tokenChar(44);
        this.space();
        this.print(node.options);
      }
      this.tokenChar(41);
    }
  }
});

// node_modules/@babel/helpers/node_modules/jsesc/jsesc.js
var require_jsesc = __commonJS({
  "node_modules/@babel/helpers/node_modules/jsesc/jsesc.js"(exports2, module2) {
    "use strict";
    var object = {};
    var hasOwnProperty3 = object.hasOwnProperty;
    var forOwn = (object2, callback) => {
      for (const key2 in object2) {
        if (hasOwnProperty3.call(object2, key2)) {
          callback(key2, object2[key2]);
        }
      }
    };
    var extend = (destination, source2) => {
      if (!source2) {
        return destination;
      }
      forOwn(source2, (key2, value) => {
        destination[key2] = value;
      });
      return destination;
    };
    var forEach = (array, callback) => {
      const length = array.length;
      let index = -1;
      while (++index < length) {
        callback(array[index]);
      }
    };
    var fourHexEscape = (hex) => {
      return "\\u" + ("0000" + hex).slice(-4);
    };
    var hexadecimal = (code, lowercase) => {
      let hexadecimal2 = code.toString(16);
      if (lowercase) return hexadecimal2;
      return hexadecimal2.toUpperCase();
    };
    var toString = object.toString;
    var isArray = Array.isArray;
    var isBuffer = (value) => {
      return typeof Buffer === "function" && Buffer.isBuffer(value);
    };
    var isObject = (value) => {
      return toString.call(value) == "[object Object]";
    };
    var isString = (value) => {
      return typeof value == "string" || toString.call(value) == "[object String]";
    };
    var isNumber = (value) => {
      return typeof value == "number" || toString.call(value) == "[object Number]";
    };
    var isBigInt = (value) => {
      return typeof value == "bigint";
    };
    var isFunction = (value) => {
      return typeof value == "function";
    };
    var isMap = (value) => {
      return toString.call(value) == "[object Map]";
    };
    var isSet = (value) => {
      return toString.call(value) == "[object Set]";
    };
    var singleEscapes = {
      "\\": "\\\\",
      "\b": "\\b",
      "\f": "\\f",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t"
      // `\v` is omitted intentionally, because in IE < 9, '\v' == 'v'.
      // '\v': '\\x0B'
    };
    var regexSingleEscape = /[\\\b\f\n\r\t]/;
    var regexDigit = /[0-9]/;
    var regexWhitespace = /[\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
    var escapeEverythingRegex = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^]/g;
    var escapeNonAsciiRegex = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^ !#-&\(-\[\]-_a-~]/g;
    var jsesc = (argument, options) => {
      const increaseIndentation = () => {
        oldIndent = indent;
        ++options.indentLevel;
        indent = options.indent.repeat(options.indentLevel);
      };
      const defaults = {
        "escapeEverything": false,
        "minimal": false,
        "isScriptContext": false,
        "quotes": "single",
        "wrap": false,
        "es6": false,
        "json": false,
        "compact": true,
        "lowercaseHex": false,
        "numbers": "decimal",
        "indent": "	",
        "indentLevel": 0,
        "__inline1__": false,
        "__inline2__": false
      };
      const json = options && options.json;
      if (json) {
        defaults.quotes = "double";
        defaults.wrap = true;
      }
      options = extend(defaults, options);
      if (options.quotes != "single" && options.quotes != "double" && options.quotes != "backtick") {
        options.quotes = "single";
      }
      const quote = options.quotes == "double" ? '"' : options.quotes == "backtick" ? "`" : "'";
      const compact = options.compact;
      const lowercaseHex = options.lowercaseHex;
      let indent = options.indent.repeat(options.indentLevel);
      let oldIndent = "";
      const inline1 = options.__inline1__;
      const inline2 = options.__inline2__;
      const newLine = compact ? "" : "\n";
      let result;
      let isEmpty = true;
      const useBinNumbers = options.numbers == "binary";
      const useOctNumbers = options.numbers == "octal";
      const useDecNumbers = options.numbers == "decimal";
      const useHexNumbers = options.numbers == "hexadecimal";
      if (json && argument && isFunction(argument.toJSON)) {
        argument = argument.toJSON();
      }
      if (!isString(argument)) {
        if (isMap(argument)) {
          if (argument.size == 0) {
            return "new Map()";
          }
          if (!compact) {
            options.__inline1__ = true;
            options.__inline2__ = false;
          }
          return "new Map(" + jsesc(Array.from(argument), options) + ")";
        }
        if (isSet(argument)) {
          if (argument.size == 0) {
            return "new Set()";
          }
          return "new Set(" + jsesc(Array.from(argument), options) + ")";
        }
        if (isBuffer(argument)) {
          if (argument.length == 0) {
            return "Buffer.from([])";
          }
          return "Buffer.from(" + jsesc(Array.from(argument), options) + ")";
        }
        if (isArray(argument)) {
          result = [];
          options.wrap = true;
          if (inline1) {
            options.__inline1__ = false;
            options.__inline2__ = true;
          }
          if (!inline2) {
            increaseIndentation();
          }
          forEach(argument, (value) => {
            isEmpty = false;
            if (inline2) {
              options.__inline2__ = false;
            }
            result.push(
              (compact || inline2 ? "" : indent) + jsesc(value, options)
            );
          });
          if (isEmpty) {
            return "[]";
          }
          if (inline2) {
            return "[" + result.join(", ") + "]";
          }
          return "[" + newLine + result.join("," + newLine) + newLine + (compact ? "" : oldIndent) + "]";
        } else if (isNumber(argument) || isBigInt(argument)) {
          if (json) {
            return JSON.stringify(Number(argument));
          }
          let result2;
          if (useDecNumbers) {
            result2 = String(argument);
          } else if (useHexNumbers) {
            let hexadecimal2 = argument.toString(16);
            if (!lowercaseHex) {
              hexadecimal2 = hexadecimal2.toUpperCase();
            }
            result2 = "0x" + hexadecimal2;
          } else if (useBinNumbers) {
            result2 = "0b" + argument.toString(2);
          } else if (useOctNumbers) {
            result2 = "0o" + argument.toString(8);
          }
          if (isBigInt(argument)) {
            return result2 + "n";
          }
          return result2;
        } else if (isBigInt(argument)) {
          if (json) {
            return JSON.stringify(Number(argument));
          }
          return argument + "n";
        } else if (!isObject(argument)) {
          if (json) {
            return JSON.stringify(argument) || "null";
          }
          return String(argument);
        } else {
          result = [];
          options.wrap = true;
          increaseIndentation();
          forOwn(argument, (key2, value) => {
            isEmpty = false;
            result.push(
              (compact ? "" : indent) + jsesc(key2, options) + ":" + (compact ? "" : " ") + jsesc(value, options)
            );
          });
          if (isEmpty) {
            return "{}";
          }
          return "{" + newLine + result.join("," + newLine) + newLine + (compact ? "" : oldIndent) + "}";
        }
      }
      const regex = options.escapeEverything ? escapeEverythingRegex : escapeNonAsciiRegex;
      result = argument.replace(regex, (char, pair, lone, quoteChar, index, string) => {
        if (pair) {
          if (options.minimal) return pair;
          const first = pair.charCodeAt(0);
          const second = pair.charCodeAt(1);
          if (options.es6) {
            const codePoint = (first - 55296) * 1024 + second - 56320 + 65536;
            const hex2 = hexadecimal(codePoint, lowercaseHex);
            return "\\u{" + hex2 + "}";
          }
          return fourHexEscape(hexadecimal(first, lowercaseHex)) + fourHexEscape(hexadecimal(second, lowercaseHex));
        }
        if (lone) {
          return fourHexEscape(hexadecimal(lone.charCodeAt(0), lowercaseHex));
        }
        if (char == "\0" && !json && !regexDigit.test(string.charAt(index + 1))) {
          return "\\0";
        }
        if (quoteChar) {
          if (quoteChar == quote || options.escapeEverything) {
            return "\\" + quoteChar;
          }
          return quoteChar;
        }
        if (regexSingleEscape.test(char)) {
          return singleEscapes[char];
        }
        if (options.minimal && !regexWhitespace.test(char)) {
          return char;
        }
        const hex = hexadecimal(char.charCodeAt(0), lowercaseHex);
        if (json || hex.length > 2) {
          return fourHexEscape(hex);
        }
        return "\\x" + ("00" + hex).slice(-2);
      });
      if (quote == "`") {
        result = result.replace(/\$\{/g, "\\${");
      }
      if (options.isScriptContext) {
        result = result.replace(/<\/(script|style)/gi, "<\\/$1").replace(/<!--/g, json ? "\\u003C!--" : "\\x3C!--");
      }
      if (options.wrap) {
        result = quote + result + quote;
      }
      return result;
    };
    jsesc.version = "3.0.2";
    module2.exports = jsesc;
  }
});

// node_modules/@babel/helpers/node_modules/@babel/generator/lib/generators/types.js
var require_types = __commonJS({
  "node_modules/@babel/helpers/node_modules/@babel/generator/lib/generators/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ArgumentPlaceholder = ArgumentPlaceholder;
    exports2.ArrayPattern = exports2.ArrayExpression = ArrayExpression6;
    exports2.BigIntLiteral = BigIntLiteral;
    exports2.BooleanLiteral = BooleanLiteral;
    exports2.Identifier = Identifier25;
    exports2.NullLiteral = NullLiteral;
    exports2.NumericLiteral = NumericLiteral;
    exports2.ObjectPattern = exports2.ObjectExpression = ObjectExpression;
    exports2.ObjectMethod = ObjectMethod4;
    exports2.ObjectProperty = ObjectProperty4;
    exports2.PipelineBareFunction = PipelineBareFunction;
    exports2.PipelinePrimaryTopicReference = PipelinePrimaryTopicReference;
    exports2.PipelineTopicExpression = PipelineTopicExpression;
    exports2.RecordExpression = RecordExpression;
    exports2.RegExpLiteral = RegExpLiteral;
    exports2.SpreadElement = exports2.RestElement = RestElement;
    exports2.StringLiteral = StringLiteral;
    exports2.TopicReference = TopicReference;
    exports2.TupleExpression = TupleExpression;
    exports2._getRawIdentifier = _getRawIdentifier;
    var _t = require("@babel/types");
    var _jsesc = require_jsesc();
    var {
      isAssignmentPattern,
      isIdentifier
    } = _t;
    var lastRawIdentNode = null;
    var lastRawIdentResult = "";
    function _getRawIdentifier(node) {
      if (node === lastRawIdentNode) return lastRawIdentResult;
      lastRawIdentNode = node;
      const {
        name
      } = node;
      const token2 = this.tokenMap.find(node, (tok) => tok.value === name);
      if (token2) {
        lastRawIdentResult = this._originalCode.slice(token2.start, token2.end);
        return lastRawIdentResult;
      }
      return lastRawIdentResult = node.name;
    }
    function Identifier25(node) {
      var _node$loc;
      this.sourceIdentifierName(((_node$loc = node.loc) == null ? void 0 : _node$loc.identifierName) || node.name);
      this.word(this.tokenMap ? this._getRawIdentifier(node) : node.name);
    }
    function ArgumentPlaceholder() {
      this.tokenChar(63);
    }
    function RestElement(node) {
      this.token("...");
      this.print(node.argument);
    }
    function ObjectExpression(node) {
      const props = node.properties;
      this.tokenChar(123);
      if (props.length) {
        const exit = this.enterDelimited();
        this.space();
        this.printList(props, this.shouldPrintTrailingComma("}"), true, true);
        this.space();
        exit();
      }
      this.sourceWithOffset("end", node.loc, -1);
      this.tokenChar(125);
    }
    function ObjectMethod4(node) {
      this.printJoin(node.decorators);
      this._methodHead(node);
      this.space();
      this.print(node.body);
    }
    function ObjectProperty4(node) {
      this.printJoin(node.decorators);
      if (node.computed) {
        this.tokenChar(91);
        this.print(node.key);
        this.tokenChar(93);
      } else {
        if (isAssignmentPattern(node.value) && isIdentifier(node.key) && node.key.name === node.value.left.name) {
          this.print(node.value);
          return;
        }
        this.print(node.key);
        if (node.shorthand && isIdentifier(node.key) && isIdentifier(node.value) && node.key.name === node.value.name) {
          return;
        }
      }
      this.tokenChar(58);
      this.space();
      this.print(node.value);
    }
    function ArrayExpression6(node) {
      const elems = node.elements;
      const len = elems.length;
      this.tokenChar(91);
      const exit = this.enterDelimited();
      for (let i = 0; i < elems.length; i++) {
        const elem = elems[i];
        if (elem) {
          if (i > 0) this.space();
          this.print(elem);
          if (i < len - 1 || this.shouldPrintTrailingComma("]")) {
            this.token(",", false, i);
          }
        } else {
          this.token(",", false, i);
        }
      }
      exit();
      this.tokenChar(93);
    }
    function RecordExpression(node) {
      const props = node.properties;
      let startToken;
      let endToken;
      {
        if (this.format.recordAndTupleSyntaxType === "bar") {
          startToken = "{|";
          endToken = "|}";
        } else if (this.format.recordAndTupleSyntaxType !== "hash" && this.format.recordAndTupleSyntaxType != null) {
          throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)} received).`);
        } else {
          startToken = "#{";
          endToken = "}";
        }
      }
      this.token(startToken);
      if (props.length) {
        this.space();
        this.printList(props, this.shouldPrintTrailingComma(endToken), true, true);
        this.space();
      }
      this.token(endToken);
    }
    function TupleExpression(node) {
      const elems = node.elements;
      const len = elems.length;
      let startToken;
      let endToken;
      {
        if (this.format.recordAndTupleSyntaxType === "bar") {
          startToken = "[|";
          endToken = "|]";
        } else if (this.format.recordAndTupleSyntaxType === "hash") {
          startToken = "#[";
          endToken = "]";
        } else {
          throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);
        }
      }
      this.token(startToken);
      for (let i = 0; i < elems.length; i++) {
        const elem = elems[i];
        if (elem) {
          if (i > 0) this.space();
          this.print(elem);
          if (i < len - 1 || this.shouldPrintTrailingComma(endToken)) {
            this.token(",", false, i);
          }
        }
      }
      this.token(endToken);
    }
    function RegExpLiteral(node) {
      this.word(`/${node.pattern}/${node.flags}`);
    }
    function BooleanLiteral(node) {
      this.word(node.value ? "true" : "false");
    }
    function NullLiteral() {
      this.word("null");
    }
    function NumericLiteral(node) {
      const raw = this.getPossibleRaw(node);
      const opts = this.format.jsescOption;
      const value = node.value;
      const str = value + "";
      if (opts.numbers) {
        this.number(_jsesc(value, opts), value);
      } else if (raw == null) {
        this.number(str, value);
      } else if (this.format.minified) {
        this.number(raw.length < str.length ? raw : str, value);
      } else {
        this.number(raw, value);
      }
    }
    function StringLiteral(node) {
      const raw = this.getPossibleRaw(node);
      if (!this.format.minified && raw !== void 0) {
        this.token(raw);
        return;
      }
      const val = _jsesc(node.value, this.format.jsescOption);
      this.token(val);
    }
    function BigIntLiteral(node) {
      const raw = this.getPossibleRaw(node);
      if (!this.format.minified && raw !== void 0) {
        this.word(raw);
        return;
      }
      this.word(node.value + "n");
    }
    var validTopicTokenSet = /* @__PURE__ */ new Set(["^^", "@@", "^", "%", "#"]);
    function TopicReference() {
      const {
        topicToken
      } = this.format;
      if (validTopicTokenSet.has(topicToken)) {
        this.token(topicToken);
      } else {
        const givenTopicTokenJSON = JSON.stringify(topicToken);
        const validTopics = Array.from(validTopicTokenSet, (v) => JSON.stringify(v));
        throw new Error(`The "topicToken" generator option must be one of ${validTopics.join(", ")} (${givenTopicTokenJSON} received instead).`);
      }
    }
    function PipelineTopicExpression(node) {
      this.print(node.expression);
    }
    function PipelineBareFunction(node) {
      this.print(node.callee);
    }
    function PipelinePrimaryTopicReference() {
      this.tokenChar(35);
    }
  }
});

// node_modules/@babel/helpers/node_modules/@babel/generator/lib/generators/flow.js
var require_flow = __commonJS({
  "node_modules/@babel/helpers/node_modules/@babel/generator/lib/generators/flow.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.AnyTypeAnnotation = AnyTypeAnnotation;
    exports2.ArrayTypeAnnotation = ArrayTypeAnnotation;
    exports2.BooleanLiteralTypeAnnotation = BooleanLiteralTypeAnnotation;
    exports2.BooleanTypeAnnotation = BooleanTypeAnnotation;
    exports2.DeclareClass = DeclareClass;
    exports2.DeclareExportAllDeclaration = DeclareExportAllDeclaration;
    exports2.DeclareExportDeclaration = DeclareExportDeclaration;
    exports2.DeclareFunction = DeclareFunction;
    exports2.DeclareInterface = DeclareInterface;
    exports2.DeclareModule = DeclareModule;
    exports2.DeclareModuleExports = DeclareModuleExports;
    exports2.DeclareOpaqueType = DeclareOpaqueType;
    exports2.DeclareTypeAlias = DeclareTypeAlias;
    exports2.DeclareVariable = DeclareVariable;
    exports2.DeclaredPredicate = DeclaredPredicate;
    exports2.EmptyTypeAnnotation = EmptyTypeAnnotation;
    exports2.EnumBooleanBody = EnumBooleanBody;
    exports2.EnumBooleanMember = EnumBooleanMember;
    exports2.EnumDeclaration = EnumDeclaration;
    exports2.EnumDefaultedMember = EnumDefaultedMember;
    exports2.EnumNumberBody = EnumNumberBody;
    exports2.EnumNumberMember = EnumNumberMember;
    exports2.EnumStringBody = EnumStringBody;
    exports2.EnumStringMember = EnumStringMember;
    exports2.EnumSymbolBody = EnumSymbolBody;
    exports2.ExistsTypeAnnotation = ExistsTypeAnnotation;
    exports2.FunctionTypeAnnotation = FunctionTypeAnnotation;
    exports2.FunctionTypeParam = FunctionTypeParam;
    exports2.IndexedAccessType = IndexedAccessType;
    exports2.InferredPredicate = InferredPredicate;
    exports2.InterfaceDeclaration = InterfaceDeclaration;
    exports2.GenericTypeAnnotation = exports2.ClassImplements = exports2.InterfaceExtends = InterfaceExtends;
    exports2.InterfaceTypeAnnotation = InterfaceTypeAnnotation;
    exports2.IntersectionTypeAnnotation = IntersectionTypeAnnotation;
    exports2.MixedTypeAnnotation = MixedTypeAnnotation;
    exports2.NullLiteralTypeAnnotation = NullLiteralTypeAnnotation;
    exports2.NullableTypeAnnotation = NullableTypeAnnotation;
    Object.defineProperty(exports2, "NumberLiteralTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _types2.NumericLiteral;
      }
    });
    exports2.NumberTypeAnnotation = NumberTypeAnnotation;
    exports2.ObjectTypeAnnotation = ObjectTypeAnnotation;
    exports2.ObjectTypeCallProperty = ObjectTypeCallProperty;
    exports2.ObjectTypeIndexer = ObjectTypeIndexer;
    exports2.ObjectTypeInternalSlot = ObjectTypeInternalSlot;
    exports2.ObjectTypeProperty = ObjectTypeProperty;
    exports2.ObjectTypeSpreadProperty = ObjectTypeSpreadProperty;
    exports2.OpaqueType = OpaqueType;
    exports2.OptionalIndexedAccessType = OptionalIndexedAccessType;
    exports2.QualifiedTypeIdentifier = QualifiedTypeIdentifier;
    Object.defineProperty(exports2, "StringLiteralTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _types2.StringLiteral;
      }
    });
    exports2.StringTypeAnnotation = StringTypeAnnotation;
    exports2.SymbolTypeAnnotation = SymbolTypeAnnotation;
    exports2.ThisTypeAnnotation = ThisTypeAnnotation;
    exports2.TupleTypeAnnotation = TupleTypeAnnotation;
    exports2.TypeAlias = TypeAlias;
    exports2.TypeAnnotation = TypeAnnotation;
    exports2.TypeCastExpression = TypeCastExpression;
    exports2.TypeParameter = TypeParameter;
    exports2.TypeParameterDeclaration = exports2.TypeParameterInstantiation = TypeParameterInstantiation;
    exports2.TypeofTypeAnnotation = TypeofTypeAnnotation;
    exports2.UnionTypeAnnotation = UnionTypeAnnotation;
    exports2.Variance = Variance;
    exports2.VoidTypeAnnotation = VoidTypeAnnotation;
    exports2._interfaceish = _interfaceish;
    exports2._variance = _variance;
    var _t = require("@babel/types");
    var _modules = require_modules();
    var _index = require_node2();
    var _types2 = require_types();
    var {
      isDeclareExportDeclaration,
      isStatement: isStatement2
    } = _t;
    function AnyTypeAnnotation() {
      this.word("any");
    }
    function ArrayTypeAnnotation(node) {
      this.print(node.elementType, true);
      this.tokenChar(91);
      this.tokenChar(93);
    }
    function BooleanTypeAnnotation() {
      this.word("boolean");
    }
    function BooleanLiteralTypeAnnotation(node) {
      this.word(node.value ? "true" : "false");
    }
    function NullLiteralTypeAnnotation() {
      this.word("null");
    }
    function DeclareClass(node, parent) {
      if (!isDeclareExportDeclaration(parent)) {
        this.word("declare");
        this.space();
      }
      this.word("class");
      this.space();
      this._interfaceish(node);
    }
    function DeclareFunction(node, parent) {
      if (!isDeclareExportDeclaration(parent)) {
        this.word("declare");
        this.space();
      }
      this.word("function");
      this.space();
      this.print(node.id);
      this.print(node.id.typeAnnotation.typeAnnotation);
      if (node.predicate) {
        this.space();
        this.print(node.predicate);
      }
      this.semicolon();
    }
    function InferredPredicate() {
      this.tokenChar(37);
      this.word("checks");
    }
    function DeclaredPredicate(node) {
      this.tokenChar(37);
      this.word("checks");
      this.tokenChar(40);
      this.print(node.value);
      this.tokenChar(41);
    }
    function DeclareInterface(node) {
      this.word("declare");
      this.space();
      this.InterfaceDeclaration(node);
    }
    function DeclareModule(node) {
      this.word("declare");
      this.space();
      this.word("module");
      this.space();
      this.print(node.id);
      this.space();
      this.print(node.body);
    }
    function DeclareModuleExports(node) {
      this.word("declare");
      this.space();
      this.word("module");
      this.tokenChar(46);
      this.word("exports");
      this.print(node.typeAnnotation);
    }
    function DeclareTypeAlias(node) {
      this.word("declare");
      this.space();
      this.TypeAlias(node);
    }
    function DeclareOpaqueType(node, parent) {
      if (!isDeclareExportDeclaration(parent)) {
        this.word("declare");
        this.space();
      }
      this.OpaqueType(node);
    }
    function DeclareVariable(node, parent) {
      if (!isDeclareExportDeclaration(parent)) {
        this.word("declare");
        this.space();
      }
      this.word("var");
      this.space();
      this.print(node.id);
      this.print(node.id.typeAnnotation);
      this.semicolon();
    }
    function DeclareExportDeclaration(node) {
      this.word("declare");
      this.space();
      this.word("export");
      this.space();
      if (node.default) {
        this.word("default");
        this.space();
      }
      FlowExportDeclaration.call(this, node);
    }
    function DeclareExportAllDeclaration(node) {
      this.word("declare");
      this.space();
      _modules.ExportAllDeclaration.call(this, node);
    }
    function EnumDeclaration(node) {
      const {
        id,
        body
      } = node;
      this.word("enum");
      this.space();
      this.print(id);
      this.print(body);
    }
    function enumExplicitType(context, name, hasExplicitType) {
      if (hasExplicitType) {
        context.space();
        context.word("of");
        context.space();
        context.word(name);
      }
      context.space();
    }
    function enumBody(context, node) {
      const {
        members
      } = node;
      context.token("{");
      context.indent();
      context.newline();
      for (const member of members) {
        context.print(member);
        context.newline();
      }
      if (node.hasUnknownMembers) {
        context.token("...");
        context.newline();
      }
      context.dedent();
      context.token("}");
    }
    function EnumBooleanBody(node) {
      const {
        explicitType
      } = node;
      enumExplicitType(this, "boolean", explicitType);
      enumBody(this, node);
    }
    function EnumNumberBody(node) {
      const {
        explicitType
      } = node;
      enumExplicitType(this, "number", explicitType);
      enumBody(this, node);
    }
    function EnumStringBody(node) {
      const {
        explicitType
      } = node;
      enumExplicitType(this, "string", explicitType);
      enumBody(this, node);
    }
    function EnumSymbolBody(node) {
      enumExplicitType(this, "symbol", true);
      enumBody(this, node);
    }
    function EnumDefaultedMember(node) {
      const {
        id
      } = node;
      this.print(id);
      this.tokenChar(44);
    }
    function enumInitializedMember(context, node) {
      context.print(node.id);
      context.space();
      context.token("=");
      context.space();
      context.print(node.init);
      context.token(",");
    }
    function EnumBooleanMember(node) {
      enumInitializedMember(this, node);
    }
    function EnumNumberMember(node) {
      enumInitializedMember(this, node);
    }
    function EnumStringMember(node) {
      enumInitializedMember(this, node);
    }
    function FlowExportDeclaration(node) {
      if (node.declaration) {
        const declar = node.declaration;
        this.print(declar);
        if (!isStatement2(declar)) this.semicolon();
      } else {
        this.tokenChar(123);
        if (node.specifiers.length) {
          this.space();
          this.printList(node.specifiers);
          this.space();
        }
        this.tokenChar(125);
        if (node.source) {
          this.space();
          this.word("from");
          this.space();
          this.print(node.source);
        }
        this.semicolon();
      }
    }
    function ExistsTypeAnnotation() {
      this.tokenChar(42);
    }
    function FunctionTypeAnnotation(node, parent) {
      this.print(node.typeParameters);
      this.tokenChar(40);
      if (node.this) {
        this.word("this");
        this.tokenChar(58);
        this.space();
        this.print(node.this.typeAnnotation);
        if (node.params.length || node.rest) {
          this.tokenChar(44);
          this.space();
        }
      }
      this.printList(node.params);
      if (node.rest) {
        if (node.params.length) {
          this.tokenChar(44);
          this.space();
        }
        this.token("...");
        this.print(node.rest);
      }
      this.tokenChar(41);
      const type = parent == null ? void 0 : parent.type;
      if (type != null && (type === "ObjectTypeCallProperty" || type === "ObjectTypeInternalSlot" || type === "DeclareFunction" || type === "ObjectTypeProperty" && parent.method)) {
        this.tokenChar(58);
      } else {
        this.space();
        this.token("=>");
      }
      this.space();
      this.print(node.returnType);
    }
    function FunctionTypeParam(node) {
      this.print(node.name);
      if (node.optional) this.tokenChar(63);
      if (node.name) {
        this.tokenChar(58);
        this.space();
      }
      this.print(node.typeAnnotation);
    }
    function InterfaceExtends(node) {
      this.print(node.id);
      this.print(node.typeParameters, true);
    }
    function _interfaceish(node) {
      var _node$extends;
      this.print(node.id);
      this.print(node.typeParameters);
      if ((_node$extends = node.extends) != null && _node$extends.length) {
        this.space();
        this.word("extends");
        this.space();
        this.printList(node.extends);
      }
      if (node.type === "DeclareClass") {
        var _node$mixins, _node$implements;
        if ((_node$mixins = node.mixins) != null && _node$mixins.length) {
          this.space();
          this.word("mixins");
          this.space();
          this.printList(node.mixins);
        }
        if ((_node$implements = node.implements) != null && _node$implements.length) {
          this.space();
          this.word("implements");
          this.space();
          this.printList(node.implements);
        }
      }
      this.space();
      this.print(node.body);
    }
    function _variance(node) {
      var _node$variance;
      const kind = (_node$variance = node.variance) == null ? void 0 : _node$variance.kind;
      if (kind != null) {
        if (kind === "plus") {
          this.tokenChar(43);
        } else if (kind === "minus") {
          this.tokenChar(45);
        }
      }
    }
    function InterfaceDeclaration(node) {
      this.word("interface");
      this.space();
      this._interfaceish(node);
    }
    function andSeparator(occurrenceCount) {
      this.space();
      this.token("&", false, occurrenceCount);
      this.space();
    }
    function InterfaceTypeAnnotation(node) {
      var _node$extends2;
      this.word("interface");
      if ((_node$extends2 = node.extends) != null && _node$extends2.length) {
        this.space();
        this.word("extends");
        this.space();
        this.printList(node.extends);
      }
      this.space();
      this.print(node.body);
    }
    function IntersectionTypeAnnotation(node) {
      this.printJoin(node.types, void 0, void 0, andSeparator);
    }
    function MixedTypeAnnotation() {
      this.word("mixed");
    }
    function EmptyTypeAnnotation() {
      this.word("empty");
    }
    function NullableTypeAnnotation(node) {
      this.tokenChar(63);
      this.print(node.typeAnnotation);
    }
    function NumberTypeAnnotation() {
      this.word("number");
    }
    function StringTypeAnnotation() {
      this.word("string");
    }
    function ThisTypeAnnotation() {
      this.word("this");
    }
    function TupleTypeAnnotation(node) {
      this.tokenChar(91);
      this.printList(node.types);
      this.tokenChar(93);
    }
    function TypeofTypeAnnotation(node) {
      this.word("typeof");
      this.space();
      this.print(node.argument);
    }
    function TypeAlias(node) {
      this.word("type");
      this.space();
      this.print(node.id);
      this.print(node.typeParameters);
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node.right);
      this.semicolon();
    }
    function TypeAnnotation(node, parent) {
      this.tokenChar(58);
      this.space();
      if (parent.type === "ArrowFunctionExpression") {
        this.tokenContext |= _index.TokenContext.arrowFlowReturnType;
      } else if (node.optional) {
        this.tokenChar(63);
      }
      this.print(node.typeAnnotation);
    }
    function TypeParameterInstantiation(node) {
      this.tokenChar(60);
      this.printList(node.params);
      this.tokenChar(62);
    }
    function TypeParameter(node) {
      this._variance(node);
      this.word(node.name);
      if (node.bound) {
        this.print(node.bound);
      }
      if (node.default) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node.default);
      }
    }
    function OpaqueType(node) {
      this.word("opaque");
      this.space();
      this.word("type");
      this.space();
      this.print(node.id);
      this.print(node.typeParameters);
      if (node.supertype) {
        this.tokenChar(58);
        this.space();
        this.print(node.supertype);
      }
      if (node.impltype) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node.impltype);
      }
      this.semicolon();
    }
    function ObjectTypeAnnotation(node) {
      if (node.exact) {
        this.token("{|");
      } else {
        this.tokenChar(123);
      }
      const props = [...node.properties, ...node.callProperties || [], ...node.indexers || [], ...node.internalSlots || []];
      if (props.length) {
        this.newline();
        this.space();
        this.printJoin(props, true, true, void 0, void 0, function addNewlines(leading) {
          if (leading && !props[0]) return 1;
        }, () => {
          if (props.length !== 1 || node.inexact) {
            this.tokenChar(44);
            this.space();
          }
        });
        this.space();
      }
      if (node.inexact) {
        this.indent();
        this.token("...");
        if (props.length) {
          this.newline();
        }
        this.dedent();
      }
      if (node.exact) {
        this.token("|}");
      } else {
        this.tokenChar(125);
      }
    }
    function ObjectTypeInternalSlot(node) {
      if (node.static) {
        this.word("static");
        this.space();
      }
      this.tokenChar(91);
      this.tokenChar(91);
      this.print(node.id);
      this.tokenChar(93);
      this.tokenChar(93);
      if (node.optional) this.tokenChar(63);
      if (!node.method) {
        this.tokenChar(58);
        this.space();
      }
      this.print(node.value);
    }
    function ObjectTypeCallProperty(node) {
      if (node.static) {
        this.word("static");
        this.space();
      }
      this.print(node.value);
    }
    function ObjectTypeIndexer(node) {
      if (node.static) {
        this.word("static");
        this.space();
      }
      this._variance(node);
      this.tokenChar(91);
      if (node.id) {
        this.print(node.id);
        this.tokenChar(58);
        this.space();
      }
      this.print(node.key);
      this.tokenChar(93);
      this.tokenChar(58);
      this.space();
      this.print(node.value);
    }
    function ObjectTypeProperty(node) {
      if (node.proto) {
        this.word("proto");
        this.space();
      }
      if (node.static) {
        this.word("static");
        this.space();
      }
      if (node.kind === "get" || node.kind === "set") {
        this.word(node.kind);
        this.space();
      }
      this._variance(node);
      this.print(node.key);
      if (node.optional) this.tokenChar(63);
      if (!node.method) {
        this.tokenChar(58);
        this.space();
      }
      this.print(node.value);
    }
    function ObjectTypeSpreadProperty(node) {
      this.token("...");
      this.print(node.argument);
    }
    function QualifiedTypeIdentifier(node) {
      this.print(node.qualification);
      this.tokenChar(46);
      this.print(node.id);
    }
    function SymbolTypeAnnotation() {
      this.word("symbol");
    }
    function orSeparator(occurrenceCount) {
      this.space();
      this.token("|", false, occurrenceCount);
      this.space();
    }
    function UnionTypeAnnotation(node) {
      this.printJoin(node.types, void 0, void 0, orSeparator);
    }
    function TypeCastExpression(node) {
      this.tokenChar(40);
      this.print(node.expression);
      this.print(node.typeAnnotation);
      this.tokenChar(41);
    }
    function Variance(node) {
      if (node.kind === "plus") {
        this.tokenChar(43);
      } else {
        this.tokenChar(45);
      }
    }
    function VoidTypeAnnotation() {
      this.word("void");
    }
    function IndexedAccessType(node) {
      this.print(node.objectType, true);
      this.tokenChar(91);
      this.print(node.indexType);
      this.tokenChar(93);
    }
    function OptionalIndexedAccessType(node) {
      this.print(node.objectType);
      if (node.optional) {
        this.token("?.");
      }
      this.tokenChar(91);
      this.print(node.indexType);
      this.tokenChar(93);
    }
  }
});

// node_modules/@babel/helpers/node_modules/@babel/generator/lib/generators/base.js
var require_base = __commonJS({
  "node_modules/@babel/helpers/node_modules/@babel/generator/lib/generators/base.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.BlockStatement = BlockStatement;
    exports2.Directive = Directive;
    exports2.DirectiveLiteral = DirectiveLiteral;
    exports2.File = File;
    exports2.InterpreterDirective = InterpreterDirective;
    exports2.Placeholder = Placeholder;
    exports2.Program = Program;
    function File(node) {
      if (node.program) {
        this.print(node.program.interpreter);
      }
      this.print(node.program);
    }
    function Program(node) {
      var _node$directives;
      this.noIndentInnerCommentsHere();
      this.printInnerComments();
      const directivesLen = (_node$directives = node.directives) == null ? void 0 : _node$directives.length;
      if (directivesLen) {
        var _node$directives$trai;
        const newline = node.body.length ? 2 : 1;
        this.printSequence(node.directives, void 0, newline);
        if (!((_node$directives$trai = node.directives[directivesLen - 1].trailingComments) != null && _node$directives$trai.length)) {
          this.newline(newline);
        }
      }
      this.printSequence(node.body);
    }
    function BlockStatement(node) {
      var _node$directives2;
      this.tokenChar(123);
      const exit = this.enterDelimited();
      const directivesLen = (_node$directives2 = node.directives) == null ? void 0 : _node$directives2.length;
      if (directivesLen) {
        var _node$directives$trai2;
        const newline = node.body.length ? 2 : 1;
        this.printSequence(node.directives, true, newline);
        if (!((_node$directives$trai2 = node.directives[directivesLen - 1].trailingComments) != null && _node$directives$trai2.length)) {
          this.newline(newline);
        }
      }
      this.printSequence(node.body, true);
      exit();
      this.rightBrace(node);
    }
    function Directive(node) {
      this.print(node.value);
      this.semicolon();
    }
    var unescapedSingleQuoteRE = /(?:^|[^\\])(?:\\\\)*'/;
    var unescapedDoubleQuoteRE = /(?:^|[^\\])(?:\\\\)*"/;
    function DirectiveLiteral(node) {
      const raw = this.getPossibleRaw(node);
      if (!this.format.minified && raw !== void 0) {
        this.token(raw);
        return;
      }
      const {
        value
      } = node;
      if (!unescapedDoubleQuoteRE.test(value)) {
        this.token(`"${value}"`);
      } else if (!unescapedSingleQuoteRE.test(value)) {
        this.token(`'${value}'`);
      } else {
        throw new Error("Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.");
      }
    }
    function InterpreterDirective(node) {
      this.token(`#!${node.value}`);
      this.newline(1, true);
    }
    function Placeholder(node) {
      this.token("%%");
      this.print(node.name);
      this.token("%%");
      if (node.expectedNode === "Statement") {
        this.semicolon();
      }
    }
  }
});

// node_modules/@babel/helpers/node_modules/@babel/generator/lib/generators/jsx.js
var require_jsx = __commonJS({
  "node_modules/@babel/helpers/node_modules/@babel/generator/lib/generators/jsx.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.JSXAttribute = JSXAttribute;
    exports2.JSXClosingElement = JSXClosingElement;
    exports2.JSXClosingFragment = JSXClosingFragment;
    exports2.JSXElement = JSXElement;
    exports2.JSXEmptyExpression = JSXEmptyExpression;
    exports2.JSXExpressionContainer = JSXExpressionContainer;
    exports2.JSXFragment = JSXFragment;
    exports2.JSXIdentifier = JSXIdentifier;
    exports2.JSXMemberExpression = JSXMemberExpression;
    exports2.JSXNamespacedName = JSXNamespacedName;
    exports2.JSXOpeningElement = JSXOpeningElement;
    exports2.JSXOpeningFragment = JSXOpeningFragment;
    exports2.JSXSpreadAttribute = JSXSpreadAttribute;
    exports2.JSXSpreadChild = JSXSpreadChild;
    exports2.JSXText = JSXText;
    function JSXAttribute(node) {
      this.print(node.name);
      if (node.value) {
        this.tokenChar(61);
        this.print(node.value);
      }
    }
    function JSXIdentifier(node) {
      this.word(node.name);
    }
    function JSXNamespacedName(node) {
      this.print(node.namespace);
      this.tokenChar(58);
      this.print(node.name);
    }
    function JSXMemberExpression(node) {
      this.print(node.object);
      this.tokenChar(46);
      this.print(node.property);
    }
    function JSXSpreadAttribute(node) {
      this.tokenChar(123);
      this.token("...");
      this.print(node.argument);
      this.rightBrace(node);
    }
    function JSXExpressionContainer(node) {
      this.tokenChar(123);
      this.print(node.expression);
      this.rightBrace(node);
    }
    function JSXSpreadChild(node) {
      this.tokenChar(123);
      this.token("...");
      this.print(node.expression);
      this.rightBrace(node);
    }
    function JSXText(node) {
      const raw = this.getPossibleRaw(node);
      if (raw !== void 0) {
        this.token(raw, true);
      } else {
        this.token(node.value, true);
      }
    }
    function JSXElement(node) {
      const open = node.openingElement;
      this.print(open);
      if (open.selfClosing) return;
      this.indent();
      for (const child of node.children) {
        this.print(child);
      }
      this.dedent();
      this.print(node.closingElement);
    }
    function spaceSeparator() {
      this.space();
    }
    function JSXOpeningElement(node) {
      this.tokenChar(60);
      this.print(node.name);
      {
        if (node.typeArguments) {
          this.print(node.typeArguments);
        }
        this.print(node.typeParameters);
      }
      if (node.attributes.length > 0) {
        this.space();
        this.printJoin(node.attributes, void 0, void 0, spaceSeparator);
      }
      if (node.selfClosing) {
        this.space();
        this.tokenChar(47);
      }
      this.tokenChar(62);
    }
    function JSXClosingElement(node) {
      this.tokenChar(60);
      this.tokenChar(47);
      this.print(node.name);
      this.tokenChar(62);
    }
    function JSXEmptyExpression() {
      this.printInnerComments();
    }
    function JSXFragment(node) {
      this.print(node.openingFragment);
      this.indent();
      for (const child of node.children) {
        this.print(child);
      }
      this.dedent();
      this.print(node.closingFragment);
    }
    function JSXOpeningFragment() {
      this.tokenChar(60);
      this.tokenChar(62);
    }
    function JSXClosingFragment() {
      this.token("</");
      this.tokenChar(62);
    }
  }
});

// node_modules/@babel/helpers/node_modules/@babel/generator/lib/generators/typescript.js
var require_typescript = __commonJS({
  "node_modules/@babel/helpers/node_modules/@babel/generator/lib/generators/typescript.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.TSAnyKeyword = TSAnyKeyword;
    exports2.TSArrayType = TSArrayType;
    exports2.TSSatisfiesExpression = exports2.TSAsExpression = TSTypeExpression;
    exports2.TSBigIntKeyword = TSBigIntKeyword;
    exports2.TSBooleanKeyword = TSBooleanKeyword;
    exports2.TSCallSignatureDeclaration = TSCallSignatureDeclaration;
    exports2.TSInterfaceHeritage = exports2.TSClassImplements = TSClassImplements;
    exports2.TSConditionalType = TSConditionalType;
    exports2.TSConstructSignatureDeclaration = TSConstructSignatureDeclaration;
    exports2.TSConstructorType = TSConstructorType;
    exports2.TSDeclareFunction = TSDeclareFunction;
    exports2.TSDeclareMethod = TSDeclareMethod;
    exports2.TSEnumBody = TSEnumBody;
    exports2.TSEnumDeclaration = TSEnumDeclaration;
    exports2.TSEnumMember = TSEnumMember;
    exports2.TSExportAssignment = TSExportAssignment;
    exports2.TSExternalModuleReference = TSExternalModuleReference;
    exports2.TSFunctionType = TSFunctionType;
    exports2.TSImportEqualsDeclaration = TSImportEqualsDeclaration;
    exports2.TSImportType = TSImportType;
    exports2.TSIndexSignature = TSIndexSignature;
    exports2.TSIndexedAccessType = TSIndexedAccessType;
    exports2.TSInferType = TSInferType;
    exports2.TSInstantiationExpression = TSInstantiationExpression;
    exports2.TSInterfaceBody = TSInterfaceBody;
    exports2.TSInterfaceDeclaration = TSInterfaceDeclaration;
    exports2.TSIntersectionType = TSIntersectionType;
    exports2.TSIntrinsicKeyword = TSIntrinsicKeyword;
    exports2.TSLiteralType = TSLiteralType;
    exports2.TSMappedType = TSMappedType;
    exports2.TSMethodSignature = TSMethodSignature;
    exports2.TSModuleBlock = TSModuleBlock;
    exports2.TSModuleDeclaration = TSModuleDeclaration;
    exports2.TSNamedTupleMember = TSNamedTupleMember;
    exports2.TSNamespaceExportDeclaration = TSNamespaceExportDeclaration;
    exports2.TSNeverKeyword = TSNeverKeyword;
    exports2.TSNonNullExpression = TSNonNullExpression;
    exports2.TSNullKeyword = TSNullKeyword;
    exports2.TSNumberKeyword = TSNumberKeyword;
    exports2.TSObjectKeyword = TSObjectKeyword;
    exports2.TSOptionalType = TSOptionalType;
    exports2.TSParameterProperty = TSParameterProperty;
    exports2.TSParenthesizedType = TSParenthesizedType;
    exports2.TSPropertySignature = TSPropertySignature;
    exports2.TSQualifiedName = TSQualifiedName;
    exports2.TSRestType = TSRestType;
    exports2.TSStringKeyword = TSStringKeyword;
    exports2.TSSymbolKeyword = TSSymbolKeyword;
    exports2.TSTemplateLiteralType = TSTemplateLiteralType;
    exports2.TSThisType = TSThisType;
    exports2.TSTupleType = TSTupleType;
    exports2.TSTypeAliasDeclaration = TSTypeAliasDeclaration;
    exports2.TSTypeAnnotation = TSTypeAnnotation;
    exports2.TSTypeAssertion = TSTypeAssertion;
    exports2.TSTypeLiteral = TSTypeLiteral;
    exports2.TSTypeOperator = TSTypeOperator;
    exports2.TSTypeParameter = TSTypeParameter;
    exports2.TSTypeParameterDeclaration = exports2.TSTypeParameterInstantiation = TSTypeParameterInstantiation;
    exports2.TSTypePredicate = TSTypePredicate;
    exports2.TSTypeQuery = TSTypeQuery;
    exports2.TSTypeReference = TSTypeReference;
    exports2.TSUndefinedKeyword = TSUndefinedKeyword;
    exports2.TSUnionType = TSUnionType;
    exports2.TSUnknownKeyword = TSUnknownKeyword;
    exports2.TSVoidKeyword = TSVoidKeyword;
    exports2.tsPrintClassMemberModifiers = tsPrintClassMemberModifiers;
    exports2.tsPrintFunctionOrConstructorType = tsPrintFunctionOrConstructorType;
    exports2.tsPrintPropertyOrMethodName = tsPrintPropertyOrMethodName;
    exports2.tsPrintSignatureDeclarationBase = tsPrintSignatureDeclarationBase;
    function TSTypeAnnotation(node, parent) {
      this.token((parent.type === "TSFunctionType" || parent.type === "TSConstructorType") && parent.typeAnnotation === node ? "=>" : ":");
      this.space();
      if (node.optional) this.tokenChar(63);
      this.print(node.typeAnnotation);
    }
    function TSTypeParameterInstantiation(node, parent) {
      this.tokenChar(60);
      let printTrailingSeparator = parent.type === "ArrowFunctionExpression" && node.params.length === 1;
      if (this.tokenMap && node.start != null && node.end != null) {
        printTrailingSeparator && (printTrailingSeparator = !!this.tokenMap.find(node, (t6) => this.tokenMap.matchesOriginal(t6, ",")));
        printTrailingSeparator || (printTrailingSeparator = this.shouldPrintTrailingComma(">"));
      }
      this.printList(node.params, printTrailingSeparator);
      this.tokenChar(62);
    }
    function TSTypeParameter(node) {
      if (node.in) {
        this.word("in");
        this.space();
      }
      if (node.out) {
        this.word("out");
        this.space();
      }
      this.word(node.name);
      if (node.constraint) {
        this.space();
        this.word("extends");
        this.space();
        this.print(node.constraint);
      }
      if (node.default) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node.default);
      }
    }
    function TSParameterProperty(node) {
      if (node.accessibility) {
        this.word(node.accessibility);
        this.space();
      }
      if (node.readonly) {
        this.word("readonly");
        this.space();
      }
      this._param(node.parameter);
    }
    function TSDeclareFunction(node, parent) {
      if (node.declare) {
        this.word("declare");
        this.space();
      }
      this._functionHead(node, parent);
      this.semicolon();
    }
    function TSDeclareMethod(node) {
      this._classMethodHead(node);
      this.semicolon();
    }
    function TSQualifiedName(node) {
      this.print(node.left);
      this.tokenChar(46);
      this.print(node.right);
    }
    function TSCallSignatureDeclaration(node) {
      this.tsPrintSignatureDeclarationBase(node);
      maybePrintTrailingCommaOrSemicolon(this, node);
    }
    function maybePrintTrailingCommaOrSemicolon(printer, node) {
      if (!printer.tokenMap || !node.start || !node.end) {
        printer.semicolon();
        return;
      }
      if (printer.tokenMap.endMatches(node, ",")) {
        printer.token(",");
      } else if (printer.tokenMap.endMatches(node, ";")) {
        printer.semicolon();
      }
    }
    function TSConstructSignatureDeclaration(node) {
      this.word("new");
      this.space();
      this.tsPrintSignatureDeclarationBase(node);
      maybePrintTrailingCommaOrSemicolon(this, node);
    }
    function TSPropertySignature(node) {
      const {
        readonly
      } = node;
      if (readonly) {
        this.word("readonly");
        this.space();
      }
      this.tsPrintPropertyOrMethodName(node);
      this.print(node.typeAnnotation);
      maybePrintTrailingCommaOrSemicolon(this, node);
    }
    function tsPrintPropertyOrMethodName(node) {
      if (node.computed) {
        this.tokenChar(91);
      }
      this.print(node.key);
      if (node.computed) {
        this.tokenChar(93);
      }
      if (node.optional) {
        this.tokenChar(63);
      }
    }
    function TSMethodSignature(node) {
      const {
        kind
      } = node;
      if (kind === "set" || kind === "get") {
        this.word(kind);
        this.space();
      }
      this.tsPrintPropertyOrMethodName(node);
      this.tsPrintSignatureDeclarationBase(node);
      maybePrintTrailingCommaOrSemicolon(this, node);
    }
    function TSIndexSignature(node) {
      const {
        readonly,
        static: isStatic
      } = node;
      if (isStatic) {
        this.word("static");
        this.space();
      }
      if (readonly) {
        this.word("readonly");
        this.space();
      }
      this.tokenChar(91);
      this._parameters(node.parameters, "]");
      this.print(node.typeAnnotation);
      maybePrintTrailingCommaOrSemicolon(this, node);
    }
    function TSAnyKeyword() {
      this.word("any");
    }
    function TSBigIntKeyword() {
      this.word("bigint");
    }
    function TSUnknownKeyword() {
      this.word("unknown");
    }
    function TSNumberKeyword() {
      this.word("number");
    }
    function TSObjectKeyword() {
      this.word("object");
    }
    function TSBooleanKeyword() {
      this.word("boolean");
    }
    function TSStringKeyword() {
      this.word("string");
    }
    function TSSymbolKeyword() {
      this.word("symbol");
    }
    function TSVoidKeyword() {
      this.word("void");
    }
    function TSUndefinedKeyword() {
      this.word("undefined");
    }
    function TSNullKeyword() {
      this.word("null");
    }
    function TSNeverKeyword() {
      this.word("never");
    }
    function TSIntrinsicKeyword() {
      this.word("intrinsic");
    }
    function TSThisType() {
      this.word("this");
    }
    function TSFunctionType(node) {
      this.tsPrintFunctionOrConstructorType(node);
    }
    function TSConstructorType(node) {
      if (node.abstract) {
        this.word("abstract");
        this.space();
      }
      this.word("new");
      this.space();
      this.tsPrintFunctionOrConstructorType(node);
    }
    function tsPrintFunctionOrConstructorType(node) {
      const {
        typeParameters
      } = node;
      const parameters = node.parameters;
      this.print(typeParameters);
      this.tokenChar(40);
      this._parameters(parameters, ")");
      this.space();
      const returnType = node.typeAnnotation;
      this.print(returnType);
    }
    function TSTypeReference(node) {
      const typeArguments = node.typeParameters;
      this.print(node.typeName, !!typeArguments);
      this.print(typeArguments);
    }
    function TSTypePredicate(node) {
      if (node.asserts) {
        this.word("asserts");
        this.space();
      }
      this.print(node.parameterName);
      if (node.typeAnnotation) {
        this.space();
        this.word("is");
        this.space();
        this.print(node.typeAnnotation.typeAnnotation);
      }
    }
    function TSTypeQuery(node) {
      this.word("typeof");
      this.space();
      this.print(node.exprName);
      const typeArguments = node.typeParameters;
      if (typeArguments) {
        this.print(typeArguments);
      }
    }
    function TSTypeLiteral(node) {
      printBraced(this, node, () => this.printJoin(node.members, true, true));
    }
    function TSArrayType(node) {
      this.print(node.elementType, true);
      this.tokenChar(91);
      this.tokenChar(93);
    }
    function TSTupleType(node) {
      this.tokenChar(91);
      this.printList(node.elementTypes, this.shouldPrintTrailingComma("]"));
      this.tokenChar(93);
    }
    function TSOptionalType(node) {
      this.print(node.typeAnnotation);
      this.tokenChar(63);
    }
    function TSRestType(node) {
      this.token("...");
      this.print(node.typeAnnotation);
    }
    function TSNamedTupleMember(node) {
      this.print(node.label);
      if (node.optional) this.tokenChar(63);
      this.tokenChar(58);
      this.space();
      this.print(node.elementType);
    }
    function TSUnionType(node) {
      tsPrintUnionOrIntersectionType(this, node, "|");
    }
    function TSIntersectionType(node) {
      tsPrintUnionOrIntersectionType(this, node, "&");
    }
    function tsPrintUnionOrIntersectionType(printer, node, sep) {
      var _printer$tokenMap;
      let hasLeadingToken = 0;
      if ((_printer$tokenMap = printer.tokenMap) != null && _printer$tokenMap.startMatches(node, sep)) {
        hasLeadingToken = 1;
        printer.token(sep);
      }
      printer.printJoin(node.types, void 0, void 0, function(i) {
        this.space();
        this.token(sep, null, i + hasLeadingToken);
        this.space();
      });
    }
    function TSConditionalType(node) {
      this.print(node.checkType);
      this.space();
      this.word("extends");
      this.space();
      this.print(node.extendsType);
      this.space();
      this.tokenChar(63);
      this.space();
      this.print(node.trueType);
      this.space();
      this.tokenChar(58);
      this.space();
      this.print(node.falseType);
    }
    function TSInferType(node) {
      this.word("infer");
      this.print(node.typeParameter);
    }
    function TSParenthesizedType(node) {
      this.tokenChar(40);
      this.print(node.typeAnnotation);
      this.tokenChar(41);
    }
    function TSTypeOperator(node) {
      this.word(node.operator);
      this.space();
      this.print(node.typeAnnotation);
    }
    function TSIndexedAccessType(node) {
      this.print(node.objectType, true);
      this.tokenChar(91);
      this.print(node.indexType);
      this.tokenChar(93);
    }
    function TSMappedType(node) {
      const {
        nameType,
        optional,
        readonly,
        typeAnnotation: typeAnnotation2
      } = node;
      this.tokenChar(123);
      const exit = this.enterDelimited();
      this.space();
      if (readonly) {
        tokenIfPlusMinus(this, readonly);
        this.word("readonly");
        this.space();
      }
      this.tokenChar(91);
      {
        this.word(node.typeParameter.name);
      }
      this.space();
      this.word("in");
      this.space();
      {
        this.print(node.typeParameter.constraint);
      }
      if (nameType) {
        this.space();
        this.word("as");
        this.space();
        this.print(nameType);
      }
      this.tokenChar(93);
      if (optional) {
        tokenIfPlusMinus(this, optional);
        this.tokenChar(63);
      }
      if (typeAnnotation2) {
        this.tokenChar(58);
        this.space();
        this.print(typeAnnotation2);
      }
      this.space();
      exit();
      this.tokenChar(125);
    }
    function tokenIfPlusMinus(self2, tok) {
      if (tok !== true) {
        self2.token(tok);
      }
    }
    function TSTemplateLiteralType(node) {
      this._printTemplate(node, node.types);
    }
    function TSLiteralType(node) {
      this.print(node.literal);
    }
    function TSClassImplements(node) {
      this.print(node.expression);
      this.print(node.typeArguments);
    }
    function TSInterfaceDeclaration(node) {
      const {
        declare,
        id,
        typeParameters,
        extends: extendz,
        body
      } = node;
      if (declare) {
        this.word("declare");
        this.space();
      }
      this.word("interface");
      this.space();
      this.print(id);
      this.print(typeParameters);
      if (extendz != null && extendz.length) {
        this.space();
        this.word("extends");
        this.space();
        this.printList(extendz);
      }
      this.space();
      this.print(body);
    }
    function TSInterfaceBody(node) {
      printBraced(this, node, () => this.printJoin(node.body, true, true));
    }
    function TSTypeAliasDeclaration(node) {
      const {
        declare,
        id,
        typeParameters,
        typeAnnotation: typeAnnotation2
      } = node;
      if (declare) {
        this.word("declare");
        this.space();
      }
      this.word("type");
      this.space();
      this.print(id);
      this.print(typeParameters);
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(typeAnnotation2);
      this.semicolon();
    }
    function TSTypeExpression(node) {
      const {
        type,
        expression,
        typeAnnotation: typeAnnotation2
      } = node;
      this.print(expression, true);
      this.space();
      this.word(type === "TSAsExpression" ? "as" : "satisfies");
      this.space();
      this.print(typeAnnotation2);
    }
    function TSTypeAssertion(node) {
      const {
        typeAnnotation: typeAnnotation2,
        expression
      } = node;
      this.tokenChar(60);
      this.print(typeAnnotation2);
      this.tokenChar(62);
      this.space();
      this.print(expression);
    }
    function TSInstantiationExpression(node) {
      this.print(node.expression);
      {
        this.print(node.typeParameters);
      }
    }
    function TSEnumDeclaration(node) {
      const {
        declare,
        const: isConst,
        id
      } = node;
      if (declare) {
        this.word("declare");
        this.space();
      }
      if (isConst) {
        this.word("const");
        this.space();
      }
      this.word("enum");
      this.space();
      this.print(id);
      this.space();
      {
        TSEnumBody.call(this, node);
      }
    }
    function TSEnumBody(node) {
      printBraced(this, node, () => {
        var _this$shouldPrintTrai;
        return this.printList(node.members, (_this$shouldPrintTrai = this.shouldPrintTrailingComma("}")) != null ? _this$shouldPrintTrai : true, true, true);
      });
    }
    function TSEnumMember(node) {
      const {
        id,
        initializer
      } = node;
      this.print(id);
      if (initializer) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(initializer);
      }
    }
    function TSModuleDeclaration(node) {
      const {
        declare,
        id,
        kind
      } = node;
      if (declare) {
        this.word("declare");
        this.space();
      }
      {
        if (!node.global) {
          this.word(kind != null ? kind : id.type === "Identifier" ? "namespace" : "module");
          this.space();
        }
        this.print(id);
        if (!node.body) {
          this.semicolon();
          return;
        }
        let body = node.body;
        while (body.type === "TSModuleDeclaration") {
          this.tokenChar(46);
          this.print(body.id);
          body = body.body;
        }
        this.space();
        this.print(body);
      }
    }
    function TSModuleBlock(node) {
      printBraced(this, node, () => this.printSequence(node.body, true));
    }
    function TSImportType(node) {
      const {
        argument,
        qualifier,
        options
      } = node;
      this.word("import");
      this.tokenChar(40);
      this.print(argument);
      if (options) {
        this.tokenChar(44);
        this.print(options);
      }
      this.tokenChar(41);
      if (qualifier) {
        this.tokenChar(46);
        this.print(qualifier);
      }
      const typeArguments = node.typeParameters;
      if (typeArguments) {
        this.print(typeArguments);
      }
    }
    function TSImportEqualsDeclaration(node) {
      const {
        id,
        moduleReference
      } = node;
      if (node.isExport) {
        this.word("export");
        this.space();
      }
      this.word("import");
      this.space();
      this.print(id);
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(moduleReference);
      this.semicolon();
    }
    function TSExternalModuleReference(node) {
      this.token("require(");
      this.print(node.expression);
      this.tokenChar(41);
    }
    function TSNonNullExpression(node) {
      this.print(node.expression);
      this.tokenChar(33);
    }
    function TSExportAssignment(node) {
      this.word("export");
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node.expression);
      this.semicolon();
    }
    function TSNamespaceExportDeclaration(node) {
      this.word("export");
      this.space();
      this.word("as");
      this.space();
      this.word("namespace");
      this.space();
      this.print(node.id);
      this.semicolon();
    }
    function tsPrintSignatureDeclarationBase(node) {
      const {
        typeParameters
      } = node;
      const parameters = node.parameters;
      this.print(typeParameters);
      this.tokenChar(40);
      this._parameters(parameters, ")");
      const returnType = node.typeAnnotation;
      this.print(returnType);
    }
    function tsPrintClassMemberModifiers(node) {
      const isPrivateField = node.type === "ClassPrivateProperty";
      const isPublicField = node.type === "ClassAccessorProperty" || node.type === "ClassProperty";
      printModifiersList(this, node, [isPublicField && node.declare && "declare", !isPrivateField && node.accessibility]);
      if (node.static) {
        this.word("static");
        this.space();
      }
      printModifiersList(this, node, [!isPrivateField && node.abstract && "abstract", !isPrivateField && node.override && "override", (isPublicField || isPrivateField) && node.readonly && "readonly"]);
    }
    function printBraced(printer, node, cb) {
      printer.token("{");
      const exit = printer.enterDelimited();
      cb();
      exit();
      printer.rightBrace(node);
    }
    function printModifiersList(printer, node, modifiers) {
      var _printer$tokenMap2;
      const modifiersSet = /* @__PURE__ */ new Set();
      for (const modifier of modifiers) {
        if (modifier) modifiersSet.add(modifier);
      }
      (_printer$tokenMap2 = printer.tokenMap) == null || _printer$tokenMap2.find(node, (tok) => {
        if (modifiersSet.has(tok.value)) {
          printer.token(tok.value);
          printer.space();
          modifiersSet.delete(tok.value);
          return modifiersSet.size === 0;
        }
      });
      for (const modifier of modifiersSet) {
        printer.word(modifier);
        printer.space();
      }
    }
  }
});

// node_modules/@babel/helpers/node_modules/@babel/generator/lib/generators/index.js
var require_generators = __commonJS({
  "node_modules/@babel/helpers/node_modules/@babel/generator/lib/generators/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _templateLiterals = require_template_literals();
    Object.keys(_templateLiterals).forEach(function(key2) {
      if (key2 === "default" || key2 === "__esModule") return;
      if (key2 in exports2 && exports2[key2] === _templateLiterals[key2]) return;
      Object.defineProperty(exports2, key2, {
        enumerable: true,
        get: function() {
          return _templateLiterals[key2];
        }
      });
    });
    var _expressions = require_expressions();
    Object.keys(_expressions).forEach(function(key2) {
      if (key2 === "default" || key2 === "__esModule") return;
      if (key2 in exports2 && exports2[key2] === _expressions[key2]) return;
      Object.defineProperty(exports2, key2, {
        enumerable: true,
        get: function() {
          return _expressions[key2];
        }
      });
    });
    var _statements = require_statements();
    Object.keys(_statements).forEach(function(key2) {
      if (key2 === "default" || key2 === "__esModule") return;
      if (key2 in exports2 && exports2[key2] === _statements[key2]) return;
      Object.defineProperty(exports2, key2, {
        enumerable: true,
        get: function() {
          return _statements[key2];
        }
      });
    });
    var _classes = require_classes();
    Object.keys(_classes).forEach(function(key2) {
      if (key2 === "default" || key2 === "__esModule") return;
      if (key2 in exports2 && exports2[key2] === _classes[key2]) return;
      Object.defineProperty(exports2, key2, {
        enumerable: true,
        get: function() {
          return _classes[key2];
        }
      });
    });
    var _methods = require_methods();
    Object.keys(_methods).forEach(function(key2) {
      if (key2 === "default" || key2 === "__esModule") return;
      if (key2 in exports2 && exports2[key2] === _methods[key2]) return;
      Object.defineProperty(exports2, key2, {
        enumerable: true,
        get: function() {
          return _methods[key2];
        }
      });
    });
    var _modules = require_modules();
    Object.keys(_modules).forEach(function(key2) {
      if (key2 === "default" || key2 === "__esModule") return;
      if (key2 in exports2 && exports2[key2] === _modules[key2]) return;
      Object.defineProperty(exports2, key2, {
        enumerable: true,
        get: function() {
          return _modules[key2];
        }
      });
    });
    var _types2 = require_types();
    Object.keys(_types2).forEach(function(key2) {
      if (key2 === "default" || key2 === "__esModule") return;
      if (key2 in exports2 && exports2[key2] === _types2[key2]) return;
      Object.defineProperty(exports2, key2, {
        enumerable: true,
        get: function() {
          return _types2[key2];
        }
      });
    });
    var _flow = require_flow();
    Object.keys(_flow).forEach(function(key2) {
      if (key2 === "default" || key2 === "__esModule") return;
      if (key2 in exports2 && exports2[key2] === _flow[key2]) return;
      Object.defineProperty(exports2, key2, {
        enumerable: true,
        get: function() {
          return _flow[key2];
        }
      });
    });
    var _base = require_base();
    Object.keys(_base).forEach(function(key2) {
      if (key2 === "default" || key2 === "__esModule") return;
      if (key2 in exports2 && exports2[key2] === _base[key2]) return;
      Object.defineProperty(exports2, key2, {
        enumerable: true,
        get: function() {
          return _base[key2];
        }
      });
    });
    var _jsx = require_jsx();
    Object.keys(_jsx).forEach(function(key2) {
      if (key2 === "default" || key2 === "__esModule") return;
      if (key2 in exports2 && exports2[key2] === _jsx[key2]) return;
      Object.defineProperty(exports2, key2, {
        enumerable: true,
        get: function() {
          return _jsx[key2];
        }
      });
    });
    var _typescript = require_typescript();
    Object.keys(_typescript).forEach(function(key2) {
      if (key2 === "default" || key2 === "__esModule") return;
      if (key2 in exports2 && exports2[key2] === _typescript[key2]) return;
      Object.defineProperty(exports2, key2, {
        enumerable: true,
        get: function() {
          return _typescript[key2];
        }
      });
    });
  }
});

// node_modules/@babel/helpers/node_modules/@babel/generator/lib/generators/deprecated.js
var require_deprecated = __commonJS({
  "node_modules/@babel/helpers/node_modules/@babel/generator/lib/generators/deprecated.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.addDeprecatedGenerators = addDeprecatedGenerators;
    function addDeprecatedGenerators(PrinterClass) {
      {
        const deprecatedBabel7Generators = {
          Noop() {
          },
          TSExpressionWithTypeArguments(node) {
            this.print(node.expression);
            this.print(node.typeParameters);
          },
          DecimalLiteral(node) {
            const raw = this.getPossibleRaw(node);
            if (!this.format.minified && raw !== void 0) {
              this.word(raw);
              return;
            }
            this.word(node.value + "m");
          }
        };
        Object.assign(PrinterClass.prototype, deprecatedBabel7Generators);
      }
    }
  }
});

// node_modules/@babel/helpers/node_modules/@babel/generator/lib/printer.js
var require_printer = __commonJS({
  "node_modules/@babel/helpers/node_modules/@babel/generator/lib/printer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _buffer = require_buffer();
    var n = require_node2();
    var _t = require("@babel/types");
    var _tokenMap = require_token_map();
    var generatorFunctions = require_generators();
    var _deprecated = require_deprecated();
    var {
      isExpression: isExpression2,
      isFunction,
      isStatement: isStatement2,
      isClassBody,
      isTSInterfaceBody,
      isTSEnumMember
    } = _t;
    var SCIENTIFIC_NOTATION = /e/i;
    var ZERO_DECIMAL_INTEGER = /\.0+$/;
    var HAS_NEWLINE = /[\n\r\u2028\u2029]/;
    var HAS_NEWLINE_OR_BlOCK_COMMENT_END = /[\n\r\u2028\u2029]|\*\//;
    function commentIsNewline(c2) {
      return c2.type === "CommentLine" || HAS_NEWLINE.test(c2.value);
    }
    var {
      needsParens
    } = n;
    var Printer = class {
      constructor(format, map, tokens, originalCode) {
        this.inForStatementInit = false;
        this.tokenContext = 0;
        this._tokens = null;
        this._originalCode = null;
        this._currentNode = null;
        this._indent = 0;
        this._indentRepeat = 0;
        this._insideAux = false;
        this._noLineTerminator = false;
        this._noLineTerminatorAfterNode = null;
        this._printAuxAfterOnNextUserNode = false;
        this._printedComments = /* @__PURE__ */ new Set();
        this._endsWithInteger = false;
        this._endsWithWord = false;
        this._endsWithDiv = false;
        this._lastCommentLine = 0;
        this._endsWithInnerRaw = false;
        this._indentInnerComments = true;
        this.tokenMap = null;
        this._boundGetRawIdentifier = this._getRawIdentifier.bind(this);
        this._printSemicolonBeforeNextNode = -1;
        this._printSemicolonBeforeNextToken = -1;
        this.format = format;
        this._tokens = tokens;
        this._originalCode = originalCode;
        this._indentRepeat = format.indent.style.length;
        this._inputMap = map == null ? void 0 : map._inputMap;
        this._buf = new _buffer.default(map, format.indent.style[0]);
      }
      enterForStatementInit() {
        if (this.inForStatementInit) return () => {
        };
        this.inForStatementInit = true;
        return () => {
          this.inForStatementInit = false;
        };
      }
      enterDelimited() {
        const oldInForStatementInit = this.inForStatementInit;
        const oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;
        if (oldInForStatementInit === false && oldNoLineTerminatorAfterNode === null) {
          return () => {
          };
        }
        this.inForStatementInit = false;
        this._noLineTerminatorAfterNode = null;
        return () => {
          this.inForStatementInit = oldInForStatementInit;
          this._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode;
        };
      }
      generate(ast) {
        if (this.format.preserveFormat) {
          this.tokenMap = new _tokenMap.TokenMap(ast, this._tokens, this._originalCode);
        }
        this.print(ast);
        this._maybeAddAuxComment();
        return this._buf.get();
      }
      indent() {
        const {
          format
        } = this;
        if (format.preserveFormat || format.compact || format.concise) {
          return;
        }
        this._indent++;
      }
      dedent() {
        const {
          format
        } = this;
        if (format.preserveFormat || format.compact || format.concise) {
          return;
        }
        this._indent--;
      }
      semicolon(force = false) {
        this._maybeAddAuxComment();
        if (force) {
          this._appendChar(59);
          this._noLineTerminator = false;
          return;
        }
        if (this.tokenMap) {
          const node = this._currentNode;
          if (node.start != null && node.end != null) {
            if (!this.tokenMap.endMatches(node, ";")) {
              this._printSemicolonBeforeNextNode = this._buf.getCurrentLine();
              return;
            }
            const indexes = this.tokenMap.getIndexes(this._currentNode);
            this._catchUpTo(this._tokens[indexes[indexes.length - 1]].loc.start);
          }
        }
        this._queue(59);
        this._noLineTerminator = false;
      }
      rightBrace(node) {
        if (this.format.minified) {
          this._buf.removeLastSemicolon();
        }
        this.sourceWithOffset("end", node.loc, -1);
        this.tokenChar(125);
      }
      rightParens(node) {
        this.sourceWithOffset("end", node.loc, -1);
        this.tokenChar(41);
      }
      space(force = false) {
        const {
          format
        } = this;
        if (format.compact || format.preserveFormat) return;
        if (force) {
          this._space();
        } else if (this._buf.hasContent()) {
          const lastCp = this.getLastChar();
          if (lastCp !== 32 && lastCp !== 10) {
            this._space();
          }
        }
      }
      word(str, noLineTerminatorAfter = false) {
        this.tokenContext = 0;
        this._maybePrintInnerComments(str);
        this._maybeAddAuxComment();
        if (this.tokenMap) this._catchUpToCurrentToken(str);
        if (this._endsWithWord || this._endsWithDiv && str.charCodeAt(0) === 47) {
          this._space();
        }
        this._append(str, false);
        this._endsWithWord = true;
        this._noLineTerminator = noLineTerminatorAfter;
      }
      number(str, number) {
        function isNonDecimalLiteral(str2) {
          if (str2.length > 2 && str2.charCodeAt(0) === 48) {
            const secondChar = str2.charCodeAt(1);
            return secondChar === 98 || secondChar === 111 || secondChar === 120;
          }
          return false;
        }
        this.word(str);
        this._endsWithInteger = Number.isInteger(number) && !isNonDecimalLiteral(str) && !SCIENTIFIC_NOTATION.test(str) && !ZERO_DECIMAL_INTEGER.test(str) && str.charCodeAt(str.length - 1) !== 46;
      }
      token(str, maybeNewline = false, occurrenceCount = 0) {
        this.tokenContext = 0;
        this._maybePrintInnerComments(str, occurrenceCount);
        this._maybeAddAuxComment();
        if (this.tokenMap) this._catchUpToCurrentToken(str, occurrenceCount);
        const lastChar = this.getLastChar();
        const strFirst = str.charCodeAt(0);
        if (lastChar === 33 && (str === "--" || strFirst === 61) || strFirst === 43 && lastChar === 43 || strFirst === 45 && lastChar === 45 || strFirst === 46 && this._endsWithInteger) {
          this._space();
        }
        this._append(str, maybeNewline);
        this._noLineTerminator = false;
      }
      tokenChar(char) {
        this.tokenContext = 0;
        const str = String.fromCharCode(char);
        this._maybePrintInnerComments(str);
        this._maybeAddAuxComment();
        if (this.tokenMap) this._catchUpToCurrentToken(str);
        const lastChar = this.getLastChar();
        if (char === 43 && lastChar === 43 || char === 45 && lastChar === 45 || char === 46 && this._endsWithInteger) {
          this._space();
        }
        this._appendChar(char);
        this._noLineTerminator = false;
      }
      newline(i = 1, force) {
        if (i <= 0) return;
        if (!force) {
          if (this.format.retainLines || this.format.compact) return;
          if (this.format.concise) {
            this.space();
            return;
          }
        }
        if (i > 2) i = 2;
        i -= this._buf.getNewlineCount();
        for (let j = 0; j < i; j++) {
          this._newline();
        }
        return;
      }
      endsWith(char) {
        return this.getLastChar() === char;
      }
      getLastChar() {
        return this._buf.getLastChar();
      }
      endsWithCharAndNewline() {
        return this._buf.endsWithCharAndNewline();
      }
      removeTrailingNewline() {
        this._buf.removeTrailingNewline();
      }
      exactSource(loc, cb) {
        if (!loc) {
          cb();
          return;
        }
        this._catchUp("start", loc);
        this._buf.exactSource(loc, cb);
      }
      source(prop, loc) {
        if (!loc) return;
        this._catchUp(prop, loc);
        this._buf.source(prop, loc);
      }
      sourceWithOffset(prop, loc, columnOffset) {
        if (!loc || this.format.preserveFormat) return;
        this._catchUp(prop, loc);
        this._buf.sourceWithOffset(prop, loc, columnOffset);
      }
      sourceIdentifierName(identifierName, pos2) {
        if (!this._buf._canMarkIdName) return;
        const sourcePosition = this._buf._sourcePosition;
        sourcePosition.identifierNamePos = pos2;
        sourcePosition.identifierName = identifierName;
      }
      _space() {
        this._queue(32);
      }
      _newline() {
        this._queue(10);
      }
      _catchUpToCurrentToken(str, occurrenceCount = 0) {
        const token2 = this.tokenMap.findMatching(this._currentNode, str, occurrenceCount);
        if (token2) this._catchUpTo(token2.loc.start);
        if (this._printSemicolonBeforeNextToken !== -1 && this._printSemicolonBeforeNextToken === this._buf.getCurrentLine()) {
          this._buf.appendChar(59);
          this._endsWithWord = false;
          this._endsWithInteger = false;
          this._endsWithDiv = false;
        }
        this._printSemicolonBeforeNextToken = -1;
        this._printSemicolonBeforeNextNode = -1;
      }
      _append(str, maybeNewline) {
        this._maybeIndent(str.charCodeAt(0));
        this._buf.append(str, maybeNewline);
        this._endsWithWord = false;
        this._endsWithInteger = false;
        this._endsWithDiv = false;
      }
      _appendChar(char) {
        this._maybeIndent(char);
        this._buf.appendChar(char);
        this._endsWithWord = false;
        this._endsWithInteger = false;
        this._endsWithDiv = false;
      }
      _queue(char) {
        this._maybeIndent(char);
        this._buf.queue(char);
        this._endsWithWord = false;
        this._endsWithInteger = false;
      }
      _maybeIndent(firstChar) {
        if (this._indent && firstChar !== 10 && this.endsWith(10)) {
          this._buf.queueIndentation(this._getIndent());
        }
      }
      _shouldIndent(firstChar) {
        if (this._indent && firstChar !== 10 && this.endsWith(10)) {
          return true;
        }
      }
      catchUp(line2) {
        if (!this.format.retainLines) return;
        const count = line2 - this._buf.getCurrentLine();
        for (let i = 0; i < count; i++) {
          this._newline();
        }
      }
      _catchUp(prop, loc) {
        const {
          format
        } = this;
        if (!format.preserveFormat) {
          if (format.retainLines && loc != null && loc[prop]) {
            this.catchUp(loc[prop].line);
          }
          return;
        }
        const pos2 = loc == null ? void 0 : loc[prop];
        if (pos2 != null) this._catchUpTo(pos2);
      }
      _catchUpTo({
        line: line2,
        column: column2,
        index
      }) {
        const count = line2 - this._buf.getCurrentLine();
        if (count > 0 && this._noLineTerminator) {
          return;
        }
        for (let i = 0; i < count; i++) {
          this._newline();
        }
        const spacesCount = count > 0 ? column2 : column2 - this._buf.getCurrentColumn();
        if (spacesCount > 0) {
          const spaces = this._originalCode ? this._originalCode.slice(index - spacesCount, index).replace(/[^\t\x0B\f \xA0\u1680\u2000-\u200A\u202F\u205F\u3000\uFEFF]/gu, " ") : " ".repeat(spacesCount);
          this._append(spaces, false);
        }
      }
      _getIndent() {
        return this._indentRepeat * this._indent;
      }
      printTerminatorless(node) {
        this._noLineTerminator = true;
        this.print(node);
      }
      print(node, noLineTerminatorAfter, trailingCommentsLineOffset) {
        var _node$extra, _node$leadingComments, _node$leadingComments2;
        if (!node) return;
        this._endsWithInnerRaw = false;
        const nodeType = node.type;
        const format = this.format;
        const oldConcise = format.concise;
        if (node._compact) {
          format.concise = true;
        }
        const printMethod = this[nodeType];
        if (printMethod === void 0) {
          throw new ReferenceError(`unknown node of type ${JSON.stringify(nodeType)} with constructor ${JSON.stringify(node.constructor.name)}`);
        }
        const parent = this._currentNode;
        this._currentNode = node;
        if (this.tokenMap) {
          this._printSemicolonBeforeNextToken = this._printSemicolonBeforeNextNode;
        }
        const oldInAux = this._insideAux;
        this._insideAux = node.loc == null;
        this._maybeAddAuxComment(this._insideAux && !oldInAux);
        const parenthesized = (_node$extra = node.extra) == null ? void 0 : _node$extra.parenthesized;
        let shouldPrintParens = parenthesized && format.preserveFormat || parenthesized && format.retainFunctionParens && nodeType === "FunctionExpression" || needsParens(node, parent, this.tokenContext, this.inForStatementInit, format.preserveFormat ? this._boundGetRawIdentifier : void 0);
        if (!shouldPrintParens && parenthesized && (_node$leadingComments = node.leadingComments) != null && _node$leadingComments.length && node.leadingComments[0].type === "CommentBlock") {
          const parentType = parent == null ? void 0 : parent.type;
          switch (parentType) {
            case "ExpressionStatement":
            case "VariableDeclarator":
            case "AssignmentExpression":
            case "ReturnStatement":
              break;
            case "CallExpression":
            case "OptionalCallExpression":
            case "NewExpression":
              if (parent.callee !== node) break;
            default:
              shouldPrintParens = true;
          }
        }
        let indentParenthesized = false;
        if (!shouldPrintParens && this._noLineTerminator && ((_node$leadingComments2 = node.leadingComments) != null && _node$leadingComments2.some(commentIsNewline) || this.format.retainLines && node.loc && node.loc.start.line > this._buf.getCurrentLine())) {
          shouldPrintParens = true;
          indentParenthesized = true;
        }
        let oldNoLineTerminatorAfterNode;
        let oldInForStatementInitWasTrue;
        if (!shouldPrintParens) {
          noLineTerminatorAfter || (noLineTerminatorAfter = parent && this._noLineTerminatorAfterNode === parent && n.isLastChild(parent, node));
          if (noLineTerminatorAfter) {
            var _node$trailingComment;
            if ((_node$trailingComment = node.trailingComments) != null && _node$trailingComment.some(commentIsNewline)) {
              if (isExpression2(node)) shouldPrintParens = true;
            } else {
              oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;
              this._noLineTerminatorAfterNode = node;
            }
          }
        }
        if (shouldPrintParens) {
          this.tokenChar(40);
          if (indentParenthesized) this.indent();
          this._endsWithInnerRaw = false;
          if (this.inForStatementInit) {
            oldInForStatementInitWasTrue = true;
            this.inForStatementInit = false;
          }
          oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;
          this._noLineTerminatorAfterNode = null;
        }
        this._lastCommentLine = 0;
        this._printLeadingComments(node, parent);
        const loc = nodeType === "Program" || nodeType === "File" ? null : node.loc;
        this.exactSource(loc, printMethod.bind(this, node, parent));
        if (shouldPrintParens) {
          this._printTrailingComments(node, parent);
          if (indentParenthesized) {
            this.dedent();
            this.newline();
          }
          this.tokenChar(41);
          this._noLineTerminator = noLineTerminatorAfter;
          if (oldInForStatementInitWasTrue) this.inForStatementInit = true;
        } else if (noLineTerminatorAfter && !this._noLineTerminator) {
          this._noLineTerminator = true;
          this._printTrailingComments(node, parent);
        } else {
          this._printTrailingComments(node, parent, trailingCommentsLineOffset);
        }
        this._currentNode = parent;
        format.concise = oldConcise;
        this._insideAux = oldInAux;
        if (oldNoLineTerminatorAfterNode !== void 0) {
          this._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode;
        }
        this._endsWithInnerRaw = false;
      }
      _maybeAddAuxComment(enteredPositionlessNode) {
        if (enteredPositionlessNode) this._printAuxBeforeComment();
        if (!this._insideAux) this._printAuxAfterComment();
      }
      _printAuxBeforeComment() {
        if (this._printAuxAfterOnNextUserNode) return;
        this._printAuxAfterOnNextUserNode = true;
        const comment = this.format.auxiliaryCommentBefore;
        if (comment) {
          this._printComment({
            type: "CommentBlock",
            value: comment
          }, 0);
        }
      }
      _printAuxAfterComment() {
        if (!this._printAuxAfterOnNextUserNode) return;
        this._printAuxAfterOnNextUserNode = false;
        const comment = this.format.auxiliaryCommentAfter;
        if (comment) {
          this._printComment({
            type: "CommentBlock",
            value: comment
          }, 0);
        }
      }
      getPossibleRaw(node) {
        const extra = node.extra;
        if ((extra == null ? void 0 : extra.raw) != null && extra.rawValue != null && node.value === extra.rawValue) {
          return extra.raw;
        }
      }
      printJoin(nodes, statement, indent, separator, printTrailingSeparator, addNewlines, iterator, trailingCommentsLineOffset) {
        if (!(nodes != null && nodes.length)) return;
        if (indent == null && this.format.retainLines) {
          var _nodes$0$loc;
          const startLine = (_nodes$0$loc = nodes[0].loc) == null ? void 0 : _nodes$0$loc.start.line;
          if (startLine != null && startLine !== this._buf.getCurrentLine()) {
            indent = true;
          }
        }
        if (indent) this.indent();
        const newlineOpts = {
          addNewlines,
          nextNodeStartLine: 0
        };
        const boundSeparator = separator == null ? void 0 : separator.bind(this);
        const len = nodes.length;
        for (let i = 0; i < len; i++) {
          const node = nodes[i];
          if (!node) continue;
          if (statement) this._printNewline(i === 0, newlineOpts);
          this.print(node, void 0, trailingCommentsLineOffset || 0);
          iterator == null || iterator(node, i);
          if (boundSeparator != null) {
            if (i < len - 1) boundSeparator(i, false);
            else if (printTrailingSeparator) boundSeparator(i, true);
          }
          if (statement) {
            var _node$trailingComment2;
            if (!((_node$trailingComment2 = node.trailingComments) != null && _node$trailingComment2.length)) {
              this._lastCommentLine = 0;
            }
            if (i + 1 === len) {
              this.newline(1);
            } else {
              var _nextNode$loc;
              const nextNode = nodes[i + 1];
              newlineOpts.nextNodeStartLine = ((_nextNode$loc = nextNode.loc) == null ? void 0 : _nextNode$loc.start.line) || 0;
              this._printNewline(true, newlineOpts);
            }
          }
        }
        if (indent) this.dedent();
      }
      printAndIndentOnComments(node) {
        const indent = node.leadingComments && node.leadingComments.length > 0;
        if (indent) this.indent();
        this.print(node);
        if (indent) this.dedent();
      }
      printBlock(parent) {
        const node = parent.body;
        if (node.type !== "EmptyStatement") {
          this.space();
        }
        this.print(node);
      }
      _printTrailingComments(node, parent, lineOffset) {
        const {
          innerComments,
          trailingComments
        } = node;
        if (innerComments != null && innerComments.length) {
          this._printComments(2, innerComments, node, parent, lineOffset);
        }
        if (trailingComments != null && trailingComments.length) {
          this._printComments(2, trailingComments, node, parent, lineOffset);
        }
      }
      _printLeadingComments(node, parent) {
        const comments = node.leadingComments;
        if (!(comments != null && comments.length)) return;
        this._printComments(0, comments, node, parent);
      }
      _maybePrintInnerComments(nextTokenStr, nextTokenOccurrenceCount) {
        if (this._endsWithInnerRaw) {
          var _this$tokenMap;
          this.printInnerComments((_this$tokenMap = this.tokenMap) == null ? void 0 : _this$tokenMap.findMatching(this._currentNode, nextTokenStr, nextTokenOccurrenceCount));
        }
        this._endsWithInnerRaw = true;
        this._indentInnerComments = true;
      }
      printInnerComments(nextToken) {
        const node = this._currentNode;
        const comments = node.innerComments;
        if (!(comments != null && comments.length)) return;
        const hasSpace = this.endsWith(32);
        const indent = this._indentInnerComments;
        const printedCommentsCount = this._printedComments.size;
        if (indent) this.indent();
        this._printComments(1, comments, node, void 0, void 0, nextToken);
        if (hasSpace && printedCommentsCount !== this._printedComments.size) {
          this.space();
        }
        if (indent) this.dedent();
      }
      noIndentInnerCommentsHere() {
        this._indentInnerComments = false;
      }
      printSequence(nodes, indent, trailingCommentsLineOffset, addNewlines) {
        this.printJoin(nodes, true, indent != null ? indent : false, void 0, void 0, addNewlines, void 0, trailingCommentsLineOffset);
      }
      printList(items, printTrailingSeparator, statement, indent, separator, iterator) {
        this.printJoin(items, statement, indent, separator != null ? separator : commaSeparator, printTrailingSeparator, void 0, iterator);
      }
      shouldPrintTrailingComma(listEnd) {
        if (!this.tokenMap) return null;
        const listEndIndex = this.tokenMap.findLastIndex(this._currentNode, (token2) => this.tokenMap.matchesOriginal(token2, listEnd));
        if (listEndIndex <= 0) return null;
        return this.tokenMap.matchesOriginal(this._tokens[listEndIndex - 1], ",");
      }
      _printNewline(newLine, opts) {
        const format = this.format;
        if (format.retainLines || format.compact) return;
        if (format.concise) {
          this.space();
          return;
        }
        if (!newLine) {
          return;
        }
        const startLine = opts.nextNodeStartLine;
        const lastCommentLine = this._lastCommentLine;
        if (startLine > 0 && lastCommentLine > 0) {
          const offset = startLine - lastCommentLine;
          if (offset >= 0) {
            this.newline(offset || 1);
            return;
          }
        }
        if (this._buf.hasContent()) {
          this.newline(1);
        }
      }
      _shouldPrintComment(comment, nextToken) {
        if (comment.ignore) return 0;
        if (this._printedComments.has(comment)) return 0;
        if (this._noLineTerminator && HAS_NEWLINE_OR_BlOCK_COMMENT_END.test(comment.value)) {
          return 2;
        }
        if (nextToken && this.tokenMap) {
          const commentTok = this.tokenMap.find(this._currentNode, (token2) => token2.value === comment.value);
          if (commentTok && commentTok.start > nextToken.start) {
            return 2;
          }
        }
        this._printedComments.add(comment);
        if (!this.format.shouldPrintComment(comment.value)) {
          return 0;
        }
        return 1;
      }
      _printComment(comment, skipNewLines) {
        const noLineTerminator = this._noLineTerminator;
        const isBlockComment = comment.type === "CommentBlock";
        const printNewLines = isBlockComment && skipNewLines !== 1 && !this._noLineTerminator;
        if (printNewLines && this._buf.hasContent() && skipNewLines !== 2) {
          this.newline(1);
        }
        const lastCharCode = this.getLastChar();
        if (lastCharCode !== 91 && lastCharCode !== 123 && lastCharCode !== 40) {
          this.space();
        }
        let val;
        if (isBlockComment) {
          val = `/*${comment.value}*/`;
          if (this.format.indent.adjustMultilineComment) {
            var _comment$loc;
            const offset = (_comment$loc = comment.loc) == null ? void 0 : _comment$loc.start.column;
            if (offset) {
              const newlineRegex = new RegExp("\\n\\s{1," + offset + "}", "g");
              val = val.replace(newlineRegex, "\n");
            }
            if (this.format.concise) {
              val = val.replace(/\n(?!$)/g, `
`);
            } else {
              let indentSize = this.format.retainLines ? 0 : this._buf.getCurrentColumn();
              if (this._shouldIndent(47) || this.format.retainLines) {
                indentSize += this._getIndent();
              }
              val = val.replace(/\n(?!$)/g, `
${" ".repeat(indentSize)}`);
            }
          }
        } else if (!noLineTerminator) {
          val = `//${comment.value}`;
        } else {
          val = `/*${comment.value}*/`;
        }
        if (this._endsWithDiv) this._space();
        if (this.tokenMap) {
          const {
            _printSemicolonBeforeNextToken,
            _printSemicolonBeforeNextNode
          } = this;
          this._printSemicolonBeforeNextToken = -1;
          this._printSemicolonBeforeNextNode = -1;
          this.source("start", comment.loc);
          this._append(val, isBlockComment);
          this._printSemicolonBeforeNextNode = _printSemicolonBeforeNextNode;
          this._printSemicolonBeforeNextToken = _printSemicolonBeforeNextToken;
        } else {
          this.source("start", comment.loc);
          this._append(val, isBlockComment);
        }
        if (!isBlockComment && !noLineTerminator) {
          this.newline(1, true);
        }
        if (printNewLines && skipNewLines !== 3) {
          this.newline(1);
        }
      }
      _printComments(type, comments, node, parent, lineOffset = 0, nextToken) {
        const nodeLoc = node.loc;
        const len = comments.length;
        let hasLoc = !!nodeLoc;
        const nodeStartLine = hasLoc ? nodeLoc.start.line : 0;
        const nodeEndLine = hasLoc ? nodeLoc.end.line : 0;
        let lastLine = 0;
        let leadingCommentNewline = 0;
        const maybeNewline = this._noLineTerminator ? function() {
        } : this.newline.bind(this);
        for (let i = 0; i < len; i++) {
          const comment = comments[i];
          const shouldPrint = this._shouldPrintComment(comment, nextToken);
          if (shouldPrint === 2) {
            hasLoc = false;
            break;
          }
          if (hasLoc && comment.loc && shouldPrint === 1) {
            const commentStartLine = comment.loc.start.line;
            const commentEndLine = comment.loc.end.line;
            if (type === 0) {
              let offset = 0;
              if (i === 0) {
                if (this._buf.hasContent() && (comment.type === "CommentLine" || commentStartLine !== commentEndLine)) {
                  offset = leadingCommentNewline = 1;
                }
              } else {
                offset = commentStartLine - lastLine;
              }
              lastLine = commentEndLine;
              maybeNewline(offset);
              this._printComment(comment, 1);
              if (i + 1 === len) {
                maybeNewline(Math.max(nodeStartLine - lastLine, leadingCommentNewline));
                lastLine = nodeStartLine;
              }
            } else if (type === 1) {
              const offset = commentStartLine - (i === 0 ? nodeStartLine : lastLine);
              lastLine = commentEndLine;
              maybeNewline(offset);
              this._printComment(comment, 1);
              if (i + 1 === len) {
                maybeNewline(Math.min(1, nodeEndLine - lastLine));
                lastLine = nodeEndLine;
              }
            } else {
              const offset = commentStartLine - (i === 0 ? nodeEndLine - lineOffset : lastLine);
              lastLine = commentEndLine;
              maybeNewline(offset);
              this._printComment(comment, 1);
            }
          } else {
            hasLoc = false;
            if (shouldPrint !== 1) {
              continue;
            }
            if (len === 1) {
              const singleLine = comment.loc ? comment.loc.start.line === comment.loc.end.line : !HAS_NEWLINE.test(comment.value);
              const shouldSkipNewline = singleLine && !isStatement2(node) && !isClassBody(parent) && !isTSInterfaceBody(parent) && !isTSEnumMember(node);
              if (type === 0) {
                this._printComment(comment, shouldSkipNewline && node.type !== "ObjectExpression" || singleLine && isFunction(parent, {
                  body: node
                }) ? 1 : 0);
              } else if (shouldSkipNewline && type === 2) {
                this._printComment(comment, 1);
              } else {
                this._printComment(comment, 0);
              }
            } else if (type === 1 && !(node.type === "ObjectExpression" && node.properties.length > 1) && node.type !== "ClassBody" && node.type !== "TSInterfaceBody") {
              this._printComment(comment, i === 0 ? 2 : i === len - 1 ? 3 : 0);
            } else {
              this._printComment(comment, 0);
            }
          }
        }
        if (type === 2 && hasLoc && lastLine) {
          this._lastCommentLine = lastLine;
        }
      }
    };
    Object.assign(Printer.prototype, generatorFunctions);
    {
      (0, _deprecated.addDeprecatedGenerators)(Printer);
    }
    var _default = exports2.default = Printer;
    function commaSeparator(occurrenceCount, last) {
      this.token(",", false, occurrenceCount);
      if (!last) this.space();
    }
  }
});

// node_modules/@babel/helpers/node_modules/@babel/generator/lib/index.js
var require_lib = __commonJS({
  "node_modules/@babel/helpers/node_modules/@babel/generator/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    exports2.generate = generate2;
    var _sourceMap = require_source_map();
    var _printer = require_printer();
    function normalizeOptions(code, opts, ast) {
      if (opts.experimental_preserveFormat) {
        if (typeof code !== "string") {
          throw new Error("`experimental_preserveFormat` requires the original `code` to be passed to @babel/generator as a string");
        }
        if (!opts.retainLines) {
          throw new Error("`experimental_preserveFormat` requires `retainLines` to be set to `true`");
        }
        if (opts.compact && opts.compact !== "auto") {
          throw new Error("`experimental_preserveFormat` is not compatible with the `compact` option");
        }
        if (opts.minified) {
          throw new Error("`experimental_preserveFormat` is not compatible with the `minified` option");
        }
        if (opts.jsescOption) {
          throw new Error("`experimental_preserveFormat` is not compatible with the `jsescOption` option");
        }
        if (!Array.isArray(ast.tokens)) {
          throw new Error("`experimental_preserveFormat` requires the AST to have attatched the token of the input code. Make sure to enable the `tokens: true` parser option.");
        }
      }
      const format = {
        auxiliaryCommentBefore: opts.auxiliaryCommentBefore,
        auxiliaryCommentAfter: opts.auxiliaryCommentAfter,
        shouldPrintComment: opts.shouldPrintComment,
        preserveFormat: opts.experimental_preserveFormat,
        retainLines: opts.retainLines,
        retainFunctionParens: opts.retainFunctionParens,
        comments: opts.comments == null || opts.comments,
        compact: opts.compact,
        minified: opts.minified,
        concise: opts.concise,
        indent: {
          adjustMultilineComment: true,
          style: "  "
        },
        jsescOption: Object.assign({
          quotes: "double",
          wrap: true,
          minimal: false
        }, opts.jsescOption),
        topicToken: opts.topicToken,
        importAttributesKeyword: opts.importAttributesKeyword
      };
      {
        var _opts$recordAndTupleS;
        format.decoratorsBeforeExport = opts.decoratorsBeforeExport;
        format.jsescOption.json = opts.jsonCompatibleStrings;
        format.recordAndTupleSyntaxType = (_opts$recordAndTupleS = opts.recordAndTupleSyntaxType) != null ? _opts$recordAndTupleS : "hash";
      }
      if (format.minified) {
        format.compact = true;
        format.shouldPrintComment = format.shouldPrintComment || (() => format.comments);
      } else {
        format.shouldPrintComment = format.shouldPrintComment || ((value) => format.comments || value.includes("@license") || value.includes("@preserve"));
      }
      if (format.compact === "auto") {
        format.compact = typeof code === "string" && code.length > 5e5;
        if (format.compact) {
          console.error(`[BABEL] Note: The code generator has deoptimised the styling of ${opts.filename} as it exceeds the max of ${"500KB"}.`);
        }
      }
      if (format.compact || format.preserveFormat) {
        format.indent.adjustMultilineComment = false;
      }
      const {
        auxiliaryCommentBefore,
        auxiliaryCommentAfter,
        shouldPrintComment
      } = format;
      if (auxiliaryCommentBefore && !shouldPrintComment(auxiliaryCommentBefore)) {
        format.auxiliaryCommentBefore = void 0;
      }
      if (auxiliaryCommentAfter && !shouldPrintComment(auxiliaryCommentAfter)) {
        format.auxiliaryCommentAfter = void 0;
      }
      return format;
    }
    {
      exports2.CodeGenerator = class CodeGenerator {
        constructor(ast, opts = {}, code) {
          this._ast = void 0;
          this._format = void 0;
          this._map = void 0;
          this._ast = ast;
          this._format = normalizeOptions(code, opts, ast);
          this._map = opts.sourceMaps ? new _sourceMap.default(opts, code) : null;
        }
        generate() {
          const printer = new _printer.default(this._format, this._map);
          return printer.generate(this._ast);
        }
      };
    }
    function generate2(ast, opts = {}, code) {
      const format = normalizeOptions(code, opts, ast);
      const map = opts.sourceMaps ? new _sourceMap.default(opts, code) : null;
      const printer = new _printer.default(format, map, ast.tokens, typeof code === "string" ? code : null);
      return printer.generate(ast);
    }
    var _default = exports2.default = generate2;
  }
});

// node_modules/@babel/helpers/node_modules/@babel/traverse/lib/path/ancestry.js
var require_ancestry = __commonJS({
  "node_modules/@babel/helpers/node_modules/@babel/traverse/lib/path/ancestry.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.find = find;
    exports2.findParent = findParent;
    exports2.getAncestry = getAncestry;
    exports2.getDeepestCommonAncestorFrom = getDeepestCommonAncestorFrom;
    exports2.getEarliestCommonAncestorFrom = getEarliestCommonAncestorFrom;
    exports2.getFunctionParent = getFunctionParent;
    exports2.getStatementParent = getStatementParent;
    exports2.inType = inType;
    exports2.isAncestor = isAncestor;
    exports2.isDescendant = isDescendant;
    var _t = require("@babel/types");
    var {
      VISITOR_KEYS
    } = _t;
    function findParent(callback) {
      let path = this;
      while (path = path.parentPath) {
        if (callback(path)) return path;
      }
      return null;
    }
    function find(callback) {
      let path = this;
      do {
        if (callback(path)) return path;
      } while (path = path.parentPath);
      return null;
    }
    function getFunctionParent() {
      return this.findParent((p) => p.isFunction());
    }
    function getStatementParent() {
      let path = this;
      do {
        if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {
          break;
        } else {
          path = path.parentPath;
        }
      } while (path);
      if (path && (path.isProgram() || path.isFile())) {
        throw new Error("File/Program node, we can't possibly find a statement parent to this");
      }
      return path;
    }
    function getEarliestCommonAncestorFrom(paths) {
      return this.getDeepestCommonAncestorFrom(paths, function(deepest, i, ancestries) {
        let earliest;
        const keys = VISITOR_KEYS[deepest.type];
        for (const ancestry of ancestries) {
          const path = ancestry[i + 1];
          if (!earliest) {
            earliest = path;
            continue;
          }
          if (path.listKey && earliest.listKey === path.listKey) {
            if (path.key < earliest.key) {
              earliest = path;
              continue;
            }
          }
          const earliestKeyIndex = keys.indexOf(earliest.parentKey);
          const currentKeyIndex = keys.indexOf(path.parentKey);
          if (earliestKeyIndex > currentKeyIndex) {
            earliest = path;
          }
        }
        return earliest;
      });
    }
    function getDeepestCommonAncestorFrom(paths, filter) {
      if (!paths.length) {
        return this;
      }
      if (paths.length === 1) {
        return paths[0];
      }
      let minDepth = Infinity;
      let lastCommonIndex, lastCommon;
      const ancestries = paths.map((path) => {
        const ancestry = [];
        do {
          ancestry.unshift(path);
        } while ((path = path.parentPath) && path !== this);
        if (ancestry.length < minDepth) {
          minDepth = ancestry.length;
        }
        return ancestry;
      });
      const first = ancestries[0];
      depthLoop: for (let i = 0; i < minDepth; i++) {
        const shouldMatch = first[i];
        for (const ancestry of ancestries) {
          if (ancestry[i] !== shouldMatch) {
            break depthLoop;
          }
        }
        lastCommonIndex = i;
        lastCommon = shouldMatch;
      }
      if (lastCommon) {
        if (filter) {
          return filter(lastCommon, lastCommonIndex, ancestries);
        } else {
          return lastCommon;
        }
      } else {
        throw new Error("Couldn't find intersection");
      }
    }
    function getAncestry() {
      let path = this;
      const paths = [];
      do {
        paths.push(path);
      } while (path = path.parentPath);
      return paths;
    }
    function isAncestor(maybeDescendant) {
      return maybeDescendant.isDescendant(this);
    }
    function isDescendant(maybeAncestor) {
      return !!this.findParent((parent) => parent === maybeAncestor);
    }
    function inType(...candidateTypes) {
      let path = this;
      while (path) {
        for (const type of candidateTypes) {
          if (path.node.type === type) return true;
        }
        path = path.parentPath;
      }
      return false;
    }
  }
});

// node_modules/@babel/helpers/node_modules/@babel/traverse/lib/path/inference/util.js
var require_util = __commonJS({
  "node_modules/@babel/helpers/node_modules/@babel/traverse/lib/path/inference/util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.createUnionType = createUnionType;
    var _t = require("@babel/types");
    var {
      createFlowUnionType,
      createTSUnionType,
      createUnionTypeAnnotation,
      isFlowType,
      isTSType: isTSType2
    } = _t;
    function createUnionType(types) {
      {
        if (types.every((v) => isFlowType(v))) {
          if (createFlowUnionType) {
            return createFlowUnionType(types);
          }
          return createUnionTypeAnnotation(types);
        } else if (types.every((v) => isTSType2(v))) {
          if (createTSUnionType) {
            return createTSUnionType(types);
          }
        }
      }
    }
  }
});

// node_modules/@babel/helpers/node_modules/@babel/traverse/lib/path/inference/inferer-reference.js
var require_inferer_reference = __commonJS({
  "node_modules/@babel/helpers/node_modules/@babel/traverse/lib/path/inference/inferer-reference.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = _default;
    var _t = require("@babel/types");
    var _util = require_util();
    var {
      BOOLEAN_NUMBER_BINARY_OPERATORS,
      createTypeAnnotationBasedOnTypeof,
      numberTypeAnnotation,
      voidTypeAnnotation
    } = _t;
    function _default(node) {
      if (!this.isReferenced()) return;
      const binding = this.scope.getBinding(node.name);
      if (binding) {
        if (binding.identifier.typeAnnotation) {
          return binding.identifier.typeAnnotation;
        } else {
          return getTypeAnnotationBindingConstantViolations(binding, this, node.name);
        }
      }
      if (node.name === "undefined") {
        return voidTypeAnnotation();
      } else if (node.name === "NaN" || node.name === "Infinity") {
        return numberTypeAnnotation();
      } else if (node.name === "arguments") {
      }
    }
    function getTypeAnnotationBindingConstantViolations(binding, path, name) {
      const types = [];
      const functionConstantViolations = [];
      let constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);
      const testType = getConditionalAnnotation(binding, path, name);
      if (testType) {
        const testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);
        constantViolations = constantViolations.filter((path2) => !testConstantViolations.includes(path2));
        types.push(testType.typeAnnotation);
      }
      if (constantViolations.length) {
        constantViolations.push(...functionConstantViolations);
        for (const violation of constantViolations) {
          types.push(violation.getTypeAnnotation());
        }
      }
      if (!types.length) {
        return;
      }
      return (0, _util.createUnionType)(types);
    }
    function getConstantViolationsBefore(binding, path, functions) {
      const violations = binding.constantViolations.slice();
      violations.unshift(binding.path);
      return violations.filter((violation) => {
        violation = violation.resolve();
        const status = violation._guessExecutionStatusRelativeTo(path);
        if (functions && status === "unknown") functions.push(violation);
        return status === "before";
      });
    }
    function inferAnnotationFromBinaryExpression(name, path) {
      const operator = path.node.operator;
      const right = path.get("right").resolve();
      const left = path.get("left").resolve();
      let target;
      if (left.isIdentifier({
        name
      })) {
        target = right;
      } else if (right.isIdentifier({
        name
      })) {
        target = left;
      }
      if (target) {
        if (operator === "===") {
          return target.getTypeAnnotation();
        }
        if (BOOLEAN_NUMBER_BINARY_OPERATORS.includes(operator)) {
          return numberTypeAnnotation();
        }
        return;
      }
      if (operator !== "===" && operator !== "==") return;
      let typeofPath;
      let typePath;
      if (left.isUnaryExpression({
        operator: "typeof"
      })) {
        typeofPath = left;
        typePath = right;
      } else if (right.isUnaryExpression({
        operator: "typeof"
      })) {
        typeofPath = right;
        typePath = left;
      }
      if (!typeofPath) return;
      if (!typeofPath.get("argument").isIdentifier({
        name
      })) return;
      typePath = typePath.resolve();
      if (!typePath.isLiteral()) return;
      const typeValue = typePath.node.value;
      if (typeof typeValue !== "string") return;
      return createTypeAnnotationBasedOnTypeof(typeValue);
    }
    function getParentConditionalPath(binding, path, name) {
      let parentPath;
      while (parentPath = path.parentPath) {
        if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {
          if (path.key === "test") {
            return;
          }
          return parentPath;
        }
        if (parentPath.isFunction()) {
          if (parentPath.parentPath.scope.getBinding(name) !== binding) return;
        }
        path = parentPath;
      }
    }
    function getConditionalAnnotation(binding, path, name) {
      const ifStatement3 = getParentConditionalPath(binding, path, name);
      if (!ifStatement3) return;
      const test = ifStatement3.get("test");
      const paths = [test];
      const types = [];
      for (let i = 0; i < paths.length; i++) {
        const path2 = paths[i];
        if (path2.isLogicalExpression()) {
          if (path2.node.operator === "&&") {
            paths.push(path2.get("left"));
            paths.push(path2.get("right"));
          }
        } else if (path2.isBinaryExpression()) {
          const type = inferAnnotationFromBinaryExpression(name, path2);
          if (type) types.push(type);
        }
      }
      if (types.length) {
        return {
          typeAnnotation: (0, _util.createUnionType)(types),
          ifStatement: ifStatement3
        };
      }
      return getConditionalAnnotation(binding, ifStatement3, name);
    }
  }
});

// node_modules/@babel/helpers/node_modules/@babel/traverse/lib/path/inference/inferers.js
var require_inferers = __commonJS({
  "node_modules/@babel/helpers/node_modules/@babel/traverse/lib/path/inference/inferers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ArrayExpression = ArrayExpression6;
    exports2.AssignmentExpression = AssignmentExpression;
    exports2.BinaryExpression = BinaryExpression;
    exports2.BooleanLiteral = BooleanLiteral;
    exports2.CallExpression = CallExpression4;
    exports2.ConditionalExpression = ConditionalExpression;
    exports2.ClassDeclaration = exports2.ClassExpression = exports2.FunctionDeclaration = exports2.ArrowFunctionExpression = exports2.FunctionExpression = Func;
    Object.defineProperty(exports2, "Identifier", {
      enumerable: true,
      get: function() {
        return _infererReference.default;
      }
    });
    exports2.LogicalExpression = LogicalExpression;
    exports2.NewExpression = NewExpression;
    exports2.NullLiteral = NullLiteral;
    exports2.NumericLiteral = NumericLiteral;
    exports2.ObjectExpression = ObjectExpression;
    exports2.ParenthesizedExpression = ParenthesizedExpression;
    exports2.RegExpLiteral = RegExpLiteral;
    exports2.RestElement = RestElement;
    exports2.SequenceExpression = SequenceExpression;
    exports2.StringLiteral = StringLiteral;
    exports2.TSAsExpression = TSAsExpression;
    exports2.TSNonNullExpression = TSNonNullExpression;
    exports2.TaggedTemplateExpression = TaggedTemplateExpression;
    exports2.TemplateLiteral = TemplateLiteral;
    exports2.TypeCastExpression = TypeCastExpression;
    exports2.UnaryExpression = UnaryExpression;
    exports2.UpdateExpression = UpdateExpression;
    exports2.VariableDeclarator = VariableDeclarator;
    var _t = require("@babel/types");
    var _infererReference = require_inferer_reference();
    var _util = require_util();
    var {
      BOOLEAN_BINARY_OPERATORS,
      BOOLEAN_UNARY_OPERATORS,
      NUMBER_BINARY_OPERATORS,
      NUMBER_UNARY_OPERATORS,
      STRING_UNARY_OPERATORS,
      anyTypeAnnotation,
      arrayTypeAnnotation,
      booleanTypeAnnotation,
      buildMatchMemberExpression,
      genericTypeAnnotation,
      identifier: identifier4,
      nullLiteralTypeAnnotation,
      numberTypeAnnotation,
      stringTypeAnnotation,
      tupleTypeAnnotation,
      unionTypeAnnotation,
      voidTypeAnnotation,
      isIdentifier
    } = _t;
    function VariableDeclarator() {
      if (!this.get("id").isIdentifier()) return;
      return this.get("init").getTypeAnnotation();
    }
    function TypeCastExpression(node) {
      return node.typeAnnotation;
    }
    TypeCastExpression.validParent = true;
    function TSAsExpression(node) {
      return node.typeAnnotation;
    }
    TSAsExpression.validParent = true;
    function TSNonNullExpression() {
      return this.get("expression").getTypeAnnotation();
    }
    function NewExpression(node) {
      if (node.callee.type === "Identifier") {
        return genericTypeAnnotation(node.callee);
      }
    }
    function TemplateLiteral() {
      return stringTypeAnnotation();
    }
    function UnaryExpression(node) {
      const operator = node.operator;
      if (operator === "void") {
        return voidTypeAnnotation();
      } else if (NUMBER_UNARY_OPERATORS.includes(operator)) {
        return numberTypeAnnotation();
      } else if (STRING_UNARY_OPERATORS.includes(operator)) {
        return stringTypeAnnotation();
      } else if (BOOLEAN_UNARY_OPERATORS.includes(operator)) {
        return booleanTypeAnnotation();
      }
    }
    function BinaryExpression(node) {
      const operator = node.operator;
      if (NUMBER_BINARY_OPERATORS.includes(operator)) {
        return numberTypeAnnotation();
      } else if (BOOLEAN_BINARY_OPERATORS.includes(operator)) {
        return booleanTypeAnnotation();
      } else if (operator === "+") {
        const right = this.get("right");
        const left = this.get("left");
        if (left.isBaseType("number") && right.isBaseType("number")) {
          return numberTypeAnnotation();
        } else if (left.isBaseType("string") || right.isBaseType("string")) {
          return stringTypeAnnotation();
        }
        return unionTypeAnnotation([stringTypeAnnotation(), numberTypeAnnotation()]);
      }
    }
    function LogicalExpression() {
      const argumentTypes = [this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()];
      return (0, _util.createUnionType)(argumentTypes);
    }
    function ConditionalExpression() {
      const argumentTypes = [this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()];
      return (0, _util.createUnionType)(argumentTypes);
    }
    function SequenceExpression() {
      return this.get("expressions").pop().getTypeAnnotation();
    }
    function ParenthesizedExpression() {
      return this.get("expression").getTypeAnnotation();
    }
    function AssignmentExpression() {
      return this.get("right").getTypeAnnotation();
    }
    function UpdateExpression(node) {
      const operator = node.operator;
      if (operator === "++" || operator === "--") {
        return numberTypeAnnotation();
      }
    }
    function StringLiteral() {
      return stringTypeAnnotation();
    }
    function NumericLiteral() {
      return numberTypeAnnotation();
    }
    function BooleanLiteral() {
      return booleanTypeAnnotation();
    }
    function NullLiteral() {
      return nullLiteralTypeAnnotation();
    }
    function RegExpLiteral() {
      return genericTypeAnnotation(identifier4("RegExp"));
    }
    function ObjectExpression() {
      return genericTypeAnnotation(identifier4("Object"));
    }
    function ArrayExpression6() {
      return genericTypeAnnotation(identifier4("Array"));
    }
    function RestElement() {
      return ArrayExpression6();
    }
    RestElement.validParent = true;
    function Func() {
      return genericTypeAnnotation(identifier4("Function"));
    }
    var isArrayFrom = buildMatchMemberExpression("Array.from");
    var isObjectKeys = buildMatchMemberExpression("Object.keys");
    var isObjectValues = buildMatchMemberExpression("Object.values");
    var isObjectEntries = buildMatchMemberExpression("Object.entries");
    function CallExpression4() {
      const {
        callee
      } = this.node;
      if (isObjectKeys(callee)) {
        return arrayTypeAnnotation(stringTypeAnnotation());
      } else if (isArrayFrom(callee) || isObjectValues(callee) || isIdentifier(callee, {
        name: "Array"
      })) {
        return arrayTypeAnnotation(anyTypeAnnotation());
      } else if (isObjectEntries(callee)) {
        return arrayTypeAnnotation(tupleTypeAnnotation([stringTypeAnnotation(), anyTypeAnnotation()]));
      }
      return resolveCall(this.get("callee"));
    }
    function TaggedTemplateExpression() {
      return resolveCall(this.get("tag"));
    }
    function resolveCall(callee) {
      callee = callee.resolve();
      if (callee.isFunction()) {
        const {
          node
        } = callee;
        if (node.async) {
          if (node.generator) {
            return genericTypeAnnotation(identifier4("AsyncIterator"));
          } else {
            return genericTypeAnnotation(identifier4("Promise"));
          }
        } else {
          if (node.generator) {
            return genericTypeAnnotation(identifier4("Iterator"));
          } else if (callee.node.returnType) {
            return callee.node.returnType;
          } else {
          }
        }
      }
    }
  }
});

// node_modules/@babel/helpers/node_modules/@babel/traverse/lib/path/inference/index.js
var require_inference = __commonJS({
  "node_modules/@babel/helpers/node_modules/@babel/traverse/lib/path/inference/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2._getTypeAnnotation = _getTypeAnnotation;
    exports2.baseTypeStrictlyMatches = baseTypeStrictlyMatches;
    exports2.couldBeBaseType = couldBeBaseType;
    exports2.getTypeAnnotation = getTypeAnnotation;
    exports2.isBaseType = isBaseType;
    exports2.isGenericType = isGenericType;
    var inferers = require_inferers();
    var _t = require("@babel/types");
    var {
      anyTypeAnnotation,
      isAnyTypeAnnotation,
      isArrayTypeAnnotation,
      isBooleanTypeAnnotation,
      isEmptyTypeAnnotation,
      isFlowBaseAnnotation,
      isGenericTypeAnnotation,
      isIdentifier,
      isMixedTypeAnnotation,
      isNumberTypeAnnotation,
      isStringTypeAnnotation,
      isTSArrayType,
      isTSTypeAnnotation,
      isTSTypeReference,
      isTupleTypeAnnotation,
      isTypeAnnotation,
      isUnionTypeAnnotation,
      isVoidTypeAnnotation,
      stringTypeAnnotation,
      voidTypeAnnotation
    } = _t;
    function getTypeAnnotation() {
      let type = this.getData("typeAnnotation");
      if (type != null) {
        return type;
      }
      type = _getTypeAnnotation.call(this) || anyTypeAnnotation();
      if (isTypeAnnotation(type) || isTSTypeAnnotation(type)) {
        type = type.typeAnnotation;
      }
      this.setData("typeAnnotation", type);
      return type;
    }
    var typeAnnotationInferringNodes = /* @__PURE__ */ new WeakSet();
    function _getTypeAnnotation() {
      const node = this.node;
      if (!node) {
        if (this.key === "init" && this.parentPath.isVariableDeclarator()) {
          const declar = this.parentPath.parentPath;
          const declarParent = declar.parentPath;
          if (declar.key === "left" && declarParent.isForInStatement()) {
            return stringTypeAnnotation();
          }
          if (declar.key === "left" && declarParent.isForOfStatement()) {
            return anyTypeAnnotation();
          }
          return voidTypeAnnotation();
        } else {
          return;
        }
      }
      if (node.typeAnnotation) {
        return node.typeAnnotation;
      }
      if (typeAnnotationInferringNodes.has(node)) {
        return;
      }
      typeAnnotationInferringNodes.add(node);
      try {
        var _inferer;
        let inferer = inferers[node.type];
        if (inferer) {
          return inferer.call(this, node);
        }
        inferer = inferers[this.parentPath.type];
        if ((_inferer = inferer) != null && _inferer.validParent) {
          return this.parentPath.getTypeAnnotation();
        }
      } finally {
        typeAnnotationInferringNodes.delete(node);
      }
    }
    function isBaseType(baseName, soft) {
      return _isBaseType(baseName, this.getTypeAnnotation(), soft);
    }
    function _isBaseType(baseName, type, soft) {
      if (baseName === "string") {
        return isStringTypeAnnotation(type);
      } else if (baseName === "number") {
        return isNumberTypeAnnotation(type);
      } else if (baseName === "boolean") {
        return isBooleanTypeAnnotation(type);
      } else if (baseName === "any") {
        return isAnyTypeAnnotation(type);
      } else if (baseName === "mixed") {
        return isMixedTypeAnnotation(type);
      } else if (baseName === "empty") {
        return isEmptyTypeAnnotation(type);
      } else if (baseName === "void") {
        return isVoidTypeAnnotation(type);
      } else {
        if (soft) {
          return false;
        } else {
          throw new Error(`Unknown base type ${baseName}`);
        }
      }
    }
    function couldBeBaseType(name) {
      const type = this.getTypeAnnotation();
      if (isAnyTypeAnnotation(type)) return true;
      if (isUnionTypeAnnotation(type)) {
        for (const type2 of type.types) {
          if (isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) {
            return true;
          }
        }
        return false;
      } else {
        return _isBaseType(name, type, true);
      }
    }
    function baseTypeStrictlyMatches(rightArg) {
      const left = this.getTypeAnnotation();
      const right = rightArg.getTypeAnnotation();
      if (!isAnyTypeAnnotation(left) && isFlowBaseAnnotation(left)) {
        return right.type === left.type;
      }
      return false;
    }
    function isGenericType(genericName) {
      const type = this.getTypeAnnotation();
      if (genericName === "Array") {
        if (isTSArrayType(type) || isArrayTypeAnnotation(type) || isTupleTypeAnnotation(type)) {
          return true;
        }
      }
      return isGenericTypeAnnotation(type) && isIdentifier(type.id, {
        name: genericName
      }) || isTSTypeReference(type) && isIdentifier(type.typeName, {
        name: genericName
      });
    }
  }
});

// ../../node_modules/picocolors/picocolors.js
var require_picocolors = __commonJS({
  "../../node_modules/picocolors/picocolors.js"(exports2, module2) {
    "use strict";
    var p = process || {};
    var argv = p.argv || [];
    var env = p.env || {};
    var isColorSupported = !(!!env.NO_COLOR || argv.includes("--no-color")) && (!!env.FORCE_COLOR || argv.includes("--color") || p.platform === "win32" || (p.stdout || {}).isTTY && env.TERM !== "dumb" || !!env.CI);
    var formatter = (open, close, replace = open) => (input) => {
      let string = "" + input, index = string.indexOf(close, open.length);
      return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;
    };
    var replaceClose = (string, close, replace, index) => {
      let result = "", cursor = 0;
      do {
        result += string.substring(cursor, index) + replace;
        cursor = index + close.length;
        index = string.indexOf(close, cursor);
      } while (~index);
      return result + string.substring(cursor);
    };
    var createColors = (enabled = isColorSupported) => {
      let f = enabled ? formatter : () => String;
      return {
        isColorSupported: enabled,
        reset: f("\x1B[0m", "\x1B[0m"),
        bold: f("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m"),
        dim: f("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m"),
        italic: f("\x1B[3m", "\x1B[23m"),
        underline: f("\x1B[4m", "\x1B[24m"),
        inverse: f("\x1B[7m", "\x1B[27m"),
        hidden: f("\x1B[8m", "\x1B[28m"),
        strikethrough: f("\x1B[9m", "\x1B[29m"),
        black: f("\x1B[30m", "\x1B[39m"),
        red: f("\x1B[31m", "\x1B[39m"),
        green: f("\x1B[32m", "\x1B[39m"),
        yellow: f("\x1B[33m", "\x1B[39m"),
        blue: f("\x1B[34m", "\x1B[39m"),
        magenta: f("\x1B[35m", "\x1B[39m"),
        cyan: f("\x1B[36m", "\x1B[39m"),
        white: f("\x1B[37m", "\x1B[39m"),
        gray: f("\x1B[90m", "\x1B[39m"),
        bgBlack: f("\x1B[40m", "\x1B[49m"),
        bgRed: f("\x1B[41m", "\x1B[49m"),
        bgGreen: f("\x1B[42m", "\x1B[49m"),
        bgYellow: f("\x1B[43m", "\x1B[49m"),
        bgBlue: f("\x1B[44m", "\x1B[49m"),
        bgMagenta: f("\x1B[45m", "\x1B[49m"),
        bgCyan: f("\x1B[46m", "\x1B[49m"),
        bgWhite: f("\x1B[47m", "\x1B[49m"),
        blackBright: f("\x1B[90m", "\x1B[39m"),
        redBright: f("\x1B[91m", "\x1B[39m"),
        greenBright: f("\x1B[92m", "\x1B[39m"),
        yellowBright: f("\x1B[93m", "\x1B[39m"),
        blueBright: f("\x1B[94m", "\x1B[39m"),
        magentaBright: f("\x1B[95m", "\x1B[39m"),
        cyanBright: f("\x1B[96m", "\x1B[39m"),
        whiteBright: f("\x1B[97m", "\x1B[39m"),
        bgBlackBright: f("\x1B[100m", "\x1B[49m"),
        bgRedBright: f("\x1B[101m", "\x1B[49m"),
        bgGreenBright: f("\x1B[102m", "\x1B[49m"),
        bgYellowBright: f("\x1B[103m", "\x1B[49m"),
        bgBlueBright: f("\x1B[104m", "\x1B[49m"),
        bgMagentaBright: f("\x1B[105m", "\x1B[49m"),
        bgCyanBright: f("\x1B[106m", "\x1B[49m"),
        bgWhiteBright: f("\x1B[107m", "\x1B[49m")
      };
    };
    module2.exports = createColors();
    module2.exports.createColors = createColors;
  }
});

// ../../node_modules/js-tokens/index.js
var require_js_tokens = __commonJS({
  "../../node_modules/js-tokens/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;
    exports2.matchToToken = function(match) {
      var token2 = { type: "invalid", value: match[0], closed: void 0 };
      if (match[1]) token2.type = "string", token2.closed = !!(match[3] || match[4]);
      else if (match[5]) token2.type = "comment";
      else if (match[6]) token2.type = "comment", token2.closed = !!match[7];
      else if (match[8]) token2.type = "regex";
      else if (match[9]) token2.type = "number";
      else if (match[10]) token2.type = "name";
      else if (match[11]) token2.type = "punctuator";
      else if (match[12]) token2.type = "whitespace";
      return token2;
    };
  }
});

// ../../node_modules/@babel/helper-validator-identifier/lib/identifier.js
var require_identifier = __commonJS({
  "../../node_modules/@babel/helper-validator-identifier/lib/identifier.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isIdentifierChar = isIdentifierChar;
    exports2.isIdentifierName = isIdentifierName;
    exports2.isIdentifierStart = isIdentifierStart;
    var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
    var nonASCIIidentifierChars = "\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65";
    var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
    var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
    nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
    var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
    var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
    function isInAstralSet(code, set) {
      let pos2 = 65536;
      for (let i = 0, length = set.length; i < length; i += 2) {
        pos2 += set[i];
        if (pos2 > code) return false;
        pos2 += set[i + 1];
        if (pos2 >= code) return true;
      }
      return false;
    }
    function isIdentifierStart(code) {
      if (code < 65) return code === 36;
      if (code <= 90) return true;
      if (code < 97) return code === 95;
      if (code <= 122) return true;
      if (code <= 65535) {
        return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
      }
      return isInAstralSet(code, astralIdentifierStartCodes);
    }
    function isIdentifierChar(code) {
      if (code < 48) return code === 36;
      if (code < 58) return true;
      if (code < 65) return false;
      if (code <= 90) return true;
      if (code < 97) return code === 95;
      if (code <= 122) return true;
      if (code <= 65535) {
        return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
      }
      return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
    }
    function isIdentifierName(name) {
      let isFirst = true;
      for (let i = 0; i < name.length; i++) {
        let cp = name.charCodeAt(i);
        if ((cp & 64512) === 55296 && i + 1 < name.length) {
          const trail = name.charCodeAt(++i);
          if ((trail & 64512) === 56320) {
            cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
          }
        }
        if (isFirst) {
          isFirst = false;
          if (!isIdentifierStart(cp)) {
            return false;
          }
        } else if (!isIdentifierChar(cp)) {
          return false;
        }
      }
      return !isFirst;
    }
  }
});

// ../../node_modules/@babel/helper-validator-identifier/lib/keyword.js
var require_keyword = __commonJS({
  "../../node_modules/@babel/helper-validator-identifier/lib/keyword.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isKeyword = isKeyword;
    exports2.isReservedWord = isReservedWord2;
    exports2.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;
    exports2.isStrictBindReservedWord = isStrictBindReservedWord;
    exports2.isStrictReservedWord = isStrictReservedWord;
    var reservedWords = {
      keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
      strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
      strictBind: ["eval", "arguments"]
    };
    var keywords = new Set(reservedWords.keyword);
    var reservedWordsStrictSet = new Set(reservedWords.strict);
    var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
    function isReservedWord2(word, inModule) {
      return inModule && word === "await" || word === "enum";
    }
    function isStrictReservedWord(word, inModule) {
      return isReservedWord2(word, inModule) || reservedWordsStrictSet.has(word);
    }
    function isStrictBindOnlyReservedWord(word) {
      return reservedWordsStrictBindSet.has(word);
    }
    function isStrictBindReservedWord(word, inModule) {
      return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
    }
    function isKeyword(word) {
      return keywords.has(word);
    }
  }
});

// ../../node_modules/@babel/helper-validator-identifier/lib/index.js
var require_lib2 = __commonJS({
  "../../node_modules/@babel/helper-validator-identifier/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "isIdentifierChar", {
      enumerable: true,
      get: function() {
        return _identifier.isIdentifierChar;
      }
    });
    Object.defineProperty(exports2, "isIdentifierName", {
      enumerable: true,
      get: function() {
        return _identifier.isIdentifierName;
      }
    });
    Object.defineProperty(exports2, "isIdentifierStart", {
      enumerable: true,
      get: function() {
        return _identifier.isIdentifierStart;
      }
    });
    Object.defineProperty(exports2, "isKeyword", {
      enumerable: true,
      get: function() {
        return _keyword.isKeyword;
      }
    });
    Object.defineProperty(exports2, "isReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isReservedWord;
      }
    });
    Object.defineProperty(exports2, "isStrictBindOnlyReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isStrictBindOnlyReservedWord;
      }
    });
    Object.defineProperty(exports2, "isStrictBindReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isStrictBindReservedWord;
      }
    });
    Object.defineProperty(exports2, "isStrictReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isStrictReservedWord;
      }
    });
    var _identifier = require_identifier();
    var _keyword = require_keyword();
  }
});

// ../../node_modules/@babel/code-frame/lib/index.js
var require_lib3 = __commonJS({
  "../../node_modules/@babel/code-frame/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var picocolors = require_picocolors();
    var jsTokens = require_js_tokens();
    var helperValidatorIdentifier = require_lib2();
    function isColorSupported() {
      return typeof process === "object" && (process.env.FORCE_COLOR === "0" || process.env.FORCE_COLOR === "false") ? false : picocolors.isColorSupported;
    }
    var compose = (f, g) => (v) => f(g(v));
    function buildDefs(colors) {
      return {
        keyword: colors.cyan,
        capitalized: colors.yellow,
        jsxIdentifier: colors.yellow,
        punctuator: colors.yellow,
        number: colors.magenta,
        string: colors.green,
        regex: colors.magenta,
        comment: colors.gray,
        invalid: compose(compose(colors.white, colors.bgRed), colors.bold),
        gutter: colors.gray,
        marker: compose(colors.red, colors.bold),
        message: compose(colors.red, colors.bold),
        reset: colors.reset
      };
    }
    var defsOn = buildDefs(picocolors.createColors(true));
    var defsOff = buildDefs(picocolors.createColors(false));
    function getDefs(enabled) {
      return enabled ? defsOn : defsOff;
    }
    var sometimesKeywords = /* @__PURE__ */ new Set(["as", "async", "from", "get", "of", "set"]);
    var NEWLINE$1 = /\r\n|[\n\r\u2028\u2029]/;
    var BRACKET = /^[()[\]{}]$/;
    var tokenize;
    {
      const JSX_TAG = /^[a-z][\w-]*$/i;
      const getTokenType = function(token2, offset, text) {
        if (token2.type === "name") {
          if (helperValidatorIdentifier.isKeyword(token2.value) || helperValidatorIdentifier.isStrictReservedWord(token2.value, true) || sometimesKeywords.has(token2.value)) {
            return "keyword";
          }
          if (JSX_TAG.test(token2.value) && (text[offset - 1] === "<" || text.slice(offset - 2, offset) === "</")) {
            return "jsxIdentifier";
          }
          if (token2.value[0] !== token2.value[0].toLowerCase()) {
            return "capitalized";
          }
        }
        if (token2.type === "punctuator" && BRACKET.test(token2.value)) {
          return "bracket";
        }
        if (token2.type === "invalid" && (token2.value === "@" || token2.value === "#")) {
          return "punctuator";
        }
        return token2.type;
      };
      tokenize = function* (text) {
        let match;
        while (match = jsTokens.default.exec(text)) {
          const token2 = jsTokens.matchToToken(match);
          yield {
            type: getTokenType(token2, match.index, text),
            value: token2.value
          };
        }
      };
    }
    function highlight(text) {
      if (text === "") return "";
      const defs = getDefs(true);
      let highlighted = "";
      for (const {
        type,
        value
      } of tokenize(text)) {
        if (type in defs) {
          highlighted += value.split(NEWLINE$1).map((str) => defs[type](str)).join("\n");
        } else {
          highlighted += value;
        }
      }
      return highlighted;
    }
    var deprecationWarningShown = false;
    var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
    function getMarkerLines(loc, source2, opts) {
      const startLoc = Object.assign({
        column: 0,
        line: -1
      }, loc.start);
      const endLoc = Object.assign({}, startLoc, loc.end);
      const {
        linesAbove = 2,
        linesBelow = 3
      } = opts || {};
      const startLine = startLoc.line;
      const startColumn = startLoc.column;
      const endLine = endLoc.line;
      const endColumn = endLoc.column;
      let start = Math.max(startLine - (linesAbove + 1), 0);
      let end = Math.min(source2.length, endLine + linesBelow);
      if (startLine === -1) {
        start = 0;
      }
      if (endLine === -1) {
        end = source2.length;
      }
      const lineDiff = endLine - startLine;
      const markerLines = {};
      if (lineDiff) {
        for (let i = 0; i <= lineDiff; i++) {
          const lineNumber = i + startLine;
          if (!startColumn) {
            markerLines[lineNumber] = true;
          } else if (i === 0) {
            const sourceLength = source2[lineNumber - 1].length;
            markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];
          } else if (i === lineDiff) {
            markerLines[lineNumber] = [0, endColumn];
          } else {
            const sourceLength = source2[lineNumber - i].length;
            markerLines[lineNumber] = [0, sourceLength];
          }
        }
      } else {
        if (startColumn === endColumn) {
          if (startColumn) {
            markerLines[startLine] = [startColumn, 0];
          } else {
            markerLines[startLine] = true;
          }
        } else {
          markerLines[startLine] = [startColumn, endColumn - startColumn];
        }
      }
      return {
        start,
        end,
        markerLines
      };
    }
    function codeFrameColumns2(rawLines, loc, opts = {}) {
      const shouldHighlight = opts.forceColor || isColorSupported() && opts.highlightCode;
      const defs = getDefs(shouldHighlight);
      const lines = rawLines.split(NEWLINE);
      const {
        start,
        end,
        markerLines
      } = getMarkerLines(loc, lines, opts);
      const hasColumns = loc.start && typeof loc.start.column === "number";
      const numberMaxWidth = String(end).length;
      const highlightedLines = shouldHighlight ? highlight(rawLines) : rawLines;
      let frame = highlightedLines.split(NEWLINE, end).slice(start, end).map((line2, index2) => {
        const number = start + 1 + index2;
        const paddedNumber = ` ${number}`.slice(-numberMaxWidth);
        const gutter = ` ${paddedNumber} |`;
        const hasMarker = markerLines[number];
        const lastMarkerLine = !markerLines[number + 1];
        if (hasMarker) {
          let markerLine = "";
          if (Array.isArray(hasMarker)) {
            const markerSpacing = line2.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\t]/g, " ");
            const numberOfMarkers = hasMarker[1] || 1;
            markerLine = ["\n ", defs.gutter(gutter.replace(/\d/g, " ")), " ", markerSpacing, defs.marker("^").repeat(numberOfMarkers)].join("");
            if (lastMarkerLine && opts.message) {
              markerLine += " " + defs.message(opts.message);
            }
          }
          return [defs.marker(">"), defs.gutter(gutter), line2.length > 0 ? ` ${line2}` : "", markerLine].join("");
        } else {
          return ` ${defs.gutter(gutter)}${line2.length > 0 ? ` ${line2}` : ""}`;
        }
      }).join("\n");
      if (opts.message && !hasColumns) {
        frame = `${" ".repeat(numberMaxWidth + 1)}${opts.message}
${frame}`;
      }
      if (shouldHighlight) {
        return defs.reset(frame);
      } else {
        return frame;
      }
    }
    function index(rawLines, lineNumber, colNumber, opts = {}) {
      if (!deprecationWarningShown) {
        deprecationWarningShown = true;
        const message = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
        if (process.emitWarning) {
          process.emitWarning(message, "DeprecationWarning");
        } else {
          const deprecationError = new Error(message);
          deprecationError.name = "DeprecationWarning";
          console.warn(new Error(message));
        }
      }
      colNumber = Math.max(colNumber, 0);
      const location = {
        start: {
          column: colNumber,
          line: lineNumber
        }
      };
      return codeFrameColumns2(rawLines, location, opts);
    }
    exports2.codeFrameColumns = codeFrameColumns2;
    exports2.default = index;
    exports2.highlight = highlight;
  }
});

// node_modules/@babel/helpers/node_modules/@babel/traverse/lib/path/lib/hoister.js
var require_hoister = __commonJS({
  "node_modules/@babel/helpers/node_modules/@babel/traverse/lib/path/lib/hoister.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _t = require("@babel/types");
    var _t2 = _t;
    var {
      react
    } = _t;
    var {
      cloneNode: cloneNode2,
      jsxExpressionContainer: jsxExpressionContainer2,
      variableDeclaration: variableDeclaration3,
      variableDeclarator: variableDeclarator3
    } = _t2;
    var referenceVisitor = {
      ReferencedIdentifier(path, state) {
        if (path.isJSXIdentifier() && react.isCompatTag(path.node.name) && !path.parentPath.isJSXMemberExpression()) {
          return;
        }
        if (path.node.name === "this") {
          let scope = path.scope;
          do {
            if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {
              break;
            }
          } while (scope = scope.parent);
          if (scope) state.breakOnScopePaths.push(scope.path);
        }
        const binding = path.scope.getBinding(path.node.name);
        if (!binding) return;
        for (const violation of binding.constantViolations) {
          if (violation.scope !== binding.path.scope) {
            state.mutableBinding = true;
            path.stop();
            return;
          }
        }
        if (binding !== state.scope.getBinding(path.node.name)) return;
        state.bindings[path.node.name] = binding;
      }
    };
    var PathHoister = class {
      constructor(path, scope) {
        this.breakOnScopePaths = void 0;
        this.bindings = void 0;
        this.mutableBinding = void 0;
        this.scopes = void 0;
        this.scope = void 0;
        this.path = void 0;
        this.attachAfter = void 0;
        this.breakOnScopePaths = [];
        this.bindings = {};
        this.mutableBinding = false;
        this.scopes = [];
        this.scope = scope;
        this.path = path;
        this.attachAfter = false;
      }
      isCompatibleScope(scope) {
        for (const key2 of Object.keys(this.bindings)) {
          const binding = this.bindings[key2];
          if (!scope.bindingIdentifierEquals(key2, binding.identifier)) {
            return false;
          }
        }
        return true;
      }
      getCompatibleScopes() {
        let scope = this.path.scope;
        do {
          if (this.isCompatibleScope(scope)) {
            this.scopes.push(scope);
          } else {
            break;
          }
          if (this.breakOnScopePaths.includes(scope.path)) {
            break;
          }
        } while (scope = scope.parent);
      }
      getAttachmentPath() {
        let path = this._getAttachmentPath();
        if (!path) return;
        let targetScope = path.scope;
        if (targetScope.path === path) {
          targetScope = path.scope.parent;
        }
        if (targetScope.path.isProgram() || targetScope.path.isFunction()) {
          for (const name of Object.keys(this.bindings)) {
            if (!targetScope.hasOwnBinding(name)) continue;
            const binding = this.bindings[name];
            if (binding.kind === "param" || binding.path.parentKey === "params") {
              continue;
            }
            const bindingParentPath = this.getAttachmentParentForPath(binding.path);
            if (bindingParentPath.key >= path.key) {
              this.attachAfter = true;
              path = binding.path;
              for (const violationPath of binding.constantViolations) {
                if (this.getAttachmentParentForPath(violationPath).key > path.key) {
                  path = violationPath;
                }
              }
            }
          }
        }
        return path;
      }
      _getAttachmentPath() {
        const scopes = this.scopes;
        const scope = scopes.pop();
        if (!scope) return;
        if (scope.path.isFunction()) {
          if (this.hasOwnParamBindings(scope)) {
            if (this.scope === scope) return;
            const bodies = scope.path.get("body").get("body");
            for (let i = 0; i < bodies.length; i++) {
              if (bodies[i].node._blockHoist) continue;
              return bodies[i];
            }
          } else {
            return this.getNextScopeAttachmentParent();
          }
        } else if (scope.path.isProgram()) {
          return this.getNextScopeAttachmentParent();
        }
      }
      getNextScopeAttachmentParent() {
        const scope = this.scopes.pop();
        if (scope) return this.getAttachmentParentForPath(scope.path);
      }
      getAttachmentParentForPath(path) {
        do {
          if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {
            return path;
          }
        } while (path = path.parentPath);
      }
      hasOwnParamBindings(scope) {
        for (const name of Object.keys(this.bindings)) {
          if (!scope.hasOwnBinding(name)) continue;
          const binding = this.bindings[name];
          if (binding.kind === "param" && binding.constant) return true;
        }
        return false;
      }
      run() {
        this.path.traverse(referenceVisitor, this);
        if (this.mutableBinding) return;
        this.getCompatibleScopes();
        const attachTo = this.getAttachmentPath();
        if (!attachTo) return;
        if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;
        let uid = attachTo.scope.generateUidIdentifier("ref");
        const declarator = variableDeclarator3(uid, this.path.node);
        const insertFn = this.attachAfter ? "insertAfter" : "insertBefore";
        const [attached] = attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : variableDeclaration3("var", [declarator])]);
        const parent = this.path.parentPath;
        if (parent.isJSXElement() && this.path.container === parent.node.children) {
          uid = jsxExpressionContainer2(uid);
        }
        this.path.replaceWith(cloneNode2(uid));
        return attachTo.isVariableDeclarator() ? attached.get("init") : attached.get("declarations.0.init");
      }
    };
    exports2.default = PathHoister;
  }
});

// node_modules/@babel/helpers/node_modules/@babel/traverse/lib/path/lib/removal-hooks.js
var require_removal_hooks = __commonJS({
  "node_modules/@babel/helpers/node_modules/@babel/traverse/lib/path/lib/removal-hooks.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.hooks = void 0;
    var hooks = exports2.hooks = [function(self2, parent) {
      const removeParent = self2.key === "test" && (parent.isWhile() || parent.isSwitchCase()) || self2.key === "declaration" && parent.isExportDeclaration() || self2.key === "body" && parent.isLabeledStatement() || self2.listKey === "declarations" && parent.isVariableDeclaration() && parent.node.declarations.length === 1 || self2.key === "expression" && parent.isExpressionStatement();
      if (removeParent) {
        parent.remove();
        return true;
      }
    }, function(self2, parent) {
      if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {
        parent.replaceWith(parent.node.expressions[0]);
        return true;
      }
    }, function(self2, parent) {
      if (parent.isBinary()) {
        if (self2.key === "left") {
          parent.replaceWith(parent.node.right);
        } else {
          parent.replaceWith(parent.node.left);
        }
        return true;
      }
    }, function(self2, parent) {
      if (parent.isIfStatement() && self2.key === "consequent" || self2.key === "body" && (parent.isLoop() || parent.isArrowFunctionExpression())) {
        self2.replaceWith({
          type: "BlockStatement",
          body: []
        });
        return true;
      }
    }];
  }
});

// node_modules/@babel/helpers/node_modules/@babel/traverse/lib/path/removal.js
var require_removal = __commonJS({
  "node_modules/@babel/helpers/node_modules/@babel/traverse/lib/path/removal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2._assertUnremoved = _assertUnremoved;
    exports2._callRemovalHooks = _callRemovalHooks;
    exports2._markRemoved = _markRemoved;
    exports2._remove = _remove;
    exports2._removeFromScope = _removeFromScope;
    exports2.remove = remove;
    var _removalHooks = require_removal_hooks();
    var _cache = require_cache();
    var _replacement = require_replacement();
    var _index = require_path();
    var _t = require("@babel/types");
    var _modification = require_modification();
    var _context3 = require_context2();
    var {
      getBindingIdentifiers
    } = _t;
    function remove() {
      var _this$opts;
      _assertUnremoved.call(this);
      _context3.resync.call(this);
      if (_callRemovalHooks.call(this)) {
        _markRemoved.call(this);
        return;
      }
      if (!((_this$opts = this.opts) != null && _this$opts.noScope)) {
        _removeFromScope.call(this);
      }
      this.shareCommentsWithSiblings();
      _remove.call(this);
      _markRemoved.call(this);
    }
    function _removeFromScope() {
      const bindings = getBindingIdentifiers(this.node, false, false, true);
      Object.keys(bindings).forEach((name) => this.scope.removeBinding(name));
    }
    function _callRemovalHooks() {
      if (this.parentPath) {
        for (const fn of _removalHooks.hooks) {
          if (fn(this, this.parentPath)) return true;
        }
      }
    }
    function _remove() {
      if (Array.isArray(this.container)) {
        this.container.splice(this.key, 1);
        _modification.updateSiblingKeys.call(this, this.key, -1);
      } else {
        _replacement._replaceWith.call(this, null);
      }
    }
    function _markRemoved() {
      this._traverseFlags |= _index.SHOULD_SKIP | _index.REMOVED;
      if (this.parent) {
        (0, _cache.getCachedPaths)(this.hub, this.parent).delete(this.node);
      }
      this.node = null;
    }
    function _assertUnremoved() {
      if (this.removed) {
        throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
      }
    }
  }
});

// node_modules/@babel/helpers/node_modules/@babel/traverse/lib/path/modification.js
var require_modification = __commonJS({
  "node_modules/@babel/helpers/node_modules/@babel/traverse/lib/path/modification.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2._containerInsert = _containerInsert;
    exports2._containerInsertAfter = _containerInsertAfter;
    exports2._containerInsertBefore = _containerInsertBefore;
    exports2._verifyNodeList = _verifyNodeList;
    exports2.insertAfter = insertAfter;
    exports2.insertBefore = insertBefore;
    exports2.pushContainer = pushContainer;
    exports2.unshiftContainer = unshiftContainer;
    exports2.updateSiblingKeys = updateSiblingKeys;
    var _cache = require_cache();
    var _hoister = require_hoister();
    var _index = require_path();
    var _context3 = require_context2();
    var _removal = require_removal();
    var _t = require("@babel/types");
    var {
      arrowFunctionExpression: arrowFunctionExpression2,
      assertExpression,
      assignmentExpression: assignmentExpression2,
      blockStatement: blockStatement3,
      callExpression: callExpression3,
      cloneNode: cloneNode2,
      expressionStatement: expressionStatement2,
      isAssignmentExpression,
      isCallExpression,
      isExportNamedDeclaration,
      isExpression: isExpression2,
      isIdentifier,
      isSequenceExpression,
      isSuper,
      thisExpression
    } = _t;
    function insertBefore(nodes_) {
      _removal._assertUnremoved.call(this);
      const nodes = _verifyNodeList.call(this, nodes_);
      const {
        parentPath,
        parent
      } = this;
      if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || isExportNamedDeclaration(parent) || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {
        return parentPath.insertBefore(nodes);
      } else if (this.isNodeType("Expression") && !this.isJSXElement() || parentPath.isForStatement() && this.key === "init") {
        if (this.node) nodes.push(this.node);
        return this.replaceExpressionWithStatements(nodes);
      } else if (Array.isArray(this.container)) {
        return _containerInsertBefore.call(this, nodes);
      } else if (this.isStatementOrBlock()) {
        const node = this.node;
        const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);
        this.replaceWith(blockStatement3(shouldInsertCurrentNode ? [node] : []));
        return this.unshiftContainer("body", nodes);
      } else {
        throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
      }
    }
    function _containerInsert(from, nodes) {
      updateSiblingKeys.call(this, from, nodes.length);
      const paths = [];
      this.container.splice(from, 0, ...nodes);
      for (let i = 0; i < nodes.length; i++) {
        var _this$context;
        const to = from + i;
        const path = this.getSibling(to);
        paths.push(path);
        if ((_this$context = this.context) != null && _this$context.queue) {
          _context3.pushContext.call(path, this.context);
        }
      }
      const contexts = _context3._getQueueContexts.call(this);
      for (const path of paths) {
        _context3.setScope.call(path);
        path.debug("Inserted.");
        for (const context of contexts) {
          context.maybeQueue(path, true);
        }
      }
      return paths;
    }
    function _containerInsertBefore(nodes) {
      return _containerInsert.call(this, this.key, nodes);
    }
    function _containerInsertAfter(nodes) {
      return _containerInsert.call(this, this.key + 1, nodes);
    }
    var last = (arr) => arr[arr.length - 1];
    function isHiddenInSequenceExpression(path) {
      return isSequenceExpression(path.parent) && (last(path.parent.expressions) !== path.node || isHiddenInSequenceExpression(path.parentPath));
    }
    function isAlmostConstantAssignment(node, scope) {
      if (!isAssignmentExpression(node) || !isIdentifier(node.left)) {
        return false;
      }
      const blockScope = scope.getBlockParent();
      return blockScope.hasOwnBinding(node.left.name) && blockScope.getOwnBinding(node.left.name).constantViolations.length <= 1;
    }
    function insertAfter(nodes_) {
      _removal._assertUnremoved.call(this);
      if (this.isSequenceExpression()) {
        return last(this.get("expressions")).insertAfter(nodes_);
      }
      const nodes = _verifyNodeList.call(this, nodes_);
      const {
        parentPath,
        parent
      } = this;
      if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || isExportNamedDeclaration(parent) || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {
        return parentPath.insertAfter(nodes.map((node) => {
          return isExpression2(node) ? expressionStatement2(node) : node;
        }));
      } else if (this.isNodeType("Expression") && !this.isJSXElement() && !parentPath.isJSXElement() || parentPath.isForStatement() && this.key === "init") {
        const self2 = this;
        if (self2.node) {
          const node = self2.node;
          let {
            scope
          } = this;
          if (scope.path.isPattern()) {
            assertExpression(node);
            self2.replaceWith(callExpression3(arrowFunctionExpression2([], node), []));
            self2.get("callee.body").insertAfter(nodes);
            return [self2];
          }
          if (isHiddenInSequenceExpression(self2)) {
            nodes.unshift(node);
          } else if (isCallExpression(node) && isSuper(node.callee)) {
            nodes.unshift(node);
            nodes.push(thisExpression());
          } else if (isAlmostConstantAssignment(node, scope)) {
            nodes.unshift(node);
            nodes.push(cloneNode2(node.left));
          } else if (scope.isPure(node, true)) {
            nodes.push(node);
          } else {
            if (parentPath.isMethod({
              computed: true,
              key: node
            })) {
              scope = scope.parent;
            }
            const temp = scope.generateDeclaredUidIdentifier();
            nodes.unshift(expressionStatement2(assignmentExpression2("=", cloneNode2(temp), node)));
            nodes.push(expressionStatement2(cloneNode2(temp)));
          }
        }
        return this.replaceExpressionWithStatements(nodes);
      } else if (Array.isArray(this.container)) {
        return _containerInsertAfter.call(this, nodes);
      } else if (this.isStatementOrBlock()) {
        const node = this.node;
        const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);
        this.replaceWith(blockStatement3(shouldInsertCurrentNode ? [node] : []));
        return this.pushContainer("body", nodes);
      } else {
        throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
      }
    }
    function updateSiblingKeys(fromIndex, incrementBy) {
      if (!this.parent) return;
      const paths = (0, _cache.getCachedPaths)(this.hub, this.parent) || [];
      for (const [, path] of paths) {
        if (typeof path.key === "number" && path.container === this.container && path.key >= fromIndex) {
          path.key += incrementBy;
        }
      }
    }
    function _verifyNodeList(nodes) {
      if (!nodes) {
        return [];
      }
      if (!Array.isArray(nodes)) {
        nodes = [nodes];
      }
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        let msg;
        if (!node) {
          msg = "has falsy node";
        } else if (typeof node !== "object") {
          msg = "contains a non-object node";
        } else if (!node.type) {
          msg = "without a type";
        } else if (node instanceof _index.default) {
          msg = "has a NodePath when it expected a raw object";
        }
        if (msg) {
          const type = Array.isArray(node) ? "array" : typeof node;
          throw new Error(`Node list ${msg} with the index of ${i} and type of ${type}`);
        }
      }
      return nodes;
    }
    function unshiftContainer(listKey, nodes) {
      _removal._assertUnremoved.call(this);
      nodes = _verifyNodeList.call(this, nodes);
      const path = _index.default.get({
        parentPath: this,
        parent: this.node,
        container: this.node[listKey],
        listKey,
        key: 0
      }).setContext(this.context);
      return _containerInsertBefore.call(path, nodes);
    }
    function pushContainer(listKey, nodes) {
      _removal._assertUnremoved.call(this);
      const verifiedNodes = _verifyNodeList.call(this, nodes);
      const container = this.node[listKey];
      const path = _index.default.get({
        parentPath: this,
        parent: this.node,
        container,
        listKey,
        key: container.length
      }).setContext(this.context);
      return path.replaceWithMultiple(verifiedNodes);
    }
    {
      exports2.hoist = function hoist(scope = this.scope) {
        const hoister = new _hoister.default(this, scope);
        return hoister.run();
      };
    }
  }
});

// ../../node_modules/@babel/parser/lib/index.js
var require_lib4 = __commonJS({
  "../../node_modules/@babel/parser/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    function _objectWithoutPropertiesLoose(r, e) {
      if (null == r) return {};
      var t6 = {};
      for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
        if (-1 !== e.indexOf(n)) continue;
        t6[n] = r[n];
      }
      return t6;
    }
    var Position = class {
      constructor(line2, col, index) {
        this.line = void 0;
        this.column = void 0;
        this.index = void 0;
        this.line = line2;
        this.column = col;
        this.index = index;
      }
    };
    var SourceLocation22 = class {
      constructor(start, end) {
        this.start = void 0;
        this.end = void 0;
        this.filename = void 0;
        this.identifierName = void 0;
        this.start = start;
        this.end = end;
      }
    };
    function createPositionWithColumnOffset(position, columnOffset) {
      const {
        line: line2,
        column: column2,
        index
      } = position;
      return new Position(line2, column2 + columnOffset, index + columnOffset);
    }
    var code = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED";
    var ModuleErrors = {
      ImportMetaOutsideModule: {
        message: `import.meta may appear only with 'sourceType: "module"'`,
        code
      },
      ImportOutsideModule: {
        message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
        code
      }
    };
    var NodeDescriptions = {
      ArrayPattern: "array destructuring pattern",
      AssignmentExpression: "assignment expression",
      AssignmentPattern: "assignment expression",
      ArrowFunctionExpression: "arrow function expression",
      ConditionalExpression: "conditional expression",
      CatchClause: "catch clause",
      ForOfStatement: "for-of statement",
      ForInStatement: "for-in statement",
      ForStatement: "for-loop",
      FormalParameters: "function parameter list",
      Identifier: "identifier",
      ImportSpecifier: "import specifier",
      ImportDefaultSpecifier: "import default specifier",
      ImportNamespaceSpecifier: "import namespace specifier",
      ObjectPattern: "object destructuring pattern",
      ParenthesizedExpression: "parenthesized expression",
      RestElement: "rest element",
      UpdateExpression: {
        true: "prefix operation",
        false: "postfix operation"
      },
      VariableDeclarator: "variable declaration",
      YieldExpression: "yield expression"
    };
    var toNodeDescription = (node) => node.type === "UpdateExpression" ? NodeDescriptions.UpdateExpression[`${node.prefix}`] : NodeDescriptions[node.type];
    var StandardErrors = {
      AccessorIsGenerator: ({
        kind
      }) => `A ${kind}ter cannot be a generator.`,
      ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
      AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
      AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
      AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
      AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
      AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.",
      AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
      BadGetterArity: "A 'get' accessor must not have any formal parameters.",
      BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
      BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
      ConstructorClassField: "Classes may not have a field named 'constructor'.",
      ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
      ConstructorIsAccessor: "Class constructor may not be an accessor.",
      ConstructorIsAsync: "Constructor can't be an async function.",
      ConstructorIsGenerator: "Constructor can't be a generator.",
      DeclarationMissingInitializer: ({
        kind
      }) => `Missing initializer in ${kind} declaration.`,
      DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.",
      DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.",
      DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.",
      DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
      DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.",
      DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
      DecoratorStaticBlock: "Decorators can't be used with a static block.",
      DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.',
      DeletePrivateField: "Deleting a private field is not allowed.",
      DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
      DuplicateConstructor: "Duplicate constructor in the same class.",
      DuplicateDefaultExport: "Only one default export allowed per module.",
      DuplicateExport: ({
        exportName
      }) => `\`${exportName}\` has already been exported. Exported identifiers must be unique.`,
      DuplicateProto: "Redefinition of __proto__ property.",
      DuplicateRegExpFlags: "Duplicate regular expression flag.",
      DynamicImportPhaseRequiresImportExpressions: ({
        phase
      }) => `'import.${phase}(...)' can only be parsed when using the 'createImportExpressions' option.`,
      ElementAfterRest: "Rest element must be last element.",
      EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
      ExportBindingIsString: ({
        localName,
        exportName
      }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${localName}' as '${exportName}' } from 'some-module'\`?`,
      ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
      ForInOfLoopInitializer: ({
        type
      }) => `'${type === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`,
      ForInUsing: "For-in loop may not start with 'using' declaration.",
      ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
      ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
      GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
      IllegalBreakContinue: ({
        type
      }) => `Unsyntactic ${type === "BreakStatement" ? "break" : "continue"}.`,
      IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
      IllegalReturn: "'return' outside of function.",
      ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedImportAssert` parser plugin to suppress this error.",
      ImportBindingIsString: ({
        importName
      }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${importName}" as foo }\`?`,
      ImportCallArity: `\`import()\` requires exactly one or two arguments.`,
      ImportCallNotNewExpression: "Cannot use new with import(...).",
      ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
      ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
      ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
      ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
      IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
      InvalidBigIntLiteral: "Invalid BigIntLiteral.",
      InvalidCodePoint: "Code point out of bounds.",
      InvalidCoverInitializedName: "Invalid shorthand property initializer.",
      InvalidDecimal: "Invalid decimal.",
      InvalidDigit: ({
        radix
      }) => `Expected number in radix ${radix}.`,
      InvalidEscapeSequence: "Bad character escape sequence.",
      InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
      InvalidEscapedReservedWord: ({
        reservedWord
      }) => `Escape sequence in keyword ${reservedWord}.`,
      InvalidIdentifier: ({
        identifierName
      }) => `Invalid identifier ${identifierName}.`,
      InvalidLhs: ({
        ancestor
      }) => `Invalid left-hand side in ${toNodeDescription(ancestor)}.`,
      InvalidLhsBinding: ({
        ancestor
      }) => `Binding invalid left-hand side in ${toNodeDescription(ancestor)}.`,
      InvalidLhsOptionalChaining: ({
        ancestor
      }) => `Invalid optional chaining in the left-hand side of ${toNodeDescription(ancestor)}.`,
      InvalidNumber: "Invalid number.",
      InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
      InvalidOrUnexpectedToken: ({
        unexpected
      }) => `Unexpected character '${unexpected}'.`,
      InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
      InvalidPrivateFieldResolution: ({
        identifierName
      }) => `Private name #${identifierName} is not defined.`,
      InvalidPropertyBindingPattern: "Binding member expression.",
      InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
      InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
      LabelRedeclaration: ({
        labelName
      }) => `Label '${labelName}' is already declared.`,
      LetInLexicalBinding: "'let' is disallowed as a lexically bound name.",
      LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
      MalformedRegExpFlags: "Invalid regular expression flag.",
      MissingClassName: "A class name is required.",
      MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
      MissingSemicolon: "Missing semicolon.",
      MissingPlugin: ({
        missingPlugin
      }) => `This experimental syntax requires enabling the parser plugin: ${missingPlugin.map((name) => JSON.stringify(name)).join(", ")}.`,
      MissingOneOfPlugins: ({
        missingPlugin
      }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${missingPlugin.map((name) => JSON.stringify(name)).join(", ")}.`,
      MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
      MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
      ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
      ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
      ModuleAttributesWithDuplicateKeys: ({
        key: key2
      }) => `Duplicate key "${key2}" is not allowed in module attributes.`,
      ModuleExportNameHasLoneSurrogate: ({
        surrogateCharCode
      }) => `An export name cannot include a lone surrogate, found '\\u${surrogateCharCode.toString(16)}'.`,
      ModuleExportUndefined: ({
        localName
      }) => `Export '${localName}' is not defined.`,
      MultipleDefaultsInSwitch: "Multiple default clauses.",
      NewlineAfterThrow: "Illegal newline after throw.",
      NoCatchOrFinally: "Missing catch or finally clause.",
      NumberIdentifier: "Identifier directly after number.",
      NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
      ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
      OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
      OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
      OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
      ParamDupe: "Argument name clash.",
      PatternHasAccessor: "Object pattern can't contain getter or setter.",
      PatternHasMethod: "Object pattern can't contain methods.",
      PrivateInExpectedIn: ({
        identifierName
      }) => `Private names are only allowed in property accesses (\`obj.#${identifierName}\`) or in \`in\` expressions (\`#${identifierName} in obj\`).`,
      PrivateNameRedeclaration: ({
        identifierName
      }) => `Duplicate private name #${identifierName}.`,
      RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
      RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
      RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
      RecordNoProto: "'__proto__' is not allowed in Record expressions.",
      RestTrailingComma: "Unexpected trailing comma after rest element.",
      SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",
      SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
      SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.',
      StaticPrototype: "Classes may not have static property named prototype.",
      SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
      SuperPrivateField: "Private fields can't be accessed on super.",
      TrailingDecorator: "Decorators must be attached to a class element.",
      TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
      TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
      TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
      UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
      UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
      UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
      UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
      UnexpectedKeyword: ({
        keyword
      }) => `Unexpected keyword '${keyword}'.`,
      UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
      UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
      UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
      UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
      UnexpectedPrivateField: "Unexpected private name.",
      UnexpectedReservedWord: ({
        reservedWord
      }) => `Unexpected reserved word '${reservedWord}'.`,
      UnexpectedSuper: "'super' is only allowed in object methods and classes.",
      UnexpectedToken: ({
        expected,
        unexpected
      }) => `Unexpected token${unexpected ? ` '${unexpected}'.` : ""}${expected ? `, expected "${expected}"` : ""}`,
      UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
      UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.",
      UnsupportedBind: "Binding should be performed on object property.",
      UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
      UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
      UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
      UnsupportedMetaProperty: ({
        target,
        onlyValidPropertyName
      }) => `The only valid meta property for ${target} is ${target}.${onlyValidPropertyName}.`,
      UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
      UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
      UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
      UnterminatedComment: "Unterminated comment.",
      UnterminatedRegExp: "Unterminated regular expression.",
      UnterminatedString: "Unterminated string constant.",
      UnterminatedTemplate: "Unterminated template.",
      UsingDeclarationExport: "Using declaration cannot be exported.",
      UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
      VarRedeclaration: ({
        identifierName
      }) => `Identifier '${identifierName}' has already been declared.`,
      YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
      YieldInParameter: "Yield expression is not allowed in formal parameters.",
      YieldNotInGeneratorFunction: "'yield' is only allowed within generator functions.",
      ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
    };
    var StrictModeErrors = {
      StrictDelete: "Deleting local variable in strict mode.",
      StrictEvalArguments: ({
        referenceName
      }) => `Assigning to '${referenceName}' in strict mode.`,
      StrictEvalArgumentsBinding: ({
        bindingName
      }) => `Binding '${bindingName}' in strict mode.`,
      StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
      StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
      StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
      StrictWith: "'with' in strict mode."
    };
    var UnparenthesizedPipeBodyDescriptions = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]);
    var PipelineOperatorErrors = Object.assign({
      PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",
      PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
      PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
      PipeTopicUnconfiguredToken: ({
        token: token2
      }) => `Invalid topic token ${token2}. In order to use ${token2} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${token2}" }.`,
      PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
      PipeUnparenthesizedBody: ({
        type
      }) => `Hack-style pipe body cannot be an unparenthesized ${toNodeDescription({
        type
      })}; please wrap it in parentheses.`
    }, {
      PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
      PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
      PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
      PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
      PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
      PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'
    });
    var _excluded = ["message"];
    function defineHidden(obj, key2, value) {
      Object.defineProperty(obj, key2, {
        enumerable: false,
        configurable: true,
        value
      });
    }
    function toParseErrorConstructor({
      toMessage,
      code: code2,
      reasonCode,
      syntaxPlugin
    }) {
      const hasMissingPlugin = reasonCode === "MissingPlugin" || reasonCode === "MissingOneOfPlugins";
      {
        const oldReasonCodes = {
          AccessorCannotDeclareThisParameter: "AccesorCannotDeclareThisParameter",
          AccessorCannotHaveTypeParameters: "AccesorCannotHaveTypeParameters",
          ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference",
          SetAccessorCannotHaveOptionalParameter: "SetAccesorCannotHaveOptionalParameter",
          SetAccessorCannotHaveRestParameter: "SetAccesorCannotHaveRestParameter",
          SetAccessorCannotHaveReturnType: "SetAccesorCannotHaveReturnType"
        };
        if (oldReasonCodes[reasonCode]) {
          reasonCode = oldReasonCodes[reasonCode];
        }
      }
      return function constructor(loc, details) {
        const error = new SyntaxError();
        error.code = code2;
        error.reasonCode = reasonCode;
        error.loc = loc;
        error.pos = loc.index;
        error.syntaxPlugin = syntaxPlugin;
        if (hasMissingPlugin) {
          error.missingPlugin = details.missingPlugin;
        }
        defineHidden(error, "clone", function clone(overrides = {}) {
          var _overrides$loc;
          const {
            line: line2,
            column: column2,
            index
          } = (_overrides$loc = overrides.loc) != null ? _overrides$loc : loc;
          return constructor(new Position(line2, column2, index), Object.assign({}, details, overrides.details));
        });
        defineHidden(error, "details", details);
        Object.defineProperty(error, "message", {
          configurable: true,
          get() {
            const message = `${toMessage(details)} (${loc.line}:${loc.column})`;
            this.message = message;
            return message;
          },
          set(value) {
            Object.defineProperty(this, "message", {
              value,
              writable: true
            });
          }
        });
        return error;
      };
    }
    function ParseErrorEnum(argument, syntaxPlugin) {
      if (Array.isArray(argument)) {
        return (parseErrorTemplates) => ParseErrorEnum(parseErrorTemplates, argument[0]);
      }
      const ParseErrorConstructors = {};
      for (const reasonCode of Object.keys(argument)) {
        const template = argument[reasonCode];
        const _ref = typeof template === "string" ? {
          message: () => template
        } : typeof template === "function" ? {
          message: template
        } : template, {
          message
        } = _ref, rest = _objectWithoutPropertiesLoose(_ref, _excluded);
        const toMessage = typeof message === "string" ? () => message : message;
        ParseErrorConstructors[reasonCode] = toParseErrorConstructor(Object.assign({
          code: "BABEL_PARSER_SYNTAX_ERROR",
          reasonCode,
          toMessage
        }, syntaxPlugin ? {
          syntaxPlugin
        } : {}, rest));
      }
      return ParseErrorConstructors;
    }
    var Errors = Object.assign({}, ParseErrorEnum(ModuleErrors), ParseErrorEnum(StandardErrors), ParseErrorEnum(StrictModeErrors), ParseErrorEnum`pipelineOperator`(PipelineOperatorErrors));
    function createDefaultOptions() {
      return {
        sourceType: "script",
        sourceFilename: void 0,
        startIndex: 0,
        startColumn: 0,
        startLine: 1,
        allowAwaitOutsideFunction: false,
        allowReturnOutsideFunction: false,
        allowNewTargetOutsideFunction: false,
        allowImportExportEverywhere: false,
        allowSuperOutsideMethod: false,
        allowUndeclaredExports: false,
        allowYieldOutsideFunction: false,
        plugins: [],
        strictMode: null,
        ranges: false,
        tokens: false,
        createImportExpressions: false,
        createParenthesizedExpressions: false,
        errorRecovery: false,
        attachComment: true,
        annexB: true
      };
    }
    function getOptions(opts) {
      const options = createDefaultOptions();
      if (opts == null) {
        return options;
      }
      if (opts.annexB != null && opts.annexB !== false) {
        throw new Error("The `annexB` option can only be set to `false`.");
      }
      for (const key2 of Object.keys(options)) {
        if (opts[key2] != null) options[key2] = opts[key2];
      }
      if (options.startLine === 1) {
        if (opts.startIndex == null && options.startColumn > 0) {
          options.startIndex = options.startColumn;
        } else if (opts.startColumn == null && options.startIndex > 0) {
          options.startColumn = options.startIndex;
        }
      } else if (opts.startColumn == null || opts.startIndex == null) {
        if (opts.startIndex != null) {
          throw new Error("With a `startLine > 1` you must also specify `startIndex` and `startColumn`.");
        }
      }
      return options;
    }
    var {
      defineProperty
    } = Object;
    var toUnenumerable = (object, key2) => {
      if (object) {
        defineProperty(object, key2, {
          enumerable: false,
          value: object[key2]
        });
      }
    };
    function toESTreeLocation(node) {
      toUnenumerable(node.loc.start, "index");
      toUnenumerable(node.loc.end, "index");
      return node;
    }
    var estree = (superClass) => class ESTreeParserMixin extends superClass {
      parse() {
        const file = toESTreeLocation(super.parse());
        if (this.optionFlags & 256) {
          file.tokens = file.tokens.map(toESTreeLocation);
        }
        return file;
      }
      parseRegExpLiteral({
        pattern,
        flags
      }) {
        let regex = null;
        try {
          regex = new RegExp(pattern, flags);
        } catch (_) {
        }
        const node = this.estreeParseLiteral(regex);
        node.regex = {
          pattern,
          flags
        };
        return node;
      }
      parseBigIntLiteral(value) {
        let bigInt;
        try {
          bigInt = BigInt(value);
        } catch (_unused) {
          bigInt = null;
        }
        const node = this.estreeParseLiteral(bigInt);
        node.bigint = String(node.value || value);
        return node;
      }
      parseDecimalLiteral(value) {
        const decimal = null;
        const node = this.estreeParseLiteral(decimal);
        node.decimal = String(node.value || value);
        return node;
      }
      estreeParseLiteral(value) {
        return this.parseLiteral(value, "Literal");
      }
      parseStringLiteral(value) {
        return this.estreeParseLiteral(value);
      }
      parseNumericLiteral(value) {
        return this.estreeParseLiteral(value);
      }
      parseNullLiteral() {
        return this.estreeParseLiteral(null);
      }
      parseBooleanLiteral(value) {
        return this.estreeParseLiteral(value);
      }
      directiveToStmt(directive2) {
        const expression = directive2.value;
        delete directive2.value;
        expression.type = "Literal";
        expression.raw = expression.extra.raw;
        expression.value = expression.extra.expressionValue;
        const stmt = directive2;
        stmt.type = "ExpressionStatement";
        stmt.expression = expression;
        stmt.directive = expression.extra.rawValue;
        delete expression.extra;
        return stmt;
      }
      initFunction(node, isAsync2) {
        super.initFunction(node, isAsync2);
        node.expression = false;
      }
      checkDeclaration(node) {
        if (node != null && this.isObjectProperty(node)) {
          this.checkDeclaration(node.value);
        } else {
          super.checkDeclaration(node);
        }
      }
      getObjectOrClassMethodParams(method) {
        return method.value.params;
      }
      isValidDirective(stmt) {
        var _stmt$expression$extr;
        return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && typeof stmt.expression.value === "string" && !((_stmt$expression$extr = stmt.expression.extra) != null && _stmt$expression$extr.parenthesized);
      }
      parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
        super.parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse);
        const directiveStatements = node.directives.map((d) => this.directiveToStmt(d));
        node.body = directiveStatements.concat(node.body);
        delete node.directives;
      }
      parsePrivateName() {
        const node = super.parsePrivateName();
        {
          if (!this.getPluginOption("estree", "classFeatures")) {
            return node;
          }
        }
        return this.convertPrivateNameToPrivateIdentifier(node);
      }
      convertPrivateNameToPrivateIdentifier(node) {
        const name = super.getPrivateNameSV(node);
        node = node;
        delete node.id;
        node.name = name;
        node.type = "PrivateIdentifier";
        return node;
      }
      isPrivateName(node) {
        {
          if (!this.getPluginOption("estree", "classFeatures")) {
            return super.isPrivateName(node);
          }
        }
        return node.type === "PrivateIdentifier";
      }
      getPrivateNameSV(node) {
        {
          if (!this.getPluginOption("estree", "classFeatures")) {
            return super.getPrivateNameSV(node);
          }
        }
        return node.name;
      }
      parseLiteral(value, type) {
        const node = super.parseLiteral(value, type);
        node.raw = node.extra.raw;
        delete node.extra;
        return node;
      }
      parseFunctionBody(node, allowExpression, isMethod = false) {
        super.parseFunctionBody(node, allowExpression, isMethod);
        node.expression = node.body.type !== "BlockStatement";
      }
      parseMethod(node, isGenerator, isAsync2, isConstructor, allowDirectSuper, type, inClassScope = false) {
        let funcNode = this.startNode();
        funcNode.kind = node.kind;
        funcNode = super.parseMethod(funcNode, isGenerator, isAsync2, isConstructor, allowDirectSuper, type, inClassScope);
        funcNode.type = "FunctionExpression";
        delete funcNode.kind;
        node.value = funcNode;
        const {
          typeParameters
        } = node;
        if (typeParameters) {
          delete node.typeParameters;
          funcNode.typeParameters = typeParameters;
          this.resetStartLocationFromNode(funcNode, typeParameters);
        }
        if (type === "ClassPrivateMethod") {
          node.computed = false;
        }
        return this.finishNode(node, "MethodDefinition");
      }
      nameIsConstructor(key2) {
        if (key2.type === "Literal") return key2.value === "constructor";
        return super.nameIsConstructor(key2);
      }
      parseClassProperty(...args) {
        const propertyNode = super.parseClassProperty(...args);
        {
          if (!this.getPluginOption("estree", "classFeatures")) {
            return propertyNode;
          }
        }
        {
          propertyNode.type = "PropertyDefinition";
        }
        return propertyNode;
      }
      parseClassPrivateProperty(...args) {
        const propertyNode = super.parseClassPrivateProperty(...args);
        {
          if (!this.getPluginOption("estree", "classFeatures")) {
            return propertyNode;
          }
        }
        {
          propertyNode.type = "PropertyDefinition";
        }
        propertyNode.computed = false;
        return propertyNode;
      }
      parseClassAccessorProperty(node) {
        const accessorPropertyNode = super.parseClassAccessorProperty(node);
        {
          if (!this.getPluginOption("estree", "classFeatures")) {
            return accessorPropertyNode;
          }
        }
        accessorPropertyNode.type = "AccessorProperty";
        return accessorPropertyNode;
      }
      parseObjectMethod(prop, isGenerator, isAsync2, isPattern, isAccessor) {
        const node = super.parseObjectMethod(prop, isGenerator, isAsync2, isPattern, isAccessor);
        if (node) {
          node.type = "Property";
          if (node.kind === "method") {
            node.kind = "init";
          }
          node.shorthand = false;
        }
        return node;
      }
      parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {
        const node = super.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);
        if (node) {
          node.kind = "init";
          node.type = "Property";
        }
        return node;
      }
      isValidLVal(type, isUnparenthesizedInAssign, binding) {
        return type === "Property" ? "value" : super.isValidLVal(type, isUnparenthesizedInAssign, binding);
      }
      isAssignable(node, isBinding) {
        if (node != null && this.isObjectProperty(node)) {
          return this.isAssignable(node.value, isBinding);
        }
        return super.isAssignable(node, isBinding);
      }
      toAssignable(node, isLHS = false) {
        if (node != null && this.isObjectProperty(node)) {
          const {
            key: key2,
            value
          } = node;
          if (this.isPrivateName(key2)) {
            this.classScope.usePrivateName(this.getPrivateNameSV(key2), key2.loc.start);
          }
          this.toAssignable(value, isLHS);
        } else {
          super.toAssignable(node, isLHS);
        }
      }
      toAssignableObjectExpressionProp(prop, isLast, isLHS) {
        if (prop.type === "Property" && (prop.kind === "get" || prop.kind === "set")) {
          this.raise(Errors.PatternHasAccessor, prop.key);
        } else if (prop.type === "Property" && prop.method) {
          this.raise(Errors.PatternHasMethod, prop.key);
        } else {
          super.toAssignableObjectExpressionProp(prop, isLast, isLHS);
        }
      }
      finishCallExpression(unfinished, optional) {
        const node = super.finishCallExpression(unfinished, optional);
        if (node.callee.type === "Import") {
          var _ref, _ref2;
          node.type = "ImportExpression";
          node.source = node.arguments[0];
          node.options = (_ref = node.arguments[1]) != null ? _ref : null;
          node.attributes = (_ref2 = node.arguments[1]) != null ? _ref2 : null;
          delete node.arguments;
          delete node.callee;
        }
        return node;
      }
      toReferencedArguments(node) {
        if (node.type === "ImportExpression") {
          return;
        }
        super.toReferencedArguments(node);
      }
      parseExport(unfinished, decorators) {
        const exportStartLoc = this.state.lastTokStartLoc;
        const node = super.parseExport(unfinished, decorators);
        switch (node.type) {
          case "ExportAllDeclaration":
            node.exported = null;
            break;
          case "ExportNamedDeclaration":
            if (node.specifiers.length === 1 && node.specifiers[0].type === "ExportNamespaceSpecifier") {
              node.type = "ExportAllDeclaration";
              node.exported = node.specifiers[0].exported;
              delete node.specifiers;
            }
          case "ExportDefaultDeclaration":
            {
              var _declaration$decorato;
              const {
                declaration
              } = node;
              if ((declaration == null ? void 0 : declaration.type) === "ClassDeclaration" && ((_declaration$decorato = declaration.decorators) == null ? void 0 : _declaration$decorato.length) > 0 && declaration.start === node.start) {
                this.resetStartLocation(node, exportStartLoc);
              }
            }
            break;
        }
        return node;
      }
      parseSubscript(base, startLoc, noCalls, state) {
        const node = super.parseSubscript(base, startLoc, noCalls, state);
        if (state.optionalChainMember) {
          if (node.type === "OptionalMemberExpression" || node.type === "OptionalCallExpression") {
            node.type = node.type.substring(8);
          }
          if (state.stop) {
            const chain = this.startNodeAtNode(node);
            chain.expression = node;
            return this.finishNode(chain, "ChainExpression");
          }
        } else if (node.type === "MemberExpression" || node.type === "CallExpression") {
          node.optional = false;
        }
        return node;
      }
      isOptionalMemberExpression(node) {
        if (node.type === "ChainExpression") {
          return node.expression.type === "MemberExpression";
        }
        return super.isOptionalMemberExpression(node);
      }
      hasPropertyAsPrivateName(node) {
        if (node.type === "ChainExpression") {
          node = node.expression;
        }
        return super.hasPropertyAsPrivateName(node);
      }
      isObjectProperty(node) {
        return node.type === "Property" && node.kind === "init" && !node.method;
      }
      isObjectMethod(node) {
        return node.type === "Property" && (node.method || node.kind === "get" || node.kind === "set");
      }
      finishNodeAt(node, type, endLoc) {
        return toESTreeLocation(super.finishNodeAt(node, type, endLoc));
      }
      resetStartLocation(node, startLoc) {
        super.resetStartLocation(node, startLoc);
        toESTreeLocation(node);
      }
      resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {
        super.resetEndLocation(node, endLoc);
        toESTreeLocation(node);
      }
    };
    var TokContext = class {
      constructor(token2, preserveSpace) {
        this.token = void 0;
        this.preserveSpace = void 0;
        this.token = token2;
        this.preserveSpace = !!preserveSpace;
      }
    };
    var types = {
      brace: new TokContext("{"),
      j_oTag: new TokContext("<tag"),
      j_cTag: new TokContext("</tag"),
      j_expr: new TokContext("<tag>...</tag>", true)
    };
    {
      types.template = new TokContext("`", true);
    }
    var beforeExpr = true;
    var startsExpr = true;
    var isLoop = true;
    var isAssign = true;
    var prefix = true;
    var postfix = true;
    var ExportedTokenType = class {
      constructor(label, conf = {}) {
        this.label = void 0;
        this.keyword = void 0;
        this.beforeExpr = void 0;
        this.startsExpr = void 0;
        this.rightAssociative = void 0;
        this.isLoop = void 0;
        this.isAssign = void 0;
        this.prefix = void 0;
        this.postfix = void 0;
        this.binop = void 0;
        this.label = label;
        this.keyword = conf.keyword;
        this.beforeExpr = !!conf.beforeExpr;
        this.startsExpr = !!conf.startsExpr;
        this.rightAssociative = !!conf.rightAssociative;
        this.isLoop = !!conf.isLoop;
        this.isAssign = !!conf.isAssign;
        this.prefix = !!conf.prefix;
        this.postfix = !!conf.postfix;
        this.binop = conf.binop != null ? conf.binop : null;
        {
          this.updateContext = null;
        }
      }
    };
    var keywords$1 = /* @__PURE__ */ new Map();
    function createKeyword(name, options = {}) {
      options.keyword = name;
      const token2 = createToken(name, options);
      keywords$1.set(name, token2);
      return token2;
    }
    function createBinop(name, binop) {
      return createToken(name, {
        beforeExpr,
        binop
      });
    }
    var tokenTypeCounter = -1;
    var tokenTypes = [];
    var tokenLabels = [];
    var tokenBinops = [];
    var tokenBeforeExprs = [];
    var tokenStartsExprs = [];
    var tokenPrefixes = [];
    function createToken(name, options = {}) {
      var _options$binop, _options$beforeExpr, _options$startsExpr, _options$prefix;
      ++tokenTypeCounter;
      tokenLabels.push(name);
      tokenBinops.push((_options$binop = options.binop) != null ? _options$binop : -1);
      tokenBeforeExprs.push((_options$beforeExpr = options.beforeExpr) != null ? _options$beforeExpr : false);
      tokenStartsExprs.push((_options$startsExpr = options.startsExpr) != null ? _options$startsExpr : false);
      tokenPrefixes.push((_options$prefix = options.prefix) != null ? _options$prefix : false);
      tokenTypes.push(new ExportedTokenType(name, options));
      return tokenTypeCounter;
    }
    function createKeywordLike(name, options = {}) {
      var _options$binop2, _options$beforeExpr2, _options$startsExpr2, _options$prefix2;
      ++tokenTypeCounter;
      keywords$1.set(name, tokenTypeCounter);
      tokenLabels.push(name);
      tokenBinops.push((_options$binop2 = options.binop) != null ? _options$binop2 : -1);
      tokenBeforeExprs.push((_options$beforeExpr2 = options.beforeExpr) != null ? _options$beforeExpr2 : false);
      tokenStartsExprs.push((_options$startsExpr2 = options.startsExpr) != null ? _options$startsExpr2 : false);
      tokenPrefixes.push((_options$prefix2 = options.prefix) != null ? _options$prefix2 : false);
      tokenTypes.push(new ExportedTokenType("name", options));
      return tokenTypeCounter;
    }
    var tt = {
      bracketL: createToken("[", {
        beforeExpr,
        startsExpr
      }),
      bracketHashL: createToken("#[", {
        beforeExpr,
        startsExpr
      }),
      bracketBarL: createToken("[|", {
        beforeExpr,
        startsExpr
      }),
      bracketR: createToken("]"),
      bracketBarR: createToken("|]"),
      braceL: createToken("{", {
        beforeExpr,
        startsExpr
      }),
      braceBarL: createToken("{|", {
        beforeExpr,
        startsExpr
      }),
      braceHashL: createToken("#{", {
        beforeExpr,
        startsExpr
      }),
      braceR: createToken("}"),
      braceBarR: createToken("|}"),
      parenL: createToken("(", {
        beforeExpr,
        startsExpr
      }),
      parenR: createToken(")"),
      comma: createToken(",", {
        beforeExpr
      }),
      semi: createToken(";", {
        beforeExpr
      }),
      colon: createToken(":", {
        beforeExpr
      }),
      doubleColon: createToken("::", {
        beforeExpr
      }),
      dot: createToken("."),
      question: createToken("?", {
        beforeExpr
      }),
      questionDot: createToken("?."),
      arrow: createToken("=>", {
        beforeExpr
      }),
      template: createToken("template"),
      ellipsis: createToken("...", {
        beforeExpr
      }),
      backQuote: createToken("`", {
        startsExpr
      }),
      dollarBraceL: createToken("${", {
        beforeExpr,
        startsExpr
      }),
      templateTail: createToken("...`", {
        startsExpr
      }),
      templateNonTail: createToken("...${", {
        beforeExpr,
        startsExpr
      }),
      at: createToken("@"),
      hash: createToken("#", {
        startsExpr
      }),
      interpreterDirective: createToken("#!..."),
      eq: createToken("=", {
        beforeExpr,
        isAssign
      }),
      assign: createToken("_=", {
        beforeExpr,
        isAssign
      }),
      slashAssign: createToken("_=", {
        beforeExpr,
        isAssign
      }),
      xorAssign: createToken("_=", {
        beforeExpr,
        isAssign
      }),
      moduloAssign: createToken("_=", {
        beforeExpr,
        isAssign
      }),
      incDec: createToken("++/--", {
        prefix,
        postfix,
        startsExpr
      }),
      bang: createToken("!", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      tilde: createToken("~", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      doubleCaret: createToken("^^", {
        startsExpr
      }),
      doubleAt: createToken("@@", {
        startsExpr
      }),
      pipeline: createBinop("|>", 0),
      nullishCoalescing: createBinop("??", 1),
      logicalOR: createBinop("||", 1),
      logicalAND: createBinop("&&", 2),
      bitwiseOR: createBinop("|", 3),
      bitwiseXOR: createBinop("^", 4),
      bitwiseAND: createBinop("&", 5),
      equality: createBinop("==/!=/===/!==", 6),
      lt: createBinop("</>/<=/>=", 7),
      gt: createBinop("</>/<=/>=", 7),
      relational: createBinop("</>/<=/>=", 7),
      bitShift: createBinop("<</>>/>>>", 8),
      bitShiftL: createBinop("<</>>/>>>", 8),
      bitShiftR: createBinop("<</>>/>>>", 8),
      plusMin: createToken("+/-", {
        beforeExpr,
        binop: 9,
        prefix,
        startsExpr
      }),
      modulo: createToken("%", {
        binop: 10,
        startsExpr
      }),
      star: createToken("*", {
        binop: 10
      }),
      slash: createBinop("/", 10),
      exponent: createToken("**", {
        beforeExpr,
        binop: 11,
        rightAssociative: true
      }),
      _in: createKeyword("in", {
        beforeExpr,
        binop: 7
      }),
      _instanceof: createKeyword("instanceof", {
        beforeExpr,
        binop: 7
      }),
      _break: createKeyword("break"),
      _case: createKeyword("case", {
        beforeExpr
      }),
      _catch: createKeyword("catch"),
      _continue: createKeyword("continue"),
      _debugger: createKeyword("debugger"),
      _default: createKeyword("default", {
        beforeExpr
      }),
      _else: createKeyword("else", {
        beforeExpr
      }),
      _finally: createKeyword("finally"),
      _function: createKeyword("function", {
        startsExpr
      }),
      _if: createKeyword("if"),
      _return: createKeyword("return", {
        beforeExpr
      }),
      _switch: createKeyword("switch"),
      _throw: createKeyword("throw", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      _try: createKeyword("try"),
      _var: createKeyword("var"),
      _const: createKeyword("const"),
      _with: createKeyword("with"),
      _new: createKeyword("new", {
        beforeExpr,
        startsExpr
      }),
      _this: createKeyword("this", {
        startsExpr
      }),
      _super: createKeyword("super", {
        startsExpr
      }),
      _class: createKeyword("class", {
        startsExpr
      }),
      _extends: createKeyword("extends", {
        beforeExpr
      }),
      _export: createKeyword("export"),
      _import: createKeyword("import", {
        startsExpr
      }),
      _null: createKeyword("null", {
        startsExpr
      }),
      _true: createKeyword("true", {
        startsExpr
      }),
      _false: createKeyword("false", {
        startsExpr
      }),
      _typeof: createKeyword("typeof", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      _void: createKeyword("void", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      _delete: createKeyword("delete", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      _do: createKeyword("do", {
        isLoop,
        beforeExpr
      }),
      _for: createKeyword("for", {
        isLoop
      }),
      _while: createKeyword("while", {
        isLoop
      }),
      _as: createKeywordLike("as", {
        startsExpr
      }),
      _assert: createKeywordLike("assert", {
        startsExpr
      }),
      _async: createKeywordLike("async", {
        startsExpr
      }),
      _await: createKeywordLike("await", {
        startsExpr
      }),
      _defer: createKeywordLike("defer", {
        startsExpr
      }),
      _from: createKeywordLike("from", {
        startsExpr
      }),
      _get: createKeywordLike("get", {
        startsExpr
      }),
      _let: createKeywordLike("let", {
        startsExpr
      }),
      _meta: createKeywordLike("meta", {
        startsExpr
      }),
      _of: createKeywordLike("of", {
        startsExpr
      }),
      _sent: createKeywordLike("sent", {
        startsExpr
      }),
      _set: createKeywordLike("set", {
        startsExpr
      }),
      _source: createKeywordLike("source", {
        startsExpr
      }),
      _static: createKeywordLike("static", {
        startsExpr
      }),
      _using: createKeywordLike("using", {
        startsExpr
      }),
      _yield: createKeywordLike("yield", {
        startsExpr
      }),
      _asserts: createKeywordLike("asserts", {
        startsExpr
      }),
      _checks: createKeywordLike("checks", {
        startsExpr
      }),
      _exports: createKeywordLike("exports", {
        startsExpr
      }),
      _global: createKeywordLike("global", {
        startsExpr
      }),
      _implements: createKeywordLike("implements", {
        startsExpr
      }),
      _intrinsic: createKeywordLike("intrinsic", {
        startsExpr
      }),
      _infer: createKeywordLike("infer", {
        startsExpr
      }),
      _is: createKeywordLike("is", {
        startsExpr
      }),
      _mixins: createKeywordLike("mixins", {
        startsExpr
      }),
      _proto: createKeywordLike("proto", {
        startsExpr
      }),
      _require: createKeywordLike("require", {
        startsExpr
      }),
      _satisfies: createKeywordLike("satisfies", {
        startsExpr
      }),
      _keyof: createKeywordLike("keyof", {
        startsExpr
      }),
      _readonly: createKeywordLike("readonly", {
        startsExpr
      }),
      _unique: createKeywordLike("unique", {
        startsExpr
      }),
      _abstract: createKeywordLike("abstract", {
        startsExpr
      }),
      _declare: createKeywordLike("declare", {
        startsExpr
      }),
      _enum: createKeywordLike("enum", {
        startsExpr
      }),
      _module: createKeywordLike("module", {
        startsExpr
      }),
      _namespace: createKeywordLike("namespace", {
        startsExpr
      }),
      _interface: createKeywordLike("interface", {
        startsExpr
      }),
      _type: createKeywordLike("type", {
        startsExpr
      }),
      _opaque: createKeywordLike("opaque", {
        startsExpr
      }),
      name: createToken("name", {
        startsExpr
      }),
      placeholder: createToken("%%", {
        startsExpr: true
      }),
      string: createToken("string", {
        startsExpr
      }),
      num: createToken("num", {
        startsExpr
      }),
      bigint: createToken("bigint", {
        startsExpr
      }),
      decimal: createToken("decimal", {
        startsExpr
      }),
      regexp: createToken("regexp", {
        startsExpr
      }),
      privateName: createToken("#name", {
        startsExpr
      }),
      eof: createToken("eof"),
      jsxName: createToken("jsxName"),
      jsxText: createToken("jsxText", {
        beforeExpr: true
      }),
      jsxTagStart: createToken("jsxTagStart", {
        startsExpr: true
      }),
      jsxTagEnd: createToken("jsxTagEnd")
    };
    function tokenIsIdentifier(token2) {
      return token2 >= 93 && token2 <= 133;
    }
    function tokenKeywordOrIdentifierIsKeyword(token2) {
      return token2 <= 92;
    }
    function tokenIsKeywordOrIdentifier(token2) {
      return token2 >= 58 && token2 <= 133;
    }
    function tokenIsLiteralPropertyName(token2) {
      return token2 >= 58 && token2 <= 137;
    }
    function tokenComesBeforeExpression(token2) {
      return tokenBeforeExprs[token2];
    }
    function tokenCanStartExpression(token2) {
      return tokenStartsExprs[token2];
    }
    function tokenIsAssignment(token2) {
      return token2 >= 29 && token2 <= 33;
    }
    function tokenIsFlowInterfaceOrTypeOrOpaque(token2) {
      return token2 >= 129 && token2 <= 131;
    }
    function tokenIsLoop(token2) {
      return token2 >= 90 && token2 <= 92;
    }
    function tokenIsKeyword(token2) {
      return token2 >= 58 && token2 <= 92;
    }
    function tokenIsOperator(token2) {
      return token2 >= 39 && token2 <= 59;
    }
    function tokenIsPostfix(token2) {
      return token2 === 34;
    }
    function tokenIsPrefix(token2) {
      return tokenPrefixes[token2];
    }
    function tokenIsTSTypeOperator(token2) {
      return token2 >= 121 && token2 <= 123;
    }
    function tokenIsTSDeclarationStart(token2) {
      return token2 >= 124 && token2 <= 130;
    }
    function tokenLabelName(token2) {
      return tokenLabels[token2];
    }
    function tokenOperatorPrecedence(token2) {
      return tokenBinops[token2];
    }
    function tokenIsRightAssociative(token2) {
      return token2 === 57;
    }
    function tokenIsTemplate(token2) {
      return token2 >= 24 && token2 <= 25;
    }
    function getExportedToken(token2) {
      return tokenTypes[token2];
    }
    {
      tokenTypes[8].updateContext = (context) => {
        context.pop();
      };
      tokenTypes[5].updateContext = tokenTypes[7].updateContext = tokenTypes[23].updateContext = (context) => {
        context.push(types.brace);
      };
      tokenTypes[22].updateContext = (context) => {
        if (context[context.length - 1] === types.template) {
          context.pop();
        } else {
          context.push(types.template);
        }
      };
      tokenTypes[143].updateContext = (context) => {
        context.push(types.j_expr, types.j_oTag);
      };
    }
    var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
    var nonASCIIidentifierChars = "\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65";
    var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
    var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
    nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
    var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
    var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
    function isInAstralSet(code2, set) {
      let pos2 = 65536;
      for (let i = 0, length = set.length; i < length; i += 2) {
        pos2 += set[i];
        if (pos2 > code2) return false;
        pos2 += set[i + 1];
        if (pos2 >= code2) return true;
      }
      return false;
    }
    function isIdentifierStart(code2) {
      if (code2 < 65) return code2 === 36;
      if (code2 <= 90) return true;
      if (code2 < 97) return code2 === 95;
      if (code2 <= 122) return true;
      if (code2 <= 65535) {
        return code2 >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code2));
      }
      return isInAstralSet(code2, astralIdentifierStartCodes);
    }
    function isIdentifierChar(code2) {
      if (code2 < 48) return code2 === 36;
      if (code2 < 58) return true;
      if (code2 < 65) return false;
      if (code2 <= 90) return true;
      if (code2 < 97) return code2 === 95;
      if (code2 <= 122) return true;
      if (code2 <= 65535) {
        return code2 >= 170 && nonASCIIidentifier.test(String.fromCharCode(code2));
      }
      return isInAstralSet(code2, astralIdentifierStartCodes) || isInAstralSet(code2, astralIdentifierCodes);
    }
    var reservedWords = {
      keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
      strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
      strictBind: ["eval", "arguments"]
    };
    var keywords = new Set(reservedWords.keyword);
    var reservedWordsStrictSet = new Set(reservedWords.strict);
    var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
    function isReservedWord2(word, inModule) {
      return inModule && word === "await" || word === "enum";
    }
    function isStrictReservedWord(word, inModule) {
      return isReservedWord2(word, inModule) || reservedWordsStrictSet.has(word);
    }
    function isStrictBindOnlyReservedWord(word) {
      return reservedWordsStrictBindSet.has(word);
    }
    function isStrictBindReservedWord(word, inModule) {
      return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
    }
    function isKeyword(word) {
      return keywords.has(word);
    }
    function isIteratorStart(current, next, next2) {
      return current === 64 && next === 64 && isIdentifierStart(next2);
    }
    var reservedWordLikeSet = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
    function canBeReservedWord(word) {
      return reservedWordLikeSet.has(word);
    }
    var Scope = class {
      constructor(flags) {
        this.flags = 0;
        this.names = /* @__PURE__ */ new Map();
        this.firstLexicalName = "";
        this.flags = flags;
      }
    };
    var ScopeHandler = class {
      constructor(parser, inModule) {
        this.parser = void 0;
        this.scopeStack = [];
        this.inModule = void 0;
        this.undefinedExports = /* @__PURE__ */ new Map();
        this.parser = parser;
        this.inModule = inModule;
      }
      get inTopLevel() {
        return (this.currentScope().flags & 1) > 0;
      }
      get inFunction() {
        return (this.currentVarScopeFlags() & 2) > 0;
      }
      get allowSuper() {
        return (this.currentThisScopeFlags() & 16) > 0;
      }
      get allowDirectSuper() {
        return (this.currentThisScopeFlags() & 32) > 0;
      }
      get inClass() {
        return (this.currentThisScopeFlags() & 64) > 0;
      }
      get inClassAndNotInNonArrowFunction() {
        const flags = this.currentThisScopeFlags();
        return (flags & 64) > 0 && (flags & 2) === 0;
      }
      get inStaticBlock() {
        for (let i = this.scopeStack.length - 1; ; i--) {
          const {
            flags
          } = this.scopeStack[i];
          if (flags & 128) {
            return true;
          }
          if (flags & (387 | 64)) {
            return false;
          }
        }
      }
      get inNonArrowFunction() {
        return (this.currentThisScopeFlags() & 2) > 0;
      }
      get treatFunctionsAsVar() {
        return this.treatFunctionsAsVarInScope(this.currentScope());
      }
      createScope(flags) {
        return new Scope(flags);
      }
      enter(flags) {
        this.scopeStack.push(this.createScope(flags));
      }
      exit() {
        const scope = this.scopeStack.pop();
        return scope.flags;
      }
      treatFunctionsAsVarInScope(scope) {
        return !!(scope.flags & (2 | 128) || !this.parser.inModule && scope.flags & 1);
      }
      declareName(name, bindingType, loc) {
        let scope = this.currentScope();
        if (bindingType & 8 || bindingType & 16) {
          this.checkRedeclarationInScope(scope, name, bindingType, loc);
          let type = scope.names.get(name) || 0;
          if (bindingType & 16) {
            type = type | 4;
          } else {
            if (!scope.firstLexicalName) {
              scope.firstLexicalName = name;
            }
            type = type | 2;
          }
          scope.names.set(name, type);
          if (bindingType & 8) {
            this.maybeExportDefined(scope, name);
          }
        } else if (bindingType & 4) {
          for (let i = this.scopeStack.length - 1; i >= 0; --i) {
            scope = this.scopeStack[i];
            this.checkRedeclarationInScope(scope, name, bindingType, loc);
            scope.names.set(name, (scope.names.get(name) || 0) | 1);
            this.maybeExportDefined(scope, name);
            if (scope.flags & 387) break;
          }
        }
        if (this.parser.inModule && scope.flags & 1) {
          this.undefinedExports.delete(name);
        }
      }
      maybeExportDefined(scope, name) {
        if (this.parser.inModule && scope.flags & 1) {
          this.undefinedExports.delete(name);
        }
      }
      checkRedeclarationInScope(scope, name, bindingType, loc) {
        if (this.isRedeclaredInScope(scope, name, bindingType)) {
          this.parser.raise(Errors.VarRedeclaration, loc, {
            identifierName: name
          });
        }
      }
      isRedeclaredInScope(scope, name, bindingType) {
        if (!(bindingType & 1)) return false;
        if (bindingType & 8) {
          return scope.names.has(name);
        }
        const type = scope.names.get(name);
        if (bindingType & 16) {
          return (type & 2) > 0 || !this.treatFunctionsAsVarInScope(scope) && (type & 1) > 0;
        }
        return (type & 2) > 0 && !(scope.flags & 8 && scope.firstLexicalName === name) || !this.treatFunctionsAsVarInScope(scope) && (type & 4) > 0;
      }
      checkLocalExport(id) {
        const {
          name
        } = id;
        const topLevelScope = this.scopeStack[0];
        if (!topLevelScope.names.has(name)) {
          this.undefinedExports.set(name, id.loc.start);
        }
      }
      currentScope() {
        return this.scopeStack[this.scopeStack.length - 1];
      }
      currentVarScopeFlags() {
        for (let i = this.scopeStack.length - 1; ; i--) {
          const {
            flags
          } = this.scopeStack[i];
          if (flags & 387) {
            return flags;
          }
        }
      }
      currentThisScopeFlags() {
        for (let i = this.scopeStack.length - 1; ; i--) {
          const {
            flags
          } = this.scopeStack[i];
          if (flags & (387 | 64) && !(flags & 4)) {
            return flags;
          }
        }
      }
    };
    var FlowScope = class extends Scope {
      constructor(...args) {
        super(...args);
        this.declareFunctions = /* @__PURE__ */ new Set();
      }
    };
    var FlowScopeHandler = class extends ScopeHandler {
      createScope(flags) {
        return new FlowScope(flags);
      }
      declareName(name, bindingType, loc) {
        const scope = this.currentScope();
        if (bindingType & 2048) {
          this.checkRedeclarationInScope(scope, name, bindingType, loc);
          this.maybeExportDefined(scope, name);
          scope.declareFunctions.add(name);
          return;
        }
        super.declareName(name, bindingType, loc);
      }
      isRedeclaredInScope(scope, name, bindingType) {
        if (super.isRedeclaredInScope(scope, name, bindingType)) return true;
        if (bindingType & 2048 && !scope.declareFunctions.has(name)) {
          const type = scope.names.get(name);
          return (type & 4) > 0 || (type & 2) > 0;
        }
        return false;
      }
      checkLocalExport(id) {
        if (!this.scopeStack[0].declareFunctions.has(id.name)) {
          super.checkLocalExport(id);
        }
      }
    };
    var BaseParser = class {
      constructor() {
        this.sawUnambiguousESM = false;
        this.ambiguousScriptDifferentAst = false;
      }
      sourceToOffsetPos(sourcePos) {
        return sourcePos + this.startIndex;
      }
      offsetToSourcePos(offsetPos) {
        return offsetPos - this.startIndex;
      }
      hasPlugin(pluginConfig) {
        if (typeof pluginConfig === "string") {
          return this.plugins.has(pluginConfig);
        } else {
          const [pluginName, pluginOptions] = pluginConfig;
          if (!this.hasPlugin(pluginName)) {
            return false;
          }
          const actualOptions = this.plugins.get(pluginName);
          for (const key2 of Object.keys(pluginOptions)) {
            if ((actualOptions == null ? void 0 : actualOptions[key2]) !== pluginOptions[key2]) {
              return false;
            }
          }
          return true;
        }
      }
      getPluginOption(plugin, name) {
        var _this$plugins$get;
        return (_this$plugins$get = this.plugins.get(plugin)) == null ? void 0 : _this$plugins$get[name];
      }
    };
    function setTrailingComments(node, comments) {
      if (node.trailingComments === void 0) {
        node.trailingComments = comments;
      } else {
        node.trailingComments.unshift(...comments);
      }
    }
    function setLeadingComments(node, comments) {
      if (node.leadingComments === void 0) {
        node.leadingComments = comments;
      } else {
        node.leadingComments.unshift(...comments);
      }
    }
    function setInnerComments(node, comments) {
      if (node.innerComments === void 0) {
        node.innerComments = comments;
      } else {
        node.innerComments.unshift(...comments);
      }
    }
    function adjustInnerComments(node, elements, commentWS) {
      let lastElement = null;
      let i = elements.length;
      while (lastElement === null && i > 0) {
        lastElement = elements[--i];
      }
      if (lastElement === null || lastElement.start > commentWS.start) {
        setInnerComments(node, commentWS.comments);
      } else {
        setTrailingComments(lastElement, commentWS.comments);
      }
    }
    var CommentsParser = class extends BaseParser {
      addComment(comment) {
        if (this.filename) comment.loc.filename = this.filename;
        const {
          commentsLen
        } = this.state;
        if (this.comments.length !== commentsLen) {
          this.comments.length = commentsLen;
        }
        this.comments.push(comment);
        this.state.commentsLen++;
      }
      processComment(node) {
        const {
          commentStack
        } = this.state;
        const commentStackLength = commentStack.length;
        if (commentStackLength === 0) return;
        let i = commentStackLength - 1;
        const lastCommentWS = commentStack[i];
        if (lastCommentWS.start === node.end) {
          lastCommentWS.leadingNode = node;
          i--;
        }
        const {
          start: nodeStart
        } = node;
        for (; i >= 0; i--) {
          const commentWS = commentStack[i];
          const commentEnd = commentWS.end;
          if (commentEnd > nodeStart) {
            commentWS.containingNode = node;
            this.finalizeComment(commentWS);
            commentStack.splice(i, 1);
          } else {
            if (commentEnd === nodeStart) {
              commentWS.trailingNode = node;
            }
            break;
          }
        }
      }
      finalizeComment(commentWS) {
        const {
          comments
        } = commentWS;
        if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {
          if (commentWS.leadingNode !== null) {
            setTrailingComments(commentWS.leadingNode, comments);
          }
          if (commentWS.trailingNode !== null) {
            setLeadingComments(commentWS.trailingNode, comments);
          }
        } else {
          const {
            containingNode: node,
            start: commentStart
          } = commentWS;
          if (this.input.charCodeAt(this.offsetToSourcePos(commentStart) - 1) === 44) {
            switch (node.type) {
              case "ObjectExpression":
              case "ObjectPattern":
              case "RecordExpression":
                adjustInnerComments(node, node.properties, commentWS);
                break;
              case "CallExpression":
              case "OptionalCallExpression":
                adjustInnerComments(node, node.arguments, commentWS);
                break;
              case "FunctionDeclaration":
              case "FunctionExpression":
              case "ArrowFunctionExpression":
              case "ObjectMethod":
              case "ClassMethod":
              case "ClassPrivateMethod":
                adjustInnerComments(node, node.params, commentWS);
                break;
              case "ArrayExpression":
              case "ArrayPattern":
              case "TupleExpression":
                adjustInnerComments(node, node.elements, commentWS);
                break;
              case "ExportNamedDeclaration":
              case "ImportDeclaration":
                adjustInnerComments(node, node.specifiers, commentWS);
                break;
              case "TSEnumDeclaration":
                {
                  adjustInnerComments(node, node.members, commentWS);
                }
                break;
              case "TSEnumBody":
                adjustInnerComments(node, node.members, commentWS);
                break;
              default: {
                setInnerComments(node, comments);
              }
            }
          } else {
            setInnerComments(node, comments);
          }
        }
      }
      finalizeRemainingComments() {
        const {
          commentStack
        } = this.state;
        for (let i = commentStack.length - 1; i >= 0; i--) {
          this.finalizeComment(commentStack[i]);
        }
        this.state.commentStack = [];
      }
      resetPreviousNodeTrailingComments(node) {
        const {
          commentStack
        } = this.state;
        const {
          length
        } = commentStack;
        if (length === 0) return;
        const commentWS = commentStack[length - 1];
        if (commentWS.leadingNode === node) {
          commentWS.leadingNode = null;
        }
      }
      resetPreviousIdentifierLeadingComments(node) {
        const {
          commentStack
        } = this.state;
        const {
          length
        } = commentStack;
        if (length === 0) return;
        if (commentStack[length - 1].trailingNode === node) {
          commentStack[length - 1].trailingNode = null;
        } else if (length >= 2 && commentStack[length - 2].trailingNode === node) {
          commentStack[length - 2].trailingNode = null;
        }
      }
      takeSurroundingComments(node, start, end) {
        const {
          commentStack
        } = this.state;
        const commentStackLength = commentStack.length;
        if (commentStackLength === 0) return;
        let i = commentStackLength - 1;
        for (; i >= 0; i--) {
          const commentWS = commentStack[i];
          const commentEnd = commentWS.end;
          const commentStart = commentWS.start;
          if (commentStart === end) {
            commentWS.leadingNode = node;
          } else if (commentEnd === start) {
            commentWS.trailingNode = node;
          } else if (commentEnd < start) {
            break;
          }
        }
      }
    };
    var lineBreak = /\r\n|[\r\n\u2028\u2029]/;
    var lineBreakG = new RegExp(lineBreak.source, "g");
    function isNewLine(code2) {
      switch (code2) {
        case 10:
        case 13:
        case 8232:
        case 8233:
          return true;
        default:
          return false;
      }
    }
    function hasNewLine(input, start, end) {
      for (let i = start; i < end; i++) {
        if (isNewLine(input.charCodeAt(i))) {
          return true;
        }
      }
      return false;
    }
    var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
    var skipWhiteSpaceInLine = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g;
    function isWhitespace(code2) {
      switch (code2) {
        case 9:
        case 11:
        case 12:
        case 32:
        case 160:
        case 5760:
        case 8192:
        case 8193:
        case 8194:
        case 8195:
        case 8196:
        case 8197:
        case 8198:
        case 8199:
        case 8200:
        case 8201:
        case 8202:
        case 8239:
        case 8287:
        case 12288:
        case 65279:
          return true;
        default:
          return false;
      }
    }
    var State4 = class _State {
      constructor() {
        this.flags = 1024;
        this.startIndex = void 0;
        this.curLine = void 0;
        this.lineStart = void 0;
        this.startLoc = void 0;
        this.endLoc = void 0;
        this.errors = [];
        this.potentialArrowAt = -1;
        this.noArrowAt = [];
        this.noArrowParamsConversionAt = [];
        this.topicContext = {
          maxNumOfResolvableTopics: 0,
          maxTopicIndex: null
        };
        this.labels = [];
        this.commentsLen = 0;
        this.commentStack = [];
        this.pos = 0;
        this.type = 140;
        this.value = null;
        this.start = 0;
        this.end = 0;
        this.lastTokEndLoc = null;
        this.lastTokStartLoc = null;
        this.context = [types.brace];
        this.firstInvalidTemplateEscapePos = null;
        this.strictErrors = /* @__PURE__ */ new Map();
        this.tokensLength = 0;
      }
      get strict() {
        return (this.flags & 1) > 0;
      }
      set strict(v) {
        if (v) this.flags |= 1;
        else this.flags &= -2;
      }
      init({
        strictMode,
        sourceType,
        startIndex,
        startLine,
        startColumn
      }) {
        this.strict = strictMode === false ? false : strictMode === true ? true : sourceType === "module";
        this.startIndex = startIndex;
        this.curLine = startLine;
        this.lineStart = -startColumn;
        this.startLoc = this.endLoc = new Position(startLine, startColumn, startIndex);
      }
      get maybeInArrowParameters() {
        return (this.flags & 2) > 0;
      }
      set maybeInArrowParameters(v) {
        if (v) this.flags |= 2;
        else this.flags &= -3;
      }
      get inType() {
        return (this.flags & 4) > 0;
      }
      set inType(v) {
        if (v) this.flags |= 4;
        else this.flags &= -5;
      }
      get noAnonFunctionType() {
        return (this.flags & 8) > 0;
      }
      set noAnonFunctionType(v) {
        if (v) this.flags |= 8;
        else this.flags &= -9;
      }
      get hasFlowComment() {
        return (this.flags & 16) > 0;
      }
      set hasFlowComment(v) {
        if (v) this.flags |= 16;
        else this.flags &= -17;
      }
      get isAmbientContext() {
        return (this.flags & 32) > 0;
      }
      set isAmbientContext(v) {
        if (v) this.flags |= 32;
        else this.flags &= -33;
      }
      get inAbstractClass() {
        return (this.flags & 64) > 0;
      }
      set inAbstractClass(v) {
        if (v) this.flags |= 64;
        else this.flags &= -65;
      }
      get inDisallowConditionalTypesContext() {
        return (this.flags & 128) > 0;
      }
      set inDisallowConditionalTypesContext(v) {
        if (v) this.flags |= 128;
        else this.flags &= -129;
      }
      get soloAwait() {
        return (this.flags & 256) > 0;
      }
      set soloAwait(v) {
        if (v) this.flags |= 256;
        else this.flags &= -257;
      }
      get inFSharpPipelineDirectBody() {
        return (this.flags & 512) > 0;
      }
      set inFSharpPipelineDirectBody(v) {
        if (v) this.flags |= 512;
        else this.flags &= -513;
      }
      get canStartJSXElement() {
        return (this.flags & 1024) > 0;
      }
      set canStartJSXElement(v) {
        if (v) this.flags |= 1024;
        else this.flags &= -1025;
      }
      get containsEsc() {
        return (this.flags & 2048) > 0;
      }
      set containsEsc(v) {
        if (v) this.flags |= 2048;
        else this.flags &= -2049;
      }
      get hasTopLevelAwait() {
        return (this.flags & 4096) > 0;
      }
      set hasTopLevelAwait(v) {
        if (v) this.flags |= 4096;
        else this.flags &= -4097;
      }
      curPosition() {
        return new Position(this.curLine, this.pos - this.lineStart, this.pos + this.startIndex);
      }
      clone() {
        const state = new _State();
        state.flags = this.flags;
        state.startIndex = this.startIndex;
        state.curLine = this.curLine;
        state.lineStart = this.lineStart;
        state.startLoc = this.startLoc;
        state.endLoc = this.endLoc;
        state.errors = this.errors.slice();
        state.potentialArrowAt = this.potentialArrowAt;
        state.noArrowAt = this.noArrowAt.slice();
        state.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice();
        state.topicContext = this.topicContext;
        state.labels = this.labels.slice();
        state.commentsLen = this.commentsLen;
        state.commentStack = this.commentStack.slice();
        state.pos = this.pos;
        state.type = this.type;
        state.value = this.value;
        state.start = this.start;
        state.end = this.end;
        state.lastTokEndLoc = this.lastTokEndLoc;
        state.lastTokStartLoc = this.lastTokStartLoc;
        state.context = this.context.slice();
        state.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos;
        state.strictErrors = this.strictErrors;
        state.tokensLength = this.tokensLength;
        return state;
      }
    };
    var _isDigit = function isDigit(code2) {
      return code2 >= 48 && code2 <= 57;
    };
    var forbiddenNumericSeparatorSiblings = {
      decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
      hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
    };
    var isAllowedNumericSeparatorSibling = {
      bin: (ch) => ch === 48 || ch === 49,
      oct: (ch) => ch >= 48 && ch <= 55,
      dec: (ch) => ch >= 48 && ch <= 57,
      hex: (ch) => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102
    };
    function readStringContents(type, input, pos2, lineStart, curLine, errors) {
      const initialPos = pos2;
      const initialLineStart = lineStart;
      const initialCurLine = curLine;
      let out = "";
      let firstInvalidLoc = null;
      let chunkStart = pos2;
      const {
        length
      } = input;
      for (; ; ) {
        if (pos2 >= length) {
          errors.unterminated(initialPos, initialLineStart, initialCurLine);
          out += input.slice(chunkStart, pos2);
          break;
        }
        const ch = input.charCodeAt(pos2);
        if (isStringEnd(type, ch, input, pos2)) {
          out += input.slice(chunkStart, pos2);
          break;
        }
        if (ch === 92) {
          out += input.slice(chunkStart, pos2);
          const res = readEscapedChar(input, pos2, lineStart, curLine, type === "template", errors);
          if (res.ch === null && !firstInvalidLoc) {
            firstInvalidLoc = {
              pos: pos2,
              lineStart,
              curLine
            };
          } else {
            out += res.ch;
          }
          ({
            pos: pos2,
            lineStart,
            curLine
          } = res);
          chunkStart = pos2;
        } else if (ch === 8232 || ch === 8233) {
          ++pos2;
          ++curLine;
          lineStart = pos2;
        } else if (ch === 10 || ch === 13) {
          if (type === "template") {
            out += input.slice(chunkStart, pos2) + "\n";
            ++pos2;
            if (ch === 13 && input.charCodeAt(pos2) === 10) {
              ++pos2;
            }
            ++curLine;
            chunkStart = lineStart = pos2;
          } else {
            errors.unterminated(initialPos, initialLineStart, initialCurLine);
          }
        } else {
          ++pos2;
        }
      }
      return {
        pos: pos2,
        str: out,
        firstInvalidLoc,
        lineStart,
        curLine,
        containsInvalid: !!firstInvalidLoc
      };
    }
    function isStringEnd(type, ch, input, pos2) {
      if (type === "template") {
        return ch === 96 || ch === 36 && input.charCodeAt(pos2 + 1) === 123;
      }
      return ch === (type === "double" ? 34 : 39);
    }
    function readEscapedChar(input, pos2, lineStart, curLine, inTemplate, errors) {
      const throwOnInvalid = !inTemplate;
      pos2++;
      const res = (ch2) => ({
        pos: pos2,
        ch: ch2,
        lineStart,
        curLine
      });
      const ch = input.charCodeAt(pos2++);
      switch (ch) {
        case 110:
          return res("\n");
        case 114:
          return res("\r");
        case 120: {
          let code2;
          ({
            code: code2,
            pos: pos2
          } = readHexChar(input, pos2, lineStart, curLine, 2, false, throwOnInvalid, errors));
          return res(code2 === null ? null : String.fromCharCode(code2));
        }
        case 117: {
          let code2;
          ({
            code: code2,
            pos: pos2
          } = readCodePoint(input, pos2, lineStart, curLine, throwOnInvalid, errors));
          return res(code2 === null ? null : String.fromCodePoint(code2));
        }
        case 116:
          return res("	");
        case 98:
          return res("\b");
        case 118:
          return res("\v");
        case 102:
          return res("\f");
        case 13:
          if (input.charCodeAt(pos2) === 10) {
            ++pos2;
          }
        case 10:
          lineStart = pos2;
          ++curLine;
        case 8232:
        case 8233:
          return res("");
        case 56:
        case 57:
          if (inTemplate) {
            return res(null);
          } else {
            errors.strictNumericEscape(pos2 - 1, lineStart, curLine);
          }
        default:
          if (ch >= 48 && ch <= 55) {
            const startPos = pos2 - 1;
            const match = /^[0-7]+/.exec(input.slice(startPos, pos2 + 2));
            let octalStr = match[0];
            let octal = parseInt(octalStr, 8);
            if (octal > 255) {
              octalStr = octalStr.slice(0, -1);
              octal = parseInt(octalStr, 8);
            }
            pos2 += octalStr.length - 1;
            const next = input.charCodeAt(pos2);
            if (octalStr !== "0" || next === 56 || next === 57) {
              if (inTemplate) {
                return res(null);
              } else {
                errors.strictNumericEscape(startPos, lineStart, curLine);
              }
            }
            return res(String.fromCharCode(octal));
          }
          return res(String.fromCharCode(ch));
      }
    }
    function readHexChar(input, pos2, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {
      const initialPos = pos2;
      let n;
      ({
        n,
        pos: pos2
      } = readInt(input, pos2, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid));
      if (n === null) {
        if (throwOnInvalid) {
          errors.invalidEscapeSequence(initialPos, lineStart, curLine);
        } else {
          pos2 = initialPos - 1;
        }
      }
      return {
        code: n,
        pos: pos2
      };
    }
    function readInt(input, pos2, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {
      const start = pos2;
      const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
      const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;
      let invalid = false;
      let total = 0;
      for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {
        const code2 = input.charCodeAt(pos2);
        let val;
        if (code2 === 95 && allowNumSeparator !== "bail") {
          const prev = input.charCodeAt(pos2 - 1);
          const next = input.charCodeAt(pos2 + 1);
          if (!allowNumSeparator) {
            if (bailOnError) return {
              n: null,
              pos: pos2
            };
            errors.numericSeparatorInEscapeSequence(pos2, lineStart, curLine);
          } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {
            if (bailOnError) return {
              n: null,
              pos: pos2
            };
            errors.unexpectedNumericSeparator(pos2, lineStart, curLine);
          }
          ++pos2;
          continue;
        }
        if (code2 >= 97) {
          val = code2 - 97 + 10;
        } else if (code2 >= 65) {
          val = code2 - 65 + 10;
        } else if (_isDigit(code2)) {
          val = code2 - 48;
        } else {
          val = Infinity;
        }
        if (val >= radix) {
          if (val <= 9 && bailOnError) {
            return {
              n: null,
              pos: pos2
            };
          } else if (val <= 9 && errors.invalidDigit(pos2, lineStart, curLine, radix)) {
            val = 0;
          } else if (forceLen) {
            val = 0;
            invalid = true;
          } else {
            break;
          }
        }
        ++pos2;
        total = total * radix + val;
      }
      if (pos2 === start || len != null && pos2 - start !== len || invalid) {
        return {
          n: null,
          pos: pos2
        };
      }
      return {
        n: total,
        pos: pos2
      };
    }
    function readCodePoint(input, pos2, lineStart, curLine, throwOnInvalid, errors) {
      const ch = input.charCodeAt(pos2);
      let code2;
      if (ch === 123) {
        ++pos2;
        ({
          code: code2,
          pos: pos2
        } = readHexChar(input, pos2, lineStart, curLine, input.indexOf("}", pos2) - pos2, true, throwOnInvalid, errors));
        ++pos2;
        if (code2 !== null && code2 > 1114111) {
          if (throwOnInvalid) {
            errors.invalidCodePoint(pos2, lineStart, curLine);
          } else {
            return {
              code: null,
              pos: pos2
            };
          }
        }
      } else {
        ({
          code: code2,
          pos: pos2
        } = readHexChar(input, pos2, lineStart, curLine, 4, false, throwOnInvalid, errors));
      }
      return {
        code: code2,
        pos: pos2
      };
    }
    function buildPosition(pos2, lineStart, curLine) {
      return new Position(curLine, pos2 - lineStart, pos2);
    }
    var VALID_REGEX_FLAGS = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]);
    var Token = class {
      constructor(state) {
        const startIndex = state.startIndex || 0;
        this.type = state.type;
        this.value = state.value;
        this.start = startIndex + state.start;
        this.end = startIndex + state.end;
        this.loc = new SourceLocation22(state.startLoc, state.endLoc);
      }
    };
    var Tokenizer = class extends CommentsParser {
      constructor(options, input) {
        super();
        this.isLookahead = void 0;
        this.tokens = [];
        this.errorHandlers_readInt = {
          invalidDigit: (pos2, lineStart, curLine, radix) => {
            if (!(this.optionFlags & 2048)) return false;
            this.raise(Errors.InvalidDigit, buildPosition(pos2, lineStart, curLine), {
              radix
            });
            return true;
          },
          numericSeparatorInEscapeSequence: this.errorBuilder(Errors.NumericSeparatorInEscapeSequence),
          unexpectedNumericSeparator: this.errorBuilder(Errors.UnexpectedNumericSeparator)
        };
        this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
          invalidEscapeSequence: this.errorBuilder(Errors.InvalidEscapeSequence),
          invalidCodePoint: this.errorBuilder(Errors.InvalidCodePoint)
        });
        this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
          strictNumericEscape: (pos2, lineStart, curLine) => {
            this.recordStrictModeErrors(Errors.StrictNumericEscape, buildPosition(pos2, lineStart, curLine));
          },
          unterminated: (pos2, lineStart, curLine) => {
            throw this.raise(Errors.UnterminatedString, buildPosition(pos2 - 1, lineStart, curLine));
          }
        });
        this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
          strictNumericEscape: this.errorBuilder(Errors.StrictNumericEscape),
          unterminated: (pos2, lineStart, curLine) => {
            throw this.raise(Errors.UnterminatedTemplate, buildPosition(pos2, lineStart, curLine));
          }
        });
        this.state = new State4();
        this.state.init(options);
        this.input = input;
        this.length = input.length;
        this.comments = [];
        this.isLookahead = false;
      }
      pushToken(token2) {
        this.tokens.length = this.state.tokensLength;
        this.tokens.push(token2);
        ++this.state.tokensLength;
      }
      next() {
        this.checkKeywordEscapes();
        if (this.optionFlags & 256) {
          this.pushToken(new Token(this.state));
        }
        this.state.lastTokEndLoc = this.state.endLoc;
        this.state.lastTokStartLoc = this.state.startLoc;
        this.nextToken();
      }
      eat(type) {
        if (this.match(type)) {
          this.next();
          return true;
        } else {
          return false;
        }
      }
      match(type) {
        return this.state.type === type;
      }
      createLookaheadState(state) {
        return {
          pos: state.pos,
          value: null,
          type: state.type,
          start: state.start,
          end: state.end,
          context: [this.curContext()],
          inType: state.inType,
          startLoc: state.startLoc,
          lastTokEndLoc: state.lastTokEndLoc,
          curLine: state.curLine,
          lineStart: state.lineStart,
          curPosition: state.curPosition
        };
      }
      lookahead() {
        const old = this.state;
        this.state = this.createLookaheadState(old);
        this.isLookahead = true;
        this.nextToken();
        this.isLookahead = false;
        const curr = this.state;
        this.state = old;
        return curr;
      }
      nextTokenStart() {
        return this.nextTokenStartSince(this.state.pos);
      }
      nextTokenStartSince(pos2) {
        skipWhiteSpace.lastIndex = pos2;
        return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos2;
      }
      lookaheadCharCode() {
        return this.input.charCodeAt(this.nextTokenStart());
      }
      nextTokenInLineStart() {
        return this.nextTokenInLineStartSince(this.state.pos);
      }
      nextTokenInLineStartSince(pos2) {
        skipWhiteSpaceInLine.lastIndex = pos2;
        return skipWhiteSpaceInLine.test(this.input) ? skipWhiteSpaceInLine.lastIndex : pos2;
      }
      lookaheadInLineCharCode() {
        return this.input.charCodeAt(this.nextTokenInLineStart());
      }
      codePointAtPos(pos2) {
        let cp = this.input.charCodeAt(pos2);
        if ((cp & 64512) === 55296 && ++pos2 < this.input.length) {
          const trail = this.input.charCodeAt(pos2);
          if ((trail & 64512) === 56320) {
            cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
          }
        }
        return cp;
      }
      setStrict(strict) {
        this.state.strict = strict;
        if (strict) {
          this.state.strictErrors.forEach(([toParseError, at]) => this.raise(toParseError, at));
          this.state.strictErrors.clear();
        }
      }
      curContext() {
        return this.state.context[this.state.context.length - 1];
      }
      nextToken() {
        this.skipSpace();
        this.state.start = this.state.pos;
        if (!this.isLookahead) this.state.startLoc = this.state.curPosition();
        if (this.state.pos >= this.length) {
          this.finishToken(140);
          return;
        }
        this.getTokenFromCode(this.codePointAtPos(this.state.pos));
      }
      skipBlockComment(commentEnd) {
        let startLoc;
        if (!this.isLookahead) startLoc = this.state.curPosition();
        const start = this.state.pos;
        const end = this.input.indexOf(commentEnd, start + 2);
        if (end === -1) {
          throw this.raise(Errors.UnterminatedComment, this.state.curPosition());
        }
        this.state.pos = end + commentEnd.length;
        lineBreakG.lastIndex = start + 2;
        while (lineBreakG.test(this.input) && lineBreakG.lastIndex <= end) {
          ++this.state.curLine;
          this.state.lineStart = lineBreakG.lastIndex;
        }
        if (this.isLookahead) return;
        const comment = {
          type: "CommentBlock",
          value: this.input.slice(start + 2, end),
          start: this.sourceToOffsetPos(start),
          end: this.sourceToOffsetPos(end + commentEnd.length),
          loc: new SourceLocation22(startLoc, this.state.curPosition())
        };
        if (this.optionFlags & 256) this.pushToken(comment);
        return comment;
      }
      skipLineComment(startSkip) {
        const start = this.state.pos;
        let startLoc;
        if (!this.isLookahead) startLoc = this.state.curPosition();
        let ch = this.input.charCodeAt(this.state.pos += startSkip);
        if (this.state.pos < this.length) {
          while (!isNewLine(ch) && ++this.state.pos < this.length) {
            ch = this.input.charCodeAt(this.state.pos);
          }
        }
        if (this.isLookahead) return;
        const end = this.state.pos;
        const value = this.input.slice(start + startSkip, end);
        const comment = {
          type: "CommentLine",
          value,
          start: this.sourceToOffsetPos(start),
          end: this.sourceToOffsetPos(end),
          loc: new SourceLocation22(startLoc, this.state.curPosition())
        };
        if (this.optionFlags & 256) this.pushToken(comment);
        return comment;
      }
      skipSpace() {
        const spaceStart = this.state.pos;
        const comments = this.optionFlags & 4096 ? [] : null;
        loop: while (this.state.pos < this.length) {
          const ch = this.input.charCodeAt(this.state.pos);
          switch (ch) {
            case 32:
            case 160:
            case 9:
              ++this.state.pos;
              break;
            case 13:
              if (this.input.charCodeAt(this.state.pos + 1) === 10) {
                ++this.state.pos;
              }
            case 10:
            case 8232:
            case 8233:
              ++this.state.pos;
              ++this.state.curLine;
              this.state.lineStart = this.state.pos;
              break;
            case 47:
              switch (this.input.charCodeAt(this.state.pos + 1)) {
                case 42: {
                  const comment = this.skipBlockComment("*/");
                  if (comment !== void 0) {
                    this.addComment(comment);
                    comments == null || comments.push(comment);
                  }
                  break;
                }
                case 47: {
                  const comment = this.skipLineComment(2);
                  if (comment !== void 0) {
                    this.addComment(comment);
                    comments == null || comments.push(comment);
                  }
                  break;
                }
                default:
                  break loop;
              }
              break;
            default:
              if (isWhitespace(ch)) {
                ++this.state.pos;
              } else if (ch === 45 && !this.inModule && this.optionFlags & 8192) {
                const pos2 = this.state.pos;
                if (this.input.charCodeAt(pos2 + 1) === 45 && this.input.charCodeAt(pos2 + 2) === 62 && (spaceStart === 0 || this.state.lineStart > spaceStart)) {
                  const comment = this.skipLineComment(3);
                  if (comment !== void 0) {
                    this.addComment(comment);
                    comments == null || comments.push(comment);
                  }
                } else {
                  break loop;
                }
              } else if (ch === 60 && !this.inModule && this.optionFlags & 8192) {
                const pos2 = this.state.pos;
                if (this.input.charCodeAt(pos2 + 1) === 33 && this.input.charCodeAt(pos2 + 2) === 45 && this.input.charCodeAt(pos2 + 3) === 45) {
                  const comment = this.skipLineComment(4);
                  if (comment !== void 0) {
                    this.addComment(comment);
                    comments == null || comments.push(comment);
                  }
                } else {
                  break loop;
                }
              } else {
                break loop;
              }
          }
        }
        if ((comments == null ? void 0 : comments.length) > 0) {
          const end = this.state.pos;
          const commentWhitespace = {
            start: this.sourceToOffsetPos(spaceStart),
            end: this.sourceToOffsetPos(end),
            comments,
            leadingNode: null,
            trailingNode: null,
            containingNode: null
          };
          this.state.commentStack.push(commentWhitespace);
        }
      }
      finishToken(type, val) {
        this.state.end = this.state.pos;
        this.state.endLoc = this.state.curPosition();
        const prevType = this.state.type;
        this.state.type = type;
        this.state.value = val;
        if (!this.isLookahead) {
          this.updateContext(prevType);
        }
      }
      replaceToken(type) {
        this.state.type = type;
        this.updateContext();
      }
      readToken_numberSign() {
        if (this.state.pos === 0 && this.readToken_interpreter()) {
          return;
        }
        const nextPos = this.state.pos + 1;
        const next = this.codePointAtPos(nextPos);
        if (next >= 48 && next <= 57) {
          throw this.raise(Errors.UnexpectedDigitAfterHash, this.state.curPosition());
        }
        if (next === 123 || next === 91 && this.hasPlugin("recordAndTuple")) {
          this.expectPlugin("recordAndTuple");
          if (this.getPluginOption("recordAndTuple", "syntaxType") === "bar") {
            throw this.raise(next === 123 ? Errors.RecordExpressionHashIncorrectStartSyntaxType : Errors.TupleExpressionHashIncorrectStartSyntaxType, this.state.curPosition());
          }
          this.state.pos += 2;
          if (next === 123) {
            this.finishToken(7);
          } else {
            this.finishToken(1);
          }
        } else if (isIdentifierStart(next)) {
          ++this.state.pos;
          this.finishToken(139, this.readWord1(next));
        } else if (next === 92) {
          ++this.state.pos;
          this.finishToken(139, this.readWord1());
        } else {
          this.finishOp(27, 1);
        }
      }
      readToken_dot() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next >= 48 && next <= 57) {
          this.readNumber(true);
          return;
        }
        if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {
          this.state.pos += 3;
          this.finishToken(21);
        } else {
          ++this.state.pos;
          this.finishToken(16);
        }
      }
      readToken_slash() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 61) {
          this.finishOp(31, 2);
        } else {
          this.finishOp(56, 1);
        }
      }
      readToken_interpreter() {
        if (this.state.pos !== 0 || this.length < 2) return false;
        let ch = this.input.charCodeAt(this.state.pos + 1);
        if (ch !== 33) return false;
        const start = this.state.pos;
        this.state.pos += 1;
        while (!isNewLine(ch) && ++this.state.pos < this.length) {
          ch = this.input.charCodeAt(this.state.pos);
        }
        const value = this.input.slice(start + 2, this.state.pos);
        this.finishToken(28, value);
        return true;
      }
      readToken_mult_modulo(code2) {
        let type = code2 === 42 ? 55 : 54;
        let width = 1;
        let next = this.input.charCodeAt(this.state.pos + 1);
        if (code2 === 42 && next === 42) {
          width++;
          next = this.input.charCodeAt(this.state.pos + 2);
          type = 57;
        }
        if (next === 61 && !this.state.inType) {
          width++;
          type = code2 === 37 ? 33 : 30;
        }
        this.finishOp(type, width);
      }
      readToken_pipe_amp(code2) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === code2) {
          if (this.input.charCodeAt(this.state.pos + 2) === 61) {
            this.finishOp(30, 3);
          } else {
            this.finishOp(code2 === 124 ? 41 : 42, 2);
          }
          return;
        }
        if (code2 === 124) {
          if (next === 62) {
            this.finishOp(39, 2);
            return;
          }
          if (this.hasPlugin("recordAndTuple") && next === 125) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
              throw this.raise(Errors.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
            }
            this.state.pos += 2;
            this.finishToken(9);
            return;
          }
          if (this.hasPlugin("recordAndTuple") && next === 93) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
              throw this.raise(Errors.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
            }
            this.state.pos += 2;
            this.finishToken(4);
            return;
          }
        }
        if (next === 61) {
          this.finishOp(30, 2);
          return;
        }
        this.finishOp(code2 === 124 ? 43 : 45, 1);
      }
      readToken_caret() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 61 && !this.state.inType) {
          this.finishOp(32, 2);
        } else if (next === 94 && this.hasPlugin(["pipelineOperator", {
          proposal: "hack",
          topicToken: "^^"
        }])) {
          this.finishOp(37, 2);
          const lookaheadCh = this.input.codePointAt(this.state.pos);
          if (lookaheadCh === 94) {
            this.unexpected();
          }
        } else {
          this.finishOp(44, 1);
        }
      }
      readToken_atSign() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 64 && this.hasPlugin(["pipelineOperator", {
          proposal: "hack",
          topicToken: "@@"
        }])) {
          this.finishOp(38, 2);
        } else {
          this.finishOp(26, 1);
        }
      }
      readToken_plus_min(code2) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === code2) {
          this.finishOp(34, 2);
          return;
        }
        if (next === 61) {
          this.finishOp(30, 2);
        } else {
          this.finishOp(53, 1);
        }
      }
      readToken_lt() {
        const {
          pos: pos2
        } = this.state;
        const next = this.input.charCodeAt(pos2 + 1);
        if (next === 60) {
          if (this.input.charCodeAt(pos2 + 2) === 61) {
            this.finishOp(30, 3);
            return;
          }
          this.finishOp(51, 2);
          return;
        }
        if (next === 61) {
          this.finishOp(49, 2);
          return;
        }
        this.finishOp(47, 1);
      }
      readToken_gt() {
        const {
          pos: pos2
        } = this.state;
        const next = this.input.charCodeAt(pos2 + 1);
        if (next === 62) {
          const size = this.input.charCodeAt(pos2 + 2) === 62 ? 3 : 2;
          if (this.input.charCodeAt(pos2 + size) === 61) {
            this.finishOp(30, size + 1);
            return;
          }
          this.finishOp(52, size);
          return;
        }
        if (next === 61) {
          this.finishOp(49, 2);
          return;
        }
        this.finishOp(48, 1);
      }
      readToken_eq_excl(code2) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 61) {
          this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
          return;
        }
        if (code2 === 61 && next === 62) {
          this.state.pos += 2;
          this.finishToken(19);
          return;
        }
        this.finishOp(code2 === 61 ? 29 : 35, 1);
      }
      readToken_question() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        const next2 = this.input.charCodeAt(this.state.pos + 2);
        if (next === 63) {
          if (next2 === 61) {
            this.finishOp(30, 3);
          } else {
            this.finishOp(40, 2);
          }
        } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {
          this.state.pos += 2;
          this.finishToken(18);
        } else {
          ++this.state.pos;
          this.finishToken(17);
        }
      }
      getTokenFromCode(code2) {
        switch (code2) {
          case 46:
            this.readToken_dot();
            return;
          case 40:
            ++this.state.pos;
            this.finishToken(10);
            return;
          case 41:
            ++this.state.pos;
            this.finishToken(11);
            return;
          case 59:
            ++this.state.pos;
            this.finishToken(13);
            return;
          case 44:
            ++this.state.pos;
            this.finishToken(12);
            return;
          case 91:
            if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
              if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                throw this.raise(Errors.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
              }
              this.state.pos += 2;
              this.finishToken(2);
            } else {
              ++this.state.pos;
              this.finishToken(0);
            }
            return;
          case 93:
            ++this.state.pos;
            this.finishToken(3);
            return;
          case 123:
            if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
              if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                throw this.raise(Errors.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
              }
              this.state.pos += 2;
              this.finishToken(6);
            } else {
              ++this.state.pos;
              this.finishToken(5);
            }
            return;
          case 125:
            ++this.state.pos;
            this.finishToken(8);
            return;
          case 58:
            if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) {
              this.finishOp(15, 2);
            } else {
              ++this.state.pos;
              this.finishToken(14);
            }
            return;
          case 63:
            this.readToken_question();
            return;
          case 96:
            this.readTemplateToken();
            return;
          case 48: {
            const next = this.input.charCodeAt(this.state.pos + 1);
            if (next === 120 || next === 88) {
              this.readRadixNumber(16);
              return;
            }
            if (next === 111 || next === 79) {
              this.readRadixNumber(8);
              return;
            }
            if (next === 98 || next === 66) {
              this.readRadixNumber(2);
              return;
            }
          }
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
            this.readNumber(false);
            return;
          case 34:
          case 39:
            this.readString(code2);
            return;
          case 47:
            this.readToken_slash();
            return;
          case 37:
          case 42:
            this.readToken_mult_modulo(code2);
            return;
          case 124:
          case 38:
            this.readToken_pipe_amp(code2);
            return;
          case 94:
            this.readToken_caret();
            return;
          case 43:
          case 45:
            this.readToken_plus_min(code2);
            return;
          case 60:
            this.readToken_lt();
            return;
          case 62:
            this.readToken_gt();
            return;
          case 61:
          case 33:
            this.readToken_eq_excl(code2);
            return;
          case 126:
            this.finishOp(36, 1);
            return;
          case 64:
            this.readToken_atSign();
            return;
          case 35:
            this.readToken_numberSign();
            return;
          case 92:
            this.readWord();
            return;
          default:
            if (isIdentifierStart(code2)) {
              this.readWord(code2);
              return;
            }
        }
        throw this.raise(Errors.InvalidOrUnexpectedToken, this.state.curPosition(), {
          unexpected: String.fromCodePoint(code2)
        });
      }
      finishOp(type, size) {
        const str = this.input.slice(this.state.pos, this.state.pos + size);
        this.state.pos += size;
        this.finishToken(type, str);
      }
      readRegexp() {
        const startLoc = this.state.startLoc;
        const start = this.state.start + 1;
        let escaped, inClass;
        let {
          pos: pos2
        } = this.state;
        for (; ; ++pos2) {
          if (pos2 >= this.length) {
            throw this.raise(Errors.UnterminatedRegExp, createPositionWithColumnOffset(startLoc, 1));
          }
          const ch = this.input.charCodeAt(pos2);
          if (isNewLine(ch)) {
            throw this.raise(Errors.UnterminatedRegExp, createPositionWithColumnOffset(startLoc, 1));
          }
          if (escaped) {
            escaped = false;
          } else {
            if (ch === 91) {
              inClass = true;
            } else if (ch === 93 && inClass) {
              inClass = false;
            } else if (ch === 47 && !inClass) {
              break;
            }
            escaped = ch === 92;
          }
        }
        const content = this.input.slice(start, pos2);
        ++pos2;
        let mods = "";
        const nextPos = () => createPositionWithColumnOffset(startLoc, pos2 + 2 - start);
        while (pos2 < this.length) {
          const cp = this.codePointAtPos(pos2);
          const char = String.fromCharCode(cp);
          if (VALID_REGEX_FLAGS.has(cp)) {
            if (cp === 118) {
              if (mods.includes("u")) {
                this.raise(Errors.IncompatibleRegExpUVFlags, nextPos());
              }
            } else if (cp === 117) {
              if (mods.includes("v")) {
                this.raise(Errors.IncompatibleRegExpUVFlags, nextPos());
              }
            }
            if (mods.includes(char)) {
              this.raise(Errors.DuplicateRegExpFlags, nextPos());
            }
          } else if (isIdentifierChar(cp) || cp === 92) {
            this.raise(Errors.MalformedRegExpFlags, nextPos());
          } else {
            break;
          }
          ++pos2;
          mods += char;
        }
        this.state.pos = pos2;
        this.finishToken(138, {
          pattern: content,
          flags: mods
        });
      }
      readInt(radix, len, forceLen = false, allowNumSeparator = true) {
        const {
          n,
          pos: pos2
        } = readInt(this.input, this.state.pos, this.state.lineStart, this.state.curLine, radix, len, forceLen, allowNumSeparator, this.errorHandlers_readInt, false);
        this.state.pos = pos2;
        return n;
      }
      readRadixNumber(radix) {
        const start = this.state.pos;
        const startLoc = this.state.curPosition();
        let isBigInt = false;
        this.state.pos += 2;
        const val = this.readInt(radix);
        if (val == null) {
          this.raise(Errors.InvalidDigit, createPositionWithColumnOffset(startLoc, 2), {
            radix
          });
        }
        const next = this.input.charCodeAt(this.state.pos);
        if (next === 110) {
          ++this.state.pos;
          isBigInt = true;
        } else if (next === 109) {
          throw this.raise(Errors.InvalidDecimal, startLoc);
        }
        if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
          throw this.raise(Errors.NumberIdentifier, this.state.curPosition());
        }
        if (isBigInt) {
          const str = this.input.slice(start, this.state.pos).replace(/[_n]/g, "");
          this.finishToken(136, str);
          return;
        }
        this.finishToken(135, val);
      }
      readNumber(startsWithDot) {
        const start = this.state.pos;
        const startLoc = this.state.curPosition();
        let isFloat = false;
        let isBigInt = false;
        let hasExponent = false;
        let isOctal = false;
        if (!startsWithDot && this.readInt(10) === null) {
          this.raise(Errors.InvalidNumber, this.state.curPosition());
        }
        const hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;
        if (hasLeadingZero) {
          const integer = this.input.slice(start, this.state.pos);
          this.recordStrictModeErrors(Errors.StrictOctalLiteral, startLoc);
          if (!this.state.strict) {
            const underscorePos = integer.indexOf("_");
            if (underscorePos > 0) {
              this.raise(Errors.ZeroDigitNumericSeparator, createPositionWithColumnOffset(startLoc, underscorePos));
            }
          }
          isOctal = hasLeadingZero && !/[89]/.test(integer);
        }
        let next = this.input.charCodeAt(this.state.pos);
        if (next === 46 && !isOctal) {
          ++this.state.pos;
          this.readInt(10);
          isFloat = true;
          next = this.input.charCodeAt(this.state.pos);
        }
        if ((next === 69 || next === 101) && !isOctal) {
          next = this.input.charCodeAt(++this.state.pos);
          if (next === 43 || next === 45) {
            ++this.state.pos;
          }
          if (this.readInt(10) === null) {
            this.raise(Errors.InvalidOrMissingExponent, startLoc);
          }
          isFloat = true;
          hasExponent = true;
          next = this.input.charCodeAt(this.state.pos);
        }
        if (next === 110) {
          if (isFloat || hasLeadingZero) {
            this.raise(Errors.InvalidBigIntLiteral, startLoc);
          }
          ++this.state.pos;
          isBigInt = true;
        }
        if (next === 109) {
          this.expectPlugin("decimal", this.state.curPosition());
          if (hasExponent || hasLeadingZero) {
            this.raise(Errors.InvalidDecimal, startLoc);
          }
          ++this.state.pos;
          var isDecimal = true;
        }
        if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
          throw this.raise(Errors.NumberIdentifier, this.state.curPosition());
        }
        const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, "");
        if (isBigInt) {
          this.finishToken(136, str);
          return;
        }
        if (isDecimal) {
          this.finishToken(137, str);
          return;
        }
        const val = isOctal ? parseInt(str, 8) : parseFloat(str);
        this.finishToken(135, val);
      }
      readCodePoint(throwOnInvalid) {
        const {
          code: code2,
          pos: pos2
        } = readCodePoint(this.input, this.state.pos, this.state.lineStart, this.state.curLine, throwOnInvalid, this.errorHandlers_readCodePoint);
        this.state.pos = pos2;
        return code2;
      }
      readString(quote) {
        const {
          str,
          pos: pos2,
          curLine,
          lineStart
        } = readStringContents(quote === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
        this.state.pos = pos2 + 1;
        this.state.lineStart = lineStart;
        this.state.curLine = curLine;
        this.finishToken(134, str);
      }
      readTemplateContinuation() {
        if (!this.match(8)) {
          this.unexpected(null, 8);
        }
        this.state.pos--;
        this.readTemplateToken();
      }
      readTemplateToken() {
        const opening = this.input[this.state.pos];
        const {
          str,
          firstInvalidLoc,
          pos: pos2,
          curLine,
          lineStart
        } = readStringContents("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
        this.state.pos = pos2 + 1;
        this.state.lineStart = lineStart;
        this.state.curLine = curLine;
        if (firstInvalidLoc) {
          this.state.firstInvalidTemplateEscapePos = new Position(firstInvalidLoc.curLine, firstInvalidLoc.pos - firstInvalidLoc.lineStart, this.sourceToOffsetPos(firstInvalidLoc.pos));
        }
        if (this.input.codePointAt(pos2) === 96) {
          this.finishToken(24, firstInvalidLoc ? null : opening + str + "`");
        } else {
          this.state.pos++;
          this.finishToken(25, firstInvalidLoc ? null : opening + str + "${");
        }
      }
      recordStrictModeErrors(toParseError, at) {
        const index = at.index;
        if (this.state.strict && !this.state.strictErrors.has(index)) {
          this.raise(toParseError, at);
        } else {
          this.state.strictErrors.set(index, [toParseError, at]);
        }
      }
      readWord1(firstCode) {
        this.state.containsEsc = false;
        let word = "";
        const start = this.state.pos;
        let chunkStart = this.state.pos;
        if (firstCode !== void 0) {
          this.state.pos += firstCode <= 65535 ? 1 : 2;
        }
        while (this.state.pos < this.length) {
          const ch = this.codePointAtPos(this.state.pos);
          if (isIdentifierChar(ch)) {
            this.state.pos += ch <= 65535 ? 1 : 2;
          } else if (ch === 92) {
            this.state.containsEsc = true;
            word += this.input.slice(chunkStart, this.state.pos);
            const escStart = this.state.curPosition();
            const identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;
            if (this.input.charCodeAt(++this.state.pos) !== 117) {
              this.raise(Errors.MissingUnicodeEscape, this.state.curPosition());
              chunkStart = this.state.pos - 1;
              continue;
            }
            ++this.state.pos;
            const esc = this.readCodePoint(true);
            if (esc !== null) {
              if (!identifierCheck(esc)) {
                this.raise(Errors.EscapedCharNotAnIdentifier, escStart);
              }
              word += String.fromCodePoint(esc);
            }
            chunkStart = this.state.pos;
          } else {
            break;
          }
        }
        return word + this.input.slice(chunkStart, this.state.pos);
      }
      readWord(firstCode) {
        const word = this.readWord1(firstCode);
        const type = keywords$1.get(word);
        if (type !== void 0) {
          this.finishToken(type, tokenLabelName(type));
        } else {
          this.finishToken(132, word);
        }
      }
      checkKeywordEscapes() {
        const {
          type
        } = this.state;
        if (tokenIsKeyword(type) && this.state.containsEsc) {
          this.raise(Errors.InvalidEscapedReservedWord, this.state.startLoc, {
            reservedWord: tokenLabelName(type)
          });
        }
      }
      raise(toParseError, at, details = {}) {
        const loc = at instanceof Position ? at : at.loc.start;
        const error = toParseError(loc, details);
        if (!(this.optionFlags & 2048)) throw error;
        if (!this.isLookahead) this.state.errors.push(error);
        return error;
      }
      raiseOverwrite(toParseError, at, details = {}) {
        const loc = at instanceof Position ? at : at.loc.start;
        const pos2 = loc.index;
        const errors = this.state.errors;
        for (let i = errors.length - 1; i >= 0; i--) {
          const error = errors[i];
          if (error.loc.index === pos2) {
            return errors[i] = toParseError(loc, details);
          }
          if (error.loc.index < pos2) break;
        }
        return this.raise(toParseError, at, details);
      }
      updateContext(prevType) {
      }
      unexpected(loc, type) {
        throw this.raise(Errors.UnexpectedToken, loc != null ? loc : this.state.startLoc, {
          expected: type ? tokenLabelName(type) : null
        });
      }
      expectPlugin(pluginName, loc) {
        if (this.hasPlugin(pluginName)) {
          return true;
        }
        throw this.raise(Errors.MissingPlugin, loc != null ? loc : this.state.startLoc, {
          missingPlugin: [pluginName]
        });
      }
      expectOnePlugin(pluginNames) {
        if (!pluginNames.some((name) => this.hasPlugin(name))) {
          throw this.raise(Errors.MissingOneOfPlugins, this.state.startLoc, {
            missingPlugin: pluginNames
          });
        }
      }
      errorBuilder(error) {
        return (pos2, lineStart, curLine) => {
          this.raise(error, buildPosition(pos2, lineStart, curLine));
        };
      }
    };
    var ClassScope = class {
      constructor() {
        this.privateNames = /* @__PURE__ */ new Set();
        this.loneAccessors = /* @__PURE__ */ new Map();
        this.undefinedPrivateNames = /* @__PURE__ */ new Map();
      }
    };
    var ClassScopeHandler = class {
      constructor(parser) {
        this.parser = void 0;
        this.stack = [];
        this.undefinedPrivateNames = /* @__PURE__ */ new Map();
        this.parser = parser;
      }
      current() {
        return this.stack[this.stack.length - 1];
      }
      enter() {
        this.stack.push(new ClassScope());
      }
      exit() {
        const oldClassScope = this.stack.pop();
        const current = this.current();
        for (const [name, loc] of Array.from(oldClassScope.undefinedPrivateNames)) {
          if (current) {
            if (!current.undefinedPrivateNames.has(name)) {
              current.undefinedPrivateNames.set(name, loc);
            }
          } else {
            this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, {
              identifierName: name
            });
          }
        }
      }
      declarePrivateName(name, elementType, loc) {
        const {
          privateNames,
          loneAccessors,
          undefinedPrivateNames
        } = this.current();
        let redefined = privateNames.has(name);
        if (elementType & 3) {
          const accessor = redefined && loneAccessors.get(name);
          if (accessor) {
            const oldStatic = accessor & 4;
            const newStatic = elementType & 4;
            const oldKind = accessor & 3;
            const newKind = elementType & 3;
            redefined = oldKind === newKind || oldStatic !== newStatic;
            if (!redefined) loneAccessors.delete(name);
          } else if (!redefined) {
            loneAccessors.set(name, elementType);
          }
        }
        if (redefined) {
          this.parser.raise(Errors.PrivateNameRedeclaration, loc, {
            identifierName: name
          });
        }
        privateNames.add(name);
        undefinedPrivateNames.delete(name);
      }
      usePrivateName(name, loc) {
        let classScope;
        for (classScope of this.stack) {
          if (classScope.privateNames.has(name)) return;
        }
        if (classScope) {
          classScope.undefinedPrivateNames.set(name, loc);
        } else {
          this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, {
            identifierName: name
          });
        }
      }
    };
    var ExpressionScope = class {
      constructor(type = 0) {
        this.type = type;
      }
      canBeArrowParameterDeclaration() {
        return this.type === 2 || this.type === 1;
      }
      isCertainlyParameterDeclaration() {
        return this.type === 3;
      }
    };
    var ArrowHeadParsingScope = class extends ExpressionScope {
      constructor(type) {
        super(type);
        this.declarationErrors = /* @__PURE__ */ new Map();
      }
      recordDeclarationError(ParsingErrorClass, at) {
        const index = at.index;
        this.declarationErrors.set(index, [ParsingErrorClass, at]);
      }
      clearDeclarationError(index) {
        this.declarationErrors.delete(index);
      }
      iterateErrors(iterator) {
        this.declarationErrors.forEach(iterator);
      }
    };
    var ExpressionScopeHandler = class {
      constructor(parser) {
        this.parser = void 0;
        this.stack = [new ExpressionScope()];
        this.parser = parser;
      }
      enter(scope) {
        this.stack.push(scope);
      }
      exit() {
        this.stack.pop();
      }
      recordParameterInitializerError(toParseError, node) {
        const origin = node.loc.start;
        const {
          stack: stack2
        } = this;
        let i = stack2.length - 1;
        let scope = stack2[i];
        while (!scope.isCertainlyParameterDeclaration()) {
          if (scope.canBeArrowParameterDeclaration()) {
            scope.recordDeclarationError(toParseError, origin);
          } else {
            return;
          }
          scope = stack2[--i];
        }
        this.parser.raise(toParseError, origin);
      }
      recordArrowParameterBindingError(error, node) {
        const {
          stack: stack2
        } = this;
        const scope = stack2[stack2.length - 1];
        const origin = node.loc.start;
        if (scope.isCertainlyParameterDeclaration()) {
          this.parser.raise(error, origin);
        } else if (scope.canBeArrowParameterDeclaration()) {
          scope.recordDeclarationError(error, origin);
        } else {
          return;
        }
      }
      recordAsyncArrowParametersError(at) {
        const {
          stack: stack2
        } = this;
        let i = stack2.length - 1;
        let scope = stack2[i];
        while (scope.canBeArrowParameterDeclaration()) {
          if (scope.type === 2) {
            scope.recordDeclarationError(Errors.AwaitBindingIdentifier, at);
          }
          scope = stack2[--i];
        }
      }
      validateAsPattern() {
        const {
          stack: stack2
        } = this;
        const currentScope = stack2[stack2.length - 1];
        if (!currentScope.canBeArrowParameterDeclaration()) return;
        currentScope.iterateErrors(([toParseError, loc]) => {
          this.parser.raise(toParseError, loc);
          let i = stack2.length - 2;
          let scope = stack2[i];
          while (scope.canBeArrowParameterDeclaration()) {
            scope.clearDeclarationError(loc.index);
            scope = stack2[--i];
          }
        });
      }
    };
    function newParameterDeclarationScope() {
      return new ExpressionScope(3);
    }
    function newArrowHeadScope() {
      return new ArrowHeadParsingScope(1);
    }
    function newAsyncArrowScope() {
      return new ArrowHeadParsingScope(2);
    }
    function newExpressionScope() {
      return new ExpressionScope();
    }
    var ProductionParameterHandler = class {
      constructor() {
        this.stacks = [];
      }
      enter(flags) {
        this.stacks.push(flags);
      }
      exit() {
        this.stacks.pop();
      }
      currentFlags() {
        return this.stacks[this.stacks.length - 1];
      }
      get hasAwait() {
        return (this.currentFlags() & 2) > 0;
      }
      get hasYield() {
        return (this.currentFlags() & 1) > 0;
      }
      get hasReturn() {
        return (this.currentFlags() & 4) > 0;
      }
      get hasIn() {
        return (this.currentFlags() & 8) > 0;
      }
    };
    function functionFlags(isAsync2, isGenerator) {
      return (isAsync2 ? 2 : 0) | (isGenerator ? 1 : 0);
    }
    var UtilParser = class extends Tokenizer {
      addExtra(node, key2, value, enumerable = true) {
        if (!node) return;
        let {
          extra
        } = node;
        if (extra == null) {
          extra = {};
          node.extra = extra;
        }
        if (enumerable) {
          extra[key2] = value;
        } else {
          Object.defineProperty(extra, key2, {
            enumerable,
            value
          });
        }
      }
      isContextual(token2) {
        return this.state.type === token2 && !this.state.containsEsc;
      }
      isUnparsedContextual(nameStart, name) {
        const nameEnd = nameStart + name.length;
        if (this.input.slice(nameStart, nameEnd) === name) {
          const nextCh = this.input.charCodeAt(nameEnd);
          return !(isIdentifierChar(nextCh) || (nextCh & 64512) === 55296);
        }
        return false;
      }
      isLookaheadContextual(name) {
        const next = this.nextTokenStart();
        return this.isUnparsedContextual(next, name);
      }
      eatContextual(token2) {
        if (this.isContextual(token2)) {
          this.next();
          return true;
        }
        return false;
      }
      expectContextual(token2, toParseError) {
        if (!this.eatContextual(token2)) {
          if (toParseError != null) {
            throw this.raise(toParseError, this.state.startLoc);
          }
          this.unexpected(null, token2);
        }
      }
      canInsertSemicolon() {
        return this.match(140) || this.match(8) || this.hasPrecedingLineBreak();
      }
      hasPrecedingLineBreak() {
        return hasNewLine(this.input, this.offsetToSourcePos(this.state.lastTokEndLoc.index), this.state.start);
      }
      hasFollowingLineBreak() {
        return hasNewLine(this.input, this.state.end, this.nextTokenStart());
      }
      isLineTerminator() {
        return this.eat(13) || this.canInsertSemicolon();
      }
      semicolon(allowAsi = true) {
        if (allowAsi ? this.isLineTerminator() : this.eat(13)) return;
        this.raise(Errors.MissingSemicolon, this.state.lastTokEndLoc);
      }
      expect(type, loc) {
        if (!this.eat(type)) {
          this.unexpected(loc, type);
        }
      }
      tryParse(fn, oldState = this.state.clone()) {
        const abortSignal = {
          node: null
        };
        try {
          const node = fn((node2 = null) => {
            abortSignal.node = node2;
            throw abortSignal;
          });
          if (this.state.errors.length > oldState.errors.length) {
            const failState = this.state;
            this.state = oldState;
            this.state.tokensLength = failState.tokensLength;
            return {
              node,
              error: failState.errors[oldState.errors.length],
              thrown: false,
              aborted: false,
              failState
            };
          }
          return {
            node,
            error: null,
            thrown: false,
            aborted: false,
            failState: null
          };
        } catch (error) {
          const failState = this.state;
          this.state = oldState;
          if (error instanceof SyntaxError) {
            return {
              node: null,
              error,
              thrown: true,
              aborted: false,
              failState
            };
          }
          if (error === abortSignal) {
            return {
              node: abortSignal.node,
              error: null,
              thrown: false,
              aborted: true,
              failState
            };
          }
          throw error;
        }
      }
      checkExpressionErrors(refExpressionErrors, andThrow) {
        if (!refExpressionErrors) return false;
        const {
          shorthandAssignLoc,
          doubleProtoLoc,
          privateKeyLoc,
          optionalParametersLoc
        } = refExpressionErrors;
        const hasErrors = !!shorthandAssignLoc || !!doubleProtoLoc || !!optionalParametersLoc || !!privateKeyLoc;
        if (!andThrow) {
          return hasErrors;
        }
        if (shorthandAssignLoc != null) {
          this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc);
        }
        if (doubleProtoLoc != null) {
          this.raise(Errors.DuplicateProto, doubleProtoLoc);
        }
        if (privateKeyLoc != null) {
          this.raise(Errors.UnexpectedPrivateField, privateKeyLoc);
        }
        if (optionalParametersLoc != null) {
          this.unexpected(optionalParametersLoc);
        }
      }
      isLiteralPropertyName() {
        return tokenIsLiteralPropertyName(this.state.type);
      }
      isPrivateName(node) {
        return node.type === "PrivateName";
      }
      getPrivateNameSV(node) {
        return node.id.name;
      }
      hasPropertyAsPrivateName(node) {
        return (node.type === "MemberExpression" || node.type === "OptionalMemberExpression") && this.isPrivateName(node.property);
      }
      isObjectProperty(node) {
        return node.type === "ObjectProperty";
      }
      isObjectMethod(node) {
        return node.type === "ObjectMethod";
      }
      initializeScopes(inModule = this.options.sourceType === "module") {
        const oldLabels = this.state.labels;
        this.state.labels = [];
        const oldExportedIdentifiers = this.exportedIdentifiers;
        this.exportedIdentifiers = /* @__PURE__ */ new Set();
        const oldInModule = this.inModule;
        this.inModule = inModule;
        const oldScope = this.scope;
        const ScopeHandler2 = this.getScopeHandler();
        this.scope = new ScopeHandler2(this, inModule);
        const oldProdParam = this.prodParam;
        this.prodParam = new ProductionParameterHandler();
        const oldClassScope = this.classScope;
        this.classScope = new ClassScopeHandler(this);
        const oldExpressionScope = this.expressionScope;
        this.expressionScope = new ExpressionScopeHandler(this);
        return () => {
          this.state.labels = oldLabels;
          this.exportedIdentifiers = oldExportedIdentifiers;
          this.inModule = oldInModule;
          this.scope = oldScope;
          this.prodParam = oldProdParam;
          this.classScope = oldClassScope;
          this.expressionScope = oldExpressionScope;
        };
      }
      enterInitialScopes() {
        let paramFlags = 0;
        if (this.inModule) {
          paramFlags |= 2;
        }
        if (this.optionFlags & 32) {
          paramFlags |= 1;
        }
        this.scope.enter(1);
        this.prodParam.enter(paramFlags);
      }
      checkDestructuringPrivate(refExpressionErrors) {
        const {
          privateKeyLoc
        } = refExpressionErrors;
        if (privateKeyLoc !== null) {
          this.expectPlugin("destructuringPrivate", privateKeyLoc);
        }
      }
    };
    var ExpressionErrors = class {
      constructor() {
        this.shorthandAssignLoc = null;
        this.doubleProtoLoc = null;
        this.privateKeyLoc = null;
        this.optionalParametersLoc = null;
      }
    };
    var Node2 = class {
      constructor(parser, pos2, loc) {
        this.type = "";
        this.start = pos2;
        this.end = 0;
        this.loc = new SourceLocation22(loc);
        if ((parser == null ? void 0 : parser.optionFlags) & 128) this.range = [pos2, 0];
        if (parser != null && parser.filename) this.loc.filename = parser.filename;
      }
    };
    var NodePrototype = Node2.prototype;
    {
      NodePrototype.__clone = function() {
        const newNode = new Node2(void 0, this.start, this.loc.start);
        const keys = Object.keys(this);
        for (let i = 0, length = keys.length; i < length; i++) {
          const key2 = keys[i];
          if (key2 !== "leadingComments" && key2 !== "trailingComments" && key2 !== "innerComments") {
            newNode[key2] = this[key2];
          }
        }
        return newNode;
      };
    }
    function clonePlaceholder(node) {
      return cloneIdentifier(node);
    }
    function cloneIdentifier(node) {
      const {
        type,
        start,
        end,
        loc,
        range,
        extra,
        name
      } = node;
      const cloned = Object.create(NodePrototype);
      cloned.type = type;
      cloned.start = start;
      cloned.end = end;
      cloned.loc = loc;
      cloned.range = range;
      cloned.extra = extra;
      cloned.name = name;
      if (type === "Placeholder") {
        cloned.expectedNode = node.expectedNode;
      }
      return cloned;
    }
    function cloneStringLiteral(node) {
      const {
        type,
        start,
        end,
        loc,
        range,
        extra
      } = node;
      if (type === "Placeholder") {
        return clonePlaceholder(node);
      }
      const cloned = Object.create(NodePrototype);
      cloned.type = type;
      cloned.start = start;
      cloned.end = end;
      cloned.loc = loc;
      cloned.range = range;
      if (node.raw !== void 0) {
        cloned.raw = node.raw;
      } else {
        cloned.extra = extra;
      }
      cloned.value = node.value;
      return cloned;
    }
    var NodeUtils = class extends UtilParser {
      startNode() {
        const loc = this.state.startLoc;
        return new Node2(this, loc.index, loc);
      }
      startNodeAt(loc) {
        return new Node2(this, loc.index, loc);
      }
      startNodeAtNode(type) {
        return this.startNodeAt(type.loc.start);
      }
      finishNode(node, type) {
        return this.finishNodeAt(node, type, this.state.lastTokEndLoc);
      }
      finishNodeAt(node, type, endLoc) {
        node.type = type;
        node.end = endLoc.index;
        node.loc.end = endLoc;
        if (this.optionFlags & 128) node.range[1] = endLoc.index;
        if (this.optionFlags & 4096) {
          this.processComment(node);
        }
        return node;
      }
      resetStartLocation(node, startLoc) {
        node.start = startLoc.index;
        node.loc.start = startLoc;
        if (this.optionFlags & 128) node.range[0] = startLoc.index;
      }
      resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {
        node.end = endLoc.index;
        node.loc.end = endLoc;
        if (this.optionFlags & 128) node.range[1] = endLoc.index;
      }
      resetStartLocationFromNode(node, locationNode) {
        this.resetStartLocation(node, locationNode.loc.start);
      }
    };
    var reservedTypes = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]);
    var FlowErrors = ParseErrorEnum`flow`({
      AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
      AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
      AssignReservedType: ({
        reservedType
      }) => `Cannot overwrite reserved type ${reservedType}.`,
      DeclareClassElement: "The `declare` modifier can only appear on class fields.",
      DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
      DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
      EnumBooleanMemberNotInitialized: ({
        memberName,
        enumName
      }) => `Boolean enum members need to be initialized. Use either \`${memberName} = true,\` or \`${memberName} = false,\` in enum \`${enumName}\`.`,
      EnumDuplicateMemberName: ({
        memberName,
        enumName
      }) => `Enum member names need to be unique, but the name \`${memberName}\` has already been used before in enum \`${enumName}\`.`,
      EnumInconsistentMemberValues: ({
        enumName
      }) => `Enum \`${enumName}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,
      EnumInvalidExplicitType: ({
        invalidEnumType,
        enumName
      }) => `Enum type \`${invalidEnumType}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`,
      EnumInvalidExplicitTypeUnknownSupplied: ({
        enumName
      }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`,
      EnumInvalidMemberInitializerPrimaryType: ({
        enumName,
        memberName,
        explicitType
      }) => `Enum \`${enumName}\` has type \`${explicitType}\`, so the initializer of \`${memberName}\` needs to be a ${explicitType} literal.`,
      EnumInvalidMemberInitializerSymbolType: ({
        enumName,
        memberName
      }) => `Symbol enum members cannot be initialized. Use \`${memberName},\` in enum \`${enumName}\`.`,
      EnumInvalidMemberInitializerUnknownType: ({
        enumName,
        memberName
      }) => `The enum member initializer for \`${memberName}\` needs to be a literal (either a boolean, number, or string) in enum \`${enumName}\`.`,
      EnumInvalidMemberName: ({
        enumName,
        memberName,
        suggestion
      }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${memberName}\`, consider using \`${suggestion}\`, in enum \`${enumName}\`.`,
      EnumNumberMemberNotInitialized: ({
        enumName,
        memberName
      }) => `Number enum members need to be initialized, e.g. \`${memberName} = 1\` in enum \`${enumName}\`.`,
      EnumStringMemberInconsistentlyInitialized: ({
        enumName
      }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${enumName}\`.`,
      GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
      ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
      ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
      InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
      InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
      InexactVariance: "Explicit inexact syntax cannot have variance.",
      InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
      MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
      NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
      NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
      PatternIsOptional: Object.assign({
        message: "A binding pattern parameter cannot be optional in an implementation signature."
      }, {
        reasonCode: "OptionalBindingPattern"
      }),
      SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
      SpreadVariance: "Spread properties cannot have variance.",
      ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
      ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
      ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
      ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
      ThisParamNoDefault: "The `this` parameter may not have a default value.",
      TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
      TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
      UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
      UnexpectedReservedType: ({
        reservedType
      }) => `Unexpected reserved type ${reservedType}.`,
      UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
      UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
      UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
      UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
      UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
      UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
      UnsupportedDeclareExportKind: ({
        unsupportedExportKind,
        suggestion
      }) => `\`declare export ${unsupportedExportKind}\` is not supported. Use \`${suggestion}\` instead.`,
      UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
      UnterminatedFlowComment: "Unterminated flow-comment."
    });
    function isEsModuleType(bodyElement) {
      return bodyElement.type === "DeclareExportAllDeclaration" || bodyElement.type === "DeclareExportDeclaration" && (!bodyElement.declaration || bodyElement.declaration.type !== "TypeAlias" && bodyElement.declaration.type !== "InterfaceDeclaration");
    }
    function hasTypeImportKind(node) {
      return node.importKind === "type" || node.importKind === "typeof";
    }
    var exportSuggestions = {
      const: "declare export var",
      let: "declare export var",
      type: "export type",
      interface: "export interface"
    };
    function partition(list, test) {
      const list1 = [];
      const list2 = [];
      for (let i = 0; i < list.length; i++) {
        (test(list[i], i, list) ? list1 : list2).push(list[i]);
      }
      return [list1, list2];
    }
    var FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/;
    var flow = (superClass) => class FlowParserMixin extends superClass {
      constructor(...args) {
        super(...args);
        this.flowPragma = void 0;
      }
      getScopeHandler() {
        return FlowScopeHandler;
      }
      shouldParseTypes() {
        return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
      }
      finishToken(type, val) {
        if (type !== 134 && type !== 13 && type !== 28) {
          if (this.flowPragma === void 0) {
            this.flowPragma = null;
          }
        }
        super.finishToken(type, val);
      }
      addComment(comment) {
        if (this.flowPragma === void 0) {
          const matches = FLOW_PRAGMA_REGEX.exec(comment.value);
          if (!matches) ;
          else if (matches[1] === "flow") {
            this.flowPragma = "flow";
          } else if (matches[1] === "noflow") {
            this.flowPragma = "noflow";
          } else {
            throw new Error("Unexpected flow pragma");
          }
        }
        super.addComment(comment);
      }
      flowParseTypeInitialiser(tok) {
        const oldInType = this.state.inType;
        this.state.inType = true;
        this.expect(tok || 14);
        const type = this.flowParseType();
        this.state.inType = oldInType;
        return type;
      }
      flowParsePredicate() {
        const node = this.startNode();
        const moduloLoc = this.state.startLoc;
        this.next();
        this.expectContextual(110);
        if (this.state.lastTokStartLoc.index > moduloLoc.index + 1) {
          this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks, moduloLoc);
        }
        if (this.eat(10)) {
          node.value = super.parseExpression();
          this.expect(11);
          return this.finishNode(node, "DeclaredPredicate");
        } else {
          return this.finishNode(node, "InferredPredicate");
        }
      }
      flowParseTypeAndPredicateInitialiser() {
        const oldInType = this.state.inType;
        this.state.inType = true;
        this.expect(14);
        let type = null;
        let predicate = null;
        if (this.match(54)) {
          this.state.inType = oldInType;
          predicate = this.flowParsePredicate();
        } else {
          type = this.flowParseType();
          this.state.inType = oldInType;
          if (this.match(54)) {
            predicate = this.flowParsePredicate();
          }
        }
        return [type, predicate];
      }
      flowParseDeclareClass(node) {
        this.next();
        this.flowParseInterfaceish(node, true);
        return this.finishNode(node, "DeclareClass");
      }
      flowParseDeclareFunction(node) {
        this.next();
        const id = node.id = this.parseIdentifier();
        const typeNode = this.startNode();
        const typeContainer = this.startNode();
        if (this.match(47)) {
          typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          typeNode.typeParameters = null;
        }
        this.expect(10);
        const tmp = this.flowParseFunctionTypeParams();
        typeNode.params = tmp.params;
        typeNode.rest = tmp.rest;
        typeNode.this = tmp._this;
        this.expect(11);
        [typeNode.returnType, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
        typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation");
        id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");
        this.resetEndLocation(id);
        this.semicolon();
        this.scope.declareName(node.id.name, 2048, node.id.loc.start);
        return this.finishNode(node, "DeclareFunction");
      }
      flowParseDeclare(node, insideModule) {
        if (this.match(80)) {
          return this.flowParseDeclareClass(node);
        } else if (this.match(68)) {
          return this.flowParseDeclareFunction(node);
        } else if (this.match(74)) {
          return this.flowParseDeclareVariable(node);
        } else if (this.eatContextual(127)) {
          if (this.match(16)) {
            return this.flowParseDeclareModuleExports(node);
          } else {
            if (insideModule) {
              this.raise(FlowErrors.NestedDeclareModule, this.state.lastTokStartLoc);
            }
            return this.flowParseDeclareModule(node);
          }
        } else if (this.isContextual(130)) {
          return this.flowParseDeclareTypeAlias(node);
        } else if (this.isContextual(131)) {
          return this.flowParseDeclareOpaqueType(node);
        } else if (this.isContextual(129)) {
          return this.flowParseDeclareInterface(node);
        } else if (this.match(82)) {
          return this.flowParseDeclareExportDeclaration(node, insideModule);
        } else {
          this.unexpected();
        }
      }
      flowParseDeclareVariable(node) {
        this.next();
        node.id = this.flowParseTypeAnnotatableIdentifier(true);
        this.scope.declareName(node.id.name, 5, node.id.loc.start);
        this.semicolon();
        return this.finishNode(node, "DeclareVariable");
      }
      flowParseDeclareModule(node) {
        this.scope.enter(0);
        if (this.match(134)) {
          node.id = super.parseExprAtom();
        } else {
          node.id = this.parseIdentifier();
        }
        const bodyNode = node.body = this.startNode();
        const body = bodyNode.body = [];
        this.expect(5);
        while (!this.match(8)) {
          let bodyNode2 = this.startNode();
          if (this.match(83)) {
            this.next();
            if (!this.isContextual(130) && !this.match(87)) {
              this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule, this.state.lastTokStartLoc);
            }
            super.parseImport(bodyNode2);
          } else {
            this.expectContextual(125, FlowErrors.UnsupportedStatementInDeclareModule);
            bodyNode2 = this.flowParseDeclare(bodyNode2, true);
          }
          body.push(bodyNode2);
        }
        this.scope.exit();
        this.expect(8);
        this.finishNode(bodyNode, "BlockStatement");
        let kind = null;
        let hasModuleExport = false;
        body.forEach((bodyElement) => {
          if (isEsModuleType(bodyElement)) {
            if (kind === "CommonJS") {
              this.raise(FlowErrors.AmbiguousDeclareModuleKind, bodyElement);
            }
            kind = "ES";
          } else if (bodyElement.type === "DeclareModuleExports") {
            if (hasModuleExport) {
              this.raise(FlowErrors.DuplicateDeclareModuleExports, bodyElement);
            }
            if (kind === "ES") {
              this.raise(FlowErrors.AmbiguousDeclareModuleKind, bodyElement);
            }
            kind = "CommonJS";
            hasModuleExport = true;
          }
        });
        node.kind = kind || "CommonJS";
        return this.finishNode(node, "DeclareModule");
      }
      flowParseDeclareExportDeclaration(node, insideModule) {
        this.expect(82);
        if (this.eat(65)) {
          if (this.match(68) || this.match(80)) {
            node.declaration = this.flowParseDeclare(this.startNode());
          } else {
            node.declaration = this.flowParseType();
            this.semicolon();
          }
          node.default = true;
          return this.finishNode(node, "DeclareExportDeclaration");
        } else {
          if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !insideModule) {
            const label = this.state.value;
            throw this.raise(FlowErrors.UnsupportedDeclareExportKind, this.state.startLoc, {
              unsupportedExportKind: label,
              suggestion: exportSuggestions[label]
            });
          }
          if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131)) {
            node.declaration = this.flowParseDeclare(this.startNode());
            node.default = false;
            return this.finishNode(node, "DeclareExportDeclaration");
          } else if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131)) {
            node = this.parseExport(node, null);
            if (node.type === "ExportNamedDeclaration") {
              node.type = "ExportDeclaration";
              node.default = false;
              delete node.exportKind;
            }
            node.type = "Declare" + node.type;
            return node;
          }
        }
        this.unexpected();
      }
      flowParseDeclareModuleExports(node) {
        this.next();
        this.expectContextual(111);
        node.typeAnnotation = this.flowParseTypeAnnotation();
        this.semicolon();
        return this.finishNode(node, "DeclareModuleExports");
      }
      flowParseDeclareTypeAlias(node) {
        this.next();
        const finished = this.flowParseTypeAlias(node);
        finished.type = "DeclareTypeAlias";
        return finished;
      }
      flowParseDeclareOpaqueType(node) {
        this.next();
        const finished = this.flowParseOpaqueType(node, true);
        finished.type = "DeclareOpaqueType";
        return finished;
      }
      flowParseDeclareInterface(node) {
        this.next();
        this.flowParseInterfaceish(node, false);
        return this.finishNode(node, "DeclareInterface");
      }
      flowParseInterfaceish(node, isClass) {
        node.id = this.flowParseRestrictedIdentifier(!isClass, true);
        this.scope.declareName(node.id.name, isClass ? 17 : 8201, node.id.loc.start);
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          node.typeParameters = null;
        }
        node.extends = [];
        if (this.eat(81)) {
          do {
            node.extends.push(this.flowParseInterfaceExtends());
          } while (!isClass && this.eat(12));
        }
        if (isClass) {
          node.implements = [];
          node.mixins = [];
          if (this.eatContextual(117)) {
            do {
              node.mixins.push(this.flowParseInterfaceExtends());
            } while (this.eat(12));
          }
          if (this.eatContextual(113)) {
            do {
              node.implements.push(this.flowParseInterfaceExtends());
            } while (this.eat(12));
          }
        }
        node.body = this.flowParseObjectType({
          allowStatic: isClass,
          allowExact: false,
          allowSpread: false,
          allowProto: isClass,
          allowInexact: false
        });
      }
      flowParseInterfaceExtends() {
        const node = this.startNode();
        node.id = this.flowParseQualifiedTypeIdentifier();
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterInstantiation();
        } else {
          node.typeParameters = null;
        }
        return this.finishNode(node, "InterfaceExtends");
      }
      flowParseInterface(node) {
        this.flowParseInterfaceish(node, false);
        return this.finishNode(node, "InterfaceDeclaration");
      }
      checkNotUnderscore(word) {
        if (word === "_") {
          this.raise(FlowErrors.UnexpectedReservedUnderscore, this.state.startLoc);
        }
      }
      checkReservedType(word, startLoc, declaration) {
        if (!reservedTypes.has(word)) return;
        this.raise(declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, startLoc, {
          reservedType: word
        });
      }
      flowParseRestrictedIdentifier(liberal, declaration) {
        this.checkReservedType(this.state.value, this.state.startLoc, declaration);
        return this.parseIdentifier(liberal);
      }
      flowParseTypeAlias(node) {
        node.id = this.flowParseRestrictedIdentifier(false, true);
        this.scope.declareName(node.id.name, 8201, node.id.loc.start);
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          node.typeParameters = null;
        }
        node.right = this.flowParseTypeInitialiser(29);
        this.semicolon();
        return this.finishNode(node, "TypeAlias");
      }
      flowParseOpaqueType(node, declare) {
        this.expectContextual(130);
        node.id = this.flowParseRestrictedIdentifier(true, true);
        this.scope.declareName(node.id.name, 8201, node.id.loc.start);
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          node.typeParameters = null;
        }
        node.supertype = null;
        if (this.match(14)) {
          node.supertype = this.flowParseTypeInitialiser(14);
        }
        node.impltype = null;
        if (!declare) {
          node.impltype = this.flowParseTypeInitialiser(29);
        }
        this.semicolon();
        return this.finishNode(node, "OpaqueType");
      }
      flowParseTypeParameter(requireDefault = false) {
        const nodeStartLoc = this.state.startLoc;
        const node = this.startNode();
        const variance = this.flowParseVariance();
        const ident = this.flowParseTypeAnnotatableIdentifier();
        node.name = ident.name;
        node.variance = variance;
        node.bound = ident.typeAnnotation;
        if (this.match(29)) {
          this.eat(29);
          node.default = this.flowParseType();
        } else {
          if (requireDefault) {
            this.raise(FlowErrors.MissingTypeParamDefault, nodeStartLoc);
          }
        }
        return this.finishNode(node, "TypeParameter");
      }
      flowParseTypeParameterDeclaration() {
        const oldInType = this.state.inType;
        const node = this.startNode();
        node.params = [];
        this.state.inType = true;
        if (this.match(47) || this.match(143)) {
          this.next();
        } else {
          this.unexpected();
        }
        let defaultRequired = false;
        do {
          const typeParameter = this.flowParseTypeParameter(defaultRequired);
          node.params.push(typeParameter);
          if (typeParameter.default) {
            defaultRequired = true;
          }
          if (!this.match(48)) {
            this.expect(12);
          }
        } while (!this.match(48));
        this.expect(48);
        this.state.inType = oldInType;
        return this.finishNode(node, "TypeParameterDeclaration");
      }
      flowInTopLevelContext(cb) {
        if (this.curContext() !== types.brace) {
          const oldContext = this.state.context;
          this.state.context = [oldContext[0]];
          try {
            return cb();
          } finally {
            this.state.context = oldContext;
          }
        } else {
          return cb();
        }
      }
      flowParseTypeParameterInstantiationInExpression() {
        if (this.reScan_lt() !== 47) return;
        return this.flowParseTypeParameterInstantiation();
      }
      flowParseTypeParameterInstantiation() {
        const node = this.startNode();
        const oldInType = this.state.inType;
        this.state.inType = true;
        node.params = [];
        this.flowInTopLevelContext(() => {
          this.expect(47);
          const oldNoAnonFunctionType = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = false;
          while (!this.match(48)) {
            node.params.push(this.flowParseType());
            if (!this.match(48)) {
              this.expect(12);
            }
          }
          this.state.noAnonFunctionType = oldNoAnonFunctionType;
        });
        this.state.inType = oldInType;
        if (!this.state.inType && this.curContext() === types.brace) {
          this.reScan_lt_gt();
        }
        this.expect(48);
        return this.finishNode(node, "TypeParameterInstantiation");
      }
      flowParseTypeParameterInstantiationCallOrNew() {
        if (this.reScan_lt() !== 47) return;
        const node = this.startNode();
        const oldInType = this.state.inType;
        node.params = [];
        this.state.inType = true;
        this.expect(47);
        while (!this.match(48)) {
          node.params.push(this.flowParseTypeOrImplicitInstantiation());
          if (!this.match(48)) {
            this.expect(12);
          }
        }
        this.expect(48);
        this.state.inType = oldInType;
        return this.finishNode(node, "TypeParameterInstantiation");
      }
      flowParseInterfaceType() {
        const node = this.startNode();
        this.expectContextual(129);
        node.extends = [];
        if (this.eat(81)) {
          do {
            node.extends.push(this.flowParseInterfaceExtends());
          } while (this.eat(12));
        }
        node.body = this.flowParseObjectType({
          allowStatic: false,
          allowExact: false,
          allowSpread: false,
          allowProto: false,
          allowInexact: false
        });
        return this.finishNode(node, "InterfaceTypeAnnotation");
      }
      flowParseObjectPropertyKey() {
        return this.match(135) || this.match(134) ? super.parseExprAtom() : this.parseIdentifier(true);
      }
      flowParseObjectTypeIndexer(node, isStatic, variance) {
        node.static = isStatic;
        if (this.lookahead().type === 14) {
          node.id = this.flowParseObjectPropertyKey();
          node.key = this.flowParseTypeInitialiser();
        } else {
          node.id = null;
          node.key = this.flowParseType();
        }
        this.expect(3);
        node.value = this.flowParseTypeInitialiser();
        node.variance = variance;
        return this.finishNode(node, "ObjectTypeIndexer");
      }
      flowParseObjectTypeInternalSlot(node, isStatic) {
        node.static = isStatic;
        node.id = this.flowParseObjectPropertyKey();
        this.expect(3);
        this.expect(3);
        if (this.match(47) || this.match(10)) {
          node.method = true;
          node.optional = false;
          node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));
        } else {
          node.method = false;
          if (this.eat(17)) {
            node.optional = true;
          }
          node.value = this.flowParseTypeInitialiser();
        }
        return this.finishNode(node, "ObjectTypeInternalSlot");
      }
      flowParseObjectTypeMethodish(node) {
        node.params = [];
        node.rest = null;
        node.typeParameters = null;
        node.this = null;
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        }
        this.expect(10);
        if (this.match(78)) {
          node.this = this.flowParseFunctionTypeParam(true);
          node.this.name = null;
          if (!this.match(11)) {
            this.expect(12);
          }
        }
        while (!this.match(11) && !this.match(21)) {
          node.params.push(this.flowParseFunctionTypeParam(false));
          if (!this.match(11)) {
            this.expect(12);
          }
        }
        if (this.eat(21)) {
          node.rest = this.flowParseFunctionTypeParam(false);
        }
        this.expect(11);
        node.returnType = this.flowParseTypeInitialiser();
        return this.finishNode(node, "FunctionTypeAnnotation");
      }
      flowParseObjectTypeCallProperty(node, isStatic) {
        const valueNode = this.startNode();
        node.static = isStatic;
        node.value = this.flowParseObjectTypeMethodish(valueNode);
        return this.finishNode(node, "ObjectTypeCallProperty");
      }
      flowParseObjectType({
        allowStatic,
        allowExact,
        allowSpread,
        allowProto,
        allowInexact
      }) {
        const oldInType = this.state.inType;
        this.state.inType = true;
        const nodeStart = this.startNode();
        nodeStart.callProperties = [];
        nodeStart.properties = [];
        nodeStart.indexers = [];
        nodeStart.internalSlots = [];
        let endDelim;
        let exact;
        let inexact = false;
        if (allowExact && this.match(6)) {
          this.expect(6);
          endDelim = 9;
          exact = true;
        } else {
          this.expect(5);
          endDelim = 8;
          exact = false;
        }
        nodeStart.exact = exact;
        while (!this.match(endDelim)) {
          let isStatic = false;
          let protoStartLoc = null;
          let inexactStartLoc = null;
          const node = this.startNode();
          if (allowProto && this.isContextual(118)) {
            const lookahead = this.lookahead();
            if (lookahead.type !== 14 && lookahead.type !== 17) {
              this.next();
              protoStartLoc = this.state.startLoc;
              allowStatic = false;
            }
          }
          if (allowStatic && this.isContextual(106)) {
            const lookahead = this.lookahead();
            if (lookahead.type !== 14 && lookahead.type !== 17) {
              this.next();
              isStatic = true;
            }
          }
          const variance = this.flowParseVariance();
          if (this.eat(0)) {
            if (protoStartLoc != null) {
              this.unexpected(protoStartLoc);
            }
            if (this.eat(0)) {
              if (variance) {
                this.unexpected(variance.loc.start);
              }
              nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));
            } else {
              nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));
            }
          } else if (this.match(10) || this.match(47)) {
            if (protoStartLoc != null) {
              this.unexpected(protoStartLoc);
            }
            if (variance) {
              this.unexpected(variance.loc.start);
            }
            nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));
          } else {
            let kind = "init";
            if (this.isContextual(99) || this.isContextual(104)) {
              const lookahead = this.lookahead();
              if (tokenIsLiteralPropertyName(lookahead.type)) {
                kind = this.state.value;
                this.next();
              }
            }
            const propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);
            if (propOrInexact === null) {
              inexact = true;
              inexactStartLoc = this.state.lastTokStartLoc;
            } else {
              nodeStart.properties.push(propOrInexact);
            }
          }
          this.flowObjectTypeSemicolon();
          if (inexactStartLoc && !this.match(8) && !this.match(9)) {
            this.raise(FlowErrors.UnexpectedExplicitInexactInObject, inexactStartLoc);
          }
        }
        this.expect(endDelim);
        if (allowSpread) {
          nodeStart.inexact = inexact;
        }
        const out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
        this.state.inType = oldInType;
        return out;
      }
      flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact) {
        if (this.eat(21)) {
          const isInexactToken = this.match(12) || this.match(13) || this.match(8) || this.match(9);
          if (isInexactToken) {
            if (!allowSpread) {
              this.raise(FlowErrors.InexactInsideNonObject, this.state.lastTokStartLoc);
            } else if (!allowInexact) {
              this.raise(FlowErrors.InexactInsideExact, this.state.lastTokStartLoc);
            }
            if (variance) {
              this.raise(FlowErrors.InexactVariance, variance);
            }
            return null;
          }
          if (!allowSpread) {
            this.raise(FlowErrors.UnexpectedSpreadType, this.state.lastTokStartLoc);
          }
          if (protoStartLoc != null) {
            this.unexpected(protoStartLoc);
          }
          if (variance) {
            this.raise(FlowErrors.SpreadVariance, variance);
          }
          node.argument = this.flowParseType();
          return this.finishNode(node, "ObjectTypeSpreadProperty");
        } else {
          node.key = this.flowParseObjectPropertyKey();
          node.static = isStatic;
          node.proto = protoStartLoc != null;
          node.kind = kind;
          let optional = false;
          if (this.match(47) || this.match(10)) {
            node.method = true;
            if (protoStartLoc != null) {
              this.unexpected(protoStartLoc);
            }
            if (variance) {
              this.unexpected(variance.loc.start);
            }
            node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));
            if (kind === "get" || kind === "set") {
              this.flowCheckGetterSetterParams(node);
            }
            if (!allowSpread && node.key.name === "constructor" && node.value.this) {
              this.raise(FlowErrors.ThisParamBannedInConstructor, node.value.this);
            }
          } else {
            if (kind !== "init") this.unexpected();
            node.method = false;
            if (this.eat(17)) {
              optional = true;
            }
            node.value = this.flowParseTypeInitialiser();
            node.variance = variance;
          }
          node.optional = optional;
          return this.finishNode(node, "ObjectTypeProperty");
        }
      }
      flowCheckGetterSetterParams(property) {
        const paramCount = property.kind === "get" ? 0 : 1;
        const length = property.value.params.length + (property.value.rest ? 1 : 0);
        if (property.value.this) {
          this.raise(property.kind === "get" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam, property.value.this);
        }
        if (length !== paramCount) {
          this.raise(property.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, property);
        }
        if (property.kind === "set" && property.value.rest) {
          this.raise(Errors.BadSetterRestParameter, property);
        }
      }
      flowObjectTypeSemicolon() {
        if (!this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9)) {
          this.unexpected();
        }
      }
      flowParseQualifiedTypeIdentifier(startLoc, id) {
        startLoc != null ? startLoc : startLoc = this.state.startLoc;
        let node = id || this.flowParseRestrictedIdentifier(true);
        while (this.eat(16)) {
          const node2 = this.startNodeAt(startLoc);
          node2.qualification = node;
          node2.id = this.flowParseRestrictedIdentifier(true);
          node = this.finishNode(node2, "QualifiedTypeIdentifier");
        }
        return node;
      }
      flowParseGenericType(startLoc, id) {
        const node = this.startNodeAt(startLoc);
        node.typeParameters = null;
        node.id = this.flowParseQualifiedTypeIdentifier(startLoc, id);
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterInstantiation();
        }
        return this.finishNode(node, "GenericTypeAnnotation");
      }
      flowParseTypeofType() {
        const node = this.startNode();
        this.expect(87);
        node.argument = this.flowParsePrimaryType();
        return this.finishNode(node, "TypeofTypeAnnotation");
      }
      flowParseTupleType() {
        const node = this.startNode();
        node.types = [];
        this.expect(0);
        while (this.state.pos < this.length && !this.match(3)) {
          node.types.push(this.flowParseType());
          if (this.match(3)) break;
          this.expect(12);
        }
        this.expect(3);
        return this.finishNode(node, "TupleTypeAnnotation");
      }
      flowParseFunctionTypeParam(first) {
        let name = null;
        let optional = false;
        let typeAnnotation2 = null;
        const node = this.startNode();
        const lh = this.lookahead();
        const isThis = this.state.type === 78;
        if (lh.type === 14 || lh.type === 17) {
          if (isThis && !first) {
            this.raise(FlowErrors.ThisParamMustBeFirst, node);
          }
          name = this.parseIdentifier(isThis);
          if (this.eat(17)) {
            optional = true;
            if (isThis) {
              this.raise(FlowErrors.ThisParamMayNotBeOptional, node);
            }
          }
          typeAnnotation2 = this.flowParseTypeInitialiser();
        } else {
          typeAnnotation2 = this.flowParseType();
        }
        node.name = name;
        node.optional = optional;
        node.typeAnnotation = typeAnnotation2;
        return this.finishNode(node, "FunctionTypeParam");
      }
      reinterpretTypeAsFunctionTypeParam(type) {
        const node = this.startNodeAt(type.loc.start);
        node.name = null;
        node.optional = false;
        node.typeAnnotation = type;
        return this.finishNode(node, "FunctionTypeParam");
      }
      flowParseFunctionTypeParams(params = []) {
        let rest = null;
        let _this = null;
        if (this.match(78)) {
          _this = this.flowParseFunctionTypeParam(true);
          _this.name = null;
          if (!this.match(11)) {
            this.expect(12);
          }
        }
        while (!this.match(11) && !this.match(21)) {
          params.push(this.flowParseFunctionTypeParam(false));
          if (!this.match(11)) {
            this.expect(12);
          }
        }
        if (this.eat(21)) {
          rest = this.flowParseFunctionTypeParam(false);
        }
        return {
          params,
          rest,
          _this
        };
      }
      flowIdentToTypeAnnotation(startLoc, node, id) {
        switch (id.name) {
          case "any":
            return this.finishNode(node, "AnyTypeAnnotation");
          case "bool":
          case "boolean":
            return this.finishNode(node, "BooleanTypeAnnotation");
          case "mixed":
            return this.finishNode(node, "MixedTypeAnnotation");
          case "empty":
            return this.finishNode(node, "EmptyTypeAnnotation");
          case "number":
            return this.finishNode(node, "NumberTypeAnnotation");
          case "string":
            return this.finishNode(node, "StringTypeAnnotation");
          case "symbol":
            return this.finishNode(node, "SymbolTypeAnnotation");
          default:
            this.checkNotUnderscore(id.name);
            return this.flowParseGenericType(startLoc, id);
        }
      }
      flowParsePrimaryType() {
        const startLoc = this.state.startLoc;
        const node = this.startNode();
        let tmp;
        let type;
        let isGroupedType = false;
        const oldNoAnonFunctionType = this.state.noAnonFunctionType;
        switch (this.state.type) {
          case 5:
            return this.flowParseObjectType({
              allowStatic: false,
              allowExact: false,
              allowSpread: true,
              allowProto: false,
              allowInexact: true
            });
          case 6:
            return this.flowParseObjectType({
              allowStatic: false,
              allowExact: true,
              allowSpread: true,
              allowProto: false,
              allowInexact: false
            });
          case 0:
            this.state.noAnonFunctionType = false;
            type = this.flowParseTupleType();
            this.state.noAnonFunctionType = oldNoAnonFunctionType;
            return type;
          case 47: {
            const node2 = this.startNode();
            node2.typeParameters = this.flowParseTypeParameterDeclaration();
            this.expect(10);
            tmp = this.flowParseFunctionTypeParams();
            node2.params = tmp.params;
            node2.rest = tmp.rest;
            node2.this = tmp._this;
            this.expect(11);
            this.expect(19);
            node2.returnType = this.flowParseType();
            return this.finishNode(node2, "FunctionTypeAnnotation");
          }
          case 10: {
            const node2 = this.startNode();
            this.next();
            if (!this.match(11) && !this.match(21)) {
              if (tokenIsIdentifier(this.state.type) || this.match(78)) {
                const token2 = this.lookahead().type;
                isGroupedType = token2 !== 17 && token2 !== 14;
              } else {
                isGroupedType = true;
              }
            }
            if (isGroupedType) {
              this.state.noAnonFunctionType = false;
              type = this.flowParseType();
              this.state.noAnonFunctionType = oldNoAnonFunctionType;
              if (this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19)) {
                this.expect(11);
                return type;
              } else {
                this.eat(12);
              }
            }
            if (type) {
              tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);
            } else {
              tmp = this.flowParseFunctionTypeParams();
            }
            node2.params = tmp.params;
            node2.rest = tmp.rest;
            node2.this = tmp._this;
            this.expect(11);
            this.expect(19);
            node2.returnType = this.flowParseType();
            node2.typeParameters = null;
            return this.finishNode(node2, "FunctionTypeAnnotation");
          }
          case 134:
            return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
          case 85:
          case 86:
            node.value = this.match(85);
            this.next();
            return this.finishNode(node, "BooleanLiteralTypeAnnotation");
          case 53:
            if (this.state.value === "-") {
              this.next();
              if (this.match(135)) {
                return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", node);
              }
              if (this.match(136)) {
                return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", node);
              }
              throw this.raise(FlowErrors.UnexpectedSubtractionOperand, this.state.startLoc);
            }
            this.unexpected();
            return;
          case 135:
            return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
          case 136:
            return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
          case 88:
            this.next();
            return this.finishNode(node, "VoidTypeAnnotation");
          case 84:
            this.next();
            return this.finishNode(node, "NullLiteralTypeAnnotation");
          case 78:
            this.next();
            return this.finishNode(node, "ThisTypeAnnotation");
          case 55:
            this.next();
            return this.finishNode(node, "ExistsTypeAnnotation");
          case 87:
            return this.flowParseTypeofType();
          default:
            if (tokenIsKeyword(this.state.type)) {
              const label = tokenLabelName(this.state.type);
              this.next();
              return super.createIdentifier(node, label);
            } else if (tokenIsIdentifier(this.state.type)) {
              if (this.isContextual(129)) {
                return this.flowParseInterfaceType();
              }
              return this.flowIdentToTypeAnnotation(startLoc, node, this.parseIdentifier());
            }
        }
        this.unexpected();
      }
      flowParsePostfixType() {
        const startLoc = this.state.startLoc;
        let type = this.flowParsePrimaryType();
        let seenOptionalIndexedAccess = false;
        while ((this.match(0) || this.match(18)) && !this.canInsertSemicolon()) {
          const node = this.startNodeAt(startLoc);
          const optional = this.eat(18);
          seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;
          this.expect(0);
          if (!optional && this.match(3)) {
            node.elementType = type;
            this.next();
            type = this.finishNode(node, "ArrayTypeAnnotation");
          } else {
            node.objectType = type;
            node.indexType = this.flowParseType();
            this.expect(3);
            if (seenOptionalIndexedAccess) {
              node.optional = optional;
              type = this.finishNode(node, "OptionalIndexedAccessType");
            } else {
              type = this.finishNode(node, "IndexedAccessType");
            }
          }
        }
        return type;
      }
      flowParsePrefixType() {
        const node = this.startNode();
        if (this.eat(17)) {
          node.typeAnnotation = this.flowParsePrefixType();
          return this.finishNode(node, "NullableTypeAnnotation");
        } else {
          return this.flowParsePostfixType();
        }
      }
      flowParseAnonFunctionWithoutParens() {
        const param = this.flowParsePrefixType();
        if (!this.state.noAnonFunctionType && this.eat(19)) {
          const node = this.startNodeAt(param.loc.start);
          node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];
          node.rest = null;
          node.this = null;
          node.returnType = this.flowParseType();
          node.typeParameters = null;
          return this.finishNode(node, "FunctionTypeAnnotation");
        }
        return param;
      }
      flowParseIntersectionType() {
        const node = this.startNode();
        this.eat(45);
        const type = this.flowParseAnonFunctionWithoutParens();
        node.types = [type];
        while (this.eat(45)) {
          node.types.push(this.flowParseAnonFunctionWithoutParens());
        }
        return node.types.length === 1 ? type : this.finishNode(node, "IntersectionTypeAnnotation");
      }
      flowParseUnionType() {
        const node = this.startNode();
        this.eat(43);
        const type = this.flowParseIntersectionType();
        node.types = [type];
        while (this.eat(43)) {
          node.types.push(this.flowParseIntersectionType());
        }
        return node.types.length === 1 ? type : this.finishNode(node, "UnionTypeAnnotation");
      }
      flowParseType() {
        const oldInType = this.state.inType;
        this.state.inType = true;
        const type = this.flowParseUnionType();
        this.state.inType = oldInType;
        return type;
      }
      flowParseTypeOrImplicitInstantiation() {
        if (this.state.type === 132 && this.state.value === "_") {
          const startLoc = this.state.startLoc;
          const node = this.parseIdentifier();
          return this.flowParseGenericType(startLoc, node);
        } else {
          return this.flowParseType();
        }
      }
      flowParseTypeAnnotation() {
        const node = this.startNode();
        node.typeAnnotation = this.flowParseTypeInitialiser();
        return this.finishNode(node, "TypeAnnotation");
      }
      flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
        const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
        if (this.match(14)) {
          ident.typeAnnotation = this.flowParseTypeAnnotation();
          this.resetEndLocation(ident);
        }
        return ident;
      }
      typeCastToParameter(node) {
        node.expression.typeAnnotation = node.typeAnnotation;
        this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);
        return node.expression;
      }
      flowParseVariance() {
        let variance = null;
        if (this.match(53)) {
          variance = this.startNode();
          if (this.state.value === "+") {
            variance.kind = "plus";
          } else {
            variance.kind = "minus";
          }
          this.next();
          return this.finishNode(variance, "Variance");
        }
        return variance;
      }
      parseFunctionBody(node, allowExpressionBody, isMethod = false) {
        if (allowExpressionBody) {
          this.forwardNoArrowParamsConversionAt(node, () => super.parseFunctionBody(node, true, isMethod));
          return;
        }
        super.parseFunctionBody(node, false, isMethod);
      }
      parseFunctionBodyAndFinish(node, type, isMethod = false) {
        if (this.match(14)) {
          const typeNode = this.startNode();
          [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
          node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
        }
        return super.parseFunctionBodyAndFinish(node, type, isMethod);
      }
      parseStatementLike(flags) {
        if (this.state.strict && this.isContextual(129)) {
          const lookahead = this.lookahead();
          if (tokenIsKeywordOrIdentifier(lookahead.type)) {
            const node = this.startNode();
            this.next();
            return this.flowParseInterface(node);
          }
        } else if (this.isContextual(126)) {
          const node = this.startNode();
          this.next();
          return this.flowParseEnumDeclaration(node);
        }
        const stmt = super.parseStatementLike(flags);
        if (this.flowPragma === void 0 && !this.isValidDirective(stmt)) {
          this.flowPragma = null;
        }
        return stmt;
      }
      parseExpressionStatement(node, expr, decorators) {
        if (expr.type === "Identifier") {
          if (expr.name === "declare") {
            if (this.match(80) || tokenIsIdentifier(this.state.type) || this.match(68) || this.match(74) || this.match(82)) {
              return this.flowParseDeclare(node);
            }
          } else if (tokenIsIdentifier(this.state.type)) {
            if (expr.name === "interface") {
              return this.flowParseInterface(node);
            } else if (expr.name === "type") {
              return this.flowParseTypeAlias(node);
            } else if (expr.name === "opaque") {
              return this.flowParseOpaqueType(node, false);
            }
          }
        }
        return super.parseExpressionStatement(node, expr, decorators);
      }
      shouldParseExportDeclaration() {
        const {
          type
        } = this.state;
        if (type === 126 || tokenIsFlowInterfaceOrTypeOrOpaque(type)) {
          return !this.state.containsEsc;
        }
        return super.shouldParseExportDeclaration();
      }
      isExportDefaultSpecifier() {
        const {
          type
        } = this.state;
        if (type === 126 || tokenIsFlowInterfaceOrTypeOrOpaque(type)) {
          return this.state.containsEsc;
        }
        return super.isExportDefaultSpecifier();
      }
      parseExportDefaultExpression() {
        if (this.isContextual(126)) {
          const node = this.startNode();
          this.next();
          return this.flowParseEnumDeclaration(node);
        }
        return super.parseExportDefaultExpression();
      }
      parseConditional(expr, startLoc, refExpressionErrors) {
        if (!this.match(17)) return expr;
        if (this.state.maybeInArrowParameters) {
          const nextCh = this.lookaheadCharCode();
          if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {
            this.setOptionalParametersError(refExpressionErrors);
            return expr;
          }
        }
        this.expect(17);
        const state = this.state.clone();
        const originalNoArrowAt = this.state.noArrowAt;
        const node = this.startNodeAt(startLoc);
        let {
          consequent,
          failed
        } = this.tryParseConditionalConsequent();
        let [valid, invalid] = this.getArrowLikeExpressions(consequent);
        if (failed || invalid.length > 0) {
          const noArrowAt = [...originalNoArrowAt];
          if (invalid.length > 0) {
            this.state = state;
            this.state.noArrowAt = noArrowAt;
            for (let i = 0; i < invalid.length; i++) {
              noArrowAt.push(invalid[i].start);
            }
            ({
              consequent,
              failed
            } = this.tryParseConditionalConsequent());
            [valid, invalid] = this.getArrowLikeExpressions(consequent);
          }
          if (failed && valid.length > 1) {
            this.raise(FlowErrors.AmbiguousConditionalArrow, state.startLoc);
          }
          if (failed && valid.length === 1) {
            this.state = state;
            noArrowAt.push(valid[0].start);
            this.state.noArrowAt = noArrowAt;
            ({
              consequent,
              failed
            } = this.tryParseConditionalConsequent());
          }
        }
        this.getArrowLikeExpressions(consequent, true);
        this.state.noArrowAt = originalNoArrowAt;
        this.expect(14);
        node.test = expr;
        node.consequent = consequent;
        node.alternate = this.forwardNoArrowParamsConversionAt(node, () => this.parseMaybeAssign(void 0, void 0));
        return this.finishNode(node, "ConditionalExpression");
      }
      tryParseConditionalConsequent() {
        this.state.noArrowParamsConversionAt.push(this.state.start);
        const consequent = this.parseMaybeAssignAllowIn();
        const failed = !this.match(14);
        this.state.noArrowParamsConversionAt.pop();
        return {
          consequent,
          failed
        };
      }
      getArrowLikeExpressions(node, disallowInvalid) {
        const stack2 = [node];
        const arrows = [];
        while (stack2.length !== 0) {
          const node2 = stack2.pop();
          if (node2.type === "ArrowFunctionExpression" && node2.body.type !== "BlockStatement") {
            if (node2.typeParameters || !node2.returnType) {
              this.finishArrowValidation(node2);
            } else {
              arrows.push(node2);
            }
            stack2.push(node2.body);
          } else if (node2.type === "ConditionalExpression") {
            stack2.push(node2.consequent);
            stack2.push(node2.alternate);
          }
        }
        if (disallowInvalid) {
          arrows.forEach((node2) => this.finishArrowValidation(node2));
          return [arrows, []];
        }
        return partition(arrows, (node2) => node2.params.every((param) => this.isAssignable(param, true)));
      }
      finishArrowValidation(node) {
        var _node$extra;
        this.toAssignableList(node.params, (_node$extra = node.extra) == null ? void 0 : _node$extra.trailingCommaLoc, false);
        this.scope.enter(2 | 4);
        super.checkParams(node, false, true);
        this.scope.exit();
      }
      forwardNoArrowParamsConversionAt(node, parse5) {
        let result;
        if (this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node.start))) {
          this.state.noArrowParamsConversionAt.push(this.state.start);
          result = parse5();
          this.state.noArrowParamsConversionAt.pop();
        } else {
          result = parse5();
        }
        return result;
      }
      parseParenItem(node, startLoc) {
        const newNode = super.parseParenItem(node, startLoc);
        if (this.eat(17)) {
          newNode.optional = true;
          this.resetEndLocation(node);
        }
        if (this.match(14)) {
          const typeCastNode = this.startNodeAt(startLoc);
          typeCastNode.expression = newNode;
          typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();
          return this.finishNode(typeCastNode, "TypeCastExpression");
        }
        return newNode;
      }
      assertModuleNodeAllowed(node) {
        if (node.type === "ImportDeclaration" && (node.importKind === "type" || node.importKind === "typeof") || node.type === "ExportNamedDeclaration" && node.exportKind === "type" || node.type === "ExportAllDeclaration" && node.exportKind === "type") {
          return;
        }
        super.assertModuleNodeAllowed(node);
      }
      parseExportDeclaration(node) {
        if (this.isContextual(130)) {
          node.exportKind = "type";
          const declarationNode = this.startNode();
          this.next();
          if (this.match(5)) {
            node.specifiers = this.parseExportSpecifiers(true);
            super.parseExportFrom(node);
            return null;
          } else {
            return this.flowParseTypeAlias(declarationNode);
          }
        } else if (this.isContextual(131)) {
          node.exportKind = "type";
          const declarationNode = this.startNode();
          this.next();
          return this.flowParseOpaqueType(declarationNode, false);
        } else if (this.isContextual(129)) {
          node.exportKind = "type";
          const declarationNode = this.startNode();
          this.next();
          return this.flowParseInterface(declarationNode);
        } else if (this.isContextual(126)) {
          node.exportKind = "value";
          const declarationNode = this.startNode();
          this.next();
          return this.flowParseEnumDeclaration(declarationNode);
        } else {
          return super.parseExportDeclaration(node);
        }
      }
      eatExportStar(node) {
        if (super.eatExportStar(node)) return true;
        if (this.isContextual(130) && this.lookahead().type === 55) {
          node.exportKind = "type";
          this.next();
          this.next();
          return true;
        }
        return false;
      }
      maybeParseExportNamespaceSpecifier(node) {
        const {
          startLoc
        } = this.state;
        const hasNamespace = super.maybeParseExportNamespaceSpecifier(node);
        if (hasNamespace && node.exportKind === "type") {
          this.unexpected(startLoc);
        }
        return hasNamespace;
      }
      parseClassId(node, isStatement2, optionalId) {
        super.parseClassId(node, isStatement2, optionalId);
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        }
      }
      parseClassMember(classBody, member, state) {
        const {
          startLoc
        } = this.state;
        if (this.isContextual(125)) {
          if (super.parseClassMemberFromModifier(classBody, member)) {
            return;
          }
          member.declare = true;
        }
        super.parseClassMember(classBody, member, state);
        if (member.declare) {
          if (member.type !== "ClassProperty" && member.type !== "ClassPrivateProperty" && member.type !== "PropertyDefinition") {
            this.raise(FlowErrors.DeclareClassElement, startLoc);
          } else if (member.value) {
            this.raise(FlowErrors.DeclareClassFieldInitializer, member.value);
          }
        }
      }
      isIterator(word) {
        return word === "iterator" || word === "asyncIterator";
      }
      readIterator() {
        const word = super.readWord1();
        const fullWord = "@@" + word;
        if (!this.isIterator(word) || !this.state.inType) {
          this.raise(Errors.InvalidIdentifier, this.state.curPosition(), {
            identifierName: fullWord
          });
        }
        this.finishToken(132, fullWord);
      }
      getTokenFromCode(code2) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (code2 === 123 && next === 124) {
          this.finishOp(6, 2);
        } else if (this.state.inType && (code2 === 62 || code2 === 60)) {
          this.finishOp(code2 === 62 ? 48 : 47, 1);
        } else if (this.state.inType && code2 === 63) {
          if (next === 46) {
            this.finishOp(18, 2);
          } else {
            this.finishOp(17, 1);
          }
        } else if (isIteratorStart(code2, next, this.input.charCodeAt(this.state.pos + 2))) {
          this.state.pos += 2;
          this.readIterator();
        } else {
          super.getTokenFromCode(code2);
        }
      }
      isAssignable(node, isBinding) {
        if (node.type === "TypeCastExpression") {
          return this.isAssignable(node.expression, isBinding);
        } else {
          return super.isAssignable(node, isBinding);
        }
      }
      toAssignable(node, isLHS = false) {
        if (!isLHS && node.type === "AssignmentExpression" && node.left.type === "TypeCastExpression") {
          node.left = this.typeCastToParameter(node.left);
        }
        super.toAssignable(node, isLHS);
      }
      toAssignableList(exprList, trailingCommaLoc, isLHS) {
        for (let i = 0; i < exprList.length; i++) {
          const expr = exprList[i];
          if ((expr == null ? void 0 : expr.type) === "TypeCastExpression") {
            exprList[i] = this.typeCastToParameter(expr);
          }
        }
        super.toAssignableList(exprList, trailingCommaLoc, isLHS);
      }
      toReferencedList(exprList, isParenthesizedExpr) {
        for (let i = 0; i < exprList.length; i++) {
          var _expr$extra;
          const expr = exprList[i];
          if (expr && expr.type === "TypeCastExpression" && !((_expr$extra = expr.extra) != null && _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {
            this.raise(FlowErrors.TypeCastInPattern, expr.typeAnnotation);
          }
        }
        return exprList;
      }
      parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
        const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);
        if (canBePattern && !this.state.maybeInArrowParameters) {
          this.toReferencedList(node.elements);
        }
        return node;
      }
      isValidLVal(type, isParenthesized, binding) {
        return type === "TypeCastExpression" || super.isValidLVal(type, isParenthesized, binding);
      }
      parseClassProperty(node) {
        if (this.match(14)) {
          node.typeAnnotation = this.flowParseTypeAnnotation();
        }
        return super.parseClassProperty(node);
      }
      parseClassPrivateProperty(node) {
        if (this.match(14)) {
          node.typeAnnotation = this.flowParseTypeAnnotation();
        }
        return super.parseClassPrivateProperty(node);
      }
      isClassMethod() {
        return this.match(47) || super.isClassMethod();
      }
      isClassProperty() {
        return this.match(14) || super.isClassProperty();
      }
      isNonstaticConstructor(method) {
        return !this.match(14) && super.isNonstaticConstructor(method);
      }
      pushClassMethod(classBody, method, isGenerator, isAsync2, isConstructor, allowsDirectSuper) {
        if (method.variance) {
          this.unexpected(method.variance.loc.start);
        }
        delete method.variance;
        if (this.match(47)) {
          method.typeParameters = this.flowParseTypeParameterDeclaration();
        }
        super.pushClassMethod(classBody, method, isGenerator, isAsync2, isConstructor, allowsDirectSuper);
        if (method.params && isConstructor) {
          const params = method.params;
          if (params.length > 0 && this.isThisParam(params[0])) {
            this.raise(FlowErrors.ThisParamBannedInConstructor, method);
          }
        } else if (method.type === "MethodDefinition" && isConstructor && method.value.params) {
          const params = method.value.params;
          if (params.length > 0 && this.isThisParam(params[0])) {
            this.raise(FlowErrors.ThisParamBannedInConstructor, method);
          }
        }
      }
      pushClassPrivateMethod(classBody, method, isGenerator, isAsync2) {
        if (method.variance) {
          this.unexpected(method.variance.loc.start);
        }
        delete method.variance;
        if (this.match(47)) {
          method.typeParameters = this.flowParseTypeParameterDeclaration();
        }
        super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync2);
      }
      parseClassSuper(node) {
        super.parseClassSuper(node);
        if (node.superClass && (this.match(47) || this.match(51))) {
          {
            node.superTypeParameters = this.flowParseTypeParameterInstantiationInExpression();
          }
        }
        if (this.isContextual(113)) {
          this.next();
          const implemented = node.implements = [];
          do {
            const node2 = this.startNode();
            node2.id = this.flowParseRestrictedIdentifier(true);
            if (this.match(47)) {
              node2.typeParameters = this.flowParseTypeParameterInstantiation();
            } else {
              node2.typeParameters = null;
            }
            implemented.push(this.finishNode(node2, "ClassImplements"));
          } while (this.eat(12));
        }
      }
      checkGetterSetterParams(method) {
        super.checkGetterSetterParams(method);
        const params = this.getObjectOrClassMethodParams(method);
        if (params.length > 0) {
          const param = params[0];
          if (this.isThisParam(param) && method.kind === "get") {
            this.raise(FlowErrors.GetterMayNotHaveThisParam, param);
          } else if (this.isThisParam(param)) {
            this.raise(FlowErrors.SetterMayNotHaveThisParam, param);
          }
        }
      }
      parsePropertyNamePrefixOperator(node) {
        node.variance = this.flowParseVariance();
      }
      parseObjPropValue(prop, startLoc, isGenerator, isAsync2, isPattern, isAccessor, refExpressionErrors) {
        if (prop.variance) {
          this.unexpected(prop.variance.loc.start);
        }
        delete prop.variance;
        let typeParameters;
        if (this.match(47) && !isAccessor) {
          typeParameters = this.flowParseTypeParameterDeclaration();
          if (!this.match(10)) this.unexpected();
        }
        const result = super.parseObjPropValue(prop, startLoc, isGenerator, isAsync2, isPattern, isAccessor, refExpressionErrors);
        if (typeParameters) {
          (result.value || result).typeParameters = typeParameters;
        }
        return result;
      }
      parseFunctionParamType(param) {
        if (this.eat(17)) {
          if (param.type !== "Identifier") {
            this.raise(FlowErrors.PatternIsOptional, param);
          }
          if (this.isThisParam(param)) {
            this.raise(FlowErrors.ThisParamMayNotBeOptional, param);
          }
          param.optional = true;
        }
        if (this.match(14)) {
          param.typeAnnotation = this.flowParseTypeAnnotation();
        } else if (this.isThisParam(param)) {
          this.raise(FlowErrors.ThisParamAnnotationRequired, param);
        }
        if (this.match(29) && this.isThisParam(param)) {
          this.raise(FlowErrors.ThisParamNoDefault, param);
        }
        this.resetEndLocation(param);
        return param;
      }
      parseMaybeDefault(startLoc, left) {
        const node = super.parseMaybeDefault(startLoc, left);
        if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
          this.raise(FlowErrors.TypeBeforeInitializer, node.typeAnnotation);
        }
        return node;
      }
      checkImportReflection(node) {
        super.checkImportReflection(node);
        if (node.module && node.importKind !== "value") {
          this.raise(FlowErrors.ImportReflectionHasImportType, node.specifiers[0].loc.start);
        }
      }
      parseImportSpecifierLocal(node, specifier, type) {
        specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();
        node.specifiers.push(this.finishImportSpecifier(specifier, type));
      }
      isPotentialImportPhase(isExport) {
        if (super.isPotentialImportPhase(isExport)) return true;
        if (this.isContextual(130)) {
          if (!isExport) return true;
          const ch = this.lookaheadCharCode();
          return ch === 123 || ch === 42;
        }
        return !isExport && this.isContextual(87);
      }
      applyImportPhase(node, isExport, phase, loc) {
        super.applyImportPhase(node, isExport, phase, loc);
        if (isExport) {
          if (!phase && this.match(65)) {
            return;
          }
          node.exportKind = phase === "type" ? phase : "value";
        } else {
          if (phase === "type" && this.match(55)) this.unexpected();
          node.importKind = phase === "type" || phase === "typeof" ? phase : "value";
        }
      }
      parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
        const firstIdent = specifier.imported;
        let specifierTypeKind = null;
        if (firstIdent.type === "Identifier") {
          if (firstIdent.name === "type") {
            specifierTypeKind = "type";
          } else if (firstIdent.name === "typeof") {
            specifierTypeKind = "typeof";
          }
        }
        let isBinding = false;
        if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
          const as_ident = this.parseIdentifier(true);
          if (specifierTypeKind !== null && !tokenIsKeywordOrIdentifier(this.state.type)) {
            specifier.imported = as_ident;
            specifier.importKind = specifierTypeKind;
            specifier.local = cloneIdentifier(as_ident);
          } else {
            specifier.imported = firstIdent;
            specifier.importKind = null;
            specifier.local = this.parseIdentifier();
          }
        } else {
          if (specifierTypeKind !== null && tokenIsKeywordOrIdentifier(this.state.type)) {
            specifier.imported = this.parseIdentifier(true);
            specifier.importKind = specifierTypeKind;
          } else {
            if (importedIsString) {
              throw this.raise(Errors.ImportBindingIsString, specifier, {
                importName: firstIdent.value
              });
            }
            specifier.imported = firstIdent;
            specifier.importKind = null;
          }
          if (this.eatContextual(93)) {
            specifier.local = this.parseIdentifier();
          } else {
            isBinding = true;
            specifier.local = cloneIdentifier(specifier.imported);
          }
        }
        const specifierIsTypeImport = hasTypeImportKind(specifier);
        if (isInTypeOnlyImport && specifierIsTypeImport) {
          this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, specifier);
        }
        if (isInTypeOnlyImport || specifierIsTypeImport) {
          this.checkReservedType(specifier.local.name, specifier.local.loc.start, true);
        }
        if (isBinding && !isInTypeOnlyImport && !specifierIsTypeImport) {
          this.checkReservedWord(specifier.local.name, specifier.loc.start, true, true);
        }
        return this.finishImportSpecifier(specifier, "ImportSpecifier");
      }
      parseBindingAtom() {
        switch (this.state.type) {
          case 78:
            return this.parseIdentifier(true);
          default:
            return super.parseBindingAtom();
        }
      }
      parseFunctionParams(node, isConstructor) {
        const kind = node.kind;
        if (kind !== "get" && kind !== "set" && this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        }
        super.parseFunctionParams(node, isConstructor);
      }
      parseVarId(decl, kind) {
        super.parseVarId(decl, kind);
        if (this.match(14)) {
          decl.id.typeAnnotation = this.flowParseTypeAnnotation();
          this.resetEndLocation(decl.id);
        }
      }
      parseAsyncArrowFromCallExpression(node, call) {
        if (this.match(14)) {
          const oldNoAnonFunctionType = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = true;
          node.returnType = this.flowParseTypeAnnotation();
          this.state.noAnonFunctionType = oldNoAnonFunctionType;
        }
        return super.parseAsyncArrowFromCallExpression(node, call);
      }
      shouldParseAsyncArrow() {
        return this.match(14) || super.shouldParseAsyncArrow();
      }
      parseMaybeAssign(refExpressionErrors, afterLeftParse) {
        var _jsx;
        let state = null;
        let jsx2;
        if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
          state = this.state.clone();
          jsx2 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
          if (!jsx2.error) return jsx2.node;
          const {
            context
          } = this.state;
          const currentContext = context[context.length - 1];
          if (currentContext === types.j_oTag || currentContext === types.j_expr) {
            context.pop();
          }
        }
        if ((_jsx = jsx2) != null && _jsx.error || this.match(47)) {
          var _jsx2, _jsx3;
          state = state || this.state.clone();
          let typeParameters;
          const arrow = this.tryParse((abort) => {
            var _arrowExpression$extr;
            typeParameters = this.flowParseTypeParameterDeclaration();
            const arrowExpression2 = this.forwardNoArrowParamsConversionAt(typeParameters, () => {
              const result = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
              this.resetStartLocationFromNode(result, typeParameters);
              return result;
            });
            if ((_arrowExpression$extr = arrowExpression2.extra) != null && _arrowExpression$extr.parenthesized) abort();
            const expr = this.maybeUnwrapTypeCastExpression(arrowExpression2);
            if (expr.type !== "ArrowFunctionExpression") abort();
            expr.typeParameters = typeParameters;
            this.resetStartLocationFromNode(expr, typeParameters);
            return arrowExpression2;
          }, state);
          let arrowExpression = null;
          if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === "ArrowFunctionExpression") {
            if (!arrow.error && !arrow.aborted) {
              if (arrow.node.async) {
                this.raise(FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction, typeParameters);
              }
              return arrow.node;
            }
            arrowExpression = arrow.node;
          }
          if ((_jsx2 = jsx2) != null && _jsx2.node) {
            this.state = jsx2.failState;
            return jsx2.node;
          }
          if (arrowExpression) {
            this.state = arrow.failState;
            return arrowExpression;
          }
          if ((_jsx3 = jsx2) != null && _jsx3.thrown) throw jsx2.error;
          if (arrow.thrown) throw arrow.error;
          throw this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter, typeParameters);
        }
        return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
      }
      parseArrow(node) {
        if (this.match(14)) {
          const result = this.tryParse(() => {
            const oldNoAnonFunctionType = this.state.noAnonFunctionType;
            this.state.noAnonFunctionType = true;
            const typeNode = this.startNode();
            [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
            this.state.noAnonFunctionType = oldNoAnonFunctionType;
            if (this.canInsertSemicolon()) this.unexpected();
            if (!this.match(19)) this.unexpected();
            return typeNode;
          });
          if (result.thrown) return null;
          if (result.error) this.state = result.failState;
          node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, "TypeAnnotation") : null;
        }
        return super.parseArrow(node);
      }
      shouldParseArrow(params) {
        return this.match(14) || super.shouldParseArrow(params);
      }
      setArrowFunctionParameters(node, params) {
        if (this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node.start))) {
          node.params = params;
        } else {
          super.setArrowFunctionParameters(node, params);
        }
      }
      checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {
        if (isArrowFunction && this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node.start))) {
          return;
        }
        for (let i = 0; i < node.params.length; i++) {
          if (this.isThisParam(node.params[i]) && i > 0) {
            this.raise(FlowErrors.ThisParamMustBeFirst, node.params[i]);
          }
        }
        super.checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged);
      }
      parseParenAndDistinguishExpression(canBeArrow) {
        return super.parseParenAndDistinguishExpression(canBeArrow && !this.state.noArrowAt.includes(this.sourceToOffsetPos(this.state.start)));
      }
      parseSubscripts(base, startLoc, noCalls) {
        if (base.type === "Identifier" && base.name === "async" && this.state.noArrowAt.includes(startLoc.index)) {
          this.next();
          const node = this.startNodeAt(startLoc);
          node.callee = base;
          node.arguments = super.parseCallExpressionArguments(11);
          base = this.finishNode(node, "CallExpression");
        } else if (base.type === "Identifier" && base.name === "async" && this.match(47)) {
          const state = this.state.clone();
          const arrow = this.tryParse((abort) => this.parseAsyncArrowWithTypeParameters(startLoc) || abort(), state);
          if (!arrow.error && !arrow.aborted) return arrow.node;
          const result = this.tryParse(() => super.parseSubscripts(base, startLoc, noCalls), state);
          if (result.node && !result.error) return result.node;
          if (arrow.node) {
            this.state = arrow.failState;
            return arrow.node;
          }
          if (result.node) {
            this.state = result.failState;
            return result.node;
          }
          throw arrow.error || result.error;
        }
        return super.parseSubscripts(base, startLoc, noCalls);
      }
      parseSubscript(base, startLoc, noCalls, subscriptState) {
        if (this.match(18) && this.isLookaheadToken_lt()) {
          subscriptState.optionalChainMember = true;
          if (noCalls) {
            subscriptState.stop = true;
            return base;
          }
          this.next();
          const node = this.startNodeAt(startLoc);
          node.callee = base;
          node.typeArguments = this.flowParseTypeParameterInstantiationInExpression();
          this.expect(10);
          node.arguments = this.parseCallExpressionArguments(11);
          node.optional = true;
          return this.finishCallExpression(node, true);
        } else if (!noCalls && this.shouldParseTypes() && (this.match(47) || this.match(51))) {
          const node = this.startNodeAt(startLoc);
          node.callee = base;
          const result = this.tryParse(() => {
            node.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();
            this.expect(10);
            node.arguments = super.parseCallExpressionArguments(11);
            if (subscriptState.optionalChainMember) {
              node.optional = false;
            }
            return this.finishCallExpression(node, subscriptState.optionalChainMember);
          });
          if (result.node) {
            if (result.error) this.state = result.failState;
            return result.node;
          }
        }
        return super.parseSubscript(base, startLoc, noCalls, subscriptState);
      }
      parseNewCallee(node) {
        super.parseNewCallee(node);
        let targs = null;
        if (this.shouldParseTypes() && this.match(47)) {
          targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node;
        }
        node.typeArguments = targs;
      }
      parseAsyncArrowWithTypeParameters(startLoc) {
        const node = this.startNodeAt(startLoc);
        this.parseFunctionParams(node, false);
        if (!this.parseArrow(node)) return;
        return super.parseArrowExpression(node, void 0, true);
      }
      readToken_mult_modulo(code2) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (code2 === 42 && next === 47 && this.state.hasFlowComment) {
          this.state.hasFlowComment = false;
          this.state.pos += 2;
          this.nextToken();
          return;
        }
        super.readToken_mult_modulo(code2);
      }
      readToken_pipe_amp(code2) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (code2 === 124 && next === 125) {
          this.finishOp(9, 2);
          return;
        }
        super.readToken_pipe_amp(code2);
      }
      parseTopLevel(file, program) {
        const fileNode = super.parseTopLevel(file, program);
        if (this.state.hasFlowComment) {
          this.raise(FlowErrors.UnterminatedFlowComment, this.state.curPosition());
        }
        return fileNode;
      }
      skipBlockComment() {
        if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
          if (this.state.hasFlowComment) {
            throw this.raise(FlowErrors.NestedFlowComment, this.state.startLoc);
          }
          this.hasFlowCommentCompletion();
          const commentSkip = this.skipFlowComment();
          if (commentSkip) {
            this.state.pos += commentSkip;
            this.state.hasFlowComment = true;
          }
          return;
        }
        return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
      }
      skipFlowComment() {
        const {
          pos: pos2
        } = this.state;
        let shiftToFirstNonWhiteSpace = 2;
        while ([32, 9].includes(this.input.charCodeAt(pos2 + shiftToFirstNonWhiteSpace))) {
          shiftToFirstNonWhiteSpace++;
        }
        const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos2);
        const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos2 + 1);
        if (ch2 === 58 && ch3 === 58) {
          return shiftToFirstNonWhiteSpace + 2;
        }
        if (this.input.slice(shiftToFirstNonWhiteSpace + pos2, shiftToFirstNonWhiteSpace + pos2 + 12) === "flow-include") {
          return shiftToFirstNonWhiteSpace + 12;
        }
        if (ch2 === 58 && ch3 !== 58) {
          return shiftToFirstNonWhiteSpace;
        }
        return false;
      }
      hasFlowCommentCompletion() {
        const end = this.input.indexOf("*/", this.state.pos);
        if (end === -1) {
          throw this.raise(Errors.UnterminatedComment, this.state.curPosition());
        }
      }
      flowEnumErrorBooleanMemberNotInitialized(loc, {
        enumName,
        memberName
      }) {
        this.raise(FlowErrors.EnumBooleanMemberNotInitialized, loc, {
          memberName,
          enumName
        });
      }
      flowEnumErrorInvalidMemberInitializer(loc, enumContext) {
        return this.raise(!enumContext.explicitType ? FlowErrors.EnumInvalidMemberInitializerUnknownType : enumContext.explicitType === "symbol" ? FlowErrors.EnumInvalidMemberInitializerSymbolType : FlowErrors.EnumInvalidMemberInitializerPrimaryType, loc, enumContext);
      }
      flowEnumErrorNumberMemberNotInitialized(loc, details) {
        this.raise(FlowErrors.EnumNumberMemberNotInitialized, loc, details);
      }
      flowEnumErrorStringMemberInconsistentlyInitialized(node, details) {
        this.raise(FlowErrors.EnumStringMemberInconsistentlyInitialized, node, details);
      }
      flowEnumMemberInit() {
        const startLoc = this.state.startLoc;
        const endOfInit = () => this.match(12) || this.match(8);
        switch (this.state.type) {
          case 135: {
            const literal2 = this.parseNumericLiteral(this.state.value);
            if (endOfInit()) {
              return {
                type: "number",
                loc: literal2.loc.start,
                value: literal2
              };
            }
            return {
              type: "invalid",
              loc: startLoc
            };
          }
          case 134: {
            const literal2 = this.parseStringLiteral(this.state.value);
            if (endOfInit()) {
              return {
                type: "string",
                loc: literal2.loc.start,
                value: literal2
              };
            }
            return {
              type: "invalid",
              loc: startLoc
            };
          }
          case 85:
          case 86: {
            const literal2 = this.parseBooleanLiteral(this.match(85));
            if (endOfInit()) {
              return {
                type: "boolean",
                loc: literal2.loc.start,
                value: literal2
              };
            }
            return {
              type: "invalid",
              loc: startLoc
            };
          }
          default:
            return {
              type: "invalid",
              loc: startLoc
            };
        }
      }
      flowEnumMemberRaw() {
        const loc = this.state.startLoc;
        const id = this.parseIdentifier(true);
        const init = this.eat(29) ? this.flowEnumMemberInit() : {
          type: "none",
          loc
        };
        return {
          id,
          init
        };
      }
      flowEnumCheckExplicitTypeMismatch(loc, context, expectedType) {
        const {
          explicitType
        } = context;
        if (explicitType === null) {
          return;
        }
        if (explicitType !== expectedType) {
          this.flowEnumErrorInvalidMemberInitializer(loc, context);
        }
      }
      flowEnumMembers({
        enumName,
        explicitType
      }) {
        const seenNames = /* @__PURE__ */ new Set();
        const members = {
          booleanMembers: [],
          numberMembers: [],
          stringMembers: [],
          defaultedMembers: []
        };
        let hasUnknownMembers = false;
        while (!this.match(8)) {
          if (this.eat(21)) {
            hasUnknownMembers = true;
            break;
          }
          const memberNode = this.startNode();
          const {
            id,
            init
          } = this.flowEnumMemberRaw();
          const memberName = id.name;
          if (memberName === "") {
            continue;
          }
          if (/^[a-z]/.test(memberName)) {
            this.raise(FlowErrors.EnumInvalidMemberName, id, {
              memberName,
              suggestion: memberName[0].toUpperCase() + memberName.slice(1),
              enumName
            });
          }
          if (seenNames.has(memberName)) {
            this.raise(FlowErrors.EnumDuplicateMemberName, id, {
              memberName,
              enumName
            });
          }
          seenNames.add(memberName);
          const context = {
            enumName,
            explicitType,
            memberName
          };
          memberNode.id = id;
          switch (init.type) {
            case "boolean": {
              this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "boolean");
              memberNode.init = init.value;
              members.booleanMembers.push(this.finishNode(memberNode, "EnumBooleanMember"));
              break;
            }
            case "number": {
              this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "number");
              memberNode.init = init.value;
              members.numberMembers.push(this.finishNode(memberNode, "EnumNumberMember"));
              break;
            }
            case "string": {
              this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "string");
              memberNode.init = init.value;
              members.stringMembers.push(this.finishNode(memberNode, "EnumStringMember"));
              break;
            }
            case "invalid": {
              throw this.flowEnumErrorInvalidMemberInitializer(init.loc, context);
            }
            case "none": {
              switch (explicitType) {
                case "boolean":
                  this.flowEnumErrorBooleanMemberNotInitialized(init.loc, context);
                  break;
                case "number":
                  this.flowEnumErrorNumberMemberNotInitialized(init.loc, context);
                  break;
                default:
                  members.defaultedMembers.push(this.finishNode(memberNode, "EnumDefaultedMember"));
              }
            }
          }
          if (!this.match(8)) {
            this.expect(12);
          }
        }
        return {
          members,
          hasUnknownMembers
        };
      }
      flowEnumStringMembers(initializedMembers, defaultedMembers, {
        enumName
      }) {
        if (initializedMembers.length === 0) {
          return defaultedMembers;
        } else if (defaultedMembers.length === 0) {
          return initializedMembers;
        } else if (defaultedMembers.length > initializedMembers.length) {
          for (const member of initializedMembers) {
            this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {
              enumName
            });
          }
          return defaultedMembers;
        } else {
          for (const member of defaultedMembers) {
            this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {
              enumName
            });
          }
          return initializedMembers;
        }
      }
      flowEnumParseExplicitType({
        enumName
      }) {
        if (!this.eatContextual(102)) return null;
        if (!tokenIsIdentifier(this.state.type)) {
          throw this.raise(FlowErrors.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, {
            enumName
          });
        }
        const {
          value
        } = this.state;
        this.next();
        if (value !== "boolean" && value !== "number" && value !== "string" && value !== "symbol") {
          this.raise(FlowErrors.EnumInvalidExplicitType, this.state.startLoc, {
            enumName,
            invalidEnumType: value
          });
        }
        return value;
      }
      flowEnumBody(node, id) {
        const enumName = id.name;
        const nameLoc = id.loc.start;
        const explicitType = this.flowEnumParseExplicitType({
          enumName
        });
        this.expect(5);
        const {
          members,
          hasUnknownMembers
        } = this.flowEnumMembers({
          enumName,
          explicitType
        });
        node.hasUnknownMembers = hasUnknownMembers;
        switch (explicitType) {
          case "boolean":
            node.explicitType = true;
            node.members = members.booleanMembers;
            this.expect(8);
            return this.finishNode(node, "EnumBooleanBody");
          case "number":
            node.explicitType = true;
            node.members = members.numberMembers;
            this.expect(8);
            return this.finishNode(node, "EnumNumberBody");
          case "string":
            node.explicitType = true;
            node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
              enumName
            });
            this.expect(8);
            return this.finishNode(node, "EnumStringBody");
          case "symbol":
            node.members = members.defaultedMembers;
            this.expect(8);
            return this.finishNode(node, "EnumSymbolBody");
          default: {
            const empty2 = () => {
              node.members = [];
              this.expect(8);
              return this.finishNode(node, "EnumStringBody");
            };
            node.explicitType = false;
            const boolsLen = members.booleanMembers.length;
            const numsLen = members.numberMembers.length;
            const strsLen = members.stringMembers.length;
            const defaultedLen = members.defaultedMembers.length;
            if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {
              return empty2();
            } else if (!boolsLen && !numsLen) {
              node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
                enumName
              });
              this.expect(8);
              return this.finishNode(node, "EnumStringBody");
            } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {
              for (const member of members.defaultedMembers) {
                this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start, {
                  enumName,
                  memberName: member.id.name
                });
              }
              node.members = members.booleanMembers;
              this.expect(8);
              return this.finishNode(node, "EnumBooleanBody");
            } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {
              for (const member of members.defaultedMembers) {
                this.flowEnumErrorNumberMemberNotInitialized(member.loc.start, {
                  enumName,
                  memberName: member.id.name
                });
              }
              node.members = members.numberMembers;
              this.expect(8);
              return this.finishNode(node, "EnumNumberBody");
            } else {
              this.raise(FlowErrors.EnumInconsistentMemberValues, nameLoc, {
                enumName
              });
              return empty2();
            }
          }
        }
      }
      flowParseEnumDeclaration(node) {
        const id = this.parseIdentifier();
        node.id = id;
        node.body = this.flowEnumBody(this.startNode(), id);
        return this.finishNode(node, "EnumDeclaration");
      }
      jsxParseOpeningElementAfterName(node) {
        if (this.shouldParseTypes()) {
          if (this.match(47) || this.match(51)) {
            node.typeArguments = this.flowParseTypeParameterInstantiationInExpression();
          }
        }
        return super.jsxParseOpeningElementAfterName(node);
      }
      isLookaheadToken_lt() {
        const next = this.nextTokenStart();
        if (this.input.charCodeAt(next) === 60) {
          const afterNext = this.input.charCodeAt(next + 1);
          return afterNext !== 60 && afterNext !== 61;
        }
        return false;
      }
      reScan_lt_gt() {
        const {
          type
        } = this.state;
        if (type === 47) {
          this.state.pos -= 1;
          this.readToken_lt();
        } else if (type === 48) {
          this.state.pos -= 1;
          this.readToken_gt();
        }
      }
      reScan_lt() {
        const {
          type
        } = this.state;
        if (type === 51) {
          this.state.pos -= 2;
          this.finishOp(47, 1);
          return 47;
        }
        return type;
      }
      maybeUnwrapTypeCastExpression(node) {
        return node.type === "TypeCastExpression" ? node.expression : node;
      }
    };
    var entities = {
      __proto__: null,
      quot: '"',
      amp: "&",
      apos: "'",
      lt: "<",
      gt: ">",
      nbsp: "\xA0",
      iexcl: "\xA1",
      cent: "\xA2",
      pound: "\xA3",
      curren: "\xA4",
      yen: "\xA5",
      brvbar: "\xA6",
      sect: "\xA7",
      uml: "\xA8",
      copy: "\xA9",
      ordf: "\xAA",
      laquo: "\xAB",
      not: "\xAC",
      shy: "\xAD",
      reg: "\xAE",
      macr: "\xAF",
      deg: "\xB0",
      plusmn: "\xB1",
      sup2: "\xB2",
      sup3: "\xB3",
      acute: "\xB4",
      micro: "\xB5",
      para: "\xB6",
      middot: "\xB7",
      cedil: "\xB8",
      sup1: "\xB9",
      ordm: "\xBA",
      raquo: "\xBB",
      frac14: "\xBC",
      frac12: "\xBD",
      frac34: "\xBE",
      iquest: "\xBF",
      Agrave: "\xC0",
      Aacute: "\xC1",
      Acirc: "\xC2",
      Atilde: "\xC3",
      Auml: "\xC4",
      Aring: "\xC5",
      AElig: "\xC6",
      Ccedil: "\xC7",
      Egrave: "\xC8",
      Eacute: "\xC9",
      Ecirc: "\xCA",
      Euml: "\xCB",
      Igrave: "\xCC",
      Iacute: "\xCD",
      Icirc: "\xCE",
      Iuml: "\xCF",
      ETH: "\xD0",
      Ntilde: "\xD1",
      Ograve: "\xD2",
      Oacute: "\xD3",
      Ocirc: "\xD4",
      Otilde: "\xD5",
      Ouml: "\xD6",
      times: "\xD7",
      Oslash: "\xD8",
      Ugrave: "\xD9",
      Uacute: "\xDA",
      Ucirc: "\xDB",
      Uuml: "\xDC",
      Yacute: "\xDD",
      THORN: "\xDE",
      szlig: "\xDF",
      agrave: "\xE0",
      aacute: "\xE1",
      acirc: "\xE2",
      atilde: "\xE3",
      auml: "\xE4",
      aring: "\xE5",
      aelig: "\xE6",
      ccedil: "\xE7",
      egrave: "\xE8",
      eacute: "\xE9",
      ecirc: "\xEA",
      euml: "\xEB",
      igrave: "\xEC",
      iacute: "\xED",
      icirc: "\xEE",
      iuml: "\xEF",
      eth: "\xF0",
      ntilde: "\xF1",
      ograve: "\xF2",
      oacute: "\xF3",
      ocirc: "\xF4",
      otilde: "\xF5",
      ouml: "\xF6",
      divide: "\xF7",
      oslash: "\xF8",
      ugrave: "\xF9",
      uacute: "\xFA",
      ucirc: "\xFB",
      uuml: "\xFC",
      yacute: "\xFD",
      thorn: "\xFE",
      yuml: "\xFF",
      OElig: "\u0152",
      oelig: "\u0153",
      Scaron: "\u0160",
      scaron: "\u0161",
      Yuml: "\u0178",
      fnof: "\u0192",
      circ: "\u02C6",
      tilde: "\u02DC",
      Alpha: "\u0391",
      Beta: "\u0392",
      Gamma: "\u0393",
      Delta: "\u0394",
      Epsilon: "\u0395",
      Zeta: "\u0396",
      Eta: "\u0397",
      Theta: "\u0398",
      Iota: "\u0399",
      Kappa: "\u039A",
      Lambda: "\u039B",
      Mu: "\u039C",
      Nu: "\u039D",
      Xi: "\u039E",
      Omicron: "\u039F",
      Pi: "\u03A0",
      Rho: "\u03A1",
      Sigma: "\u03A3",
      Tau: "\u03A4",
      Upsilon: "\u03A5",
      Phi: "\u03A6",
      Chi: "\u03A7",
      Psi: "\u03A8",
      Omega: "\u03A9",
      alpha: "\u03B1",
      beta: "\u03B2",
      gamma: "\u03B3",
      delta: "\u03B4",
      epsilon: "\u03B5",
      zeta: "\u03B6",
      eta: "\u03B7",
      theta: "\u03B8",
      iota: "\u03B9",
      kappa: "\u03BA",
      lambda: "\u03BB",
      mu: "\u03BC",
      nu: "\u03BD",
      xi: "\u03BE",
      omicron: "\u03BF",
      pi: "\u03C0",
      rho: "\u03C1",
      sigmaf: "\u03C2",
      sigma: "\u03C3",
      tau: "\u03C4",
      upsilon: "\u03C5",
      phi: "\u03C6",
      chi: "\u03C7",
      psi: "\u03C8",
      omega: "\u03C9",
      thetasym: "\u03D1",
      upsih: "\u03D2",
      piv: "\u03D6",
      ensp: "\u2002",
      emsp: "\u2003",
      thinsp: "\u2009",
      zwnj: "\u200C",
      zwj: "\u200D",
      lrm: "\u200E",
      rlm: "\u200F",
      ndash: "\u2013",
      mdash: "\u2014",
      lsquo: "\u2018",
      rsquo: "\u2019",
      sbquo: "\u201A",
      ldquo: "\u201C",
      rdquo: "\u201D",
      bdquo: "\u201E",
      dagger: "\u2020",
      Dagger: "\u2021",
      bull: "\u2022",
      hellip: "\u2026",
      permil: "\u2030",
      prime: "\u2032",
      Prime: "\u2033",
      lsaquo: "\u2039",
      rsaquo: "\u203A",
      oline: "\u203E",
      frasl: "\u2044",
      euro: "\u20AC",
      image: "\u2111",
      weierp: "\u2118",
      real: "\u211C",
      trade: "\u2122",
      alefsym: "\u2135",
      larr: "\u2190",
      uarr: "\u2191",
      rarr: "\u2192",
      darr: "\u2193",
      harr: "\u2194",
      crarr: "\u21B5",
      lArr: "\u21D0",
      uArr: "\u21D1",
      rArr: "\u21D2",
      dArr: "\u21D3",
      hArr: "\u21D4",
      forall: "\u2200",
      part: "\u2202",
      exist: "\u2203",
      empty: "\u2205",
      nabla: "\u2207",
      isin: "\u2208",
      notin: "\u2209",
      ni: "\u220B",
      prod: "\u220F",
      sum: "\u2211",
      minus: "\u2212",
      lowast: "\u2217",
      radic: "\u221A",
      prop: "\u221D",
      infin: "\u221E",
      ang: "\u2220",
      and: "\u2227",
      or: "\u2228",
      cap: "\u2229",
      cup: "\u222A",
      int: "\u222B",
      there4: "\u2234",
      sim: "\u223C",
      cong: "\u2245",
      asymp: "\u2248",
      ne: "\u2260",
      equiv: "\u2261",
      le: "\u2264",
      ge: "\u2265",
      sub: "\u2282",
      sup: "\u2283",
      nsub: "\u2284",
      sube: "\u2286",
      supe: "\u2287",
      oplus: "\u2295",
      otimes: "\u2297",
      perp: "\u22A5",
      sdot: "\u22C5",
      lceil: "\u2308",
      rceil: "\u2309",
      lfloor: "\u230A",
      rfloor: "\u230B",
      lang: "\u2329",
      rang: "\u232A",
      loz: "\u25CA",
      spades: "\u2660",
      clubs: "\u2663",
      hearts: "\u2665",
      diams: "\u2666"
    };
    var JsxErrors = ParseErrorEnum`jsx`({
      AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
      MissingClosingTagElement: ({
        openingTagName
      }) => `Expected corresponding JSX closing tag for <${openingTagName}>.`,
      MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
      UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
      UnexpectedToken: ({
        unexpected,
        HTMLEntity
      }) => `Unexpected token \`${unexpected}\`. Did you mean \`${HTMLEntity}\` or \`{'${unexpected}'}\`?`,
      UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
      UnterminatedJsxContent: "Unterminated JSX contents.",
      UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
    });
    function isFragment(object) {
      return object ? object.type === "JSXOpeningFragment" || object.type === "JSXClosingFragment" : false;
    }
    function getQualifiedJSXName(object) {
      if (object.type === "JSXIdentifier") {
        return object.name;
      }
      if (object.type === "JSXNamespacedName") {
        return object.namespace.name + ":" + object.name.name;
      }
      if (object.type === "JSXMemberExpression") {
        return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
      }
      throw new Error("Node had unexpected type: " + object.type);
    }
    var jsx = (superClass) => class JSXParserMixin extends superClass {
      jsxReadToken() {
        let out = "";
        let chunkStart = this.state.pos;
        for (; ; ) {
          if (this.state.pos >= this.length) {
            throw this.raise(JsxErrors.UnterminatedJsxContent, this.state.startLoc);
          }
          const ch = this.input.charCodeAt(this.state.pos);
          switch (ch) {
            case 60:
            case 123:
              if (this.state.pos === this.state.start) {
                if (ch === 60 && this.state.canStartJSXElement) {
                  ++this.state.pos;
                  this.finishToken(143);
                } else {
                  super.getTokenFromCode(ch);
                }
                return;
              }
              out += this.input.slice(chunkStart, this.state.pos);
              this.finishToken(142, out);
              return;
            case 38:
              out += this.input.slice(chunkStart, this.state.pos);
              out += this.jsxReadEntity();
              chunkStart = this.state.pos;
              break;
            case 62:
            case 125:
            default:
              if (isNewLine(ch)) {
                out += this.input.slice(chunkStart, this.state.pos);
                out += this.jsxReadNewLine(true);
                chunkStart = this.state.pos;
              } else {
                ++this.state.pos;
              }
          }
        }
      }
      jsxReadNewLine(normalizeCRLF) {
        const ch = this.input.charCodeAt(this.state.pos);
        let out;
        ++this.state.pos;
        if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
          ++this.state.pos;
          out = normalizeCRLF ? "\n" : "\r\n";
        } else {
          out = String.fromCharCode(ch);
        }
        ++this.state.curLine;
        this.state.lineStart = this.state.pos;
        return out;
      }
      jsxReadString(quote) {
        let out = "";
        let chunkStart = ++this.state.pos;
        for (; ; ) {
          if (this.state.pos >= this.length) {
            throw this.raise(Errors.UnterminatedString, this.state.startLoc);
          }
          const ch = this.input.charCodeAt(this.state.pos);
          if (ch === quote) break;
          if (ch === 38) {
            out += this.input.slice(chunkStart, this.state.pos);
            out += this.jsxReadEntity();
            chunkStart = this.state.pos;
          } else if (isNewLine(ch)) {
            out += this.input.slice(chunkStart, this.state.pos);
            out += this.jsxReadNewLine(false);
            chunkStart = this.state.pos;
          } else {
            ++this.state.pos;
          }
        }
        out += this.input.slice(chunkStart, this.state.pos++);
        this.finishToken(134, out);
      }
      jsxReadEntity() {
        const startPos = ++this.state.pos;
        if (this.codePointAtPos(this.state.pos) === 35) {
          ++this.state.pos;
          let radix = 10;
          if (this.codePointAtPos(this.state.pos) === 120) {
            radix = 16;
            ++this.state.pos;
          }
          const codePoint = this.readInt(radix, void 0, false, "bail");
          if (codePoint !== null && this.codePointAtPos(this.state.pos) === 59) {
            ++this.state.pos;
            return String.fromCodePoint(codePoint);
          }
        } else {
          let count = 0;
          let semi = false;
          while (count++ < 10 && this.state.pos < this.length && !(semi = this.codePointAtPos(this.state.pos) === 59)) {
            ++this.state.pos;
          }
          if (semi) {
            const desc = this.input.slice(startPos, this.state.pos);
            const entity = entities[desc];
            ++this.state.pos;
            if (entity) {
              return entity;
            }
          }
        }
        this.state.pos = startPos;
        return "&";
      }
      jsxReadWord() {
        let ch;
        const start = this.state.pos;
        do {
          ch = this.input.charCodeAt(++this.state.pos);
        } while (isIdentifierChar(ch) || ch === 45);
        this.finishToken(141, this.input.slice(start, this.state.pos));
      }
      jsxParseIdentifier() {
        const node = this.startNode();
        if (this.match(141)) {
          node.name = this.state.value;
        } else if (tokenIsKeyword(this.state.type)) {
          node.name = tokenLabelName(this.state.type);
        } else {
          this.unexpected();
        }
        this.next();
        return this.finishNode(node, "JSXIdentifier");
      }
      jsxParseNamespacedName() {
        const startLoc = this.state.startLoc;
        const name = this.jsxParseIdentifier();
        if (!this.eat(14)) return name;
        const node = this.startNodeAt(startLoc);
        node.namespace = name;
        node.name = this.jsxParseIdentifier();
        return this.finishNode(node, "JSXNamespacedName");
      }
      jsxParseElementName() {
        const startLoc = this.state.startLoc;
        let node = this.jsxParseNamespacedName();
        if (node.type === "JSXNamespacedName") {
          return node;
        }
        while (this.eat(16)) {
          const newNode = this.startNodeAt(startLoc);
          newNode.object = node;
          newNode.property = this.jsxParseIdentifier();
          node = this.finishNode(newNode, "JSXMemberExpression");
        }
        return node;
      }
      jsxParseAttributeValue() {
        let node;
        switch (this.state.type) {
          case 5:
            node = this.startNode();
            this.setContext(types.brace);
            this.next();
            node = this.jsxParseExpressionContainer(node, types.j_oTag);
            if (node.expression.type === "JSXEmptyExpression") {
              this.raise(JsxErrors.AttributeIsEmpty, node);
            }
            return node;
          case 143:
          case 134:
            return this.parseExprAtom();
          default:
            throw this.raise(JsxErrors.UnsupportedJsxValue, this.state.startLoc);
        }
      }
      jsxParseEmptyExpression() {
        const node = this.startNodeAt(this.state.lastTokEndLoc);
        return this.finishNodeAt(node, "JSXEmptyExpression", this.state.startLoc);
      }
      jsxParseSpreadChild(node) {
        this.next();
        node.expression = this.parseExpression();
        this.setContext(types.j_expr);
        this.state.canStartJSXElement = true;
        this.expect(8);
        return this.finishNode(node, "JSXSpreadChild");
      }
      jsxParseExpressionContainer(node, previousContext) {
        if (this.match(8)) {
          node.expression = this.jsxParseEmptyExpression();
        } else {
          const expression = this.parseExpression();
          node.expression = expression;
        }
        this.setContext(previousContext);
        this.state.canStartJSXElement = true;
        this.expect(8);
        return this.finishNode(node, "JSXExpressionContainer");
      }
      jsxParseAttribute() {
        const node = this.startNode();
        if (this.match(5)) {
          this.setContext(types.brace);
          this.next();
          this.expect(21);
          node.argument = this.parseMaybeAssignAllowIn();
          this.setContext(types.j_oTag);
          this.state.canStartJSXElement = true;
          this.expect(8);
          return this.finishNode(node, "JSXSpreadAttribute");
        }
        node.name = this.jsxParseNamespacedName();
        node.value = this.eat(29) ? this.jsxParseAttributeValue() : null;
        return this.finishNode(node, "JSXAttribute");
      }
      jsxParseOpeningElementAt(startLoc) {
        const node = this.startNodeAt(startLoc);
        if (this.eat(144)) {
          return this.finishNode(node, "JSXOpeningFragment");
        }
        node.name = this.jsxParseElementName();
        return this.jsxParseOpeningElementAfterName(node);
      }
      jsxParseOpeningElementAfterName(node) {
        const attributes = [];
        while (!this.match(56) && !this.match(144)) {
          attributes.push(this.jsxParseAttribute());
        }
        node.attributes = attributes;
        node.selfClosing = this.eat(56);
        this.expect(144);
        return this.finishNode(node, "JSXOpeningElement");
      }
      jsxParseClosingElementAt(startLoc) {
        const node = this.startNodeAt(startLoc);
        if (this.eat(144)) {
          return this.finishNode(node, "JSXClosingFragment");
        }
        node.name = this.jsxParseElementName();
        this.expect(144);
        return this.finishNode(node, "JSXClosingElement");
      }
      jsxParseElementAt(startLoc) {
        const node = this.startNodeAt(startLoc);
        const children = [];
        const openingElement = this.jsxParseOpeningElementAt(startLoc);
        let closingElement = null;
        if (!openingElement.selfClosing) {
          contents: for (; ; ) {
            switch (this.state.type) {
              case 143:
                startLoc = this.state.startLoc;
                this.next();
                if (this.eat(56)) {
                  closingElement = this.jsxParseClosingElementAt(startLoc);
                  break contents;
                }
                children.push(this.jsxParseElementAt(startLoc));
                break;
              case 142:
                children.push(this.parseLiteral(this.state.value, "JSXText"));
                break;
              case 5: {
                const node2 = this.startNode();
                this.setContext(types.brace);
                this.next();
                if (this.match(21)) {
                  children.push(this.jsxParseSpreadChild(node2));
                } else {
                  children.push(this.jsxParseExpressionContainer(node2, types.j_expr));
                }
                break;
              }
              default:
                this.unexpected();
            }
          }
          if (isFragment(openingElement) && !isFragment(closingElement) && closingElement !== null) {
            this.raise(JsxErrors.MissingClosingTagFragment, closingElement);
          } else if (!isFragment(openingElement) && isFragment(closingElement)) {
            this.raise(JsxErrors.MissingClosingTagElement, closingElement, {
              openingTagName: getQualifiedJSXName(openingElement.name)
            });
          } else if (!isFragment(openingElement) && !isFragment(closingElement)) {
            if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
              this.raise(JsxErrors.MissingClosingTagElement, closingElement, {
                openingTagName: getQualifiedJSXName(openingElement.name)
              });
            }
          }
        }
        if (isFragment(openingElement)) {
          node.openingFragment = openingElement;
          node.closingFragment = closingElement;
        } else {
          node.openingElement = openingElement;
          node.closingElement = closingElement;
        }
        node.children = children;
        if (this.match(47)) {
          throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements, this.state.startLoc);
        }
        return isFragment(openingElement) ? this.finishNode(node, "JSXFragment") : this.finishNode(node, "JSXElement");
      }
      jsxParseElement() {
        const startLoc = this.state.startLoc;
        this.next();
        return this.jsxParseElementAt(startLoc);
      }
      setContext(newContext) {
        const {
          context
        } = this.state;
        context[context.length - 1] = newContext;
      }
      parseExprAtom(refExpressionErrors) {
        if (this.match(143)) {
          return this.jsxParseElement();
        } else if (this.match(47) && this.input.charCodeAt(this.state.pos) !== 33) {
          this.replaceToken(143);
          return this.jsxParseElement();
        } else {
          return super.parseExprAtom(refExpressionErrors);
        }
      }
      skipSpace() {
        const curContext = this.curContext();
        if (!curContext.preserveSpace) super.skipSpace();
      }
      getTokenFromCode(code2) {
        const context = this.curContext();
        if (context === types.j_expr) {
          this.jsxReadToken();
          return;
        }
        if (context === types.j_oTag || context === types.j_cTag) {
          if (isIdentifierStart(code2)) {
            this.jsxReadWord();
            return;
          }
          if (code2 === 62) {
            ++this.state.pos;
            this.finishToken(144);
            return;
          }
          if ((code2 === 34 || code2 === 39) && context === types.j_oTag) {
            this.jsxReadString(code2);
            return;
          }
        }
        if (code2 === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
          ++this.state.pos;
          this.finishToken(143);
          return;
        }
        super.getTokenFromCode(code2);
      }
      updateContext(prevType) {
        const {
          context,
          type
        } = this.state;
        if (type === 56 && prevType === 143) {
          context.splice(-2, 2, types.j_cTag);
          this.state.canStartJSXElement = false;
        } else if (type === 143) {
          context.push(types.j_oTag);
        } else if (type === 144) {
          const out = context[context.length - 1];
          if (out === types.j_oTag && prevType === 56 || out === types.j_cTag) {
            context.pop();
            this.state.canStartJSXElement = context[context.length - 1] === types.j_expr;
          } else {
            this.setContext(types.j_expr);
            this.state.canStartJSXElement = true;
          }
        } else {
          this.state.canStartJSXElement = tokenComesBeforeExpression(type);
        }
      }
    };
    var TypeScriptScope = class extends Scope {
      constructor(...args) {
        super(...args);
        this.tsNames = /* @__PURE__ */ new Map();
      }
    };
    var TypeScriptScopeHandler = class extends ScopeHandler {
      constructor(...args) {
        super(...args);
        this.importsStack = [];
      }
      createScope(flags) {
        this.importsStack.push(/* @__PURE__ */ new Set());
        return new TypeScriptScope(flags);
      }
      enter(flags) {
        if (flags === 256) {
          this.importsStack.push(/* @__PURE__ */ new Set());
        }
        super.enter(flags);
      }
      exit() {
        const flags = super.exit();
        if (flags === 256) {
          this.importsStack.pop();
        }
        return flags;
      }
      hasImport(name, allowShadow) {
        const len = this.importsStack.length;
        if (this.importsStack[len - 1].has(name)) {
          return true;
        }
        if (!allowShadow && len > 1) {
          for (let i = 0; i < len - 1; i++) {
            if (this.importsStack[i].has(name)) return true;
          }
        }
        return false;
      }
      declareName(name, bindingType, loc) {
        if (bindingType & 4096) {
          if (this.hasImport(name, true)) {
            this.parser.raise(Errors.VarRedeclaration, loc, {
              identifierName: name
            });
          }
          this.importsStack[this.importsStack.length - 1].add(name);
          return;
        }
        const scope = this.currentScope();
        let type = scope.tsNames.get(name) || 0;
        if (bindingType & 1024) {
          this.maybeExportDefined(scope, name);
          scope.tsNames.set(name, type | 16);
          return;
        }
        super.declareName(name, bindingType, loc);
        if (bindingType & 2) {
          if (!(bindingType & 1)) {
            this.checkRedeclarationInScope(scope, name, bindingType, loc);
            this.maybeExportDefined(scope, name);
          }
          type = type | 1;
        }
        if (bindingType & 256) {
          type = type | 2;
        }
        if (bindingType & 512) {
          type = type | 4;
        }
        if (bindingType & 128) {
          type = type | 8;
        }
        if (type) scope.tsNames.set(name, type);
      }
      isRedeclaredInScope(scope, name, bindingType) {
        const type = scope.tsNames.get(name);
        if ((type & 2) > 0) {
          if (bindingType & 256) {
            const isConst = !!(bindingType & 512);
            const wasConst = (type & 4) > 0;
            return isConst !== wasConst;
          }
          return true;
        }
        if (bindingType & 128 && (type & 8) > 0) {
          if (scope.names.get(name) & 2) {
            return !!(bindingType & 1);
          } else {
            return false;
          }
        }
        if (bindingType & 2 && (type & 1) > 0) {
          return true;
        }
        return super.isRedeclaredInScope(scope, name, bindingType);
      }
      checkLocalExport(id) {
        const {
          name
        } = id;
        if (this.hasImport(name)) return;
        const len = this.scopeStack.length;
        for (let i = len - 1; i >= 0; i--) {
          const scope = this.scopeStack[i];
          const type = scope.tsNames.get(name);
          if ((type & 1) > 0 || (type & 16) > 0) {
            return;
          }
        }
        super.checkLocalExport(id);
      }
    };
    var unwrapParenthesizedExpression = (node) => {
      return node.type === "ParenthesizedExpression" ? unwrapParenthesizedExpression(node.expression) : node;
    };
    var LValParser = class extends NodeUtils {
      toAssignable(node, isLHS = false) {
        var _node$extra, _node$extra3;
        let parenthesized = void 0;
        if (node.type === "ParenthesizedExpression" || (_node$extra = node.extra) != null && _node$extra.parenthesized) {
          parenthesized = unwrapParenthesizedExpression(node);
          if (isLHS) {
            if (parenthesized.type === "Identifier") {
              this.expressionScope.recordArrowParameterBindingError(Errors.InvalidParenthesizedAssignment, node);
            } else if (parenthesized.type !== "MemberExpression" && !this.isOptionalMemberExpression(parenthesized)) {
              this.raise(Errors.InvalidParenthesizedAssignment, node);
            }
          } else {
            this.raise(Errors.InvalidParenthesizedAssignment, node);
          }
        }
        switch (node.type) {
          case "Identifier":
          case "ObjectPattern":
          case "ArrayPattern":
          case "AssignmentPattern":
          case "RestElement":
            break;
          case "ObjectExpression":
            node.type = "ObjectPattern";
            for (let i = 0, length = node.properties.length, last = length - 1; i < length; i++) {
              var _node$extra2;
              const prop = node.properties[i];
              const isLast = i === last;
              this.toAssignableObjectExpressionProp(prop, isLast, isLHS);
              if (isLast && prop.type === "RestElement" && (_node$extra2 = node.extra) != null && _node$extra2.trailingCommaLoc) {
                this.raise(Errors.RestTrailingComma, node.extra.trailingCommaLoc);
              }
            }
            break;
          case "ObjectProperty": {
            const {
              key: key2,
              value
            } = node;
            if (this.isPrivateName(key2)) {
              this.classScope.usePrivateName(this.getPrivateNameSV(key2), key2.loc.start);
            }
            this.toAssignable(value, isLHS);
            break;
          }
          case "SpreadElement": {
            throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
          }
          case "ArrayExpression":
            node.type = "ArrayPattern";
            this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingCommaLoc, isLHS);
            break;
          case "AssignmentExpression":
            if (node.operator !== "=") {
              this.raise(Errors.MissingEqInAssignment, node.left.loc.end);
            }
            node.type = "AssignmentPattern";
            delete node.operator;
            this.toAssignable(node.left, isLHS);
            break;
          case "ParenthesizedExpression":
            this.toAssignable(parenthesized, isLHS);
            break;
        }
      }
      toAssignableObjectExpressionProp(prop, isLast, isLHS) {
        if (prop.type === "ObjectMethod") {
          this.raise(prop.kind === "get" || prop.kind === "set" ? Errors.PatternHasAccessor : Errors.PatternHasMethod, prop.key);
        } else if (prop.type === "SpreadElement") {
          prop.type = "RestElement";
          const arg = prop.argument;
          this.checkToRestConversion(arg, false);
          this.toAssignable(arg, isLHS);
          if (!isLast) {
            this.raise(Errors.RestTrailingComma, prop);
          }
        } else {
          this.toAssignable(prop, isLHS);
        }
      }
      toAssignableList(exprList, trailingCommaLoc, isLHS) {
        const end = exprList.length - 1;
        for (let i = 0; i <= end; i++) {
          const elt = exprList[i];
          if (!elt) continue;
          this.toAssignableListItem(exprList, i, isLHS);
          if (elt.type === "RestElement") {
            if (i < end) {
              this.raise(Errors.RestTrailingComma, elt);
            } else if (trailingCommaLoc) {
              this.raise(Errors.RestTrailingComma, trailingCommaLoc);
            }
          }
        }
      }
      toAssignableListItem(exprList, index, isLHS) {
        const node = exprList[index];
        if (node.type === "SpreadElement") {
          node.type = "RestElement";
          const arg = node.argument;
          this.checkToRestConversion(arg, true);
          this.toAssignable(arg, isLHS);
        } else {
          this.toAssignable(node, isLHS);
        }
      }
      isAssignable(node, isBinding) {
        switch (node.type) {
          case "Identifier":
          case "ObjectPattern":
          case "ArrayPattern":
          case "AssignmentPattern":
          case "RestElement":
            return true;
          case "ObjectExpression": {
            const last = node.properties.length - 1;
            return node.properties.every((prop, i) => {
              return prop.type !== "ObjectMethod" && (i === last || prop.type !== "SpreadElement") && this.isAssignable(prop);
            });
          }
          case "ObjectProperty":
            return this.isAssignable(node.value);
          case "SpreadElement":
            return this.isAssignable(node.argument);
          case "ArrayExpression":
            return node.elements.every((element) => element === null || this.isAssignable(element));
          case "AssignmentExpression":
            return node.operator === "=";
          case "ParenthesizedExpression":
            return this.isAssignable(node.expression);
          case "MemberExpression":
          case "OptionalMemberExpression":
            return !isBinding;
          default:
            return false;
        }
      }
      toReferencedList(exprList, isParenthesizedExpr) {
        return exprList;
      }
      toReferencedListDeep(exprList, isParenthesizedExpr) {
        this.toReferencedList(exprList, isParenthesizedExpr);
        for (const expr of exprList) {
          if ((expr == null ? void 0 : expr.type) === "ArrayExpression") {
            this.toReferencedListDeep(expr.elements);
          }
        }
      }
      parseSpread(refExpressionErrors) {
        const node = this.startNode();
        this.next();
        node.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, void 0);
        return this.finishNode(node, "SpreadElement");
      }
      parseRestBinding() {
        const node = this.startNode();
        this.next();
        node.argument = this.parseBindingAtom();
        return this.finishNode(node, "RestElement");
      }
      parseBindingAtom() {
        switch (this.state.type) {
          case 0: {
            const node = this.startNode();
            this.next();
            node.elements = this.parseBindingList(3, 93, 1);
            return this.finishNode(node, "ArrayPattern");
          }
          case 5:
            return this.parseObjectLike(8, true);
        }
        return this.parseIdentifier();
      }
      parseBindingList(close, closeCharCode, flags) {
        const allowEmpty = flags & 1;
        const elts = [];
        let first = true;
        while (!this.eat(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(12);
          }
          if (allowEmpty && this.match(12)) {
            elts.push(null);
          } else if (this.eat(close)) {
            break;
          } else if (this.match(21)) {
            let rest = this.parseRestBinding();
            if (this.hasPlugin("flow") || flags & 2) {
              rest = this.parseFunctionParamType(rest);
            }
            elts.push(rest);
            if (!this.checkCommaAfterRest(closeCharCode)) {
              this.expect(close);
              break;
            }
          } else {
            const decorators = [];
            if (flags & 2) {
              if (this.match(26) && this.hasPlugin("decorators")) {
                this.raise(Errors.UnsupportedParameterDecorator, this.state.startLoc);
              }
              while (this.match(26)) {
                decorators.push(this.parseDecorator());
              }
            }
            elts.push(this.parseBindingElement(flags, decorators));
          }
        }
        return elts;
      }
      parseBindingRestProperty(prop) {
        this.next();
        prop.argument = this.parseIdentifier();
        this.checkCommaAfterRest(125);
        return this.finishNode(prop, "RestElement");
      }
      parseBindingProperty() {
        const {
          type,
          startLoc
        } = this.state;
        if (type === 21) {
          return this.parseBindingRestProperty(this.startNode());
        }
        const prop = this.startNode();
        if (type === 139) {
          this.expectPlugin("destructuringPrivate", startLoc);
          this.classScope.usePrivateName(this.state.value, startLoc);
          prop.key = this.parsePrivateName();
        } else {
          this.parsePropertyName(prop);
        }
        prop.method = false;
        return this.parseObjPropValue(prop, startLoc, false, false, true, false);
      }
      parseBindingElement(flags, decorators) {
        const left = this.parseMaybeDefault();
        if (this.hasPlugin("flow") || flags & 2) {
          this.parseFunctionParamType(left);
        }
        const elt = this.parseMaybeDefault(left.loc.start, left);
        if (decorators.length) {
          left.decorators = decorators;
        }
        return elt;
      }
      parseFunctionParamType(param) {
        return param;
      }
      parseMaybeDefault(startLoc, left) {
        startLoc != null ? startLoc : startLoc = this.state.startLoc;
        left = left != null ? left : this.parseBindingAtom();
        if (!this.eat(29)) return left;
        const node = this.startNodeAt(startLoc);
        node.left = left;
        node.right = this.parseMaybeAssignAllowIn();
        return this.finishNode(node, "AssignmentPattern");
      }
      isValidLVal(type, isUnparenthesizedInAssign, binding) {
        switch (type) {
          case "AssignmentPattern":
            return "left";
          case "RestElement":
            return "argument";
          case "ObjectProperty":
            return "value";
          case "ParenthesizedExpression":
            return "expression";
          case "ArrayPattern":
            return "elements";
          case "ObjectPattern":
            return "properties";
        }
        return false;
      }
      isOptionalMemberExpression(expression) {
        return expression.type === "OptionalMemberExpression";
      }
      checkLVal(expression, ancestor, binding = 64, checkClashes = false, strictModeChanged = false, hasParenthesizedAncestor = false) {
        var _expression$extra;
        const type = expression.type;
        if (this.isObjectMethod(expression)) return;
        const isOptionalMemberExpression2 = this.isOptionalMemberExpression(expression);
        if (isOptionalMemberExpression2 || type === "MemberExpression") {
          if (isOptionalMemberExpression2) {
            this.expectPlugin("optionalChainingAssign", expression.loc.start);
            if (ancestor.type !== "AssignmentExpression") {
              this.raise(Errors.InvalidLhsOptionalChaining, expression, {
                ancestor
              });
            }
          }
          if (binding !== 64) {
            this.raise(Errors.InvalidPropertyBindingPattern, expression);
          }
          return;
        }
        if (type === "Identifier") {
          this.checkIdentifier(expression, binding, strictModeChanged);
          const {
            name
          } = expression;
          if (checkClashes) {
            if (checkClashes.has(name)) {
              this.raise(Errors.ParamDupe, expression);
            } else {
              checkClashes.add(name);
            }
          }
          return;
        }
        const validity = this.isValidLVal(type, !(hasParenthesizedAncestor || (_expression$extra = expression.extra) != null && _expression$extra.parenthesized) && ancestor.type === "AssignmentExpression", binding);
        if (validity === true) return;
        if (validity === false) {
          const ParseErrorClass = binding === 64 ? Errors.InvalidLhs : Errors.InvalidLhsBinding;
          this.raise(ParseErrorClass, expression, {
            ancestor
          });
          return;
        }
        let key2, isParenthesizedExpression;
        if (typeof validity === "string") {
          key2 = validity;
          isParenthesizedExpression = type === "ParenthesizedExpression";
        } else {
          [key2, isParenthesizedExpression] = validity;
        }
        const nextAncestor = type === "ArrayPattern" || type === "ObjectPattern" ? {
          type
        } : ancestor;
        const val = expression[key2];
        if (Array.isArray(val)) {
          for (const child of val) {
            if (child) {
              this.checkLVal(child, nextAncestor, binding, checkClashes, strictModeChanged, isParenthesizedExpression);
            }
          }
        } else if (val) {
          this.checkLVal(val, nextAncestor, binding, checkClashes, strictModeChanged, isParenthesizedExpression);
        }
      }
      checkIdentifier(at, bindingType, strictModeChanged = false) {
        if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(at.name, this.inModule) : isStrictBindOnlyReservedWord(at.name))) {
          if (bindingType === 64) {
            this.raise(Errors.StrictEvalArguments, at, {
              referenceName: at.name
            });
          } else {
            this.raise(Errors.StrictEvalArgumentsBinding, at, {
              bindingName: at.name
            });
          }
        }
        if (bindingType & 8192 && at.name === "let") {
          this.raise(Errors.LetInLexicalBinding, at);
        }
        if (!(bindingType & 64)) {
          this.declareNameFromIdentifier(at, bindingType);
        }
      }
      declareNameFromIdentifier(identifier4, binding) {
        this.scope.declareName(identifier4.name, binding, identifier4.loc.start);
      }
      checkToRestConversion(node, allowPattern) {
        switch (node.type) {
          case "ParenthesizedExpression":
            this.checkToRestConversion(node.expression, allowPattern);
            break;
          case "Identifier":
          case "MemberExpression":
            break;
          case "ArrayExpression":
          case "ObjectExpression":
            if (allowPattern) break;
          default:
            this.raise(Errors.InvalidRestAssignmentPattern, node);
        }
      }
      checkCommaAfterRest(close) {
        if (!this.match(12)) {
          return false;
        }
        this.raise(this.lookaheadCharCode() === close ? Errors.RestTrailingComma : Errors.ElementAfterRest, this.state.startLoc);
        return true;
      }
    };
    function nonNull2(x) {
      if (x == null) {
        throw new Error(`Unexpected ${x} value.`);
      }
      return x;
    }
    function assert(x) {
      if (!x) {
        throw new Error("Assert fail");
      }
    }
    var TSErrors = ParseErrorEnum`typescript`({
      AbstractMethodHasImplementation: ({
        methodName
      }) => `Method '${methodName}' cannot have an implementation because it is marked abstract.`,
      AbstractPropertyHasInitializer: ({
        propertyName
      }) => `Property '${propertyName}' cannot have an initializer because it is marked abstract.`,
      AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
      AccessorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
      AccessorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
      ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
      ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
      ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
      ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
      DeclareAccessor: ({
        kind
      }) => `'declare' is not allowed in ${kind}ters.`,
      DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
      DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
      DuplicateAccessibilityModifier: ({
        modifier
      }) => `Accessibility modifier already seen.`,
      DuplicateModifier: ({
        modifier
      }) => `Duplicate modifier: '${modifier}'.`,
      EmptyHeritageClauseType: ({
        token: token2
      }) => `'${token2}' list cannot be empty.`,
      EmptyTypeArguments: "Type argument list cannot be empty.",
      EmptyTypeParameters: "Type parameter list cannot be empty.",
      ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
      ImportAliasHasImportType: "An import alias can not use 'import type'.",
      ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
      IncompatibleModifiers: ({
        modifiers
      }) => `'${modifiers[0]}' modifier cannot be used with '${modifiers[1]}' modifier.`,
      IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
      IndexSignatureHasAccessibility: ({
        modifier
      }) => `Index signatures cannot have an accessibility modifier ('${modifier}').`,
      IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
      IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
      IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
      InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
      InvalidHeritageClauseType: ({
        token: token2
      }) => `'${token2}' list can only include identifiers or qualified-names with optional type arguments.`,
      InvalidModifierOnTypeMember: ({
        modifier
      }) => `'${modifier}' modifier cannot appear on a type member.`,
      InvalidModifierOnTypeParameter: ({
        modifier
      }) => `'${modifier}' modifier cannot appear on a type parameter.`,
      InvalidModifierOnTypeParameterPositions: ({
        modifier
      }) => `'${modifier}' modifier can only appear on a type parameter of a class, interface or type alias.`,
      InvalidModifiersOrder: ({
        orderedModifiers
      }) => `'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`,
      InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.",
      InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
      MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
      NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
      NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
      OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
      OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
      PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
      PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
      PrivateElementHasAccessibility: ({
        modifier
      }) => `Private elements cannot have an accessibility modifier ('${modifier}').`,
      ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
      ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
      ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
      SetAccessorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
      SetAccessorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
      SetAccessorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
      SingleTypeParameterWithoutTrailingComma: ({
        typeParameterName
      }) => `Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`,
      StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
      TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).",
      TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
      TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
      TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
      TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
      UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
      UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
      UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
      UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
      UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
      UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
      UnsupportedSignatureParameterKind: ({
        type
      }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type}.`
    });
    function keywordTypeFromName(value) {
      switch (value) {
        case "any":
          return "TSAnyKeyword";
        case "boolean":
          return "TSBooleanKeyword";
        case "bigint":
          return "TSBigIntKeyword";
        case "never":
          return "TSNeverKeyword";
        case "number":
          return "TSNumberKeyword";
        case "object":
          return "TSObjectKeyword";
        case "string":
          return "TSStringKeyword";
        case "symbol":
          return "TSSymbolKeyword";
        case "undefined":
          return "TSUndefinedKeyword";
        case "unknown":
          return "TSUnknownKeyword";
        default:
          return void 0;
      }
    }
    function tsIsAccessModifier(modifier) {
      return modifier === "private" || modifier === "public" || modifier === "protected";
    }
    function tsIsVarianceAnnotations(modifier) {
      return modifier === "in" || modifier === "out";
    }
    var typescript = (superClass) => class TypeScriptParserMixin extends superClass {
      constructor(...args) {
        super(...args);
        this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
          allowedModifiers: ["in", "out"],
          disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"],
          errorTemplate: TSErrors.InvalidModifierOnTypeParameter
        });
        this.tsParseConstModifier = this.tsParseModifiers.bind(this, {
          allowedModifiers: ["const"],
          disallowedModifiers: ["in", "out"],
          errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
        });
        this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {
          allowedModifiers: ["in", "out", "const"],
          disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],
          errorTemplate: TSErrors.InvalidModifierOnTypeParameter
        });
      }
      getScopeHandler() {
        return TypeScriptScopeHandler;
      }
      tsIsIdentifier() {
        return tokenIsIdentifier(this.state.type);
      }
      tsTokenCanFollowModifier() {
        return this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(139) || this.isLiteralPropertyName();
      }
      tsNextTokenOnSameLineAndCanFollowModifier() {
        this.next();
        if (this.hasPrecedingLineBreak()) {
          return false;
        }
        return this.tsTokenCanFollowModifier();
      }
      tsNextTokenCanFollowModifier() {
        if (this.match(106)) {
          this.next();
          return this.tsTokenCanFollowModifier();
        }
        return this.tsNextTokenOnSameLineAndCanFollowModifier();
      }
      tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock) {
        if (!tokenIsIdentifier(this.state.type) && this.state.type !== 58 && this.state.type !== 75) {
          return void 0;
        }
        const modifier = this.state.value;
        if (allowedModifiers.includes(modifier)) {
          if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) {
            return void 0;
          }
          if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {
            return modifier;
          }
        }
        return void 0;
      }
      tsParseModifiers({
        allowedModifiers,
        disallowedModifiers,
        stopOnStartOfClassStaticBlock,
        errorTemplate = TSErrors.InvalidModifierOnTypeMember
      }, modified) {
        const enforceOrder = (loc, modifier, before, after) => {
          if (modifier === before && modified[after]) {
            this.raise(TSErrors.InvalidModifiersOrder, loc, {
              orderedModifiers: [before, after]
            });
          }
        };
        const incompatible = (loc, modifier, mod1, mod2) => {
          if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {
            this.raise(TSErrors.IncompatibleModifiers, loc, {
              modifiers: [mod1, mod2]
            });
          }
        };
        for (; ; ) {
          const {
            startLoc
          } = this.state;
          const modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []), stopOnStartOfClassStaticBlock);
          if (!modifier) break;
          if (tsIsAccessModifier(modifier)) {
            if (modified.accessibility) {
              this.raise(TSErrors.DuplicateAccessibilityModifier, startLoc, {
                modifier
              });
            } else {
              enforceOrder(startLoc, modifier, modifier, "override");
              enforceOrder(startLoc, modifier, modifier, "static");
              enforceOrder(startLoc, modifier, modifier, "readonly");
              modified.accessibility = modifier;
            }
          } else if (tsIsVarianceAnnotations(modifier)) {
            if (modified[modifier]) {
              this.raise(TSErrors.DuplicateModifier, startLoc, {
                modifier
              });
            }
            modified[modifier] = true;
            enforceOrder(startLoc, modifier, "in", "out");
          } else {
            if (hasOwnProperty.call(modified, modifier)) {
              this.raise(TSErrors.DuplicateModifier, startLoc, {
                modifier
              });
            } else {
              enforceOrder(startLoc, modifier, "static", "readonly");
              enforceOrder(startLoc, modifier, "static", "override");
              enforceOrder(startLoc, modifier, "override", "readonly");
              enforceOrder(startLoc, modifier, "abstract", "override");
              incompatible(startLoc, modifier, "declare", "override");
              incompatible(startLoc, modifier, "static", "abstract");
            }
            modified[modifier] = true;
          }
          if (disallowedModifiers != null && disallowedModifiers.includes(modifier)) {
            this.raise(errorTemplate, startLoc, {
              modifier
            });
          }
        }
      }
      tsIsListTerminator(kind) {
        switch (kind) {
          case "EnumMembers":
          case "TypeMembers":
            return this.match(8);
          case "HeritageClauseElement":
            return this.match(5);
          case "TupleElementTypes":
            return this.match(3);
          case "TypeParametersOrArguments":
            return this.match(48);
        }
      }
      tsParseList(kind, parseElement) {
        const result = [];
        while (!this.tsIsListTerminator(kind)) {
          result.push(parseElement());
        }
        return result;
      }
      tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {
        return nonNull2(this.tsParseDelimitedListWorker(kind, parseElement, true, refTrailingCommaPos));
      }
      tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {
        const result = [];
        let trailingCommaPos = -1;
        for (; ; ) {
          if (this.tsIsListTerminator(kind)) {
            break;
          }
          trailingCommaPos = -1;
          const element = parseElement();
          if (element == null) {
            return void 0;
          }
          result.push(element);
          if (this.eat(12)) {
            trailingCommaPos = this.state.lastTokStartLoc.index;
            continue;
          }
          if (this.tsIsListTerminator(kind)) {
            break;
          }
          if (expectSuccess) {
            this.expect(12);
          }
          return void 0;
        }
        if (refTrailingCommaPos) {
          refTrailingCommaPos.value = trailingCommaPos;
        }
        return result;
      }
      tsParseBracketedList(kind, parseElement, bracket, skipFirstToken, refTrailingCommaPos) {
        if (!skipFirstToken) {
          if (bracket) {
            this.expect(0);
          } else {
            this.expect(47);
          }
        }
        const result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos);
        if (bracket) {
          this.expect(3);
        } else {
          this.expect(48);
        }
        return result;
      }
      tsParseImportType() {
        const node = this.startNode();
        this.expect(83);
        this.expect(10);
        if (!this.match(134)) {
          this.raise(TSErrors.UnsupportedImportTypeArgument, this.state.startLoc);
          {
            node.argument = super.parseExprAtom();
          }
        } else {
          {
            node.argument = this.parseStringLiteral(this.state.value);
          }
        }
        if (this.eat(12) && !this.match(11)) {
          node.options = super.parseMaybeAssignAllowIn();
          this.eat(12);
        } else {
          node.options = null;
        }
        this.expect(11);
        if (this.eat(16)) {
          node.qualifier = this.tsParseEntityName(1 | 2);
        }
        if (this.match(47)) {
          {
            node.typeParameters = this.tsParseTypeArguments();
          }
        }
        return this.finishNode(node, "TSImportType");
      }
      tsParseEntityName(flags) {
        let entity;
        if (flags & 1 && this.match(78)) {
          if (flags & 2) {
            entity = this.parseIdentifier(true);
          } else {
            const node = this.startNode();
            this.next();
            entity = this.finishNode(node, "ThisExpression");
          }
        } else {
          entity = this.parseIdentifier(!!(flags & 1));
        }
        while (this.eat(16)) {
          const node = this.startNodeAtNode(entity);
          node.left = entity;
          node.right = this.parseIdentifier(!!(flags & 1));
          entity = this.finishNode(node, "TSQualifiedName");
        }
        return entity;
      }
      tsParseTypeReference() {
        const node = this.startNode();
        node.typeName = this.tsParseEntityName(1);
        if (!this.hasPrecedingLineBreak() && this.match(47)) {
          {
            node.typeParameters = this.tsParseTypeArguments();
          }
        }
        return this.finishNode(node, "TSTypeReference");
      }
      tsParseThisTypePredicate(lhs) {
        this.next();
        const node = this.startNodeAtNode(lhs);
        node.parameterName = lhs;
        node.typeAnnotation = this.tsParseTypeAnnotation(false);
        node.asserts = false;
        return this.finishNode(node, "TSTypePredicate");
      }
      tsParseThisTypeNode() {
        const node = this.startNode();
        this.next();
        return this.finishNode(node, "TSThisType");
      }
      tsParseTypeQuery() {
        const node = this.startNode();
        this.expect(87);
        if (this.match(83)) {
          node.exprName = this.tsParseImportType();
        } else {
          {
            node.exprName = this.tsParseEntityName(1 | 2);
          }
        }
        if (!this.hasPrecedingLineBreak() && this.match(47)) {
          {
            node.typeParameters = this.tsParseTypeArguments();
          }
        }
        return this.finishNode(node, "TSTypeQuery");
      }
      tsParseTypeParameter(parseModifiers) {
        const node = this.startNode();
        parseModifiers(node);
        node.name = this.tsParseTypeParameterName();
        node.constraint = this.tsEatThenParseType(81);
        node.default = this.tsEatThenParseType(29);
        return this.finishNode(node, "TSTypeParameter");
      }
      tsTryParseTypeParameters(parseModifiers) {
        if (this.match(47)) {
          return this.tsParseTypeParameters(parseModifiers);
        }
      }
      tsParseTypeParameters(parseModifiers) {
        const node = this.startNode();
        if (this.match(47) || this.match(143)) {
          this.next();
        } else {
          this.unexpected();
        }
        const refTrailingCommaPos = {
          value: -1
        };
        node.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, parseModifiers), false, true, refTrailingCommaPos);
        if (node.params.length === 0) {
          this.raise(TSErrors.EmptyTypeParameters, node);
        }
        if (refTrailingCommaPos.value !== -1) {
          this.addExtra(node, "trailingComma", refTrailingCommaPos.value);
        }
        return this.finishNode(node, "TSTypeParameterDeclaration");
      }
      tsFillSignature(returnToken, signature) {
        const returnTokenRequired = returnToken === 19;
        const paramsKey = "parameters";
        const returnTypeKey = "typeAnnotation";
        signature.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        this.expect(10);
        signature[paramsKey] = this.tsParseBindingListForSignature();
        if (returnTokenRequired) {
          signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
        } else if (this.match(returnToken)) {
          signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
        }
      }
      tsParseBindingListForSignature() {
        const list = super.parseBindingList(11, 41, 2);
        for (const pattern of list) {
          const {
            type
          } = pattern;
          if (type === "AssignmentPattern" || type === "TSParameterProperty") {
            this.raise(TSErrors.UnsupportedSignatureParameterKind, pattern, {
              type
            });
          }
        }
        return list;
      }
      tsParseTypeMemberSemicolon() {
        if (!this.eat(12) && !this.isLineTerminator()) {
          this.expect(13);
        }
      }
      tsParseSignatureMember(kind, node) {
        this.tsFillSignature(14, node);
        this.tsParseTypeMemberSemicolon();
        return this.finishNode(node, kind);
      }
      tsIsUnambiguouslyIndexSignature() {
        this.next();
        if (tokenIsIdentifier(this.state.type)) {
          this.next();
          return this.match(14);
        }
        return false;
      }
      tsTryParseIndexSignature(node) {
        if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {
          return;
        }
        this.expect(0);
        const id = this.parseIdentifier();
        id.typeAnnotation = this.tsParseTypeAnnotation();
        this.resetEndLocation(id);
        this.expect(3);
        node.parameters = [id];
        const type = this.tsTryParseTypeAnnotation();
        if (type) node.typeAnnotation = type;
        this.tsParseTypeMemberSemicolon();
        return this.finishNode(node, "TSIndexSignature");
      }
      tsParsePropertyOrMethodSignature(node, readonly) {
        if (this.eat(17)) node.optional = true;
        const nodeAny = node;
        if (this.match(10) || this.match(47)) {
          if (readonly) {
            this.raise(TSErrors.ReadonlyForMethodSignature, node);
          }
          const method = nodeAny;
          if (method.kind && this.match(47)) {
            this.raise(TSErrors.AccessorCannotHaveTypeParameters, this.state.curPosition());
          }
          this.tsFillSignature(14, method);
          this.tsParseTypeMemberSemicolon();
          const paramsKey = "parameters";
          const returnTypeKey = "typeAnnotation";
          if (method.kind === "get") {
            if (method[paramsKey].length > 0) {
              this.raise(Errors.BadGetterArity, this.state.curPosition());
              if (this.isThisParam(method[paramsKey][0])) {
                this.raise(TSErrors.AccessorCannotDeclareThisParameter, this.state.curPosition());
              }
            }
          } else if (method.kind === "set") {
            if (method[paramsKey].length !== 1) {
              this.raise(Errors.BadSetterArity, this.state.curPosition());
            } else {
              const firstParameter = method[paramsKey][0];
              if (this.isThisParam(firstParameter)) {
                this.raise(TSErrors.AccessorCannotDeclareThisParameter, this.state.curPosition());
              }
              if (firstParameter.type === "Identifier" && firstParameter.optional) {
                this.raise(TSErrors.SetAccessorCannotHaveOptionalParameter, this.state.curPosition());
              }
              if (firstParameter.type === "RestElement") {
                this.raise(TSErrors.SetAccessorCannotHaveRestParameter, this.state.curPosition());
              }
            }
            if (method[returnTypeKey]) {
              this.raise(TSErrors.SetAccessorCannotHaveReturnType, method[returnTypeKey]);
            }
          } else {
            method.kind = "method";
          }
          return this.finishNode(method, "TSMethodSignature");
        } else {
          const property = nodeAny;
          if (readonly) property.readonly = true;
          const type = this.tsTryParseTypeAnnotation();
          if (type) property.typeAnnotation = type;
          this.tsParseTypeMemberSemicolon();
          return this.finishNode(property, "TSPropertySignature");
        }
      }
      tsParseTypeMember() {
        const node = this.startNode();
        if (this.match(10) || this.match(47)) {
          return this.tsParseSignatureMember("TSCallSignatureDeclaration", node);
        }
        if (this.match(77)) {
          const id = this.startNode();
          this.next();
          if (this.match(10) || this.match(47)) {
            return this.tsParseSignatureMember("TSConstructSignatureDeclaration", node);
          } else {
            node.key = this.createIdentifier(id, "new");
            return this.tsParsePropertyOrMethodSignature(node, false);
          }
        }
        this.tsParseModifiers({
          allowedModifiers: ["readonly"],
          disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]
        }, node);
        const idx = this.tsTryParseIndexSignature(node);
        if (idx) {
          return idx;
        }
        super.parsePropertyName(node);
        if (!node.computed && node.key.type === "Identifier" && (node.key.name === "get" || node.key.name === "set") && this.tsTokenCanFollowModifier()) {
          node.kind = node.key.name;
          super.parsePropertyName(node);
        }
        return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);
      }
      tsParseTypeLiteral() {
        const node = this.startNode();
        node.members = this.tsParseObjectTypeMembers();
        return this.finishNode(node, "TSTypeLiteral");
      }
      tsParseObjectTypeMembers() {
        this.expect(5);
        const members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
        this.expect(8);
        return members;
      }
      tsIsStartOfMappedType() {
        this.next();
        if (this.eat(53)) {
          return this.isContextual(122);
        }
        if (this.isContextual(122)) {
          this.next();
        }
        if (!this.match(0)) {
          return false;
        }
        this.next();
        if (!this.tsIsIdentifier()) {
          return false;
        }
        this.next();
        return this.match(58);
      }
      tsParseMappedType() {
        const node = this.startNode();
        this.expect(5);
        if (this.match(53)) {
          node.readonly = this.state.value;
          this.next();
          this.expectContextual(122);
        } else if (this.eatContextual(122)) {
          node.readonly = true;
        }
        this.expect(0);
        {
          const typeParameter = this.startNode();
          typeParameter.name = this.tsParseTypeParameterName();
          typeParameter.constraint = this.tsExpectThenParseType(58);
          node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
        }
        node.nameType = this.eatContextual(93) ? this.tsParseType() : null;
        this.expect(3);
        if (this.match(53)) {
          node.optional = this.state.value;
          this.next();
          this.expect(17);
        } else if (this.eat(17)) {
          node.optional = true;
        }
        node.typeAnnotation = this.tsTryParseType();
        this.semicolon();
        this.expect(8);
        return this.finishNode(node, "TSMappedType");
      }
      tsParseTupleType() {
        const node = this.startNode();
        node.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
        let seenOptionalElement = false;
        node.elementTypes.forEach((elementNode) => {
          const {
            type
          } = elementNode;
          if (seenOptionalElement && type !== "TSRestType" && type !== "TSOptionalType" && !(type === "TSNamedTupleMember" && elementNode.optional)) {
            this.raise(TSErrors.OptionalTypeBeforeRequired, elementNode);
          }
          seenOptionalElement || (seenOptionalElement = type === "TSNamedTupleMember" && elementNode.optional || type === "TSOptionalType");
        });
        return this.finishNode(node, "TSTupleType");
      }
      tsParseTupleElementType() {
        const restStartLoc = this.state.startLoc;
        const rest = this.eat(21);
        const {
          startLoc
        } = this.state;
        let labeled;
        let label;
        let optional;
        let type;
        const isWord = tokenIsKeywordOrIdentifier(this.state.type);
        const chAfterWord = isWord ? this.lookaheadCharCode() : null;
        if (chAfterWord === 58) {
          labeled = true;
          optional = false;
          label = this.parseIdentifier(true);
          this.expect(14);
          type = this.tsParseType();
        } else if (chAfterWord === 63) {
          optional = true;
          const wordName = this.state.value;
          const typeOrLabel = this.tsParseNonArrayType();
          if (this.lookaheadCharCode() === 58) {
            labeled = true;
            label = this.createIdentifier(this.startNodeAt(startLoc), wordName);
            this.expect(17);
            this.expect(14);
            type = this.tsParseType();
          } else {
            labeled = false;
            type = typeOrLabel;
            this.expect(17);
          }
        } else {
          type = this.tsParseType();
          optional = this.eat(17);
          labeled = this.eat(14);
        }
        if (labeled) {
          let labeledNode;
          if (label) {
            labeledNode = this.startNodeAt(startLoc);
            labeledNode.optional = optional;
            labeledNode.label = label;
            labeledNode.elementType = type;
            if (this.eat(17)) {
              labeledNode.optional = true;
              this.raise(TSErrors.TupleOptionalAfterType, this.state.lastTokStartLoc);
            }
          } else {
            labeledNode = this.startNodeAt(startLoc);
            labeledNode.optional = optional;
            this.raise(TSErrors.InvalidTupleMemberLabel, type);
            labeledNode.label = type;
            labeledNode.elementType = this.tsParseType();
          }
          type = this.finishNode(labeledNode, "TSNamedTupleMember");
        } else if (optional) {
          const optionalTypeNode = this.startNodeAt(startLoc);
          optionalTypeNode.typeAnnotation = type;
          type = this.finishNode(optionalTypeNode, "TSOptionalType");
        }
        if (rest) {
          const restNode = this.startNodeAt(restStartLoc);
          restNode.typeAnnotation = type;
          type = this.finishNode(restNode, "TSRestType");
        }
        return type;
      }
      tsParseParenthesizedType() {
        const node = this.startNode();
        this.expect(10);
        node.typeAnnotation = this.tsParseType();
        this.expect(11);
        return this.finishNode(node, "TSParenthesizedType");
      }
      tsParseFunctionOrConstructorType(type, abstract) {
        const node = this.startNode();
        if (type === "TSConstructorType") {
          node.abstract = !!abstract;
          if (abstract) this.next();
          this.next();
        }
        this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, node));
        return this.finishNode(node, type);
      }
      tsParseLiteralTypeNode() {
        const node = this.startNode();
        switch (this.state.type) {
          case 135:
          case 136:
          case 134:
          case 85:
          case 86:
            node.literal = super.parseExprAtom();
            break;
          default:
            this.unexpected();
        }
        return this.finishNode(node, "TSLiteralType");
      }
      tsParseTemplateLiteralType() {
        {
          const node = this.startNode();
          node.literal = super.parseTemplate(false);
          return this.finishNode(node, "TSLiteralType");
        }
      }
      parseTemplateSubstitution() {
        if (this.state.inType) return this.tsParseType();
        return super.parseTemplateSubstitution();
      }
      tsParseThisTypeOrThisTypePredicate() {
        const thisKeyword = this.tsParseThisTypeNode();
        if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {
          return this.tsParseThisTypePredicate(thisKeyword);
        } else {
          return thisKeyword;
        }
      }
      tsParseNonArrayType() {
        switch (this.state.type) {
          case 134:
          case 135:
          case 136:
          case 85:
          case 86:
            return this.tsParseLiteralTypeNode();
          case 53:
            if (this.state.value === "-") {
              const node = this.startNode();
              const nextToken = this.lookahead();
              if (nextToken.type !== 135 && nextToken.type !== 136) {
                this.unexpected();
              }
              node.literal = this.parseMaybeUnary();
              return this.finishNode(node, "TSLiteralType");
            }
            break;
          case 78:
            return this.tsParseThisTypeOrThisTypePredicate();
          case 87:
            return this.tsParseTypeQuery();
          case 83:
            return this.tsParseImportType();
          case 5:
            return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
          case 0:
            return this.tsParseTupleType();
          case 10:
            return this.tsParseParenthesizedType();
          case 25:
          case 24:
            return this.tsParseTemplateLiteralType();
          default: {
            const {
              type
            } = this.state;
            if (tokenIsIdentifier(type) || type === 88 || type === 84) {
              const nodeType = type === 88 ? "TSVoidKeyword" : type === 84 ? "TSNullKeyword" : keywordTypeFromName(this.state.value);
              if (nodeType !== void 0 && this.lookaheadCharCode() !== 46) {
                const node = this.startNode();
                this.next();
                return this.finishNode(node, nodeType);
              }
              return this.tsParseTypeReference();
            }
          }
        }
        this.unexpected();
      }
      tsParseArrayTypeOrHigher() {
        const {
          startLoc
        } = this.state;
        let type = this.tsParseNonArrayType();
        while (!this.hasPrecedingLineBreak() && this.eat(0)) {
          if (this.match(3)) {
            const node = this.startNodeAt(startLoc);
            node.elementType = type;
            this.expect(3);
            type = this.finishNode(node, "TSArrayType");
          } else {
            const node = this.startNodeAt(startLoc);
            node.objectType = type;
            node.indexType = this.tsParseType();
            this.expect(3);
            type = this.finishNode(node, "TSIndexedAccessType");
          }
        }
        return type;
      }
      tsParseTypeOperator() {
        const node = this.startNode();
        const operator = this.state.value;
        this.next();
        node.operator = operator;
        node.typeAnnotation = this.tsParseTypeOperatorOrHigher();
        if (operator === "readonly") {
          this.tsCheckTypeAnnotationForReadOnly(node);
        }
        return this.finishNode(node, "TSTypeOperator");
      }
      tsCheckTypeAnnotationForReadOnly(node) {
        switch (node.typeAnnotation.type) {
          case "TSTupleType":
          case "TSArrayType":
            return;
          default:
            this.raise(TSErrors.UnexpectedReadonly, node);
        }
      }
      tsParseInferType() {
        const node = this.startNode();
        this.expectContextual(115);
        const typeParameter = this.startNode();
        typeParameter.name = this.tsParseTypeParameterName();
        typeParameter.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType());
        node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
        return this.finishNode(node, "TSInferType");
      }
      tsParseConstraintForInferType() {
        if (this.eat(81)) {
          const constraint = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
          if (this.state.inDisallowConditionalTypesContext || !this.match(17)) {
            return constraint;
          }
        }
      }
      tsParseTypeOperatorOrHigher() {
        const isTypeOperator = tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc;
        return isTypeOperator ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
      }
      tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
        const node = this.startNode();
        const hasLeadingOperator = this.eat(operator);
        const types2 = [];
        do {
          types2.push(parseConstituentType());
        } while (this.eat(operator));
        if (types2.length === 1 && !hasLeadingOperator) {
          return types2[0];
        }
        node.types = types2;
        return this.finishNode(node, kind);
      }
      tsParseIntersectionTypeOrHigher() {
        return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
      }
      tsParseUnionTypeOrHigher() {
        return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
      }
      tsIsStartOfFunctionType() {
        if (this.match(47)) {
          return true;
        }
        return this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
      }
      tsSkipParameterStart() {
        if (tokenIsIdentifier(this.state.type) || this.match(78)) {
          this.next();
          return true;
        }
        if (this.match(5)) {
          const {
            errors
          } = this.state;
          const previousErrorCount = errors.length;
          try {
            this.parseObjectLike(8, true);
            return errors.length === previousErrorCount;
          } catch (_unused) {
            return false;
          }
        }
        if (this.match(0)) {
          this.next();
          const {
            errors
          } = this.state;
          const previousErrorCount = errors.length;
          try {
            super.parseBindingList(3, 93, 1);
            return errors.length === previousErrorCount;
          } catch (_unused2) {
            return false;
          }
        }
        return false;
      }
      tsIsUnambiguouslyStartOfFunctionType() {
        this.next();
        if (this.match(11) || this.match(21)) {
          return true;
        }
        if (this.tsSkipParameterStart()) {
          if (this.match(14) || this.match(12) || this.match(17) || this.match(29)) {
            return true;
          }
          if (this.match(11)) {
            this.next();
            if (this.match(19)) {
              return true;
            }
          }
        }
        return false;
      }
      tsParseTypeOrTypePredicateAnnotation(returnToken) {
        return this.tsInType(() => {
          const t6 = this.startNode();
          this.expect(returnToken);
          const node = this.startNode();
          const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
          if (asserts && this.match(78)) {
            let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();
            if (thisTypePredicate.type === "TSThisType") {
              node.parameterName = thisTypePredicate;
              node.asserts = true;
              node.typeAnnotation = null;
              thisTypePredicate = this.finishNode(node, "TSTypePredicate");
            } else {
              this.resetStartLocationFromNode(thisTypePredicate, node);
              thisTypePredicate.asserts = true;
            }
            t6.typeAnnotation = thisTypePredicate;
            return this.finishNode(t6, "TSTypeAnnotation");
          }
          const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
          if (!typePredicateVariable) {
            if (!asserts) {
              return this.tsParseTypeAnnotation(false, t6);
            }
            node.parameterName = this.parseIdentifier();
            node.asserts = asserts;
            node.typeAnnotation = null;
            t6.typeAnnotation = this.finishNode(node, "TSTypePredicate");
            return this.finishNode(t6, "TSTypeAnnotation");
          }
          const type = this.tsParseTypeAnnotation(false);
          node.parameterName = typePredicateVariable;
          node.typeAnnotation = type;
          node.asserts = asserts;
          t6.typeAnnotation = this.finishNode(node, "TSTypePredicate");
          return this.finishNode(t6, "TSTypeAnnotation");
        });
      }
      tsTryParseTypeOrTypePredicateAnnotation() {
        if (this.match(14)) {
          return this.tsParseTypeOrTypePredicateAnnotation(14);
        }
      }
      tsTryParseTypeAnnotation() {
        if (this.match(14)) {
          return this.tsParseTypeAnnotation();
        }
      }
      tsTryParseType() {
        return this.tsEatThenParseType(14);
      }
      tsParseTypePredicatePrefix() {
        const id = this.parseIdentifier();
        if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {
          this.next();
          return id;
        }
      }
      tsParseTypePredicateAsserts() {
        if (this.state.type !== 109) {
          return false;
        }
        const containsEsc = this.state.containsEsc;
        this.next();
        if (!tokenIsIdentifier(this.state.type) && !this.match(78)) {
          return false;
        }
        if (containsEsc) {
          this.raise(Errors.InvalidEscapedReservedWord, this.state.lastTokStartLoc, {
            reservedWord: "asserts"
          });
        }
        return true;
      }
      tsParseTypeAnnotation(eatColon = true, t6 = this.startNode()) {
        this.tsInType(() => {
          if (eatColon) this.expect(14);
          t6.typeAnnotation = this.tsParseType();
        });
        return this.finishNode(t6, "TSTypeAnnotation");
      }
      tsParseType() {
        assert(this.state.inType);
        const type = this.tsParseNonConditionalType();
        if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) {
          return type;
        }
        const node = this.startNodeAtNode(type);
        node.checkType = type;
        node.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType());
        this.expect(17);
        node.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
        this.expect(14);
        node.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
        return this.finishNode(node, "TSConditionalType");
      }
      isAbstractConstructorSignature() {
        return this.isContextual(124) && this.lookahead().type === 77;
      }
      tsParseNonConditionalType() {
        if (this.tsIsStartOfFunctionType()) {
          return this.tsParseFunctionOrConstructorType("TSFunctionType");
        }
        if (this.match(77)) {
          return this.tsParseFunctionOrConstructorType("TSConstructorType");
        } else if (this.isAbstractConstructorSignature()) {
          return this.tsParseFunctionOrConstructorType("TSConstructorType", true);
        }
        return this.tsParseUnionTypeOrHigher();
      }
      tsParseTypeAssertion() {
        if (this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
          this.raise(TSErrors.ReservedTypeAssertion, this.state.startLoc);
        }
        const node = this.startNode();
        node.typeAnnotation = this.tsInType(() => {
          this.next();
          return this.match(75) ? this.tsParseTypeReference() : this.tsParseType();
        });
        this.expect(48);
        node.expression = this.parseMaybeUnary();
        return this.finishNode(node, "TSTypeAssertion");
      }
      tsParseHeritageClause(token2) {
        const originalStartLoc = this.state.startLoc;
        const delimitedList = this.tsParseDelimitedList("HeritageClauseElement", () => {
          {
            const node = this.startNode();
            node.expression = this.tsParseEntityName(1 | 2);
            if (this.match(47)) {
              node.typeParameters = this.tsParseTypeArguments();
            }
            return this.finishNode(node, "TSExpressionWithTypeArguments");
          }
        });
        if (!delimitedList.length) {
          this.raise(TSErrors.EmptyHeritageClauseType, originalStartLoc, {
            token: token2
          });
        }
        return delimitedList;
      }
      tsParseInterfaceDeclaration(node, properties = {}) {
        if (this.hasFollowingLineBreak()) return null;
        this.expectContextual(129);
        if (properties.declare) node.declare = true;
        if (tokenIsIdentifier(this.state.type)) {
          node.id = this.parseIdentifier();
          this.checkIdentifier(node.id, 130);
        } else {
          node.id = null;
          this.raise(TSErrors.MissingInterfaceName, this.state.startLoc);
        }
        node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
        if (this.eat(81)) {
          node.extends = this.tsParseHeritageClause("extends");
        }
        const body = this.startNode();
        body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
        node.body = this.finishNode(body, "TSInterfaceBody");
        return this.finishNode(node, "TSInterfaceDeclaration");
      }
      tsParseTypeAliasDeclaration(node) {
        node.id = this.parseIdentifier();
        this.checkIdentifier(node.id, 2);
        node.typeAnnotation = this.tsInType(() => {
          node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers);
          this.expect(29);
          if (this.isContextual(114) && this.lookahead().type !== 16) {
            const node2 = this.startNode();
            this.next();
            return this.finishNode(node2, "TSIntrinsicKeyword");
          }
          return this.tsParseType();
        });
        this.semicolon();
        return this.finishNode(node, "TSTypeAliasDeclaration");
      }
      tsInTopLevelContext(cb) {
        if (this.curContext() !== types.brace) {
          const oldContext = this.state.context;
          this.state.context = [oldContext[0]];
          try {
            return cb();
          } finally {
            this.state.context = oldContext;
          }
        } else {
          return cb();
        }
      }
      tsInType(cb) {
        const oldInType = this.state.inType;
        this.state.inType = true;
        try {
          return cb();
        } finally {
          this.state.inType = oldInType;
        }
      }
      tsInDisallowConditionalTypesContext(cb) {
        const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
        this.state.inDisallowConditionalTypesContext = true;
        try {
          return cb();
        } finally {
          this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
        }
      }
      tsInAllowConditionalTypesContext(cb) {
        const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
        this.state.inDisallowConditionalTypesContext = false;
        try {
          return cb();
        } finally {
          this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
        }
      }
      tsEatThenParseType(token2) {
        if (this.match(token2)) {
          return this.tsNextThenParseType();
        }
      }
      tsExpectThenParseType(token2) {
        return this.tsInType(() => {
          this.expect(token2);
          return this.tsParseType();
        });
      }
      tsNextThenParseType() {
        return this.tsInType(() => {
          this.next();
          return this.tsParseType();
        });
      }
      tsParseEnumMember() {
        const node = this.startNode();
        node.id = this.match(134) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(true);
        if (this.eat(29)) {
          node.initializer = super.parseMaybeAssignAllowIn();
        }
        return this.finishNode(node, "TSEnumMember");
      }
      tsParseEnumDeclaration(node, properties = {}) {
        if (properties.const) node.const = true;
        if (properties.declare) node.declare = true;
        this.expectContextual(126);
        node.id = this.parseIdentifier();
        this.checkIdentifier(node.id, node.const ? 8971 : 8459);
        {
          this.expect(5);
          node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
          this.expect(8);
        }
        return this.finishNode(node, "TSEnumDeclaration");
      }
      tsParseEnumBody() {
        const node = this.startNode();
        this.expect(5);
        node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
        this.expect(8);
        return this.finishNode(node, "TSEnumBody");
      }
      tsParseModuleBlock() {
        const node = this.startNode();
        this.scope.enter(0);
        this.expect(5);
        super.parseBlockOrModuleBlockBody(node.body = [], void 0, true, 8);
        this.scope.exit();
        return this.finishNode(node, "TSModuleBlock");
      }
      tsParseModuleOrNamespaceDeclaration(node, nested = false) {
        node.id = this.parseIdentifier();
        if (!nested) {
          this.checkIdentifier(node.id, 1024);
        }
        if (this.eat(16)) {
          const inner = this.startNode();
          this.tsParseModuleOrNamespaceDeclaration(inner, true);
          node.body = inner;
        } else {
          this.scope.enter(256);
          this.prodParam.enter(0);
          node.body = this.tsParseModuleBlock();
          this.prodParam.exit();
          this.scope.exit();
        }
        return this.finishNode(node, "TSModuleDeclaration");
      }
      tsParseAmbientExternalModuleDeclaration(node) {
        if (this.isContextual(112)) {
          node.kind = "global";
          {
            node.global = true;
          }
          node.id = this.parseIdentifier();
        } else if (this.match(134)) {
          node.kind = "module";
          node.id = super.parseStringLiteral(this.state.value);
        } else {
          this.unexpected();
        }
        if (this.match(5)) {
          this.scope.enter(256);
          this.prodParam.enter(0);
          node.body = this.tsParseModuleBlock();
          this.prodParam.exit();
          this.scope.exit();
        } else {
          this.semicolon();
        }
        return this.finishNode(node, "TSModuleDeclaration");
      }
      tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier, isExport) {
        {
          node.isExport = isExport || false;
        }
        node.id = maybeDefaultIdentifier || this.parseIdentifier();
        this.checkIdentifier(node.id, 4096);
        this.expect(29);
        const moduleReference = this.tsParseModuleReference();
        if (node.importKind === "type" && moduleReference.type !== "TSExternalModuleReference") {
          this.raise(TSErrors.ImportAliasHasImportType, moduleReference);
        }
        node.moduleReference = moduleReference;
        this.semicolon();
        return this.finishNode(node, "TSImportEqualsDeclaration");
      }
      tsIsExternalModuleReference() {
        return this.isContextual(119) && this.lookaheadCharCode() === 40;
      }
      tsParseModuleReference() {
        return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(0);
      }
      tsParseExternalModuleReference() {
        const node = this.startNode();
        this.expectContextual(119);
        this.expect(10);
        if (!this.match(134)) {
          this.unexpected();
        }
        node.expression = super.parseExprAtom();
        this.expect(11);
        this.sawUnambiguousESM = true;
        return this.finishNode(node, "TSExternalModuleReference");
      }
      tsLookAhead(f) {
        const state = this.state.clone();
        const res = f();
        this.state = state;
        return res;
      }
      tsTryParseAndCatch(f) {
        const result = this.tryParse((abort) => f() || abort());
        if (result.aborted || !result.node) return;
        if (result.error) this.state = result.failState;
        return result.node;
      }
      tsTryParse(f) {
        const state = this.state.clone();
        const result = f();
        if (result !== void 0 && result !== false) {
          return result;
        }
        this.state = state;
      }
      tsTryParseDeclare(nany) {
        if (this.isLineTerminator()) {
          return;
        }
        let startType = this.state.type;
        let kind;
        if (this.isContextual(100)) {
          startType = 74;
          kind = "let";
        }
        return this.tsInAmbientContext(() => {
          switch (startType) {
            case 68:
              nany.declare = true;
              return super.parseFunctionStatement(nany, false, false);
            case 80:
              nany.declare = true;
              return this.parseClass(nany, true, false);
            case 126:
              return this.tsParseEnumDeclaration(nany, {
                declare: true
              });
            case 112:
              return this.tsParseAmbientExternalModuleDeclaration(nany);
            case 75:
            case 74:
              if (!this.match(75) || !this.isLookaheadContextual("enum")) {
                nany.declare = true;
                return this.parseVarStatement(nany, kind || this.state.value, true);
              }
              this.expect(75);
              return this.tsParseEnumDeclaration(nany, {
                const: true,
                declare: true
              });
            case 129: {
              const result = this.tsParseInterfaceDeclaration(nany, {
                declare: true
              });
              if (result) return result;
            }
            default:
              if (tokenIsIdentifier(startType)) {
                return this.tsParseDeclaration(nany, this.state.value, true, null);
              }
          }
        });
      }
      tsTryParseExportDeclaration() {
        return this.tsParseDeclaration(this.startNode(), this.state.value, true, null);
      }
      tsParseExpressionStatement(node, expr, decorators) {
        switch (expr.name) {
          case "declare": {
            const declaration = this.tsTryParseDeclare(node);
            if (declaration) {
              declaration.declare = true;
            }
            return declaration;
          }
          case "global":
            if (this.match(5)) {
              this.scope.enter(256);
              this.prodParam.enter(0);
              const mod = node;
              mod.kind = "global";
              {
                node.global = true;
              }
              mod.id = expr;
              mod.body = this.tsParseModuleBlock();
              this.scope.exit();
              this.prodParam.exit();
              return this.finishNode(mod, "TSModuleDeclaration");
            }
            break;
          default:
            return this.tsParseDeclaration(node, expr.name, false, decorators);
        }
      }
      tsParseDeclaration(node, value, next, decorators) {
        switch (value) {
          case "abstract":
            if (this.tsCheckLineTerminator(next) && (this.match(80) || tokenIsIdentifier(this.state.type))) {
              return this.tsParseAbstractDeclaration(node, decorators);
            }
            break;
          case "module":
            if (this.tsCheckLineTerminator(next)) {
              if (this.match(134)) {
                return this.tsParseAmbientExternalModuleDeclaration(node);
              } else if (tokenIsIdentifier(this.state.type)) {
                node.kind = "module";
                return this.tsParseModuleOrNamespaceDeclaration(node);
              }
            }
            break;
          case "namespace":
            if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
              node.kind = "namespace";
              return this.tsParseModuleOrNamespaceDeclaration(node);
            }
            break;
          case "type":
            if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
              return this.tsParseTypeAliasDeclaration(node);
            }
            break;
        }
      }
      tsCheckLineTerminator(next) {
        if (next) {
          if (this.hasFollowingLineBreak()) return false;
          this.next();
          return true;
        }
        return !this.isLineTerminator();
      }
      tsTryParseGenericAsyncArrowFunction(startLoc) {
        if (!this.match(47)) return;
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        this.state.maybeInArrowParameters = true;
        const res = this.tsTryParseAndCatch(() => {
          const node = this.startNodeAt(startLoc);
          node.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);
          super.parseFunctionParams(node);
          node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();
          this.expect(19);
          return node;
        });
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        if (!res) return;
        return super.parseArrowExpression(res, null, true);
      }
      tsParseTypeArgumentsInExpression() {
        if (this.reScan_lt() !== 47) return;
        return this.tsParseTypeArguments();
      }
      tsParseTypeArguments() {
        const node = this.startNode();
        node.params = this.tsInType(() => this.tsInTopLevelContext(() => {
          this.expect(47);
          return this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this));
        }));
        if (node.params.length === 0) {
          this.raise(TSErrors.EmptyTypeArguments, node);
        } else if (!this.state.inType && this.curContext() === types.brace) {
          this.reScan_lt_gt();
        }
        this.expect(48);
        return this.finishNode(node, "TSTypeParameterInstantiation");
      }
      tsIsDeclarationStart() {
        return tokenIsTSDeclarationStart(this.state.type);
      }
      isExportDefaultSpecifier() {
        if (this.tsIsDeclarationStart()) return false;
        return super.isExportDefaultSpecifier();
      }
      parseBindingElement(flags, decorators) {
        const startLoc = this.state.startLoc;
        const modified = {};
        this.tsParseModifiers({
          allowedModifiers: ["public", "private", "protected", "override", "readonly"]
        }, modified);
        const accessibility = modified.accessibility;
        const override = modified.override;
        const readonly = modified.readonly;
        if (!(flags & 4) && (accessibility || readonly || override)) {
          this.raise(TSErrors.UnexpectedParameterModifier, startLoc);
        }
        const left = this.parseMaybeDefault();
        if (flags & 2) {
          this.parseFunctionParamType(left);
        }
        const elt = this.parseMaybeDefault(left.loc.start, left);
        if (accessibility || readonly || override) {
          const pp = this.startNodeAt(startLoc);
          if (decorators.length) {
            pp.decorators = decorators;
          }
          if (accessibility) pp.accessibility = accessibility;
          if (readonly) pp.readonly = readonly;
          if (override) pp.override = override;
          if (elt.type !== "Identifier" && elt.type !== "AssignmentPattern") {
            this.raise(TSErrors.UnsupportedParameterPropertyKind, pp);
          }
          pp.parameter = elt;
          return this.finishNode(pp, "TSParameterProperty");
        }
        if (decorators.length) {
          left.decorators = decorators;
        }
        return elt;
      }
      isSimpleParameter(node) {
        return node.type === "TSParameterProperty" && super.isSimpleParameter(node.parameter) || super.isSimpleParameter(node);
      }
      tsDisallowOptionalPattern(node) {
        for (const param of node.params) {
          if (param.type !== "Identifier" && param.optional && !this.state.isAmbientContext) {
            this.raise(TSErrors.PatternIsOptional, param);
          }
        }
      }
      setArrowFunctionParameters(node, params, trailingCommaLoc) {
        super.setArrowFunctionParameters(node, params, trailingCommaLoc);
        this.tsDisallowOptionalPattern(node);
      }
      parseFunctionBodyAndFinish(node, type, isMethod = false) {
        if (this.match(14)) {
          node.returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
        }
        const bodilessType = type === "FunctionDeclaration" ? "TSDeclareFunction" : type === "ClassMethod" || type === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
        if (bodilessType && !this.match(5) && this.isLineTerminator()) {
          return this.finishNode(node, bodilessType);
        }
        if (bodilessType === "TSDeclareFunction" && this.state.isAmbientContext) {
          this.raise(TSErrors.DeclareFunctionHasImplementation, node);
          if (node.declare) {
            return super.parseFunctionBodyAndFinish(node, bodilessType, isMethod);
          }
        }
        this.tsDisallowOptionalPattern(node);
        return super.parseFunctionBodyAndFinish(node, type, isMethod);
      }
      registerFunctionStatementId(node) {
        if (!node.body && node.id) {
          this.checkIdentifier(node.id, 1024);
        } else {
          super.registerFunctionStatementId(node);
        }
      }
      tsCheckForInvalidTypeCasts(items) {
        items.forEach((node) => {
          if ((node == null ? void 0 : node.type) === "TSTypeCastExpression") {
            this.raise(TSErrors.UnexpectedTypeAnnotation, node.typeAnnotation);
          }
        });
      }
      toReferencedList(exprList, isInParens) {
        this.tsCheckForInvalidTypeCasts(exprList);
        return exprList;
      }
      parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
        const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);
        if (node.type === "ArrayExpression") {
          this.tsCheckForInvalidTypeCasts(node.elements);
        }
        return node;
      }
      parseSubscript(base, startLoc, noCalls, state) {
        if (!this.hasPrecedingLineBreak() && this.match(35)) {
          this.state.canStartJSXElement = false;
          this.next();
          const nonNullExpression = this.startNodeAt(startLoc);
          nonNullExpression.expression = base;
          return this.finishNode(nonNullExpression, "TSNonNullExpression");
        }
        let isOptionalCall = false;
        if (this.match(18) && this.lookaheadCharCode() === 60) {
          if (noCalls) {
            state.stop = true;
            return base;
          }
          state.optionalChainMember = isOptionalCall = true;
          this.next();
        }
        if (this.match(47) || this.match(51)) {
          let missingParenErrorLoc;
          const result = this.tsTryParseAndCatch(() => {
            if (!noCalls && this.atPossibleAsyncArrow(base)) {
              const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startLoc);
              if (asyncArrowFn) {
                return asyncArrowFn;
              }
            }
            const typeArguments = this.tsParseTypeArgumentsInExpression();
            if (!typeArguments) return;
            if (isOptionalCall && !this.match(10)) {
              missingParenErrorLoc = this.state.curPosition();
              return;
            }
            if (tokenIsTemplate(this.state.type)) {
              const result2 = super.parseTaggedTemplateExpression(base, startLoc, state);
              {
                result2.typeParameters = typeArguments;
              }
              return result2;
            }
            if (!noCalls && this.eat(10)) {
              const node2 = this.startNodeAt(startLoc);
              node2.callee = base;
              node2.arguments = this.parseCallExpressionArguments(11);
              this.tsCheckForInvalidTypeCasts(node2.arguments);
              {
                node2.typeParameters = typeArguments;
              }
              if (state.optionalChainMember) {
                node2.optional = isOptionalCall;
              }
              return this.finishCallExpression(node2, state.optionalChainMember);
            }
            const tokenType = this.state.type;
            if (tokenType === 48 || tokenType === 52 || tokenType !== 10 && tokenCanStartExpression(tokenType) && !this.hasPrecedingLineBreak()) {
              return;
            }
            const node = this.startNodeAt(startLoc);
            node.expression = base;
            {
              node.typeParameters = typeArguments;
            }
            return this.finishNode(node, "TSInstantiationExpression");
          });
          if (missingParenErrorLoc) {
            this.unexpected(missingParenErrorLoc, 10);
          }
          if (result) {
            if (result.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40)) {
              this.raise(TSErrors.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc);
            }
            return result;
          }
        }
        return super.parseSubscript(base, startLoc, noCalls, state);
      }
      parseNewCallee(node) {
        var _callee$extra;
        super.parseNewCallee(node);
        const {
          callee
        } = node;
        if (callee.type === "TSInstantiationExpression" && !((_callee$extra = callee.extra) != null && _callee$extra.parenthesized)) {
          {
            node.typeParameters = callee.typeParameters;
          }
          node.callee = callee.expression;
        }
      }
      parseExprOp(left, leftStartLoc, minPrec) {
        let isSatisfies;
        if (tokenOperatorPrecedence(58) > minPrec && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (isSatisfies = this.isContextual(120)))) {
          const node = this.startNodeAt(leftStartLoc);
          node.expression = left;
          node.typeAnnotation = this.tsInType(() => {
            this.next();
            if (this.match(75)) {
              if (isSatisfies) {
                this.raise(Errors.UnexpectedKeyword, this.state.startLoc, {
                  keyword: "const"
                });
              }
              return this.tsParseTypeReference();
            }
            return this.tsParseType();
          });
          this.finishNode(node, isSatisfies ? "TSSatisfiesExpression" : "TSAsExpression");
          this.reScan_lt_gt();
          return this.parseExprOp(node, leftStartLoc, minPrec);
        }
        return super.parseExprOp(left, leftStartLoc, minPrec);
      }
      checkReservedWord(word, startLoc, checkKeywords, isBinding) {
        if (!this.state.isAmbientContext) {
          super.checkReservedWord(word, startLoc, checkKeywords, isBinding);
        }
      }
      checkImportReflection(node) {
        super.checkImportReflection(node);
        if (node.module && node.importKind !== "value") {
          this.raise(TSErrors.ImportReflectionHasImportType, node.specifiers[0].loc.start);
        }
      }
      checkDuplicateExports() {
      }
      isPotentialImportPhase(isExport) {
        if (super.isPotentialImportPhase(isExport)) return true;
        if (this.isContextual(130)) {
          const ch = this.lookaheadCharCode();
          return isExport ? ch === 123 || ch === 42 : ch !== 61;
        }
        return !isExport && this.isContextual(87);
      }
      applyImportPhase(node, isExport, phase, loc) {
        super.applyImportPhase(node, isExport, phase, loc);
        if (isExport) {
          node.exportKind = phase === "type" ? "type" : "value";
        } else {
          node.importKind = phase === "type" || phase === "typeof" ? phase : "value";
        }
      }
      parseImport(node) {
        if (this.match(134)) {
          node.importKind = "value";
          return super.parseImport(node);
        }
        let importNode;
        if (tokenIsIdentifier(this.state.type) && this.lookaheadCharCode() === 61) {
          node.importKind = "value";
          return this.tsParseImportEqualsDeclaration(node);
        } else if (this.isContextual(130)) {
          const maybeDefaultIdentifier = this.parseMaybeImportPhase(node, false);
          if (this.lookaheadCharCode() === 61) {
            return this.tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier);
          } else {
            importNode = super.parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier);
          }
        } else {
          importNode = super.parseImport(node);
        }
        if (importNode.importKind === "type" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === "ImportDefaultSpecifier") {
          this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, importNode);
        }
        return importNode;
      }
      parseExport(node, decorators) {
        if (this.match(83)) {
          const nodeImportEquals = node;
          this.next();
          let maybeDefaultIdentifier = null;
          if (this.isContextual(130) && this.isPotentialImportPhase(false)) {
            maybeDefaultIdentifier = this.parseMaybeImportPhase(nodeImportEquals, false);
          } else {
            nodeImportEquals.importKind = "value";
          }
          const declaration = this.tsParseImportEqualsDeclaration(nodeImportEquals, maybeDefaultIdentifier, true);
          {
            return declaration;
          }
        } else if (this.eat(29)) {
          const assign = node;
          assign.expression = super.parseExpression();
          this.semicolon();
          this.sawUnambiguousESM = true;
          return this.finishNode(assign, "TSExportAssignment");
        } else if (this.eatContextual(93)) {
          const decl = node;
          this.expectContextual(128);
          decl.id = this.parseIdentifier();
          this.semicolon();
          return this.finishNode(decl, "TSNamespaceExportDeclaration");
        } else {
          return super.parseExport(node, decorators);
        }
      }
      isAbstractClass() {
        return this.isContextual(124) && this.lookahead().type === 80;
      }
      parseExportDefaultExpression() {
        if (this.isAbstractClass()) {
          const cls = this.startNode();
          this.next();
          cls.abstract = true;
          return this.parseClass(cls, true, true);
        }
        if (this.match(129)) {
          const result = this.tsParseInterfaceDeclaration(this.startNode());
          if (result) return result;
        }
        return super.parseExportDefaultExpression();
      }
      parseVarStatement(node, kind, allowMissingInitializer = false) {
        const {
          isAmbientContext
        } = this.state;
        const declaration = super.parseVarStatement(node, kind, allowMissingInitializer || isAmbientContext);
        if (!isAmbientContext) return declaration;
        for (const {
          id,
          init
        } of declaration.declarations) {
          if (!init) continue;
          if (kind !== "const" || !!id.typeAnnotation) {
            this.raise(TSErrors.InitializerNotAllowedInAmbientContext, init);
          } else if (!isValidAmbientConstInitializer(init, this.hasPlugin("estree"))) {
            this.raise(TSErrors.ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference, init);
          }
        }
        return declaration;
      }
      parseStatementContent(flags, decorators) {
        if (this.match(75) && this.isLookaheadContextual("enum")) {
          const node = this.startNode();
          this.expect(75);
          return this.tsParseEnumDeclaration(node, {
            const: true
          });
        }
        if (this.isContextual(126)) {
          return this.tsParseEnumDeclaration(this.startNode());
        }
        if (this.isContextual(129)) {
          const result = this.tsParseInterfaceDeclaration(this.startNode());
          if (result) return result;
        }
        return super.parseStatementContent(flags, decorators);
      }
      parseAccessModifier() {
        return this.tsParseModifier(["public", "protected", "private"]);
      }
      tsHasSomeModifiers(member, modifiers) {
        return modifiers.some((modifier) => {
          if (tsIsAccessModifier(modifier)) {
            return member.accessibility === modifier;
          }
          return !!member[modifier];
        });
      }
      tsIsStartOfStaticBlocks() {
        return this.isContextual(106) && this.lookaheadCharCode() === 123;
      }
      parseClassMember(classBody, member, state) {
        const modifiers = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
        this.tsParseModifiers({
          allowedModifiers: modifiers,
          disallowedModifiers: ["in", "out"],
          stopOnStartOfClassStaticBlock: true,
          errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
        }, member);
        const callParseClassMemberWithIsStatic = () => {
          if (this.tsIsStartOfStaticBlocks()) {
            this.next();
            this.next();
            if (this.tsHasSomeModifiers(member, modifiers)) {
              this.raise(TSErrors.StaticBlockCannotHaveModifier, this.state.curPosition());
            }
            super.parseClassStaticBlock(classBody, member);
          } else {
            this.parseClassMemberWithIsStatic(classBody, member, state, !!member.static);
          }
        };
        if (member.declare) {
          this.tsInAmbientContext(callParseClassMemberWithIsStatic);
        } else {
          callParseClassMemberWithIsStatic();
        }
      }
      parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
        const idx = this.tsTryParseIndexSignature(member);
        if (idx) {
          classBody.body.push(idx);
          if (member.abstract) {
            this.raise(TSErrors.IndexSignatureHasAbstract, member);
          }
          if (member.accessibility) {
            this.raise(TSErrors.IndexSignatureHasAccessibility, member, {
              modifier: member.accessibility
            });
          }
          if (member.declare) {
            this.raise(TSErrors.IndexSignatureHasDeclare, member);
          }
          if (member.override) {
            this.raise(TSErrors.IndexSignatureHasOverride, member);
          }
          return;
        }
        if (!this.state.inAbstractClass && member.abstract) {
          this.raise(TSErrors.NonAbstractClassHasAbstractMethod, member);
        }
        if (member.override) {
          if (!state.hadSuperClass) {
            this.raise(TSErrors.OverrideNotInSubClass, member);
          }
        }
        super.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
      }
      parsePostMemberNameModifiers(methodOrProp) {
        const optional = this.eat(17);
        if (optional) methodOrProp.optional = true;
        if (methodOrProp.readonly && this.match(10)) {
          this.raise(TSErrors.ClassMethodHasReadonly, methodOrProp);
        }
        if (methodOrProp.declare && this.match(10)) {
          this.raise(TSErrors.ClassMethodHasDeclare, methodOrProp);
        }
      }
      parseExpressionStatement(node, expr, decorators) {
        const decl = expr.type === "Identifier" ? this.tsParseExpressionStatement(node, expr, decorators) : void 0;
        return decl || super.parseExpressionStatement(node, expr, decorators);
      }
      shouldParseExportDeclaration() {
        if (this.tsIsDeclarationStart()) return true;
        return super.shouldParseExportDeclaration();
      }
      parseConditional(expr, startLoc, refExpressionErrors) {
        if (!this.match(17)) return expr;
        if (this.state.maybeInArrowParameters) {
          const nextCh = this.lookaheadCharCode();
          if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {
            this.setOptionalParametersError(refExpressionErrors);
            return expr;
          }
        }
        return super.parseConditional(expr, startLoc, refExpressionErrors);
      }
      parseParenItem(node, startLoc) {
        const newNode = super.parseParenItem(node, startLoc);
        if (this.eat(17)) {
          newNode.optional = true;
          this.resetEndLocation(node);
        }
        if (this.match(14)) {
          const typeCastNode = this.startNodeAt(startLoc);
          typeCastNode.expression = node;
          typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
          return this.finishNode(typeCastNode, "TSTypeCastExpression");
        }
        return node;
      }
      parseExportDeclaration(node) {
        if (!this.state.isAmbientContext && this.isContextual(125)) {
          return this.tsInAmbientContext(() => this.parseExportDeclaration(node));
        }
        const startLoc = this.state.startLoc;
        const isDeclare = this.eatContextual(125);
        if (isDeclare && (this.isContextual(125) || !this.shouldParseExportDeclaration())) {
          throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
        }
        const isIdentifier = tokenIsIdentifier(this.state.type);
        const declaration = isIdentifier && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(node);
        if (!declaration) return null;
        if (declaration.type === "TSInterfaceDeclaration" || declaration.type === "TSTypeAliasDeclaration" || isDeclare) {
          node.exportKind = "type";
        }
        if (isDeclare && declaration.type !== "TSImportEqualsDeclaration") {
          this.resetStartLocation(declaration, startLoc);
          declaration.declare = true;
        }
        return declaration;
      }
      parseClassId(node, isStatement2, optionalId, bindingType) {
        if ((!isStatement2 || optionalId) && this.isContextual(113)) {
          return;
        }
        super.parseClassId(node, isStatement2, optionalId, node.declare ? 1024 : 8331);
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
        if (typeParameters) node.typeParameters = typeParameters;
      }
      parseClassPropertyAnnotation(node) {
        if (!node.optional) {
          if (this.eat(35)) {
            node.definite = true;
          } else if (this.eat(17)) {
            node.optional = true;
          }
        }
        const type = this.tsTryParseTypeAnnotation();
        if (type) node.typeAnnotation = type;
      }
      parseClassProperty(node) {
        this.parseClassPropertyAnnotation(node);
        if (this.state.isAmbientContext && !(node.readonly && !node.typeAnnotation) && this.match(29)) {
          this.raise(TSErrors.DeclareClassFieldHasInitializer, this.state.startLoc);
        }
        if (node.abstract && this.match(29)) {
          const {
            key: key2
          } = node;
          this.raise(TSErrors.AbstractPropertyHasInitializer, this.state.startLoc, {
            propertyName: key2.type === "Identifier" && !node.computed ? key2.name : `[${this.input.slice(this.offsetToSourcePos(key2.start), this.offsetToSourcePos(key2.end))}]`
          });
        }
        return super.parseClassProperty(node);
      }
      parseClassPrivateProperty(node) {
        if (node.abstract) {
          this.raise(TSErrors.PrivateElementHasAbstract, node);
        }
        if (node.accessibility) {
          this.raise(TSErrors.PrivateElementHasAccessibility, node, {
            modifier: node.accessibility
          });
        }
        this.parseClassPropertyAnnotation(node);
        return super.parseClassPrivateProperty(node);
      }
      parseClassAccessorProperty(node) {
        this.parseClassPropertyAnnotation(node);
        if (node.optional) {
          this.raise(TSErrors.AccessorCannotBeOptional, node);
        }
        return super.parseClassAccessorProperty(node);
      }
      pushClassMethod(classBody, method, isGenerator, isAsync2, isConstructor, allowsDirectSuper) {
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        if (typeParameters && isConstructor) {
          this.raise(TSErrors.ConstructorHasTypeParameters, typeParameters);
        }
        const {
          declare = false,
          kind
        } = method;
        if (declare && (kind === "get" || kind === "set")) {
          this.raise(TSErrors.DeclareAccessor, method, {
            kind
          });
        }
        if (typeParameters) method.typeParameters = typeParameters;
        super.pushClassMethod(classBody, method, isGenerator, isAsync2, isConstructor, allowsDirectSuper);
      }
      pushClassPrivateMethod(classBody, method, isGenerator, isAsync2) {
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        if (typeParameters) method.typeParameters = typeParameters;
        super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync2);
      }
      declareClassPrivateMethodInScope(node, kind) {
        if (node.type === "TSDeclareMethod") return;
        if (node.type === "MethodDefinition" && !hasOwnProperty.call(node.value, "body")) {
          return;
        }
        super.declareClassPrivateMethodInScope(node, kind);
      }
      parseClassSuper(node) {
        super.parseClassSuper(node);
        if (node.superClass && (this.match(47) || this.match(51))) {
          {
            node.superTypeParameters = this.tsParseTypeArgumentsInExpression();
          }
        }
        if (this.eatContextual(113)) {
          node.implements = this.tsParseHeritageClause("implements");
        }
      }
      parseObjPropValue(prop, startLoc, isGenerator, isAsync2, isPattern, isAccessor, refExpressionErrors) {
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        if (typeParameters) prop.typeParameters = typeParameters;
        return super.parseObjPropValue(prop, startLoc, isGenerator, isAsync2, isPattern, isAccessor, refExpressionErrors);
      }
      parseFunctionParams(node, isConstructor) {
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        if (typeParameters) node.typeParameters = typeParameters;
        super.parseFunctionParams(node, isConstructor);
      }
      parseVarId(decl, kind) {
        super.parseVarId(decl, kind);
        if (decl.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35)) {
          decl.definite = true;
        }
        const type = this.tsTryParseTypeAnnotation();
        if (type) {
          decl.id.typeAnnotation = type;
          this.resetEndLocation(decl.id);
        }
      }
      parseAsyncArrowFromCallExpression(node, call) {
        if (this.match(14)) {
          node.returnType = this.tsParseTypeAnnotation();
        }
        return super.parseAsyncArrowFromCallExpression(node, call);
      }
      parseMaybeAssign(refExpressionErrors, afterLeftParse) {
        var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2;
        let state;
        let jsx2;
        let typeCast;
        if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
          state = this.state.clone();
          jsx2 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
          if (!jsx2.error) return jsx2.node;
          const {
            context
          } = this.state;
          const currentContext = context[context.length - 1];
          if (currentContext === types.j_oTag || currentContext === types.j_expr) {
            context.pop();
          }
        }
        if (!((_jsx = jsx2) != null && _jsx.error) && !this.match(47)) {
          return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
        }
        if (!state || state === this.state) state = this.state.clone();
        let typeParameters;
        const arrow = this.tryParse((abort) => {
          var _expr$extra, _typeParameters;
          typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);
          const expr = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
          if (expr.type !== "ArrowFunctionExpression" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {
            abort();
          }
          if (((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0) {
            this.resetStartLocationFromNode(expr, typeParameters);
          }
          expr.typeParameters = typeParameters;
          return expr;
        }, state);
        if (!arrow.error && !arrow.aborted) {
          if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);
          return arrow.node;
        }
        if (!jsx2) {
          assert(!this.hasPlugin("jsx"));
          typeCast = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
          if (!typeCast.error) return typeCast.node;
        }
        if ((_jsx2 = jsx2) != null && _jsx2.node) {
          this.state = jsx2.failState;
          return jsx2.node;
        }
        if (arrow.node) {
          this.state = arrow.failState;
          if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);
          return arrow.node;
        }
        if ((_typeCast = typeCast) != null && _typeCast.node) {
          this.state = typeCast.failState;
          return typeCast.node;
        }
        throw ((_jsx3 = jsx2) == null ? void 0 : _jsx3.error) || arrow.error || ((_typeCast2 = typeCast) == null ? void 0 : _typeCast2.error);
      }
      reportReservedArrowTypeParam(node) {
        var _node$extra2;
        if (node.params.length === 1 && !node.params[0].constraint && !((_node$extra2 = node.extra) != null && _node$extra2.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
          this.raise(TSErrors.ReservedArrowTypeParam, node);
        }
      }
      parseMaybeUnary(refExpressionErrors, sawUnary) {
        if (!this.hasPlugin("jsx") && this.match(47)) {
          return this.tsParseTypeAssertion();
        }
        return super.parseMaybeUnary(refExpressionErrors, sawUnary);
      }
      parseArrow(node) {
        if (this.match(14)) {
          const result = this.tryParse((abort) => {
            const returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
            if (this.canInsertSemicolon() || !this.match(19)) abort();
            return returnType;
          });
          if (result.aborted) return;
          if (!result.thrown) {
            if (result.error) this.state = result.failState;
            node.returnType = result.node;
          }
        }
        return super.parseArrow(node);
      }
      parseFunctionParamType(param) {
        if (this.eat(17)) {
          param.optional = true;
        }
        const type = this.tsTryParseTypeAnnotation();
        if (type) param.typeAnnotation = type;
        this.resetEndLocation(param);
        return param;
      }
      isAssignable(node, isBinding) {
        switch (node.type) {
          case "TSTypeCastExpression":
            return this.isAssignable(node.expression, isBinding);
          case "TSParameterProperty":
            return true;
          default:
            return super.isAssignable(node, isBinding);
        }
      }
      toAssignable(node, isLHS = false) {
        switch (node.type) {
          case "ParenthesizedExpression":
            this.toAssignableParenthesizedExpression(node, isLHS);
            break;
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSNonNullExpression":
          case "TSTypeAssertion":
            if (isLHS) {
              this.expressionScope.recordArrowParameterBindingError(TSErrors.UnexpectedTypeCastInParameter, node);
            } else {
              this.raise(TSErrors.UnexpectedTypeCastInParameter, node);
            }
            this.toAssignable(node.expression, isLHS);
            break;
          case "AssignmentExpression":
            if (!isLHS && node.left.type === "TSTypeCastExpression") {
              node.left = this.typeCastToParameter(node.left);
            }
          default:
            super.toAssignable(node, isLHS);
        }
      }
      toAssignableParenthesizedExpression(node, isLHS) {
        switch (node.expression.type) {
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSNonNullExpression":
          case "TSTypeAssertion":
          case "ParenthesizedExpression":
            this.toAssignable(node.expression, isLHS);
            break;
          default:
            super.toAssignable(node, isLHS);
        }
      }
      checkToRestConversion(node, allowPattern) {
        switch (node.type) {
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSTypeAssertion":
          case "TSNonNullExpression":
            this.checkToRestConversion(node.expression, false);
            break;
          default:
            super.checkToRestConversion(node, allowPattern);
        }
      }
      isValidLVal(type, isUnparenthesizedInAssign, binding) {
        switch (type) {
          case "TSTypeCastExpression":
            return true;
          case "TSParameterProperty":
            return "parameter";
          case "TSNonNullExpression":
            return "expression";
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSTypeAssertion":
            return (binding !== 64 || !isUnparenthesizedInAssign) && ["expression", true];
          default:
            return super.isValidLVal(type, isUnparenthesizedInAssign, binding);
        }
      }
      parseBindingAtom() {
        if (this.state.type === 78) {
          return this.parseIdentifier(true);
        }
        return super.parseBindingAtom();
      }
      parseMaybeDecoratorArguments(expr, startLoc) {
        if (this.match(47) || this.match(51)) {
          const typeArguments = this.tsParseTypeArgumentsInExpression();
          if (this.match(10)) {
            const call = super.parseMaybeDecoratorArguments(expr, startLoc);
            {
              call.typeParameters = typeArguments;
            }
            return call;
          }
          this.unexpected(null, 10);
        }
        return super.parseMaybeDecoratorArguments(expr, startLoc);
      }
      checkCommaAfterRest(close) {
        if (this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === close) {
          this.next();
          return false;
        }
        return super.checkCommaAfterRest(close);
      }
      isClassMethod() {
        return this.match(47) || super.isClassMethod();
      }
      isClassProperty() {
        return this.match(35) || this.match(14) || super.isClassProperty();
      }
      parseMaybeDefault(startLoc, left) {
        const node = super.parseMaybeDefault(startLoc, left);
        if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
          this.raise(TSErrors.TypeAnnotationAfterAssign, node.typeAnnotation);
        }
        return node;
      }
      getTokenFromCode(code2) {
        if (this.state.inType) {
          if (code2 === 62) {
            this.finishOp(48, 1);
            return;
          }
          if (code2 === 60) {
            this.finishOp(47, 1);
            return;
          }
        }
        super.getTokenFromCode(code2);
      }
      reScan_lt_gt() {
        const {
          type
        } = this.state;
        if (type === 47) {
          this.state.pos -= 1;
          this.readToken_lt();
        } else if (type === 48) {
          this.state.pos -= 1;
          this.readToken_gt();
        }
      }
      reScan_lt() {
        const {
          type
        } = this.state;
        if (type === 51) {
          this.state.pos -= 2;
          this.finishOp(47, 1);
          return 47;
        }
        return type;
      }
      toAssignableListItem(exprList, index, isLHS) {
        const node = exprList[index];
        if (node.type === "TSTypeCastExpression") {
          exprList[index] = this.typeCastToParameter(node);
        }
        super.toAssignableListItem(exprList, index, isLHS);
      }
      typeCastToParameter(node) {
        node.expression.typeAnnotation = node.typeAnnotation;
        this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);
        return node.expression;
      }
      shouldParseArrow(params) {
        if (this.match(14)) {
          return params.every((expr) => this.isAssignable(expr, true));
        }
        return super.shouldParseArrow(params);
      }
      shouldParseAsyncArrow() {
        return this.match(14) || super.shouldParseAsyncArrow();
      }
      canHaveLeadingDecorator() {
        return super.canHaveLeadingDecorator() || this.isAbstractClass();
      }
      jsxParseOpeningElementAfterName(node) {
        if (this.match(47) || this.match(51)) {
          const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
          if (typeArguments) {
            {
              node.typeParameters = typeArguments;
            }
          }
        }
        return super.jsxParseOpeningElementAfterName(node);
      }
      getGetterSetterExpectedParamCount(method) {
        const baseCount = super.getGetterSetterExpectedParamCount(method);
        const params = this.getObjectOrClassMethodParams(method);
        const firstParam = params[0];
        const hasContextParam = firstParam && this.isThisParam(firstParam);
        return hasContextParam ? baseCount + 1 : baseCount;
      }
      parseCatchClauseParam() {
        const param = super.parseCatchClauseParam();
        const type = this.tsTryParseTypeAnnotation();
        if (type) {
          param.typeAnnotation = type;
          this.resetEndLocation(param);
        }
        return param;
      }
      tsInAmbientContext(cb) {
        const {
          isAmbientContext: oldIsAmbientContext,
          strict: oldStrict
        } = this.state;
        this.state.isAmbientContext = true;
        this.state.strict = false;
        try {
          return cb();
        } finally {
          this.state.isAmbientContext = oldIsAmbientContext;
          this.state.strict = oldStrict;
        }
      }
      parseClass(node, isStatement2, optionalId) {
        const oldInAbstractClass = this.state.inAbstractClass;
        this.state.inAbstractClass = !!node.abstract;
        try {
          return super.parseClass(node, isStatement2, optionalId);
        } finally {
          this.state.inAbstractClass = oldInAbstractClass;
        }
      }
      tsParseAbstractDeclaration(node, decorators) {
        if (this.match(80)) {
          node.abstract = true;
          return this.maybeTakeDecorators(decorators, this.parseClass(node, true, false));
        } else if (this.isContextual(129)) {
          if (!this.hasFollowingLineBreak()) {
            node.abstract = true;
            this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifer, node);
            return this.tsParseInterfaceDeclaration(node);
          }
        } else {
          this.unexpected(null, 80);
        }
      }
      parseMethod(node, isGenerator, isAsync2, isConstructor, allowDirectSuper, type, inClassScope) {
        const method = super.parseMethod(node, isGenerator, isAsync2, isConstructor, allowDirectSuper, type, inClassScope);
        if (method.abstract) {
          const hasEstreePlugin = this.hasPlugin("estree");
          const methodFn = hasEstreePlugin ? method.value : method;
          if (methodFn.body) {
            const {
              key: key2
            } = method;
            this.raise(TSErrors.AbstractMethodHasImplementation, method, {
              methodName: key2.type === "Identifier" && !method.computed ? key2.name : `[${this.input.slice(this.offsetToSourcePos(key2.start), this.offsetToSourcePos(key2.end))}]`
            });
          }
        }
        return method;
      }
      tsParseTypeParameterName() {
        const typeName = this.parseIdentifier();
        return typeName.name;
      }
      shouldParseAsAmbientContext() {
        return !!this.getPluginOption("typescript", "dts");
      }
      parse() {
        if (this.shouldParseAsAmbientContext()) {
          this.state.isAmbientContext = true;
        }
        return super.parse();
      }
      getExpression() {
        if (this.shouldParseAsAmbientContext()) {
          this.state.isAmbientContext = true;
        }
        return super.getExpression();
      }
      parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {
        if (!isString && isMaybeTypeOnly) {
          this.parseTypeOnlyImportExportSpecifier(node, false, isInTypeExport);
          return this.finishNode(node, "ExportSpecifier");
        }
        node.exportKind = "value";
        return super.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly);
      }
      parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
        if (!importedIsString && isMaybeTypeOnly) {
          this.parseTypeOnlyImportExportSpecifier(specifier, true, isInTypeOnlyImport);
          return this.finishNode(specifier, "ImportSpecifier");
        }
        specifier.importKind = "value";
        return super.parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, isInTypeOnlyImport ? 4098 : 4096);
      }
      parseTypeOnlyImportExportSpecifier(node, isImport, isInTypeOnlyImportExport) {
        const leftOfAsKey = isImport ? "imported" : "local";
        const rightOfAsKey = isImport ? "local" : "exported";
        let leftOfAs = node[leftOfAsKey];
        let rightOfAs;
        let hasTypeSpecifier = false;
        let canParseAsKeyword = true;
        const loc = leftOfAs.loc.start;
        if (this.isContextual(93)) {
          const firstAs = this.parseIdentifier();
          if (this.isContextual(93)) {
            const secondAs = this.parseIdentifier();
            if (tokenIsKeywordOrIdentifier(this.state.type)) {
              hasTypeSpecifier = true;
              leftOfAs = firstAs;
              rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();
              canParseAsKeyword = false;
            } else {
              rightOfAs = secondAs;
              canParseAsKeyword = false;
            }
          } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
            canParseAsKeyword = false;
            rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();
          } else {
            hasTypeSpecifier = true;
            leftOfAs = firstAs;
          }
        } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
          hasTypeSpecifier = true;
          if (isImport) {
            leftOfAs = this.parseIdentifier(true);
            if (!this.isContextual(93)) {
              this.checkReservedWord(leftOfAs.name, leftOfAs.loc.start, true, true);
            }
          } else {
            leftOfAs = this.parseModuleExportName();
          }
        }
        if (hasTypeSpecifier && isInTypeOnlyImportExport) {
          this.raise(isImport ? TSErrors.TypeModifierIsUsedInTypeImports : TSErrors.TypeModifierIsUsedInTypeExports, loc);
        }
        node[leftOfAsKey] = leftOfAs;
        node[rightOfAsKey] = rightOfAs;
        const kindKey = isImport ? "importKind" : "exportKind";
        node[kindKey] = hasTypeSpecifier ? "type" : "value";
        if (canParseAsKeyword && this.eatContextual(93)) {
          node[rightOfAsKey] = isImport ? this.parseIdentifier() : this.parseModuleExportName();
        }
        if (!node[rightOfAsKey]) {
          node[rightOfAsKey] = cloneIdentifier(node[leftOfAsKey]);
        }
        if (isImport) {
          this.checkIdentifier(node[rightOfAsKey], hasTypeSpecifier ? 4098 : 4096);
        }
      }
    };
    function isPossiblyLiteralEnum(expression) {
      if (expression.type !== "MemberExpression") return false;
      const {
        computed,
        property
      } = expression;
      if (computed && property.type !== "StringLiteral" && (property.type !== "TemplateLiteral" || property.expressions.length > 0)) {
        return false;
      }
      return isUncomputedMemberExpressionChain(expression.object);
    }
    function isValidAmbientConstInitializer(expression, estree2) {
      var _expression$extra;
      const {
        type
      } = expression;
      if ((_expression$extra = expression.extra) != null && _expression$extra.parenthesized) {
        return false;
      }
      if (estree2) {
        if (type === "Literal") {
          const {
            value
          } = expression;
          if (typeof value === "string" || typeof value === "boolean") {
            return true;
          }
        }
      } else {
        if (type === "StringLiteral" || type === "BooleanLiteral") {
          return true;
        }
      }
      if (isNumber(expression, estree2) || isNegativeNumber(expression, estree2)) {
        return true;
      }
      if (type === "TemplateLiteral" && expression.expressions.length === 0) {
        return true;
      }
      if (isPossiblyLiteralEnum(expression)) {
        return true;
      }
      return false;
    }
    function isNumber(expression, estree2) {
      if (estree2) {
        return expression.type === "Literal" && (typeof expression.value === "number" || "bigint" in expression);
      }
      return expression.type === "NumericLiteral" || expression.type === "BigIntLiteral";
    }
    function isNegativeNumber(expression, estree2) {
      if (expression.type === "UnaryExpression") {
        const {
          operator,
          argument
        } = expression;
        if (operator === "-" && isNumber(argument, estree2)) {
          return true;
        }
      }
      return false;
    }
    function isUncomputedMemberExpressionChain(expression) {
      if (expression.type === "Identifier") return true;
      if (expression.type !== "MemberExpression" || expression.computed) {
        return false;
      }
      return isUncomputedMemberExpressionChain(expression.object);
    }
    var PlaceholderErrors = ParseErrorEnum`placeholders`({
      ClassNameIsRequired: "A class name is required.",
      UnexpectedSpace: "Unexpected space in placeholder."
    });
    var placeholders = (superClass) => class PlaceholdersParserMixin extends superClass {
      parsePlaceholder(expectedNode) {
        if (this.match(133)) {
          const node = this.startNode();
          this.next();
          this.assertNoSpace();
          node.name = super.parseIdentifier(true);
          this.assertNoSpace();
          this.expect(133);
          return this.finishPlaceholder(node, expectedNode);
        }
      }
      finishPlaceholder(node, expectedNode) {
        let placeholder = node;
        if (!placeholder.expectedNode || !placeholder.type) {
          placeholder = this.finishNode(placeholder, "Placeholder");
        }
        placeholder.expectedNode = expectedNode;
        return placeholder;
      }
      getTokenFromCode(code2) {
        if (code2 === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {
          this.finishOp(133, 2);
        } else {
          super.getTokenFromCode(code2);
        }
      }
      parseExprAtom(refExpressionErrors) {
        return this.parsePlaceholder("Expression") || super.parseExprAtom(refExpressionErrors);
      }
      parseIdentifier(liberal) {
        return this.parsePlaceholder("Identifier") || super.parseIdentifier(liberal);
      }
      checkReservedWord(word, startLoc, checkKeywords, isBinding) {
        if (word !== void 0) {
          super.checkReservedWord(word, startLoc, checkKeywords, isBinding);
        }
      }
      parseBindingAtom() {
        return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
      }
      isValidLVal(type, isParenthesized, binding) {
        return type === "Placeholder" || super.isValidLVal(type, isParenthesized, binding);
      }
      toAssignable(node, isLHS) {
        if (node && node.type === "Placeholder" && node.expectedNode === "Expression") {
          node.expectedNode = "Pattern";
        } else {
          super.toAssignable(node, isLHS);
        }
      }
      chStartsBindingIdentifier(ch, pos2) {
        if (super.chStartsBindingIdentifier(ch, pos2)) {
          return true;
        }
        const nextToken = this.lookahead();
        if (nextToken.type === 133) {
          return true;
        }
        return false;
      }
      verifyBreakContinue(node, isBreak) {
        if (node.label && node.label.type === "Placeholder") return;
        super.verifyBreakContinue(node, isBreak);
      }
      parseExpressionStatement(node, expr) {
        var _expr$extra;
        if (expr.type !== "Placeholder" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {
          return super.parseExpressionStatement(node, expr);
        }
        if (this.match(14)) {
          const stmt = node;
          stmt.label = this.finishPlaceholder(expr, "Identifier");
          this.next();
          stmt.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration();
          return this.finishNode(stmt, "LabeledStatement");
        }
        this.semicolon();
        const stmtPlaceholder = node;
        stmtPlaceholder.name = expr.name;
        return this.finishPlaceholder(stmtPlaceholder, "Statement");
      }
      parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse) {
        return this.parsePlaceholder("BlockStatement") || super.parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse);
      }
      parseFunctionId(requireId) {
        return this.parsePlaceholder("Identifier") || super.parseFunctionId(requireId);
      }
      parseClass(node, isStatement2, optionalId) {
        const type = isStatement2 ? "ClassDeclaration" : "ClassExpression";
        this.next();
        const oldStrict = this.state.strict;
        const placeholder = this.parsePlaceholder("Identifier");
        if (placeholder) {
          if (this.match(81) || this.match(133) || this.match(5)) {
            node.id = placeholder;
          } else if (optionalId || !isStatement2) {
            node.id = null;
            node.body = this.finishPlaceholder(placeholder, "ClassBody");
            return this.finishNode(node, type);
          } else {
            throw this.raise(PlaceholderErrors.ClassNameIsRequired, this.state.startLoc);
          }
        } else {
          this.parseClassId(node, isStatement2, optionalId);
        }
        super.parseClassSuper(node);
        node.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!node.superClass, oldStrict);
        return this.finishNode(node, type);
      }
      parseExport(node, decorators) {
        const placeholder = this.parsePlaceholder("Identifier");
        if (!placeholder) return super.parseExport(node, decorators);
        const node2 = node;
        if (!this.isContextual(98) && !this.match(12)) {
          node2.specifiers = [];
          node2.source = null;
          node2.declaration = this.finishPlaceholder(placeholder, "Declaration");
          return this.finishNode(node2, "ExportNamedDeclaration");
        }
        this.expectPlugin("exportDefaultFrom");
        const specifier = this.startNode();
        specifier.exported = placeholder;
        node2.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
        return super.parseExport(node2, decorators);
      }
      isExportDefaultSpecifier() {
        if (this.match(65)) {
          const next = this.nextTokenStart();
          if (this.isUnparsedContextual(next, "from")) {
            if (this.input.startsWith(tokenLabelName(133), this.nextTokenStartSince(next + 4))) {
              return true;
            }
          }
        }
        return super.isExportDefaultSpecifier();
      }
      maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {
        var _specifiers;
        if ((_specifiers = node.specifiers) != null && _specifiers.length) {
          return true;
        }
        return super.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier);
      }
      checkExport(node) {
        const {
          specifiers
        } = node;
        if (specifiers != null && specifiers.length) {
          node.specifiers = specifiers.filter((node2) => node2.exported.type === "Placeholder");
        }
        super.checkExport(node);
        node.specifiers = specifiers;
      }
      parseImport(node) {
        const placeholder = this.parsePlaceholder("Identifier");
        if (!placeholder) return super.parseImport(node);
        node.specifiers = [];
        if (!this.isContextual(98) && !this.match(12)) {
          node.source = this.finishPlaceholder(placeholder, "StringLiteral");
          this.semicolon();
          return this.finishNode(node, "ImportDeclaration");
        }
        const specifier = this.startNodeAtNode(placeholder);
        specifier.local = placeholder;
        node.specifiers.push(this.finishNode(specifier, "ImportDefaultSpecifier"));
        if (this.eat(12)) {
          const hasStarImport = this.maybeParseStarImportSpecifier(node);
          if (!hasStarImport) this.parseNamedImportSpecifiers(node);
        }
        this.expectContextual(98);
        node.source = this.parseImportSource();
        this.semicolon();
        return this.finishNode(node, "ImportDeclaration");
      }
      parseImportSource() {
        return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
      }
      assertNoSpace() {
        if (this.state.start > this.offsetToSourcePos(this.state.lastTokEndLoc.index)) {
          this.raise(PlaceholderErrors.UnexpectedSpace, this.state.lastTokEndLoc);
        }
      }
    };
    var v8intrinsic = (superClass) => class V8IntrinsicMixin extends superClass {
      parseV8Intrinsic() {
        if (this.match(54)) {
          const v8IntrinsicStartLoc = this.state.startLoc;
          const node = this.startNode();
          this.next();
          if (tokenIsIdentifier(this.state.type)) {
            const name = this.parseIdentifierName();
            const identifier4 = this.createIdentifier(node, name);
            identifier4.type = "V8IntrinsicIdentifier";
            if (this.match(10)) {
              return identifier4;
            }
          }
          this.unexpected(v8IntrinsicStartLoc);
        }
      }
      parseExprAtom(refExpressionErrors) {
        return this.parseV8Intrinsic() || super.parseExprAtom(refExpressionErrors);
      }
    };
    var PIPELINE_PROPOSALS = ["minimal", "fsharp", "hack", "smart"];
    var TOPIC_TOKENS = ["^^", "@@", "^", "%", "#"];
    function validatePlugins(pluginsMap) {
      if (pluginsMap.has("decorators")) {
        if (pluginsMap.has("decorators-legacy")) {
          throw new Error("Cannot use the decorators and decorators-legacy plugin together");
        }
        const decoratorsBeforeExport = pluginsMap.get("decorators").decoratorsBeforeExport;
        if (decoratorsBeforeExport != null && typeof decoratorsBeforeExport !== "boolean") {
          throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
        }
        const allowCallParenthesized = pluginsMap.get("decorators").allowCallParenthesized;
        if (allowCallParenthesized != null && typeof allowCallParenthesized !== "boolean") {
          throw new Error("'allowCallParenthesized' must be a boolean.");
        }
      }
      if (pluginsMap.has("flow") && pluginsMap.has("typescript")) {
        throw new Error("Cannot combine flow and typescript plugins.");
      }
      if (pluginsMap.has("placeholders") && pluginsMap.has("v8intrinsic")) {
        throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
      }
      if (pluginsMap.has("pipelineOperator")) {
        var _pluginsMap$get;
        const proposal = pluginsMap.get("pipelineOperator").proposal;
        if (!PIPELINE_PROPOSALS.includes(proposal)) {
          const proposalList = PIPELINE_PROPOSALS.map((p) => `"${p}"`).join(", ");
          throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${proposalList}.`);
        }
        const tupleSyntaxIsHash = ((_pluginsMap$get = pluginsMap.get("recordAndTuple")) == null ? void 0 : _pluginsMap$get.syntaxType) === "hash";
        if (proposal === "hack") {
          if (pluginsMap.has("placeholders")) {
            throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
          }
          if (pluginsMap.has("v8intrinsic")) {
            throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
          }
          const topicToken = pluginsMap.get("pipelineOperator").topicToken;
          if (!TOPIC_TOKENS.includes(topicToken)) {
            const tokenList = TOPIC_TOKENS.map((t6) => `"${t6}"`).join(", ");
            throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${tokenList}.`);
          }
          if (topicToken === "#" && tupleSyntaxIsHash) {
            throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "hack", topicToken: "#" }]\` and \`${JSON.stringify(["recordAndTuple", pluginsMap.get("recordAndTuple")])}\`.`);
          }
        } else if (proposal === "smart" && tupleSyntaxIsHash) {
          throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "smart" }]\` and \`${JSON.stringify(["recordAndTuple", pluginsMap.get("recordAndTuple")])}\`.`);
        }
      }
      if (pluginsMap.has("moduleAttributes")) {
        {
          if (pluginsMap.has("deprecatedImportAssert") || pluginsMap.has("importAssertions")) {
            throw new Error("Cannot combine importAssertions, deprecatedImportAssert and moduleAttributes plugins.");
          }
          const moduleAttributesVersionPluginOption = pluginsMap.get("moduleAttributes").version;
          if (moduleAttributesVersionPluginOption !== "may-2020") {
            throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
          }
        }
      }
      if (pluginsMap.has("importAssertions")) {
        if (pluginsMap.has("deprecatedImportAssert")) {
          throw new Error("Cannot combine importAssertions and deprecatedImportAssert plugins.");
        }
      }
      if (!pluginsMap.has("deprecatedImportAssert") && pluginsMap.has("importAttributes") && pluginsMap.get("importAttributes").deprecatedAssertSyntax) {
        {
          pluginsMap.set("deprecatedImportAssert", {});
        }
      }
      if (pluginsMap.has("recordAndTuple")) {
        const syntaxType = pluginsMap.get("recordAndTuple").syntaxType;
        if (syntaxType != null) {
          {
            const RECORD_AND_TUPLE_SYNTAX_TYPES = ["hash", "bar"];
            if (!RECORD_AND_TUPLE_SYNTAX_TYPES.includes(syntaxType)) {
              throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + RECORD_AND_TUPLE_SYNTAX_TYPES.map((p) => `'${p}'`).join(", "));
            }
          }
        }
      }
      if (pluginsMap.has("asyncDoExpressions") && !pluginsMap.has("doExpressions")) {
        const error = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
        error.missingPlugins = "doExpressions";
        throw error;
      }
      if (pluginsMap.has("optionalChainingAssign") && pluginsMap.get("optionalChainingAssign").version !== "2023-07") {
        throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is '2023-07'.");
      }
    }
    var mixinPlugins = {
      estree,
      jsx,
      flow,
      typescript,
      v8intrinsic,
      placeholders
    };
    var mixinPluginNames = Object.keys(mixinPlugins);
    var ExpressionParser = class extends LValParser {
      checkProto(prop, isRecord, sawProto, refExpressionErrors) {
        if (prop.type === "SpreadElement" || this.isObjectMethod(prop) || prop.computed || prop.shorthand) {
          return sawProto;
        }
        const key2 = prop.key;
        const name = key2.type === "Identifier" ? key2.name : key2.value;
        if (name === "__proto__") {
          if (isRecord) {
            this.raise(Errors.RecordNoProto, key2);
            return true;
          }
          if (sawProto) {
            if (refExpressionErrors) {
              if (refExpressionErrors.doubleProtoLoc === null) {
                refExpressionErrors.doubleProtoLoc = key2.loc.start;
              }
            } else {
              this.raise(Errors.DuplicateProto, key2);
            }
          }
          return true;
        }
        return sawProto;
      }
      shouldExitDescending(expr, potentialArrowAt) {
        return expr.type === "ArrowFunctionExpression" && this.offsetToSourcePos(expr.start) === potentialArrowAt;
      }
      getExpression() {
        this.enterInitialScopes();
        this.nextToken();
        const expr = this.parseExpression();
        if (!this.match(140)) {
          this.unexpected();
        }
        this.finalizeRemainingComments();
        expr.comments = this.comments;
        expr.errors = this.state.errors;
        if (this.optionFlags & 256) {
          expr.tokens = this.tokens;
        }
        return expr;
      }
      parseExpression(disallowIn, refExpressionErrors) {
        if (disallowIn) {
          return this.disallowInAnd(() => this.parseExpressionBase(refExpressionErrors));
        }
        return this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));
      }
      parseExpressionBase(refExpressionErrors) {
        const startLoc = this.state.startLoc;
        const expr = this.parseMaybeAssign(refExpressionErrors);
        if (this.match(12)) {
          const node = this.startNodeAt(startLoc);
          node.expressions = [expr];
          while (this.eat(12)) {
            node.expressions.push(this.parseMaybeAssign(refExpressionErrors));
          }
          this.toReferencedList(node.expressions);
          return this.finishNode(node, "SequenceExpression");
        }
        return expr;
      }
      parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {
        return this.disallowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
      }
      parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {
        return this.allowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
      }
      setOptionalParametersError(refExpressionErrors) {
        refExpressionErrors.optionalParametersLoc = this.state.startLoc;
      }
      parseMaybeAssign(refExpressionErrors, afterLeftParse) {
        const startLoc = this.state.startLoc;
        const isYield = this.isContextual(108);
        if (isYield) {
          if (this.prodParam.hasYield) {
            this.next();
            let left2 = this.parseYield(startLoc);
            if (afterLeftParse) {
              left2 = afterLeftParse.call(this, left2, startLoc);
            }
            return left2;
          }
        }
        let ownExpressionErrors;
        if (refExpressionErrors) {
          ownExpressionErrors = false;
        } else {
          refExpressionErrors = new ExpressionErrors();
          ownExpressionErrors = true;
        }
        const {
          type
        } = this.state;
        if (type === 10 || tokenIsIdentifier(type)) {
          this.state.potentialArrowAt = this.state.start;
        }
        let left = this.parseMaybeConditional(refExpressionErrors);
        if (afterLeftParse) {
          left = afterLeftParse.call(this, left, startLoc);
        }
        if (tokenIsAssignment(this.state.type)) {
          const node = this.startNodeAt(startLoc);
          const operator = this.state.value;
          node.operator = operator;
          if (this.match(29)) {
            this.toAssignable(left, true);
            node.left = left;
            const startIndex = startLoc.index;
            if (refExpressionErrors.doubleProtoLoc != null && refExpressionErrors.doubleProtoLoc.index >= startIndex) {
              refExpressionErrors.doubleProtoLoc = null;
            }
            if (refExpressionErrors.shorthandAssignLoc != null && refExpressionErrors.shorthandAssignLoc.index >= startIndex) {
              refExpressionErrors.shorthandAssignLoc = null;
            }
            if (refExpressionErrors.privateKeyLoc != null && refExpressionErrors.privateKeyLoc.index >= startIndex) {
              this.checkDestructuringPrivate(refExpressionErrors);
              refExpressionErrors.privateKeyLoc = null;
            }
          } else {
            node.left = left;
          }
          this.next();
          node.right = this.parseMaybeAssign();
          this.checkLVal(left, this.finishNode(node, "AssignmentExpression"));
          return node;
        } else if (ownExpressionErrors) {
          this.checkExpressionErrors(refExpressionErrors, true);
        }
        if (isYield) {
          const {
            type: type2
          } = this.state;
          const startsExpr2 = this.hasPlugin("v8intrinsic") ? tokenCanStartExpression(type2) : tokenCanStartExpression(type2) && !this.match(54);
          if (startsExpr2 && !this.isAmbiguousPrefixOrIdentifier()) {
            this.raiseOverwrite(Errors.YieldNotInGeneratorFunction, startLoc);
            return this.parseYield(startLoc);
          }
        }
        return left;
      }
      parseMaybeConditional(refExpressionErrors) {
        const startLoc = this.state.startLoc;
        const potentialArrowAt = this.state.potentialArrowAt;
        const expr = this.parseExprOps(refExpressionErrors);
        if (this.shouldExitDescending(expr, potentialArrowAt)) {
          return expr;
        }
        return this.parseConditional(expr, startLoc, refExpressionErrors);
      }
      parseConditional(expr, startLoc, refExpressionErrors) {
        if (this.eat(17)) {
          const node = this.startNodeAt(startLoc);
          node.test = expr;
          node.consequent = this.parseMaybeAssignAllowIn();
          this.expect(14);
          node.alternate = this.parseMaybeAssign();
          return this.finishNode(node, "ConditionalExpression");
        }
        return expr;
      }
      parseMaybeUnaryOrPrivate(refExpressionErrors) {
        return this.match(139) ? this.parsePrivateName() : this.parseMaybeUnary(refExpressionErrors);
      }
      parseExprOps(refExpressionErrors) {
        const startLoc = this.state.startLoc;
        const potentialArrowAt = this.state.potentialArrowAt;
        const expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);
        if (this.shouldExitDescending(expr, potentialArrowAt)) {
          return expr;
        }
        return this.parseExprOp(expr, startLoc, -1);
      }
      parseExprOp(left, leftStartLoc, minPrec) {
        if (this.isPrivateName(left)) {
          const value = this.getPrivateNameSV(left);
          if (minPrec >= tokenOperatorPrecedence(58) || !this.prodParam.hasIn || !this.match(58)) {
            this.raise(Errors.PrivateInExpectedIn, left, {
              identifierName: value
            });
          }
          this.classScope.usePrivateName(value, left.loc.start);
        }
        const op = this.state.type;
        if (tokenIsOperator(op) && (this.prodParam.hasIn || !this.match(58))) {
          let prec = tokenOperatorPrecedence(op);
          if (prec > minPrec) {
            if (op === 39) {
              this.expectPlugin("pipelineOperator");
              if (this.state.inFSharpPipelineDirectBody) {
                return left;
              }
              this.checkPipelineAtInfixOperator(left, leftStartLoc);
            }
            const node = this.startNodeAt(leftStartLoc);
            node.left = left;
            node.operator = this.state.value;
            const logical = op === 41 || op === 42;
            const coalesce = op === 40;
            if (coalesce) {
              prec = tokenOperatorPrecedence(42);
            }
            this.next();
            if (op === 39 && this.hasPlugin(["pipelineOperator", {
              proposal: "minimal"
            }])) {
              if (this.state.type === 96 && this.prodParam.hasAwait) {
                throw this.raise(Errors.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
              }
            }
            node.right = this.parseExprOpRightExpr(op, prec);
            const finishedNode = this.finishNode(node, logical || coalesce ? "LogicalExpression" : "BinaryExpression");
            const nextOp = this.state.type;
            if (coalesce && (nextOp === 41 || nextOp === 42) || logical && nextOp === 40) {
              throw this.raise(Errors.MixingCoalesceWithLogical, this.state.startLoc);
            }
            return this.parseExprOp(finishedNode, leftStartLoc, minPrec);
          }
        }
        return left;
      }
      parseExprOpRightExpr(op, prec) {
        const startLoc = this.state.startLoc;
        switch (op) {
          case 39:
            switch (this.getPluginOption("pipelineOperator", "proposal")) {
              case "hack":
                return this.withTopicBindingContext(() => {
                  return this.parseHackPipeBody();
                });
              case "fsharp":
                return this.withSoloAwaitPermittingContext(() => {
                  return this.parseFSharpPipelineBody(prec);
                });
            }
            if (this.getPluginOption("pipelineOperator", "proposal") === "smart") {
              return this.withTopicBindingContext(() => {
                if (this.prodParam.hasYield && this.isContextual(108)) {
                  throw this.raise(Errors.PipeBodyIsTighter, this.state.startLoc);
                }
                return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(op, prec), startLoc);
              });
            }
          default:
            return this.parseExprOpBaseRightExpr(op, prec);
        }
      }
      parseExprOpBaseRightExpr(op, prec) {
        const startLoc = this.state.startLoc;
        return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, tokenIsRightAssociative(op) ? prec - 1 : prec);
      }
      parseHackPipeBody() {
        var _body$extra;
        const {
          startLoc
        } = this.state;
        const body = this.parseMaybeAssign();
        const requiredParentheses = UnparenthesizedPipeBodyDescriptions.has(body.type);
        if (requiredParentheses && !((_body$extra = body.extra) != null && _body$extra.parenthesized)) {
          this.raise(Errors.PipeUnparenthesizedBody, startLoc, {
            type: body.type
          });
        }
        if (!this.topicReferenceWasUsedInCurrentContext()) {
          this.raise(Errors.PipeTopicUnused, startLoc);
        }
        return body;
      }
      checkExponentialAfterUnary(node) {
        if (this.match(57)) {
          this.raise(Errors.UnexpectedTokenUnaryExponentiation, node.argument);
        }
      }
      parseMaybeUnary(refExpressionErrors, sawUnary) {
        const startLoc = this.state.startLoc;
        const isAwait = this.isContextual(96);
        if (isAwait && this.recordAwaitIfAllowed()) {
          this.next();
          const expr2 = this.parseAwait(startLoc);
          if (!sawUnary) this.checkExponentialAfterUnary(expr2);
          return expr2;
        }
        const update2 = this.match(34);
        const node = this.startNode();
        if (tokenIsPrefix(this.state.type)) {
          node.operator = this.state.value;
          node.prefix = true;
          if (this.match(72)) {
            this.expectPlugin("throwExpressions");
          }
          const isDelete = this.match(89);
          this.next();
          node.argument = this.parseMaybeUnary(null, true);
          this.checkExpressionErrors(refExpressionErrors, true);
          if (this.state.strict && isDelete) {
            const arg = node.argument;
            if (arg.type === "Identifier") {
              this.raise(Errors.StrictDelete, node);
            } else if (this.hasPropertyAsPrivateName(arg)) {
              this.raise(Errors.DeletePrivateField, node);
            }
          }
          if (!update2) {
            if (!sawUnary) {
              this.checkExponentialAfterUnary(node);
            }
            return this.finishNode(node, "UnaryExpression");
          }
        }
        const expr = this.parseUpdate(node, update2, refExpressionErrors);
        if (isAwait) {
          const {
            type
          } = this.state;
          const startsExpr2 = this.hasPlugin("v8intrinsic") ? tokenCanStartExpression(type) : tokenCanStartExpression(type) && !this.match(54);
          if (startsExpr2 && !this.isAmbiguousPrefixOrIdentifier()) {
            this.raiseOverwrite(Errors.AwaitNotInAsyncContext, startLoc);
            return this.parseAwait(startLoc);
          }
        }
        return expr;
      }
      parseUpdate(node, update2, refExpressionErrors) {
        if (update2) {
          const updateExpressionNode = node;
          this.checkLVal(updateExpressionNode.argument, this.finishNode(updateExpressionNode, "UpdateExpression"));
          return node;
        }
        const startLoc = this.state.startLoc;
        let expr = this.parseExprSubscripts(refExpressionErrors);
        if (this.checkExpressionErrors(refExpressionErrors, false)) return expr;
        while (tokenIsPostfix(this.state.type) && !this.canInsertSemicolon()) {
          const node2 = this.startNodeAt(startLoc);
          node2.operator = this.state.value;
          node2.prefix = false;
          node2.argument = expr;
          this.next();
          this.checkLVal(expr, expr = this.finishNode(node2, "UpdateExpression"));
        }
        return expr;
      }
      parseExprSubscripts(refExpressionErrors) {
        const startLoc = this.state.startLoc;
        const potentialArrowAt = this.state.potentialArrowAt;
        const expr = this.parseExprAtom(refExpressionErrors);
        if (this.shouldExitDescending(expr, potentialArrowAt)) {
          return expr;
        }
        return this.parseSubscripts(expr, startLoc);
      }
      parseSubscripts(base, startLoc, noCalls) {
        const state = {
          optionalChainMember: false,
          maybeAsyncArrow: this.atPossibleAsyncArrow(base),
          stop: false
        };
        do {
          base = this.parseSubscript(base, startLoc, noCalls, state);
          state.maybeAsyncArrow = false;
        } while (!state.stop);
        return base;
      }
      parseSubscript(base, startLoc, noCalls, state) {
        const {
          type
        } = this.state;
        if (!noCalls && type === 15) {
          return this.parseBind(base, startLoc, noCalls, state);
        } else if (tokenIsTemplate(type)) {
          return this.parseTaggedTemplateExpression(base, startLoc, state);
        }
        let optional = false;
        if (type === 18) {
          if (noCalls) {
            this.raise(Errors.OptionalChainingNoNew, this.state.startLoc);
            if (this.lookaheadCharCode() === 40) {
              state.stop = true;
              return base;
            }
          }
          state.optionalChainMember = optional = true;
          this.next();
        }
        if (!noCalls && this.match(10)) {
          return this.parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional);
        } else {
          const computed = this.eat(0);
          if (computed || optional || this.eat(16)) {
            return this.parseMember(base, startLoc, state, computed, optional);
          } else {
            state.stop = true;
            return base;
          }
        }
      }
      parseMember(base, startLoc, state, computed, optional) {
        const node = this.startNodeAt(startLoc);
        node.object = base;
        node.computed = computed;
        if (computed) {
          node.property = this.parseExpression();
          this.expect(3);
        } else if (this.match(139)) {
          if (base.type === "Super") {
            this.raise(Errors.SuperPrivateField, startLoc);
          }
          this.classScope.usePrivateName(this.state.value, this.state.startLoc);
          node.property = this.parsePrivateName();
        } else {
          node.property = this.parseIdentifier(true);
        }
        if (state.optionalChainMember) {
          node.optional = optional;
          return this.finishNode(node, "OptionalMemberExpression");
        } else {
          return this.finishNode(node, "MemberExpression");
        }
      }
      parseBind(base, startLoc, noCalls, state) {
        const node = this.startNodeAt(startLoc);
        node.object = base;
        this.next();
        node.callee = this.parseNoCallExpr();
        state.stop = true;
        return this.parseSubscripts(this.finishNode(node, "BindExpression"), startLoc, noCalls);
      }
      parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional) {
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        let refExpressionErrors = null;
        this.state.maybeInArrowParameters = true;
        this.next();
        const node = this.startNodeAt(startLoc);
        node.callee = base;
        const {
          maybeAsyncArrow,
          optionalChainMember
        } = state;
        if (maybeAsyncArrow) {
          this.expressionScope.enter(newAsyncArrowScope());
          refExpressionErrors = new ExpressionErrors();
        }
        if (optionalChainMember) {
          node.optional = optional;
        }
        if (optional) {
          node.arguments = this.parseCallExpressionArguments(11);
        } else {
          node.arguments = this.parseCallExpressionArguments(11, base.type !== "Super", node, refExpressionErrors);
        }
        let finishedNode = this.finishCallExpression(node, optionalChainMember);
        if (maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {
          state.stop = true;
          this.checkDestructuringPrivate(refExpressionErrors);
          this.expressionScope.validateAsPattern();
          this.expressionScope.exit();
          finishedNode = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startLoc), finishedNode);
        } else {
          if (maybeAsyncArrow) {
            this.checkExpressionErrors(refExpressionErrors, true);
            this.expressionScope.exit();
          }
          this.toReferencedArguments(finishedNode);
        }
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        return finishedNode;
      }
      toReferencedArguments(node, isParenthesizedExpr) {
        this.toReferencedListDeep(node.arguments, isParenthesizedExpr);
      }
      parseTaggedTemplateExpression(base, startLoc, state) {
        const node = this.startNodeAt(startLoc);
        node.tag = base;
        node.quasi = this.parseTemplate(true);
        if (state.optionalChainMember) {
          this.raise(Errors.OptionalChainingNoTemplate, startLoc);
        }
        return this.finishNode(node, "TaggedTemplateExpression");
      }
      atPossibleAsyncArrow(base) {
        return base.type === "Identifier" && base.name === "async" && this.state.lastTokEndLoc.index === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.offsetToSourcePos(base.start) === this.state.potentialArrowAt;
      }
      finishCallExpression(node, optional) {
        if (node.callee.type === "Import") {
          if (node.arguments.length === 0 || node.arguments.length > 2) {
            this.raise(Errors.ImportCallArity, node);
          } else {
            for (const arg of node.arguments) {
              if (arg.type === "SpreadElement") {
                this.raise(Errors.ImportCallSpreadArgument, arg);
              }
            }
          }
        }
        return this.finishNode(node, optional ? "OptionalCallExpression" : "CallExpression");
      }
      parseCallExpressionArguments(close, allowPlaceholder, nodeForExtra, refExpressionErrors) {
        const elts = [];
        let first = true;
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = false;
        while (!this.eat(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(12);
            if (this.match(close)) {
              if (nodeForExtra) {
                this.addTrailingCommaExtraToNode(nodeForExtra);
              }
              this.next();
              break;
            }
          }
          elts.push(this.parseExprListItem(false, refExpressionErrors, allowPlaceholder));
        }
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        return elts;
      }
      shouldParseAsyncArrow() {
        return this.match(19) && !this.canInsertSemicolon();
      }
      parseAsyncArrowFromCallExpression(node, call) {
        var _call$extra;
        this.resetPreviousNodeTrailingComments(call);
        this.expect(19);
        this.parseArrowExpression(node, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingCommaLoc);
        if (call.innerComments) {
          setInnerComments(node, call.innerComments);
        }
        if (call.callee.trailingComments) {
          setInnerComments(node, call.callee.trailingComments);
        }
        return node;
      }
      parseNoCallExpr() {
        const startLoc = this.state.startLoc;
        return this.parseSubscripts(this.parseExprAtom(), startLoc, true);
      }
      parseExprAtom(refExpressionErrors) {
        let node;
        let decorators = null;
        const {
          type
        } = this.state;
        switch (type) {
          case 79:
            return this.parseSuper();
          case 83:
            node = this.startNode();
            this.next();
            if (this.match(16)) {
              return this.parseImportMetaProperty(node);
            }
            if (this.match(10)) {
              if (this.optionFlags & 512) {
                return this.parseImportCall(node);
              } else {
                return this.finishNode(node, "Import");
              }
            } else {
              this.raise(Errors.UnsupportedImport, this.state.lastTokStartLoc);
              return this.finishNode(node, "Import");
            }
          case 78:
            node = this.startNode();
            this.next();
            return this.finishNode(node, "ThisExpression");
          case 90: {
            return this.parseDo(this.startNode(), false);
          }
          case 56:
          case 31: {
            this.readRegexp();
            return this.parseRegExpLiteral(this.state.value);
          }
          case 135:
            return this.parseNumericLiteral(this.state.value);
          case 136:
            return this.parseBigIntLiteral(this.state.value);
          case 134:
            return this.parseStringLiteral(this.state.value);
          case 84:
            return this.parseNullLiteral();
          case 85:
            return this.parseBooleanLiteral(true);
          case 86:
            return this.parseBooleanLiteral(false);
          case 10: {
            const canBeArrow = this.state.potentialArrowAt === this.state.start;
            return this.parseParenAndDistinguishExpression(canBeArrow);
          }
          case 2:
          case 1: {
            return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);
          }
          case 0: {
            return this.parseArrayLike(3, true, false, refExpressionErrors);
          }
          case 6:
          case 7: {
            return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);
          }
          case 5: {
            return this.parseObjectLike(8, false, false, refExpressionErrors);
          }
          case 68:
            return this.parseFunctionOrFunctionSent();
          case 26:
            decorators = this.parseDecorators();
          case 80:
            return this.parseClass(this.maybeTakeDecorators(decorators, this.startNode()), false);
          case 77:
            return this.parseNewOrNewTarget();
          case 25:
          case 24:
            return this.parseTemplate(false);
          case 15: {
            node = this.startNode();
            this.next();
            node.object = null;
            const callee = node.callee = this.parseNoCallExpr();
            if (callee.type === "MemberExpression") {
              return this.finishNode(node, "BindExpression");
            } else {
              throw this.raise(Errors.UnsupportedBind, callee);
            }
          }
          case 139: {
            this.raise(Errors.PrivateInExpectedIn, this.state.startLoc, {
              identifierName: this.state.value
            });
            return this.parsePrivateName();
          }
          case 33: {
            return this.parseTopicReferenceThenEqualsSign(54, "%");
          }
          case 32: {
            return this.parseTopicReferenceThenEqualsSign(44, "^");
          }
          case 37:
          case 38: {
            return this.parseTopicReference("hack");
          }
          case 44:
          case 54:
          case 27: {
            const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
            if (pipeProposal) {
              return this.parseTopicReference(pipeProposal);
            }
            this.unexpected();
            break;
          }
          case 47: {
            const lookaheadCh = this.input.codePointAt(this.nextTokenStart());
            if (isIdentifierStart(lookaheadCh) || lookaheadCh === 62) {
              this.expectOnePlugin(["jsx", "flow", "typescript"]);
            } else {
              this.unexpected();
            }
            break;
          }
          default:
            if (type === 137) {
              return this.parseDecimalLiteral(this.state.value);
            }
            if (tokenIsIdentifier(type)) {
              if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123) {
                return this.parseModuleExpression();
              }
              const canBeArrow = this.state.potentialArrowAt === this.state.start;
              const containsEsc = this.state.containsEsc;
              const id = this.parseIdentifier();
              if (!containsEsc && id.name === "async" && !this.canInsertSemicolon()) {
                const {
                  type: type2
                } = this.state;
                if (type2 === 68) {
                  this.resetPreviousNodeTrailingComments(id);
                  this.next();
                  return this.parseAsyncFunctionExpression(this.startNodeAtNode(id));
                } else if (tokenIsIdentifier(type2)) {
                  if (this.lookaheadCharCode() === 61) {
                    return this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id));
                  } else {
                    return id;
                  }
                } else if (type2 === 90) {
                  this.resetPreviousNodeTrailingComments(id);
                  return this.parseDo(this.startNodeAtNode(id), true);
                }
              }
              if (canBeArrow && this.match(19) && !this.canInsertSemicolon()) {
                this.next();
                return this.parseArrowExpression(this.startNodeAtNode(id), [id], false);
              }
              return id;
            } else {
              this.unexpected();
            }
        }
      }
      parseTopicReferenceThenEqualsSign(topicTokenType, topicTokenValue) {
        const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
        if (pipeProposal) {
          this.state.type = topicTokenType;
          this.state.value = topicTokenValue;
          this.state.pos--;
          this.state.end--;
          this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1);
          return this.parseTopicReference(pipeProposal);
        } else {
          this.unexpected();
        }
      }
      parseTopicReference(pipeProposal) {
        const node = this.startNode();
        const startLoc = this.state.startLoc;
        const tokenType = this.state.type;
        this.next();
        return this.finishTopicReference(node, startLoc, pipeProposal, tokenType);
      }
      finishTopicReference(node, startLoc, pipeProposal, tokenType) {
        if (this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType)) {
          if (pipeProposal === "hack") {
            if (!this.topicReferenceIsAllowedInCurrentContext()) {
              this.raise(Errors.PipeTopicUnbound, startLoc);
            }
            this.registerTopicReference();
            return this.finishNode(node, "TopicReference");
          } else {
            if (!this.topicReferenceIsAllowedInCurrentContext()) {
              this.raise(Errors.PrimaryTopicNotAllowed, startLoc);
            }
            this.registerTopicReference();
            return this.finishNode(node, "PipelinePrimaryTopicReference");
          }
        } else {
          throw this.raise(Errors.PipeTopicUnconfiguredToken, startLoc, {
            token: tokenLabelName(tokenType)
          });
        }
      }
      testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType) {
        switch (pipeProposal) {
          case "hack": {
            return this.hasPlugin(["pipelineOperator", {
              topicToken: tokenLabelName(tokenType)
            }]);
          }
          case "smart":
            return tokenType === 27;
          default:
            throw this.raise(Errors.PipeTopicRequiresHackPipes, startLoc);
        }
      }
      parseAsyncArrowUnaryFunction(node) {
        this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));
        const params = [this.parseIdentifier()];
        this.prodParam.exit();
        if (this.hasPrecedingLineBreak()) {
          this.raise(Errors.LineTerminatorBeforeArrow, this.state.curPosition());
        }
        this.expect(19);
        return this.parseArrowExpression(node, params, true);
      }
      parseDo(node, isAsync2) {
        this.expectPlugin("doExpressions");
        if (isAsync2) {
          this.expectPlugin("asyncDoExpressions");
        }
        node.async = isAsync2;
        this.next();
        const oldLabels = this.state.labels;
        this.state.labels = [];
        if (isAsync2) {
          this.prodParam.enter(2);
          node.body = this.parseBlock();
          this.prodParam.exit();
        } else {
          node.body = this.parseBlock();
        }
        this.state.labels = oldLabels;
        return this.finishNode(node, "DoExpression");
      }
      parseSuper() {
        const node = this.startNode();
        this.next();
        if (this.match(10) && !this.scope.allowDirectSuper && !(this.optionFlags & 16)) {
          this.raise(Errors.SuperNotAllowed, node);
        } else if (!this.scope.allowSuper && !(this.optionFlags & 16)) {
          this.raise(Errors.UnexpectedSuper, node);
        }
        if (!this.match(10) && !this.match(0) && !this.match(16)) {
          this.raise(Errors.UnsupportedSuper, node);
        }
        return this.finishNode(node, "Super");
      }
      parsePrivateName() {
        const node = this.startNode();
        const id = this.startNodeAt(createPositionWithColumnOffset(this.state.startLoc, 1));
        const name = this.state.value;
        this.next();
        node.id = this.createIdentifier(id, name);
        return this.finishNode(node, "PrivateName");
      }
      parseFunctionOrFunctionSent() {
        const node = this.startNode();
        this.next();
        if (this.prodParam.hasYield && this.match(16)) {
          const meta = this.createIdentifier(this.startNodeAtNode(node), "function");
          this.next();
          if (this.match(103)) {
            this.expectPlugin("functionSent");
          } else if (!this.hasPlugin("functionSent")) {
            this.unexpected();
          }
          return this.parseMetaProperty(node, meta, "sent");
        }
        return this.parseFunction(node);
      }
      parseMetaProperty(node, meta, propertyName) {
        node.meta = meta;
        const containsEsc = this.state.containsEsc;
        node.property = this.parseIdentifier(true);
        if (node.property.name !== propertyName || containsEsc) {
          this.raise(Errors.UnsupportedMetaProperty, node.property, {
            target: meta.name,
            onlyValidPropertyName: propertyName
          });
        }
        return this.finishNode(node, "MetaProperty");
      }
      parseImportMetaProperty(node) {
        const id = this.createIdentifier(this.startNodeAtNode(node), "import");
        this.next();
        if (this.isContextual(101)) {
          if (!this.inModule) {
            this.raise(Errors.ImportMetaOutsideModule, id);
          }
          this.sawUnambiguousESM = true;
        } else if (this.isContextual(105) || this.isContextual(97)) {
          const isSource = this.isContextual(105);
          this.expectPlugin(isSource ? "sourcePhaseImports" : "deferredImportEvaluation");
          if (!(this.optionFlags & 512)) {
            throw this.raise(Errors.DynamicImportPhaseRequiresImportExpressions, this.state.startLoc, {
              phase: this.state.value
            });
          }
          this.next();
          node.phase = isSource ? "source" : "defer";
          return this.parseImportCall(node);
        }
        return this.parseMetaProperty(node, id, "meta");
      }
      parseLiteralAtNode(value, type, node) {
        this.addExtra(node, "rawValue", value);
        this.addExtra(node, "raw", this.input.slice(this.offsetToSourcePos(node.start), this.state.end));
        node.value = value;
        this.next();
        return this.finishNode(node, type);
      }
      parseLiteral(value, type) {
        const node = this.startNode();
        return this.parseLiteralAtNode(value, type, node);
      }
      parseStringLiteral(value) {
        return this.parseLiteral(value, "StringLiteral");
      }
      parseNumericLiteral(value) {
        return this.parseLiteral(value, "NumericLiteral");
      }
      parseBigIntLiteral(value) {
        return this.parseLiteral(value, "BigIntLiteral");
      }
      parseDecimalLiteral(value) {
        return this.parseLiteral(value, "DecimalLiteral");
      }
      parseRegExpLiteral(value) {
        const node = this.startNode();
        this.addExtra(node, "raw", this.input.slice(this.offsetToSourcePos(node.start), this.state.end));
        node.pattern = value.pattern;
        node.flags = value.flags;
        this.next();
        return this.finishNode(node, "RegExpLiteral");
      }
      parseBooleanLiteral(value) {
        const node = this.startNode();
        node.value = value;
        this.next();
        return this.finishNode(node, "BooleanLiteral");
      }
      parseNullLiteral() {
        const node = this.startNode();
        this.next();
        return this.finishNode(node, "NullLiteral");
      }
      parseParenAndDistinguishExpression(canBeArrow) {
        const startLoc = this.state.startLoc;
        let val;
        this.next();
        this.expressionScope.enter(newArrowHeadScope());
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.maybeInArrowParameters = true;
        this.state.inFSharpPipelineDirectBody = false;
        const innerStartLoc = this.state.startLoc;
        const exprList = [];
        const refExpressionErrors = new ExpressionErrors();
        let first = true;
        let spreadStartLoc;
        let optionalCommaStartLoc;
        while (!this.match(11)) {
          if (first) {
            first = false;
          } else {
            this.expect(12, refExpressionErrors.optionalParametersLoc === null ? null : refExpressionErrors.optionalParametersLoc);
            if (this.match(11)) {
              optionalCommaStartLoc = this.state.startLoc;
              break;
            }
          }
          if (this.match(21)) {
            const spreadNodeStartLoc = this.state.startLoc;
            spreadStartLoc = this.state.startLoc;
            exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartLoc));
            if (!this.checkCommaAfterRest(41)) {
              break;
            }
          } else {
            exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem));
          }
        }
        const innerEndLoc = this.state.lastTokEndLoc;
        this.expect(11);
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        let arrowNode = this.startNodeAt(startLoc);
        if (canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode))) {
          this.checkDestructuringPrivate(refExpressionErrors);
          this.expressionScope.validateAsPattern();
          this.expressionScope.exit();
          this.parseArrowExpression(arrowNode, exprList, false);
          return arrowNode;
        }
        this.expressionScope.exit();
        if (!exprList.length) {
          this.unexpected(this.state.lastTokStartLoc);
        }
        if (optionalCommaStartLoc) this.unexpected(optionalCommaStartLoc);
        if (spreadStartLoc) this.unexpected(spreadStartLoc);
        this.checkExpressionErrors(refExpressionErrors, true);
        this.toReferencedListDeep(exprList, true);
        if (exprList.length > 1) {
          val = this.startNodeAt(innerStartLoc);
          val.expressions = exprList;
          this.finishNode(val, "SequenceExpression");
          this.resetEndLocation(val, innerEndLoc);
        } else {
          val = exprList[0];
        }
        return this.wrapParenthesis(startLoc, val);
      }
      wrapParenthesis(startLoc, expression) {
        if (!(this.optionFlags & 1024)) {
          this.addExtra(expression, "parenthesized", true);
          this.addExtra(expression, "parenStart", startLoc.index);
          this.takeSurroundingComments(expression, startLoc.index, this.state.lastTokEndLoc.index);
          return expression;
        }
        const parenExpression = this.startNodeAt(startLoc);
        parenExpression.expression = expression;
        return this.finishNode(parenExpression, "ParenthesizedExpression");
      }
      shouldParseArrow(params) {
        return !this.canInsertSemicolon();
      }
      parseArrow(node) {
        if (this.eat(19)) {
          return node;
        }
      }
      parseParenItem(node, startLoc) {
        return node;
      }
      parseNewOrNewTarget() {
        const node = this.startNode();
        this.next();
        if (this.match(16)) {
          const meta = this.createIdentifier(this.startNodeAtNode(node), "new");
          this.next();
          const metaProp = this.parseMetaProperty(node, meta, "target");
          if (!this.scope.inNonArrowFunction && !this.scope.inClass && !(this.optionFlags & 4)) {
            this.raise(Errors.UnexpectedNewTarget, metaProp);
          }
          return metaProp;
        }
        return this.parseNew(node);
      }
      parseNew(node) {
        this.parseNewCallee(node);
        if (this.eat(10)) {
          const args = this.parseExprList(11);
          this.toReferencedList(args);
          node.arguments = args;
        } else {
          node.arguments = [];
        }
        return this.finishNode(node, "NewExpression");
      }
      parseNewCallee(node) {
        const isImport = this.match(83);
        const callee = this.parseNoCallExpr();
        node.callee = callee;
        if (isImport && (callee.type === "Import" || callee.type === "ImportExpression")) {
          this.raise(Errors.ImportCallNotNewExpression, callee);
        }
      }
      parseTemplateElement(isTagged) {
        const {
          start,
          startLoc,
          end,
          value
        } = this.state;
        const elemStart = start + 1;
        const elem = this.startNodeAt(createPositionWithColumnOffset(startLoc, 1));
        if (value === null) {
          if (!isTagged) {
            this.raise(Errors.InvalidEscapeSequenceTemplate, createPositionWithColumnOffset(this.state.firstInvalidTemplateEscapePos, 1));
          }
        }
        const isTail = this.match(24);
        const endOffset = isTail ? -1 : -2;
        const elemEnd = end + endOffset;
        elem.value = {
          raw: this.input.slice(elemStart, elemEnd).replace(/\r\n?/g, "\n"),
          cooked: value === null ? null : value.slice(1, endOffset)
        };
        elem.tail = isTail;
        this.next();
        const finishedNode = this.finishNode(elem, "TemplateElement");
        this.resetEndLocation(finishedNode, createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset));
        return finishedNode;
      }
      parseTemplate(isTagged) {
        const node = this.startNode();
        let curElt = this.parseTemplateElement(isTagged);
        const quasis = [curElt];
        const substitutions = [];
        while (!curElt.tail) {
          substitutions.push(this.parseTemplateSubstitution());
          this.readTemplateContinuation();
          quasis.push(curElt = this.parseTemplateElement(isTagged));
        }
        node.expressions = substitutions;
        node.quasis = quasis;
        return this.finishNode(node, "TemplateLiteral");
      }
      parseTemplateSubstitution() {
        return this.parseExpression();
      }
      parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {
        if (isRecord) {
          this.expectPlugin("recordAndTuple");
        }
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = false;
        let sawProto = false;
        let first = true;
        const node = this.startNode();
        node.properties = [];
        this.next();
        while (!this.match(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(12);
            if (this.match(close)) {
              this.addTrailingCommaExtraToNode(node);
              break;
            }
          }
          let prop;
          if (isPattern) {
            prop = this.parseBindingProperty();
          } else {
            prop = this.parsePropertyDefinition(refExpressionErrors);
            sawProto = this.checkProto(prop, isRecord, sawProto, refExpressionErrors);
          }
          if (isRecord && !this.isObjectProperty(prop) && prop.type !== "SpreadElement") {
            this.raise(Errors.InvalidRecordProperty, prop);
          }
          {
            if (prop.shorthand) {
              this.addExtra(prop, "shorthand", true);
            }
          }
          node.properties.push(prop);
        }
        this.next();
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        let type = "ObjectExpression";
        if (isPattern) {
          type = "ObjectPattern";
        } else if (isRecord) {
          type = "RecordExpression";
        }
        return this.finishNode(node, type);
      }
      addTrailingCommaExtraToNode(node) {
        this.addExtra(node, "trailingComma", this.state.lastTokStartLoc.index);
        this.addExtra(node, "trailingCommaLoc", this.state.lastTokStartLoc, false);
      }
      maybeAsyncOrAccessorProp(prop) {
        return !prop.computed && prop.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
      }
      parsePropertyDefinition(refExpressionErrors) {
        let decorators = [];
        if (this.match(26)) {
          if (this.hasPlugin("decorators")) {
            this.raise(Errors.UnsupportedPropertyDecorator, this.state.startLoc);
          }
          while (this.match(26)) {
            decorators.push(this.parseDecorator());
          }
        }
        const prop = this.startNode();
        let isAsync2 = false;
        let isAccessor = false;
        let startLoc;
        if (this.match(21)) {
          if (decorators.length) this.unexpected();
          return this.parseSpread();
        }
        if (decorators.length) {
          prop.decorators = decorators;
          decorators = [];
        }
        prop.method = false;
        if (refExpressionErrors) {
          startLoc = this.state.startLoc;
        }
        let isGenerator = this.eat(55);
        this.parsePropertyNamePrefixOperator(prop);
        const containsEsc = this.state.containsEsc;
        this.parsePropertyName(prop, refExpressionErrors);
        if (!isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {
          const {
            key: key2
          } = prop;
          const keyName = key2.name;
          if (keyName === "async" && !this.hasPrecedingLineBreak()) {
            isAsync2 = true;
            this.resetPreviousNodeTrailingComments(key2);
            isGenerator = this.eat(55);
            this.parsePropertyName(prop);
          }
          if (keyName === "get" || keyName === "set") {
            isAccessor = true;
            this.resetPreviousNodeTrailingComments(key2);
            prop.kind = keyName;
            if (this.match(55)) {
              isGenerator = true;
              this.raise(Errors.AccessorIsGenerator, this.state.curPosition(), {
                kind: keyName
              });
              this.next();
            }
            this.parsePropertyName(prop);
          }
        }
        return this.parseObjPropValue(prop, startLoc, isGenerator, isAsync2, false, isAccessor, refExpressionErrors);
      }
      getGetterSetterExpectedParamCount(method) {
        return method.kind === "get" ? 0 : 1;
      }
      getObjectOrClassMethodParams(method) {
        return method.params;
      }
      checkGetterSetterParams(method) {
        var _params;
        const paramCount = this.getGetterSetterExpectedParamCount(method);
        const params = this.getObjectOrClassMethodParams(method);
        if (params.length !== paramCount) {
          this.raise(method.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, method);
        }
        if (method.kind === "set" && ((_params = params[params.length - 1]) == null ? void 0 : _params.type) === "RestElement") {
          this.raise(Errors.BadSetterRestParameter, method);
        }
      }
      parseObjectMethod(prop, isGenerator, isAsync2, isPattern, isAccessor) {
        if (isAccessor) {
          const finishedProp = this.parseMethod(prop, isGenerator, false, false, false, "ObjectMethod");
          this.checkGetterSetterParams(finishedProp);
          return finishedProp;
        }
        if (isAsync2 || isGenerator || this.match(10)) {
          if (isPattern) this.unexpected();
          prop.kind = "method";
          prop.method = true;
          return this.parseMethod(prop, isGenerator, isAsync2, false, false, "ObjectMethod");
        }
      }
      parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {
        prop.shorthand = false;
        if (this.eat(14)) {
          prop.value = isPattern ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(refExpressionErrors);
          return this.finishNode(prop, "ObjectProperty");
        }
        if (!prop.computed && prop.key.type === "Identifier") {
          this.checkReservedWord(prop.key.name, prop.key.loc.start, true, false);
          if (isPattern) {
            prop.value = this.parseMaybeDefault(startLoc, cloneIdentifier(prop.key));
          } else if (this.match(29)) {
            const shorthandAssignLoc = this.state.startLoc;
            if (refExpressionErrors != null) {
              if (refExpressionErrors.shorthandAssignLoc === null) {
                refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc;
              }
            } else {
              this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc);
            }
            prop.value = this.parseMaybeDefault(startLoc, cloneIdentifier(prop.key));
          } else {
            prop.value = cloneIdentifier(prop.key);
          }
          prop.shorthand = true;
          return this.finishNode(prop, "ObjectProperty");
        }
      }
      parseObjPropValue(prop, startLoc, isGenerator, isAsync2, isPattern, isAccessor, refExpressionErrors) {
        const node = this.parseObjectMethod(prop, isGenerator, isAsync2, isPattern, isAccessor) || this.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);
        if (!node) this.unexpected();
        return node;
      }
      parsePropertyName(prop, refExpressionErrors) {
        if (this.eat(0)) {
          prop.computed = true;
          prop.key = this.parseMaybeAssignAllowIn();
          this.expect(3);
        } else {
          const {
            type,
            value
          } = this.state;
          let key2;
          if (tokenIsKeywordOrIdentifier(type)) {
            key2 = this.parseIdentifier(true);
          } else {
            switch (type) {
              case 135:
                key2 = this.parseNumericLiteral(value);
                break;
              case 134:
                key2 = this.parseStringLiteral(value);
                break;
              case 136:
                key2 = this.parseBigIntLiteral(value);
                break;
              case 139: {
                const privateKeyLoc = this.state.startLoc;
                if (refExpressionErrors != null) {
                  if (refExpressionErrors.privateKeyLoc === null) {
                    refExpressionErrors.privateKeyLoc = privateKeyLoc;
                  }
                } else {
                  this.raise(Errors.UnexpectedPrivateField, privateKeyLoc);
                }
                key2 = this.parsePrivateName();
                break;
              }
              default:
                if (type === 137) {
                  key2 = this.parseDecimalLiteral(value);
                  break;
                }
                this.unexpected();
            }
          }
          prop.key = key2;
          if (type !== 139) {
            prop.computed = false;
          }
        }
      }
      initFunction(node, isAsync2) {
        node.id = null;
        node.generator = false;
        node.async = isAsync2;
      }
      parseMethod(node, isGenerator, isAsync2, isConstructor, allowDirectSuper, type, inClassScope = false) {
        this.initFunction(node, isAsync2);
        node.generator = isGenerator;
        this.scope.enter(2 | 16 | (inClassScope ? 64 : 0) | (allowDirectSuper ? 32 : 0));
        this.prodParam.enter(functionFlags(isAsync2, node.generator));
        this.parseFunctionParams(node, isConstructor);
        const finishedNode = this.parseFunctionBodyAndFinish(node, type, true);
        this.prodParam.exit();
        this.scope.exit();
        return finishedNode;
      }
      parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
        if (isTuple) {
          this.expectPlugin("recordAndTuple");
        }
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = false;
        const node = this.startNode();
        this.next();
        node.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node);
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        return this.finishNode(node, isTuple ? "TupleExpression" : "ArrayExpression");
      }
      parseArrowExpression(node, params, isAsync2, trailingCommaLoc) {
        this.scope.enter(2 | 4);
        let flags = functionFlags(isAsync2, false);
        if (!this.match(5) && this.prodParam.hasIn) {
          flags |= 8;
        }
        this.prodParam.enter(flags);
        this.initFunction(node, isAsync2);
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        if (params) {
          this.state.maybeInArrowParameters = true;
          this.setArrowFunctionParameters(node, params, trailingCommaLoc);
        }
        this.state.maybeInArrowParameters = false;
        this.parseFunctionBody(node, true);
        this.prodParam.exit();
        this.scope.exit();
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        return this.finishNode(node, "ArrowFunctionExpression");
      }
      setArrowFunctionParameters(node, params, trailingCommaLoc) {
        this.toAssignableList(params, trailingCommaLoc, false);
        node.params = params;
      }
      parseFunctionBodyAndFinish(node, type, isMethod = false) {
        this.parseFunctionBody(node, false, isMethod);
        return this.finishNode(node, type);
      }
      parseFunctionBody(node, allowExpression, isMethod = false) {
        const isExpression2 = allowExpression && !this.match(5);
        this.expressionScope.enter(newExpressionScope());
        if (isExpression2) {
          node.body = this.parseMaybeAssign();
          this.checkParams(node, false, allowExpression, false);
        } else {
          const oldStrict = this.state.strict;
          const oldLabels = this.state.labels;
          this.state.labels = [];
          this.prodParam.enter(this.prodParam.currentFlags() | 4);
          node.body = this.parseBlock(true, false, (hasStrictModeDirective) => {
            const nonSimple = !this.isSimpleParamList(node.params);
            if (hasStrictModeDirective && nonSimple) {
              this.raise(Errors.IllegalLanguageModeDirective, (node.kind === "method" || node.kind === "constructor") && !!node.key ? node.key.loc.end : node);
            }
            const strictModeChanged = !oldStrict && this.state.strict;
            this.checkParams(node, !this.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);
            if (this.state.strict && node.id) {
              this.checkIdentifier(node.id, 65, strictModeChanged);
            }
          });
          this.prodParam.exit();
          this.state.labels = oldLabels;
        }
        this.expressionScope.exit();
      }
      isSimpleParameter(node) {
        return node.type === "Identifier";
      }
      isSimpleParamList(params) {
        for (let i = 0, len = params.length; i < len; i++) {
          if (!this.isSimpleParameter(params[i])) return false;
        }
        return true;
      }
      checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {
        const checkClashes = !allowDuplicates && /* @__PURE__ */ new Set();
        const formalParameters = {
          type: "FormalParameters"
        };
        for (const param of node.params) {
          this.checkLVal(param, formalParameters, 5, checkClashes, strictModeChanged);
        }
      }
      parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {
        const elts = [];
        let first = true;
        while (!this.eat(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(12);
            if (this.match(close)) {
              if (nodeForExtra) {
                this.addTrailingCommaExtraToNode(nodeForExtra);
              }
              this.next();
              break;
            }
          }
          elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));
        }
        return elts;
      }
      parseExprListItem(allowEmpty, refExpressionErrors, allowPlaceholder) {
        let elt;
        if (this.match(12)) {
          if (!allowEmpty) {
            this.raise(Errors.UnexpectedToken, this.state.curPosition(), {
              unexpected: ","
            });
          }
          elt = null;
        } else if (this.match(21)) {
          const spreadNodeStartLoc = this.state.startLoc;
          elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartLoc);
        } else if (this.match(17)) {
          this.expectPlugin("partialApplication");
          if (!allowPlaceholder) {
            this.raise(Errors.UnexpectedArgumentPlaceholder, this.state.startLoc);
          }
          const node = this.startNode();
          this.next();
          elt = this.finishNode(node, "ArgumentPlaceholder");
        } else {
          elt = this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem);
        }
        return elt;
      }
      parseIdentifier(liberal) {
        const node = this.startNode();
        const name = this.parseIdentifierName(liberal);
        return this.createIdentifier(node, name);
      }
      createIdentifier(node, name) {
        node.name = name;
        node.loc.identifierName = name;
        return this.finishNode(node, "Identifier");
      }
      parseIdentifierName(liberal) {
        let name;
        const {
          startLoc,
          type
        } = this.state;
        if (tokenIsKeywordOrIdentifier(type)) {
          name = this.state.value;
        } else {
          this.unexpected();
        }
        const tokenIsKeyword2 = tokenKeywordOrIdentifierIsKeyword(type);
        if (liberal) {
          if (tokenIsKeyword2) {
            this.replaceToken(132);
          }
        } else {
          this.checkReservedWord(name, startLoc, tokenIsKeyword2, false);
        }
        this.next();
        return name;
      }
      checkReservedWord(word, startLoc, checkKeywords, isBinding) {
        if (word.length > 10) {
          return;
        }
        if (!canBeReservedWord(word)) {
          return;
        }
        if (checkKeywords && isKeyword(word)) {
          this.raise(Errors.UnexpectedKeyword, startLoc, {
            keyword: word
          });
          return;
        }
        const reservedTest = !this.state.strict ? isReservedWord2 : isBinding ? isStrictBindReservedWord : isStrictReservedWord;
        if (reservedTest(word, this.inModule)) {
          this.raise(Errors.UnexpectedReservedWord, startLoc, {
            reservedWord: word
          });
          return;
        } else if (word === "yield") {
          if (this.prodParam.hasYield) {
            this.raise(Errors.YieldBindingIdentifier, startLoc);
            return;
          }
        } else if (word === "await") {
          if (this.prodParam.hasAwait) {
            this.raise(Errors.AwaitBindingIdentifier, startLoc);
            return;
          }
          if (this.scope.inStaticBlock) {
            this.raise(Errors.AwaitBindingIdentifierInStaticBlock, startLoc);
            return;
          }
          this.expressionScope.recordAsyncArrowParametersError(startLoc);
        } else if (word === "arguments") {
          if (this.scope.inClassAndNotInNonArrowFunction) {
            this.raise(Errors.ArgumentsInClass, startLoc);
            return;
          }
        }
      }
      recordAwaitIfAllowed() {
        const isAwaitAllowed = this.prodParam.hasAwait || this.optionFlags & 1 && !this.scope.inFunction;
        if (isAwaitAllowed && !this.scope.inFunction) {
          this.state.hasTopLevelAwait = true;
        }
        return isAwaitAllowed;
      }
      parseAwait(startLoc) {
        const node = this.startNodeAt(startLoc);
        this.expressionScope.recordParameterInitializerError(Errors.AwaitExpressionFormalParameter, node);
        if (this.eat(55)) {
          this.raise(Errors.ObsoleteAwaitStar, node);
        }
        if (!this.scope.inFunction && !(this.optionFlags & 1)) {
          if (this.isAmbiguousPrefixOrIdentifier()) {
            this.ambiguousScriptDifferentAst = true;
          } else {
            this.sawUnambiguousESM = true;
          }
        }
        if (!this.state.soloAwait) {
          node.argument = this.parseMaybeUnary(null, true);
        }
        return this.finishNode(node, "AwaitExpression");
      }
      isAmbiguousPrefixOrIdentifier() {
        if (this.hasPrecedingLineBreak()) return true;
        const {
          type
        } = this.state;
        return type === 53 || type === 10 || type === 0 || tokenIsTemplate(type) || type === 102 && !this.state.containsEsc || type === 138 || type === 56 || this.hasPlugin("v8intrinsic") && type === 54;
      }
      parseYield(startLoc) {
        const node = this.startNodeAt(startLoc);
        this.expressionScope.recordParameterInitializerError(Errors.YieldInParameter, node);
        let delegating = false;
        let argument = null;
        if (!this.hasPrecedingLineBreak()) {
          delegating = this.eat(55);
          switch (this.state.type) {
            case 13:
            case 140:
            case 8:
            case 11:
            case 3:
            case 9:
            case 14:
            case 12:
              if (!delegating) break;
            default:
              argument = this.parseMaybeAssign();
          }
        }
        node.delegate = delegating;
        node.argument = argument;
        return this.finishNode(node, "YieldExpression");
      }
      parseImportCall(node) {
        this.next();
        node.source = this.parseMaybeAssignAllowIn();
        node.options = null;
        if (this.eat(12)) {
          if (!this.match(11)) {
            node.options = this.parseMaybeAssignAllowIn();
            if (this.eat(12) && !this.match(11)) {
              do {
                this.parseMaybeAssignAllowIn();
              } while (this.eat(12) && !this.match(11));
              this.raise(Errors.ImportCallArity, node);
            }
          }
        }
        this.expect(11);
        return this.finishNode(node, "ImportExpression");
      }
      checkPipelineAtInfixOperator(left, leftStartLoc) {
        if (this.hasPlugin(["pipelineOperator", {
          proposal: "smart"
        }])) {
          if (left.type === "SequenceExpression") {
            this.raise(Errors.PipelineHeadSequenceExpression, leftStartLoc);
          }
        }
      }
      parseSmartPipelineBodyInStyle(childExpr, startLoc) {
        if (this.isSimpleReference(childExpr)) {
          const bodyNode = this.startNodeAt(startLoc);
          bodyNode.callee = childExpr;
          return this.finishNode(bodyNode, "PipelineBareFunction");
        } else {
          const bodyNode = this.startNodeAt(startLoc);
          this.checkSmartPipeTopicBodyEarlyErrors(startLoc);
          bodyNode.expression = childExpr;
          return this.finishNode(bodyNode, "PipelineTopicExpression");
        }
      }
      isSimpleReference(expression) {
        switch (expression.type) {
          case "MemberExpression":
            return !expression.computed && this.isSimpleReference(expression.object);
          case "Identifier":
            return true;
          default:
            return false;
        }
      }
      checkSmartPipeTopicBodyEarlyErrors(startLoc) {
        if (this.match(19)) {
          throw this.raise(Errors.PipelineBodyNoArrow, this.state.startLoc);
        }
        if (!this.topicReferenceWasUsedInCurrentContext()) {
          this.raise(Errors.PipelineTopicUnused, startLoc);
        }
      }
      withTopicBindingContext(callback) {
        const outerContextTopicState = this.state.topicContext;
        this.state.topicContext = {
          maxNumOfResolvableTopics: 1,
          maxTopicIndex: null
        };
        try {
          return callback();
        } finally {
          this.state.topicContext = outerContextTopicState;
        }
      }
      withSmartMixTopicForbiddingContext(callback) {
        if (this.hasPlugin(["pipelineOperator", {
          proposal: "smart"
        }])) {
          const outerContextTopicState = this.state.topicContext;
          this.state.topicContext = {
            maxNumOfResolvableTopics: 0,
            maxTopicIndex: null
          };
          try {
            return callback();
          } finally {
            this.state.topicContext = outerContextTopicState;
          }
        } else {
          return callback();
        }
      }
      withSoloAwaitPermittingContext(callback) {
        const outerContextSoloAwaitState = this.state.soloAwait;
        this.state.soloAwait = true;
        try {
          return callback();
        } finally {
          this.state.soloAwait = outerContextSoloAwaitState;
        }
      }
      allowInAnd(callback) {
        const flags = this.prodParam.currentFlags();
        const prodParamToSet = 8 & ~flags;
        if (prodParamToSet) {
          this.prodParam.enter(flags | 8);
          try {
            return callback();
          } finally {
            this.prodParam.exit();
          }
        }
        return callback();
      }
      disallowInAnd(callback) {
        const flags = this.prodParam.currentFlags();
        const prodParamToClear = 8 & flags;
        if (prodParamToClear) {
          this.prodParam.enter(flags & ~8);
          try {
            return callback();
          } finally {
            this.prodParam.exit();
          }
        }
        return callback();
      }
      registerTopicReference() {
        this.state.topicContext.maxTopicIndex = 0;
      }
      topicReferenceIsAllowedInCurrentContext() {
        return this.state.topicContext.maxNumOfResolvableTopics >= 1;
      }
      topicReferenceWasUsedInCurrentContext() {
        return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
      }
      parseFSharpPipelineBody(prec) {
        const startLoc = this.state.startLoc;
        this.state.potentialArrowAt = this.state.start;
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = true;
        const ret = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, prec);
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        return ret;
      }
      parseModuleExpression() {
        this.expectPlugin("moduleBlocks");
        const node = this.startNode();
        this.next();
        if (!this.match(5)) {
          this.unexpected(null, 5);
        }
        const program = this.startNodeAt(this.state.endLoc);
        this.next();
        const revertScopes = this.initializeScopes(true);
        this.enterInitialScopes();
        try {
          node.body = this.parseProgram(program, 8, "module");
        } finally {
          revertScopes();
        }
        return this.finishNode(node, "ModuleExpression");
      }
      parsePropertyNamePrefixOperator(prop) {
      }
    };
    var loopLabel = {
      kind: 1
    };
    var switchLabel = {
      kind: 2
    };
    var loneSurrogate = /[\uD800-\uDFFF]/u;
    var keywordRelationalOperator = /in(?:stanceof)?/y;
    function babel7CompatTokens(tokens, input, startIndex) {
      for (let i = 0; i < tokens.length; i++) {
        const token2 = tokens[i];
        const {
          type
        } = token2;
        if (typeof type === "number") {
          {
            if (type === 139) {
              const {
                loc,
                start,
                value,
                end
              } = token2;
              const hashEndPos = start + 1;
              const hashEndLoc = createPositionWithColumnOffset(loc.start, 1);
              tokens.splice(i, 1, new Token({
                type: getExportedToken(27),
                value: "#",
                start,
                end: hashEndPos,
                startLoc: loc.start,
                endLoc: hashEndLoc
              }), new Token({
                type: getExportedToken(132),
                value,
                start: hashEndPos,
                end,
                startLoc: hashEndLoc,
                endLoc: loc.end
              }));
              i++;
              continue;
            }
            if (tokenIsTemplate(type)) {
              const {
                loc,
                start,
                value,
                end
              } = token2;
              const backquoteEnd = start + 1;
              const backquoteEndLoc = createPositionWithColumnOffset(loc.start, 1);
              let startToken;
              if (input.charCodeAt(start - startIndex) === 96) {
                startToken = new Token({
                  type: getExportedToken(22),
                  value: "`",
                  start,
                  end: backquoteEnd,
                  startLoc: loc.start,
                  endLoc: backquoteEndLoc
                });
              } else {
                startToken = new Token({
                  type: getExportedToken(8),
                  value: "}",
                  start,
                  end: backquoteEnd,
                  startLoc: loc.start,
                  endLoc: backquoteEndLoc
                });
              }
              let templateValue, templateElementEnd, templateElementEndLoc, endToken;
              if (type === 24) {
                templateElementEnd = end - 1;
                templateElementEndLoc = createPositionWithColumnOffset(loc.end, -1);
                templateValue = value === null ? null : value.slice(1, -1);
                endToken = new Token({
                  type: getExportedToken(22),
                  value: "`",
                  start: templateElementEnd,
                  end,
                  startLoc: templateElementEndLoc,
                  endLoc: loc.end
                });
              } else {
                templateElementEnd = end - 2;
                templateElementEndLoc = createPositionWithColumnOffset(loc.end, -2);
                templateValue = value === null ? null : value.slice(1, -2);
                endToken = new Token({
                  type: getExportedToken(23),
                  value: "${",
                  start: templateElementEnd,
                  end,
                  startLoc: templateElementEndLoc,
                  endLoc: loc.end
                });
              }
              tokens.splice(i, 1, startToken, new Token({
                type: getExportedToken(20),
                value: templateValue,
                start: backquoteEnd,
                end: templateElementEnd,
                startLoc: backquoteEndLoc,
                endLoc: templateElementEndLoc
              }), endToken);
              i += 2;
              continue;
            }
          }
          token2.type = getExportedToken(type);
        }
      }
      return tokens;
    }
    var StatementParser = class extends ExpressionParser {
      parseTopLevel(file, program) {
        file.program = this.parseProgram(program);
        file.comments = this.comments;
        if (this.optionFlags & 256) {
          file.tokens = babel7CompatTokens(this.tokens, this.input, this.startIndex);
        }
        return this.finishNode(file, "File");
      }
      parseProgram(program, end = 140, sourceType = this.options.sourceType) {
        program.sourceType = sourceType;
        program.interpreter = this.parseInterpreterDirective();
        this.parseBlockBody(program, true, true, end);
        if (this.inModule) {
          if (!(this.optionFlags & 64) && this.scope.undefinedExports.size > 0) {
            for (const [localName, at] of Array.from(this.scope.undefinedExports)) {
              this.raise(Errors.ModuleExportUndefined, at, {
                localName
              });
            }
          }
          this.addExtra(program, "topLevelAwait", this.state.hasTopLevelAwait);
        }
        let finishedProgram;
        if (end === 140) {
          finishedProgram = this.finishNode(program, "Program");
        } else {
          finishedProgram = this.finishNodeAt(program, "Program", createPositionWithColumnOffset(this.state.startLoc, -1));
        }
        return finishedProgram;
      }
      stmtToDirective(stmt) {
        const directive2 = stmt;
        directive2.type = "Directive";
        directive2.value = directive2.expression;
        delete directive2.expression;
        const directiveLiteral2 = directive2.value;
        const expressionValue = directiveLiteral2.value;
        const raw = this.input.slice(this.offsetToSourcePos(directiveLiteral2.start), this.offsetToSourcePos(directiveLiteral2.end));
        const val = directiveLiteral2.value = raw.slice(1, -1);
        this.addExtra(directiveLiteral2, "raw", raw);
        this.addExtra(directiveLiteral2, "rawValue", val);
        this.addExtra(directiveLiteral2, "expressionValue", expressionValue);
        directiveLiteral2.type = "DirectiveLiteral";
        return directive2;
      }
      parseInterpreterDirective() {
        if (!this.match(28)) {
          return null;
        }
        const node = this.startNode();
        node.value = this.state.value;
        this.next();
        return this.finishNode(node, "InterpreterDirective");
      }
      isLet() {
        if (!this.isContextual(100)) {
          return false;
        }
        return this.hasFollowingBindingAtom();
      }
      chStartsBindingIdentifier(ch, pos2) {
        if (isIdentifierStart(ch)) {
          keywordRelationalOperator.lastIndex = pos2;
          if (keywordRelationalOperator.test(this.input)) {
            const endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);
            if (!isIdentifierChar(endCh) && endCh !== 92) {
              return false;
            }
          }
          return true;
        } else if (ch === 92) {
          return true;
        } else {
          return false;
        }
      }
      chStartsBindingPattern(ch) {
        return ch === 91 || ch === 123;
      }
      hasFollowingBindingAtom() {
        const next = this.nextTokenStart();
        const nextCh = this.codePointAtPos(next);
        return this.chStartsBindingPattern(nextCh) || this.chStartsBindingIdentifier(nextCh, next);
      }
      hasInLineFollowingBindingIdentifierOrBrace() {
        const next = this.nextTokenInLineStart();
        const nextCh = this.codePointAtPos(next);
        return nextCh === 123 || this.chStartsBindingIdentifier(nextCh, next);
      }
      startsUsingForOf() {
        const {
          type,
          containsEsc
        } = this.lookahead();
        if (type === 102 && !containsEsc) {
          return false;
        } else if (tokenIsIdentifier(type) && !this.hasFollowingLineBreak()) {
          this.expectPlugin("explicitResourceManagement");
          return true;
        }
      }
      startsAwaitUsing() {
        let next = this.nextTokenInLineStart();
        if (this.isUnparsedContextual(next, "using")) {
          next = this.nextTokenInLineStartSince(next + 5);
          const nextCh = this.codePointAtPos(next);
          if (this.chStartsBindingIdentifier(nextCh, next)) {
            this.expectPlugin("explicitResourceManagement");
            return true;
          }
        }
        return false;
      }
      parseModuleItem() {
        return this.parseStatementLike(1 | 2 | 4 | 8);
      }
      parseStatementListItem() {
        return this.parseStatementLike(2 | 4 | (!this.options.annexB || this.state.strict ? 0 : 8));
      }
      parseStatementOrSloppyAnnexBFunctionDeclaration(allowLabeledFunction = false) {
        let flags = 0;
        if (this.options.annexB && !this.state.strict) {
          flags |= 4;
          if (allowLabeledFunction) {
            flags |= 8;
          }
        }
        return this.parseStatementLike(flags);
      }
      parseStatement() {
        return this.parseStatementLike(0);
      }
      parseStatementLike(flags) {
        let decorators = null;
        if (this.match(26)) {
          decorators = this.parseDecorators(true);
        }
        return this.parseStatementContent(flags, decorators);
      }
      parseStatementContent(flags, decorators) {
        const startType = this.state.type;
        const node = this.startNode();
        const allowDeclaration = !!(flags & 2);
        const allowFunctionDeclaration = !!(flags & 4);
        const topLevel = flags & 1;
        switch (startType) {
          case 60:
            return this.parseBreakContinueStatement(node, true);
          case 63:
            return this.parseBreakContinueStatement(node, false);
          case 64:
            return this.parseDebuggerStatement(node);
          case 90:
            return this.parseDoWhileStatement(node);
          case 91:
            return this.parseForStatement(node);
          case 68:
            if (this.lookaheadCharCode() === 46) break;
            if (!allowFunctionDeclaration) {
              this.raise(this.state.strict ? Errors.StrictFunction : this.options.annexB ? Errors.SloppyFunctionAnnexB : Errors.SloppyFunction, this.state.startLoc);
            }
            return this.parseFunctionStatement(node, false, !allowDeclaration && allowFunctionDeclaration);
          case 80:
            if (!allowDeclaration) this.unexpected();
            return this.parseClass(this.maybeTakeDecorators(decorators, node), true);
          case 69:
            return this.parseIfStatement(node);
          case 70:
            return this.parseReturnStatement(node);
          case 71:
            return this.parseSwitchStatement(node);
          case 72:
            return this.parseThrowStatement(node);
          case 73:
            return this.parseTryStatement(node);
          case 96:
            if (!this.state.containsEsc && this.startsAwaitUsing()) {
              if (!this.recordAwaitIfAllowed()) {
                this.raise(Errors.AwaitUsingNotInAsyncContext, node);
              } else if (!allowDeclaration) {
                this.raise(Errors.UnexpectedLexicalDeclaration, node);
              }
              this.next();
              return this.parseVarStatement(node, "await using");
            }
            break;
          case 107:
            if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifierOrBrace()) {
              break;
            }
            this.expectPlugin("explicitResourceManagement");
            if (!this.scope.inModule && this.scope.inTopLevel) {
              this.raise(Errors.UnexpectedUsingDeclaration, this.state.startLoc);
            } else if (!allowDeclaration) {
              this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc);
            }
            return this.parseVarStatement(node, "using");
          case 100: {
            if (this.state.containsEsc) {
              break;
            }
            const next = this.nextTokenStart();
            const nextCh = this.codePointAtPos(next);
            if (nextCh !== 91) {
              if (!allowDeclaration && this.hasFollowingLineBreak()) break;
              if (!this.chStartsBindingIdentifier(nextCh, next) && nextCh !== 123) {
                break;
              }
            }
          }
          case 75: {
            if (!allowDeclaration) {
              this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc);
            }
          }
          case 74: {
            const kind = this.state.value;
            return this.parseVarStatement(node, kind);
          }
          case 92:
            return this.parseWhileStatement(node);
          case 76:
            return this.parseWithStatement(node);
          case 5:
            return this.parseBlock();
          case 13:
            return this.parseEmptyStatement(node);
          case 83: {
            const nextTokenCharCode = this.lookaheadCharCode();
            if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {
              break;
            }
          }
          case 82: {
            if (!(this.optionFlags & 8) && !topLevel) {
              this.raise(Errors.UnexpectedImportExport, this.state.startLoc);
            }
            this.next();
            let result;
            if (startType === 83) {
              result = this.parseImport(node);
            } else {
              result = this.parseExport(node, decorators);
            }
            this.assertModuleNodeAllowed(result);
            return result;
          }
          default: {
            if (this.isAsyncFunction()) {
              if (!allowDeclaration) {
                this.raise(Errors.AsyncFunctionInSingleStatementContext, this.state.startLoc);
              }
              this.next();
              return this.parseFunctionStatement(node, true, !allowDeclaration && allowFunctionDeclaration);
            }
          }
        }
        const maybeName = this.state.value;
        const expr = this.parseExpression();
        if (tokenIsIdentifier(startType) && expr.type === "Identifier" && this.eat(14)) {
          return this.parseLabeledStatement(node, maybeName, expr, flags);
        } else {
          return this.parseExpressionStatement(node, expr, decorators);
        }
      }
      assertModuleNodeAllowed(node) {
        if (!(this.optionFlags & 8) && !this.inModule) {
          this.raise(Errors.ImportOutsideModule, node);
        }
      }
      decoratorsEnabledBeforeExport() {
        if (this.hasPlugin("decorators-legacy")) return true;
        return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") !== false;
      }
      maybeTakeDecorators(maybeDecorators, classNode, exportNode) {
        if (maybeDecorators) {
          var _classNode$decorators;
          if ((_classNode$decorators = classNode.decorators) != null && _classNode$decorators.length) {
            if (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") !== "boolean") {
              this.raise(Errors.DecoratorsBeforeAfterExport, classNode.decorators[0]);
            }
            classNode.decorators.unshift(...maybeDecorators);
          } else {
            classNode.decorators = maybeDecorators;
          }
          this.resetStartLocationFromNode(classNode, maybeDecorators[0]);
          if (exportNode) this.resetStartLocationFromNode(exportNode, classNode);
        }
        return classNode;
      }
      canHaveLeadingDecorator() {
        return this.match(80);
      }
      parseDecorators(allowExport) {
        const decorators = [];
        do {
          decorators.push(this.parseDecorator());
        } while (this.match(26));
        if (this.match(82)) {
          if (!allowExport) {
            this.unexpected();
          }
          if (!this.decoratorsEnabledBeforeExport()) {
            this.raise(Errors.DecoratorExportClass, this.state.startLoc);
          }
        } else if (!this.canHaveLeadingDecorator()) {
          throw this.raise(Errors.UnexpectedLeadingDecorator, this.state.startLoc);
        }
        return decorators;
      }
      parseDecorator() {
        this.expectOnePlugin(["decorators", "decorators-legacy"]);
        const node = this.startNode();
        this.next();
        if (this.hasPlugin("decorators")) {
          const startLoc = this.state.startLoc;
          let expr;
          if (this.match(10)) {
            const startLoc2 = this.state.startLoc;
            this.next();
            expr = this.parseExpression();
            this.expect(11);
            expr = this.wrapParenthesis(startLoc2, expr);
            const paramsStartLoc = this.state.startLoc;
            node.expression = this.parseMaybeDecoratorArguments(expr, startLoc2);
            if (this.getPluginOption("decorators", "allowCallParenthesized") === false && node.expression !== expr) {
              this.raise(Errors.DecoratorArgumentsOutsideParentheses, paramsStartLoc);
            }
          } else {
            expr = this.parseIdentifier(false);
            while (this.eat(16)) {
              const node2 = this.startNodeAt(startLoc);
              node2.object = expr;
              if (this.match(139)) {
                this.classScope.usePrivateName(this.state.value, this.state.startLoc);
                node2.property = this.parsePrivateName();
              } else {
                node2.property = this.parseIdentifier(true);
              }
              node2.computed = false;
              expr = this.finishNode(node2, "MemberExpression");
            }
            node.expression = this.parseMaybeDecoratorArguments(expr, startLoc);
          }
        } else {
          node.expression = this.parseExprSubscripts();
        }
        return this.finishNode(node, "Decorator");
      }
      parseMaybeDecoratorArguments(expr, startLoc) {
        if (this.eat(10)) {
          const node = this.startNodeAt(startLoc);
          node.callee = expr;
          node.arguments = this.parseCallExpressionArguments(11);
          this.toReferencedList(node.arguments);
          return this.finishNode(node, "CallExpression");
        }
        return expr;
      }
      parseBreakContinueStatement(node, isBreak) {
        this.next();
        if (this.isLineTerminator()) {
          node.label = null;
        } else {
          node.label = this.parseIdentifier();
          this.semicolon();
        }
        this.verifyBreakContinue(node, isBreak);
        return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
      }
      verifyBreakContinue(node, isBreak) {
        let i;
        for (i = 0; i < this.state.labels.length; ++i) {
          const lab = this.state.labels[i];
          if (node.label == null || lab.name === node.label.name) {
            if (lab.kind != null && (isBreak || lab.kind === 1)) {
              break;
            }
            if (node.label && isBreak) break;
          }
        }
        if (i === this.state.labels.length) {
          const type = isBreak ? "BreakStatement" : "ContinueStatement";
          this.raise(Errors.IllegalBreakContinue, node, {
            type
          });
        }
      }
      parseDebuggerStatement(node) {
        this.next();
        this.semicolon();
        return this.finishNode(node, "DebuggerStatement");
      }
      parseHeaderExpression() {
        this.expect(10);
        const val = this.parseExpression();
        this.expect(11);
        return val;
      }
      parseDoWhileStatement(node) {
        this.next();
        this.state.labels.push(loopLabel);
        node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
        this.state.labels.pop();
        this.expect(92);
        node.test = this.parseHeaderExpression();
        this.eat(13);
        return this.finishNode(node, "DoWhileStatement");
      }
      parseForStatement(node) {
        this.next();
        this.state.labels.push(loopLabel);
        let awaitAt = null;
        if (this.isContextual(96) && this.recordAwaitIfAllowed()) {
          awaitAt = this.state.startLoc;
          this.next();
        }
        this.scope.enter(0);
        this.expect(10);
        if (this.match(13)) {
          if (awaitAt !== null) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node, null);
        }
        const startsWithLet = this.isContextual(100);
        {
          const startsWithAwaitUsing = this.isContextual(96) && this.startsAwaitUsing();
          const starsWithUsingDeclaration = startsWithAwaitUsing || this.isContextual(107) && this.startsUsingForOf();
          const isLetOrUsing = startsWithLet && this.hasFollowingBindingAtom() || starsWithUsingDeclaration;
          if (this.match(74) || this.match(75) || isLetOrUsing) {
            const initNode = this.startNode();
            let kind;
            if (startsWithAwaitUsing) {
              kind = "await using";
              if (!this.recordAwaitIfAllowed()) {
                this.raise(Errors.AwaitUsingNotInAsyncContext, this.state.startLoc);
              }
              this.next();
            } else {
              kind = this.state.value;
            }
            this.next();
            this.parseVar(initNode, true, kind);
            const init2 = this.finishNode(initNode, "VariableDeclaration");
            const isForIn = this.match(58);
            if (isForIn && starsWithUsingDeclaration) {
              this.raise(Errors.ForInUsing, init2);
            }
            if ((isForIn || this.isContextual(102)) && init2.declarations.length === 1) {
              return this.parseForIn(node, init2, awaitAt);
            }
            if (awaitAt !== null) {
              this.unexpected(awaitAt);
            }
            return this.parseFor(node, init2);
          }
        }
        const startsWithAsync = this.isContextual(95);
        const refExpressionErrors = new ExpressionErrors();
        const init = this.parseExpression(true, refExpressionErrors);
        const isForOf = this.isContextual(102);
        if (isForOf) {
          if (startsWithLet) {
            this.raise(Errors.ForOfLet, init);
          }
          if (awaitAt === null && startsWithAsync && init.type === "Identifier") {
            this.raise(Errors.ForOfAsync, init);
          }
        }
        if (isForOf || this.match(58)) {
          this.checkDestructuringPrivate(refExpressionErrors);
          this.toAssignable(init, true);
          const type = isForOf ? "ForOfStatement" : "ForInStatement";
          this.checkLVal(init, {
            type
          });
          return this.parseForIn(node, init, awaitAt);
        } else {
          this.checkExpressionErrors(refExpressionErrors, true);
        }
        if (awaitAt !== null) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node, init);
      }
      parseFunctionStatement(node, isAsync2, isHangingDeclaration) {
        this.next();
        return this.parseFunction(node, 1 | (isHangingDeclaration ? 2 : 0) | (isAsync2 ? 8 : 0));
      }
      parseIfStatement(node) {
        this.next();
        node.test = this.parseHeaderExpression();
        node.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration();
        node.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null;
        return this.finishNode(node, "IfStatement");
      }
      parseReturnStatement(node) {
        if (!this.prodParam.hasReturn && !(this.optionFlags & 2)) {
          this.raise(Errors.IllegalReturn, this.state.startLoc);
        }
        this.next();
        if (this.isLineTerminator()) {
          node.argument = null;
        } else {
          node.argument = this.parseExpression();
          this.semicolon();
        }
        return this.finishNode(node, "ReturnStatement");
      }
      parseSwitchStatement(node) {
        this.next();
        node.discriminant = this.parseHeaderExpression();
        const cases = node.cases = [];
        this.expect(5);
        this.state.labels.push(switchLabel);
        this.scope.enter(0);
        let cur;
        for (let sawDefault; !this.match(8); ) {
          if (this.match(61) || this.match(65)) {
            const isCase = this.match(61);
            if (cur) this.finishNode(cur, "SwitchCase");
            cases.push(cur = this.startNode());
            cur.consequent = [];
            this.next();
            if (isCase) {
              cur.test = this.parseExpression();
            } else {
              if (sawDefault) {
                this.raise(Errors.MultipleDefaultsInSwitch, this.state.lastTokStartLoc);
              }
              sawDefault = true;
              cur.test = null;
            }
            this.expect(14);
          } else {
            if (cur) {
              cur.consequent.push(this.parseStatementListItem());
            } else {
              this.unexpected();
            }
          }
        }
        this.scope.exit();
        if (cur) this.finishNode(cur, "SwitchCase");
        this.next();
        this.state.labels.pop();
        return this.finishNode(node, "SwitchStatement");
      }
      parseThrowStatement(node) {
        this.next();
        if (this.hasPrecedingLineBreak()) {
          this.raise(Errors.NewlineAfterThrow, this.state.lastTokEndLoc);
        }
        node.argument = this.parseExpression();
        this.semicolon();
        return this.finishNode(node, "ThrowStatement");
      }
      parseCatchClauseParam() {
        const param = this.parseBindingAtom();
        this.scope.enter(this.options.annexB && param.type === "Identifier" ? 8 : 0);
        this.checkLVal(param, {
          type: "CatchClause"
        }, 9);
        return param;
      }
      parseTryStatement(node) {
        this.next();
        node.block = this.parseBlock();
        node.handler = null;
        if (this.match(62)) {
          const clause = this.startNode();
          this.next();
          if (this.match(10)) {
            this.expect(10);
            clause.param = this.parseCatchClauseParam();
            this.expect(11);
          } else {
            clause.param = null;
            this.scope.enter(0);
          }
          clause.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false));
          this.scope.exit();
          node.handler = this.finishNode(clause, "CatchClause");
        }
        node.finalizer = this.eat(67) ? this.parseBlock() : null;
        if (!node.handler && !node.finalizer) {
          this.raise(Errors.NoCatchOrFinally, node);
        }
        return this.finishNode(node, "TryStatement");
      }
      parseVarStatement(node, kind, allowMissingInitializer = false) {
        this.next();
        this.parseVar(node, false, kind, allowMissingInitializer);
        this.semicolon();
        return this.finishNode(node, "VariableDeclaration");
      }
      parseWhileStatement(node) {
        this.next();
        node.test = this.parseHeaderExpression();
        this.state.labels.push(loopLabel);
        node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
        this.state.labels.pop();
        return this.finishNode(node, "WhileStatement");
      }
      parseWithStatement(node) {
        if (this.state.strict) {
          this.raise(Errors.StrictWith, this.state.startLoc);
        }
        this.next();
        node.object = this.parseHeaderExpression();
        node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
        return this.finishNode(node, "WithStatement");
      }
      parseEmptyStatement(node) {
        this.next();
        return this.finishNode(node, "EmptyStatement");
      }
      parseLabeledStatement(node, maybeName, expr, flags) {
        for (const label of this.state.labels) {
          if (label.name === maybeName) {
            this.raise(Errors.LabelRedeclaration, expr, {
              labelName: maybeName
            });
          }
        }
        const kind = tokenIsLoop(this.state.type) ? 1 : this.match(71) ? 2 : null;
        for (let i = this.state.labels.length - 1; i >= 0; i--) {
          const label = this.state.labels[i];
          if (label.statementStart === node.start) {
            label.statementStart = this.sourceToOffsetPos(this.state.start);
            label.kind = kind;
          } else {
            break;
          }
        }
        this.state.labels.push({
          name: maybeName,
          kind,
          statementStart: this.sourceToOffsetPos(this.state.start)
        });
        node.body = flags & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(true) : this.parseStatement();
        this.state.labels.pop();
        node.label = expr;
        return this.finishNode(node, "LabeledStatement");
      }
      parseExpressionStatement(node, expr, decorators) {
        node.expression = expr;
        this.semicolon();
        return this.finishNode(node, "ExpressionStatement");
      }
      parseBlock(allowDirectives = false, createNewLexicalScope = true, afterBlockParse) {
        const node = this.startNode();
        if (allowDirectives) {
          this.state.strictErrors.clear();
        }
        this.expect(5);
        if (createNewLexicalScope) {
          this.scope.enter(0);
        }
        this.parseBlockBody(node, allowDirectives, false, 8, afterBlockParse);
        if (createNewLexicalScope) {
          this.scope.exit();
        }
        return this.finishNode(node, "BlockStatement");
      }
      isValidDirective(stmt) {
        return stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized;
      }
      parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
        const body = node.body = [];
        const directives = node.directives = [];
        this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : void 0, topLevel, end, afterBlockParse);
      }
      parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {
        const oldStrict = this.state.strict;
        let hasStrictModeDirective = false;
        let parsedNonDirective = false;
        while (!this.match(end)) {
          const stmt = topLevel ? this.parseModuleItem() : this.parseStatementListItem();
          if (directives && !parsedNonDirective) {
            if (this.isValidDirective(stmt)) {
              const directive2 = this.stmtToDirective(stmt);
              directives.push(directive2);
              if (!hasStrictModeDirective && directive2.value.value === "use strict") {
                hasStrictModeDirective = true;
                this.setStrict(true);
              }
              continue;
            }
            parsedNonDirective = true;
            this.state.strictErrors.clear();
          }
          body.push(stmt);
        }
        afterBlockParse == null || afterBlockParse.call(this, hasStrictModeDirective);
        if (!oldStrict) {
          this.setStrict(false);
        }
        this.next();
      }
      parseFor(node, init) {
        node.init = init;
        this.semicolon(false);
        node.test = this.match(13) ? null : this.parseExpression();
        this.semicolon(false);
        node.update = this.match(11) ? null : this.parseExpression();
        this.expect(11);
        node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
        this.scope.exit();
        this.state.labels.pop();
        return this.finishNode(node, "ForStatement");
      }
      parseForIn(node, init, awaitAt) {
        const isForIn = this.match(58);
        this.next();
        if (isForIn) {
          if (awaitAt !== null) this.unexpected(awaitAt);
        } else {
          node.await = awaitAt !== null;
        }
        if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || !this.options.annexB || this.state.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
          this.raise(Errors.ForInOfLoopInitializer, init, {
            type: isForIn ? "ForInStatement" : "ForOfStatement"
          });
        }
        if (init.type === "AssignmentPattern") {
          this.raise(Errors.InvalidLhs, init, {
            ancestor: {
              type: "ForStatement"
            }
          });
        }
        node.left = init;
        node.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();
        this.expect(11);
        node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
        this.scope.exit();
        this.state.labels.pop();
        return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
      }
      parseVar(node, isFor, kind, allowMissingInitializer = false) {
        const declarations = node.declarations = [];
        node.kind = kind;
        for (; ; ) {
          const decl = this.startNode();
          this.parseVarId(decl, kind);
          decl.init = !this.eat(29) ? null : isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();
          if (decl.init === null && !allowMissingInitializer) {
            if (decl.id.type !== "Identifier" && !(isFor && (this.match(58) || this.isContextual(102)))) {
              this.raise(Errors.DeclarationMissingInitializer, this.state.lastTokEndLoc, {
                kind: "destructuring"
              });
            } else if ((kind === "const" || kind === "using" || kind === "await using") && !(this.match(58) || this.isContextual(102))) {
              this.raise(Errors.DeclarationMissingInitializer, this.state.lastTokEndLoc, {
                kind
              });
            }
          }
          declarations.push(this.finishNode(decl, "VariableDeclarator"));
          if (!this.eat(12)) break;
        }
        return node;
      }
      parseVarId(decl, kind) {
        const id = this.parseBindingAtom();
        if (kind === "using" || kind === "await using") {
          if (id.type === "ArrayPattern" || id.type === "ObjectPattern") {
            this.raise(Errors.UsingDeclarationHasBindingPattern, id.loc.start);
          }
        }
        this.checkLVal(id, {
          type: "VariableDeclarator"
        }, kind === "var" ? 5 : 8201);
        decl.id = id;
      }
      parseAsyncFunctionExpression(node) {
        return this.parseFunction(node, 8);
      }
      parseFunction(node, flags = 0) {
        const hangingDeclaration = flags & 2;
        const isDeclaration = !!(flags & 1);
        const requireId = isDeclaration && !(flags & 4);
        const isAsync2 = !!(flags & 8);
        this.initFunction(node, isAsync2);
        if (this.match(55)) {
          if (hangingDeclaration) {
            this.raise(Errors.GeneratorInSingleStatementContext, this.state.startLoc);
          }
          this.next();
          node.generator = true;
        }
        if (isDeclaration) {
          node.id = this.parseFunctionId(requireId);
        }
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        this.state.maybeInArrowParameters = false;
        this.scope.enter(2);
        this.prodParam.enter(functionFlags(isAsync2, node.generator));
        if (!isDeclaration) {
          node.id = this.parseFunctionId();
        }
        this.parseFunctionParams(node, false);
        this.withSmartMixTopicForbiddingContext(() => {
          this.parseFunctionBodyAndFinish(node, isDeclaration ? "FunctionDeclaration" : "FunctionExpression");
        });
        this.prodParam.exit();
        this.scope.exit();
        if (isDeclaration && !hangingDeclaration) {
          this.registerFunctionStatementId(node);
        }
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        return node;
      }
      parseFunctionId(requireId) {
        return requireId || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null;
      }
      parseFunctionParams(node, isConstructor) {
        this.expect(10);
        this.expressionScope.enter(newParameterDeclarationScope());
        node.params = this.parseBindingList(11, 41, 2 | (isConstructor ? 4 : 0));
        this.expressionScope.exit();
      }
      registerFunctionStatementId(node) {
        if (!node.id) return;
        this.scope.declareName(node.id.name, !this.options.annexB || this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, node.id.loc.start);
      }
      parseClass(node, isStatement2, optionalId) {
        this.next();
        const oldStrict = this.state.strict;
        this.state.strict = true;
        this.parseClassId(node, isStatement2, optionalId);
        this.parseClassSuper(node);
        node.body = this.parseClassBody(!!node.superClass, oldStrict);
        return this.finishNode(node, isStatement2 ? "ClassDeclaration" : "ClassExpression");
      }
      isClassProperty() {
        return this.match(29) || this.match(13) || this.match(8);
      }
      isClassMethod() {
        return this.match(10);
      }
      nameIsConstructor(key2) {
        return key2.type === "Identifier" && key2.name === "constructor" || key2.type === "StringLiteral" && key2.value === "constructor";
      }
      isNonstaticConstructor(method) {
        return !method.computed && !method.static && this.nameIsConstructor(method.key);
      }
      parseClassBody(hadSuperClass, oldStrict) {
        this.classScope.enter();
        const state = {
          hadConstructor: false,
          hadSuperClass
        };
        let decorators = [];
        const classBody = this.startNode();
        classBody.body = [];
        this.expect(5);
        this.withSmartMixTopicForbiddingContext(() => {
          while (!this.match(8)) {
            if (this.eat(13)) {
              if (decorators.length > 0) {
                throw this.raise(Errors.DecoratorSemicolon, this.state.lastTokEndLoc);
              }
              continue;
            }
            if (this.match(26)) {
              decorators.push(this.parseDecorator());
              continue;
            }
            const member = this.startNode();
            if (decorators.length) {
              member.decorators = decorators;
              this.resetStartLocationFromNode(member, decorators[0]);
              decorators = [];
            }
            this.parseClassMember(classBody, member, state);
            if (member.kind === "constructor" && member.decorators && member.decorators.length > 0) {
              this.raise(Errors.DecoratorConstructor, member);
            }
          }
        });
        this.state.strict = oldStrict;
        this.next();
        if (decorators.length) {
          throw this.raise(Errors.TrailingDecorator, this.state.startLoc);
        }
        this.classScope.exit();
        return this.finishNode(classBody, "ClassBody");
      }
      parseClassMemberFromModifier(classBody, member) {
        const key2 = this.parseIdentifier(true);
        if (this.isClassMethod()) {
          const method = member;
          method.kind = "method";
          method.computed = false;
          method.key = key2;
          method.static = false;
          this.pushClassMethod(classBody, method, false, false, false, false);
          return true;
        } else if (this.isClassProperty()) {
          const prop = member;
          prop.computed = false;
          prop.key = key2;
          prop.static = false;
          classBody.body.push(this.parseClassProperty(prop));
          return true;
        }
        this.resetPreviousNodeTrailingComments(key2);
        return false;
      }
      parseClassMember(classBody, member, state) {
        const isStatic = this.isContextual(106);
        if (isStatic) {
          if (this.parseClassMemberFromModifier(classBody, member)) {
            return;
          }
          if (this.eat(5)) {
            this.parseClassStaticBlock(classBody, member);
            return;
          }
        }
        this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
      }
      parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
        const publicMethod = member;
        const privateMethod = member;
        const publicProp = member;
        const privateProp = member;
        const accessorProp = member;
        const method = publicMethod;
        const publicMember = publicMethod;
        member.static = isStatic;
        this.parsePropertyNamePrefixOperator(member);
        if (this.eat(55)) {
          method.kind = "method";
          const isPrivateName = this.match(139);
          this.parseClassElementName(method);
          if (isPrivateName) {
            this.pushClassPrivateMethod(classBody, privateMethod, true, false);
            return;
          }
          if (this.isNonstaticConstructor(publicMethod)) {
            this.raise(Errors.ConstructorIsGenerator, publicMethod.key);
          }
          this.pushClassMethod(classBody, publicMethod, true, false, false, false);
          return;
        }
        const isContextual = !this.state.containsEsc && tokenIsIdentifier(this.state.type);
        const key2 = this.parseClassElementName(member);
        const maybeContextualKw = isContextual ? key2.name : null;
        const isPrivate = this.isPrivateName(key2);
        const maybeQuestionTokenStartLoc = this.state.startLoc;
        this.parsePostMemberNameModifiers(publicMember);
        if (this.isClassMethod()) {
          method.kind = "method";
          if (isPrivate) {
            this.pushClassPrivateMethod(classBody, privateMethod, false, false);
            return;
          }
          const isConstructor = this.isNonstaticConstructor(publicMethod);
          let allowsDirectSuper = false;
          if (isConstructor) {
            publicMethod.kind = "constructor";
            if (state.hadConstructor && !this.hasPlugin("typescript")) {
              this.raise(Errors.DuplicateConstructor, key2);
            }
            if (isConstructor && this.hasPlugin("typescript") && member.override) {
              this.raise(Errors.OverrideOnConstructor, key2);
            }
            state.hadConstructor = true;
            allowsDirectSuper = state.hadSuperClass;
          }
          this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);
        } else if (this.isClassProperty()) {
          if (isPrivate) {
            this.pushClassPrivateProperty(classBody, privateProp);
          } else {
            this.pushClassProperty(classBody, publicProp);
          }
        } else if (maybeContextualKw === "async" && !this.isLineTerminator()) {
          this.resetPreviousNodeTrailingComments(key2);
          const isGenerator = this.eat(55);
          if (publicMember.optional) {
            this.unexpected(maybeQuestionTokenStartLoc);
          }
          method.kind = "method";
          const isPrivate2 = this.match(139);
          this.parseClassElementName(method);
          this.parsePostMemberNameModifiers(publicMember);
          if (isPrivate2) {
            this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);
          } else {
            if (this.isNonstaticConstructor(publicMethod)) {
              this.raise(Errors.ConstructorIsAsync, publicMethod.key);
            }
            this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);
          }
        } else if ((maybeContextualKw === "get" || maybeContextualKw === "set") && !(this.match(55) && this.isLineTerminator())) {
          this.resetPreviousNodeTrailingComments(key2);
          method.kind = maybeContextualKw;
          const isPrivate2 = this.match(139);
          this.parseClassElementName(publicMethod);
          if (isPrivate2) {
            this.pushClassPrivateMethod(classBody, privateMethod, false, false);
          } else {
            if (this.isNonstaticConstructor(publicMethod)) {
              this.raise(Errors.ConstructorIsAccessor, publicMethod.key);
            }
            this.pushClassMethod(classBody, publicMethod, false, false, false, false);
          }
          this.checkGetterSetterParams(publicMethod);
        } else if (maybeContextualKw === "accessor" && !this.isLineTerminator()) {
          this.expectPlugin("decoratorAutoAccessors");
          this.resetPreviousNodeTrailingComments(key2);
          const isPrivate2 = this.match(139);
          this.parseClassElementName(publicProp);
          this.pushClassAccessorProperty(classBody, accessorProp, isPrivate2);
        } else if (this.isLineTerminator()) {
          if (isPrivate) {
            this.pushClassPrivateProperty(classBody, privateProp);
          } else {
            this.pushClassProperty(classBody, publicProp);
          }
        } else {
          this.unexpected();
        }
      }
      parseClassElementName(member) {
        const {
          type,
          value
        } = this.state;
        if ((type === 132 || type === 134) && member.static && value === "prototype") {
          this.raise(Errors.StaticPrototype, this.state.startLoc);
        }
        if (type === 139) {
          if (value === "constructor") {
            this.raise(Errors.ConstructorClassPrivateField, this.state.startLoc);
          }
          const key2 = this.parsePrivateName();
          member.key = key2;
          return key2;
        }
        this.parsePropertyName(member);
        return member.key;
      }
      parseClassStaticBlock(classBody, member) {
        var _member$decorators;
        this.scope.enter(64 | 128 | 16);
        const oldLabels = this.state.labels;
        this.state.labels = [];
        this.prodParam.enter(0);
        const body = member.body = [];
        this.parseBlockOrModuleBlockBody(body, void 0, false, 8);
        this.prodParam.exit();
        this.scope.exit();
        this.state.labels = oldLabels;
        classBody.body.push(this.finishNode(member, "StaticBlock"));
        if ((_member$decorators = member.decorators) != null && _member$decorators.length) {
          this.raise(Errors.DecoratorStaticBlock, member);
        }
      }
      pushClassProperty(classBody, prop) {
        if (!prop.computed && this.nameIsConstructor(prop.key)) {
          this.raise(Errors.ConstructorClassField, prop.key);
        }
        classBody.body.push(this.parseClassProperty(prop));
      }
      pushClassPrivateProperty(classBody, prop) {
        const node = this.parseClassPrivateProperty(prop);
        classBody.body.push(node);
        this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);
      }
      pushClassAccessorProperty(classBody, prop, isPrivate) {
        if (!isPrivate && !prop.computed && this.nameIsConstructor(prop.key)) {
          this.raise(Errors.ConstructorClassField, prop.key);
        }
        const node = this.parseClassAccessorProperty(prop);
        classBody.body.push(node);
        if (isPrivate) {
          this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);
        }
      }
      pushClassMethod(classBody, method, isGenerator, isAsync2, isConstructor, allowsDirectSuper) {
        classBody.body.push(this.parseMethod(method, isGenerator, isAsync2, isConstructor, allowsDirectSuper, "ClassMethod", true));
      }
      pushClassPrivateMethod(classBody, method, isGenerator, isAsync2) {
        const node = this.parseMethod(method, isGenerator, isAsync2, false, false, "ClassPrivateMethod", true);
        classBody.body.push(node);
        const kind = node.kind === "get" ? node.static ? 6 : 2 : node.kind === "set" ? node.static ? 5 : 1 : 0;
        this.declareClassPrivateMethodInScope(node, kind);
      }
      declareClassPrivateMethodInScope(node, kind) {
        this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), kind, node.key.loc.start);
      }
      parsePostMemberNameModifiers(methodOrProp) {
      }
      parseClassPrivateProperty(node) {
        this.parseInitializer(node);
        this.semicolon();
        return this.finishNode(node, "ClassPrivateProperty");
      }
      parseClassProperty(node) {
        this.parseInitializer(node);
        this.semicolon();
        return this.finishNode(node, "ClassProperty");
      }
      parseClassAccessorProperty(node) {
        this.parseInitializer(node);
        this.semicolon();
        return this.finishNode(node, "ClassAccessorProperty");
      }
      parseInitializer(node) {
        this.scope.enter(64 | 16);
        this.expressionScope.enter(newExpressionScope());
        this.prodParam.enter(0);
        node.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null;
        this.expressionScope.exit();
        this.prodParam.exit();
        this.scope.exit();
      }
      parseClassId(node, isStatement2, optionalId, bindingType = 8331) {
        if (tokenIsIdentifier(this.state.type)) {
          node.id = this.parseIdentifier();
          if (isStatement2) {
            this.declareNameFromIdentifier(node.id, bindingType);
          }
        } else {
          if (optionalId || !isStatement2) {
            node.id = null;
          } else {
            throw this.raise(Errors.MissingClassName, this.state.startLoc);
          }
        }
      }
      parseClassSuper(node) {
        node.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
      }
      parseExport(node, decorators) {
        const maybeDefaultIdentifier = this.parseMaybeImportPhase(node, true);
        const hasDefault = this.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier);
        const parseAfterDefault = !hasDefault || this.eat(12);
        const hasStar = parseAfterDefault && this.eatExportStar(node);
        const hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node);
        const parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(12));
        const isFromRequired = hasDefault || hasStar;
        if (hasStar && !hasNamespace) {
          if (hasDefault) this.unexpected();
          if (decorators) {
            throw this.raise(Errors.UnsupportedDecoratorExport, node);
          }
          this.parseExportFrom(node, true);
          this.sawUnambiguousESM = true;
          return this.finishNode(node, "ExportAllDeclaration");
        }
        const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);
        if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers) {
          this.unexpected(null, 5);
        }
        if (hasNamespace && parseAfterNamespace) {
          this.unexpected(null, 98);
        }
        let hasDeclaration;
        if (isFromRequired || hasSpecifiers) {
          hasDeclaration = false;
          if (decorators) {
            throw this.raise(Errors.UnsupportedDecoratorExport, node);
          }
          this.parseExportFrom(node, isFromRequired);
        } else {
          hasDeclaration = this.maybeParseExportDeclaration(node);
        }
        if (isFromRequired || hasSpecifiers || hasDeclaration) {
          var _node2$declaration;
          const node2 = node;
          this.checkExport(node2, true, false, !!node2.source);
          if (((_node2$declaration = node2.declaration) == null ? void 0 : _node2$declaration.type) === "ClassDeclaration") {
            this.maybeTakeDecorators(decorators, node2.declaration, node2);
          } else if (decorators) {
            throw this.raise(Errors.UnsupportedDecoratorExport, node);
          }
          this.sawUnambiguousESM = true;
          return this.finishNode(node2, "ExportNamedDeclaration");
        }
        if (this.eat(65)) {
          const node2 = node;
          const decl = this.parseExportDefaultExpression();
          node2.declaration = decl;
          if (decl.type === "ClassDeclaration") {
            this.maybeTakeDecorators(decorators, decl, node2);
          } else if (decorators) {
            throw this.raise(Errors.UnsupportedDecoratorExport, node);
          }
          this.checkExport(node2, true, true);
          this.sawUnambiguousESM = true;
          return this.finishNode(node2, "ExportDefaultDeclaration");
        }
        this.unexpected(null, 5);
      }
      eatExportStar(node) {
        return this.eat(55);
      }
      maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {
        if (maybeDefaultIdentifier || this.isExportDefaultSpecifier()) {
          this.expectPlugin("exportDefaultFrom", maybeDefaultIdentifier == null ? void 0 : maybeDefaultIdentifier.loc.start);
          const id = maybeDefaultIdentifier || this.parseIdentifier(true);
          const specifier = this.startNodeAtNode(id);
          specifier.exported = id;
          node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
          return true;
        }
        return false;
      }
      maybeParseExportNamespaceSpecifier(node) {
        if (this.isContextual(93)) {
          var _ref, _ref$specifiers;
          (_ref$specifiers = (_ref = node).specifiers) != null ? _ref$specifiers : _ref.specifiers = [];
          const specifier = this.startNodeAt(this.state.lastTokStartLoc);
          this.next();
          specifier.exported = this.parseModuleExportName();
          node.specifiers.push(this.finishNode(specifier, "ExportNamespaceSpecifier"));
          return true;
        }
        return false;
      }
      maybeParseExportNamedSpecifiers(node) {
        if (this.match(5)) {
          const node2 = node;
          if (!node2.specifiers) node2.specifiers = [];
          const isTypeExport = node2.exportKind === "type";
          node2.specifiers.push(...this.parseExportSpecifiers(isTypeExport));
          node2.source = null;
          if (this.hasPlugin("importAssertions")) {
            node2.assertions = [];
          } else {
            node2.attributes = [];
          }
          node2.declaration = null;
          return true;
        }
        return false;
      }
      maybeParseExportDeclaration(node) {
        if (this.shouldParseExportDeclaration()) {
          node.specifiers = [];
          node.source = null;
          if (this.hasPlugin("importAssertions")) {
            node.assertions = [];
          } else {
            node.attributes = [];
          }
          node.declaration = this.parseExportDeclaration(node);
          return true;
        }
        return false;
      }
      isAsyncFunction() {
        if (!this.isContextual(95)) return false;
        const next = this.nextTokenInLineStart();
        return this.isUnparsedContextual(next, "function");
      }
      parseExportDefaultExpression() {
        const expr = this.startNode();
        if (this.match(68)) {
          this.next();
          return this.parseFunction(expr, 1 | 4);
        } else if (this.isAsyncFunction()) {
          this.next();
          this.next();
          return this.parseFunction(expr, 1 | 4 | 8);
        }
        if (this.match(80)) {
          return this.parseClass(expr, true, true);
        }
        if (this.match(26)) {
          if (this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === true) {
            this.raise(Errors.DecoratorBeforeExport, this.state.startLoc);
          }
          return this.parseClass(this.maybeTakeDecorators(this.parseDecorators(false), this.startNode()), true, true);
        }
        if (this.match(75) || this.match(74) || this.isLet()) {
          throw this.raise(Errors.UnsupportedDefaultExport, this.state.startLoc);
        }
        const res = this.parseMaybeAssignAllowIn();
        this.semicolon();
        return res;
      }
      parseExportDeclaration(node) {
        if (this.match(80)) {
          const node2 = this.parseClass(this.startNode(), true, false);
          return node2;
        }
        return this.parseStatementListItem();
      }
      isExportDefaultSpecifier() {
        const {
          type
        } = this.state;
        if (tokenIsIdentifier(type)) {
          if (type === 95 && !this.state.containsEsc || type === 100) {
            return false;
          }
          if ((type === 130 || type === 129) && !this.state.containsEsc) {
            const {
              type: nextType
            } = this.lookahead();
            if (tokenIsIdentifier(nextType) && nextType !== 98 || nextType === 5) {
              this.expectOnePlugin(["flow", "typescript"]);
              return false;
            }
          }
        } else if (!this.match(65)) {
          return false;
        }
        const next = this.nextTokenStart();
        const hasFrom = this.isUnparsedContextual(next, "from");
        if (this.input.charCodeAt(next) === 44 || tokenIsIdentifier(this.state.type) && hasFrom) {
          return true;
        }
        if (this.match(65) && hasFrom) {
          const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));
          return nextAfterFrom === 34 || nextAfterFrom === 39;
        }
        return false;
      }
      parseExportFrom(node, expect) {
        if (this.eatContextual(98)) {
          node.source = this.parseImportSource();
          this.checkExport(node);
          this.maybeParseImportAttributes(node);
          this.checkJSONModuleImport(node);
        } else if (expect) {
          this.unexpected();
        }
        this.semicolon();
      }
      shouldParseExportDeclaration() {
        const {
          type
        } = this.state;
        if (type === 26) {
          this.expectOnePlugin(["decorators", "decorators-legacy"]);
          if (this.hasPlugin("decorators")) {
            if (this.getPluginOption("decorators", "decoratorsBeforeExport") === true) {
              this.raise(Errors.DecoratorBeforeExport, this.state.startLoc);
            }
            return true;
          }
        }
        if (this.isContextual(107)) {
          this.raise(Errors.UsingDeclarationExport, this.state.startLoc);
          return true;
        }
        if (this.isContextual(96) && this.startsAwaitUsing()) {
          this.raise(Errors.UsingDeclarationExport, this.state.startLoc);
          return true;
        }
        return type === 74 || type === 75 || type === 68 || type === 80 || this.isLet() || this.isAsyncFunction();
      }
      checkExport(node, checkNames, isDefault, isFrom) {
        if (checkNames) {
          var _node$specifiers;
          if (isDefault) {
            this.checkDuplicateExports(node, "default");
            if (this.hasPlugin("exportDefaultFrom")) {
              var _declaration$extra;
              const declaration = node.declaration;
              if (declaration.type === "Identifier" && declaration.name === "from" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized)) {
                this.raise(Errors.ExportDefaultFromAsIdentifier, declaration);
              }
            }
          } else if ((_node$specifiers = node.specifiers) != null && _node$specifiers.length) {
            for (const specifier of node.specifiers) {
              const {
                exported
              } = specifier;
              const exportName = exported.type === "Identifier" ? exported.name : exported.value;
              this.checkDuplicateExports(specifier, exportName);
              if (!isFrom && specifier.local) {
                const {
                  local
                } = specifier;
                if (local.type !== "Identifier") {
                  this.raise(Errors.ExportBindingIsString, specifier, {
                    localName: local.value,
                    exportName
                  });
                } else {
                  this.checkReservedWord(local.name, local.loc.start, true, false);
                  this.scope.checkLocalExport(local);
                }
              }
            }
          } else if (node.declaration) {
            const decl = node.declaration;
            if (decl.type === "FunctionDeclaration" || decl.type === "ClassDeclaration") {
              const {
                id
              } = decl;
              if (!id) throw new Error("Assertion failure");
              this.checkDuplicateExports(node, id.name);
            } else if (decl.type === "VariableDeclaration") {
              for (const declaration of decl.declarations) {
                this.checkDeclaration(declaration.id);
              }
            }
          }
        }
      }
      checkDeclaration(node) {
        if (node.type === "Identifier") {
          this.checkDuplicateExports(node, node.name);
        } else if (node.type === "ObjectPattern") {
          for (const prop of node.properties) {
            this.checkDeclaration(prop);
          }
        } else if (node.type === "ArrayPattern") {
          for (const elem of node.elements) {
            if (elem) {
              this.checkDeclaration(elem);
            }
          }
        } else if (node.type === "ObjectProperty") {
          this.checkDeclaration(node.value);
        } else if (node.type === "RestElement") {
          this.checkDeclaration(node.argument);
        } else if (node.type === "AssignmentPattern") {
          this.checkDeclaration(node.left);
        }
      }
      checkDuplicateExports(node, exportName) {
        if (this.exportedIdentifiers.has(exportName)) {
          if (exportName === "default") {
            this.raise(Errors.DuplicateDefaultExport, node);
          } else {
            this.raise(Errors.DuplicateExport, node, {
              exportName
            });
          }
        }
        this.exportedIdentifiers.add(exportName);
      }
      parseExportSpecifiers(isInTypeExport) {
        const nodes = [];
        let first = true;
        this.expect(5);
        while (!this.eat(8)) {
          if (first) {
            first = false;
          } else {
            this.expect(12);
            if (this.eat(8)) break;
          }
          const isMaybeTypeOnly = this.isContextual(130);
          const isString = this.match(134);
          const node = this.startNode();
          node.local = this.parseModuleExportName();
          nodes.push(this.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly));
        }
        return nodes;
      }
      parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {
        if (this.eatContextual(93)) {
          node.exported = this.parseModuleExportName();
        } else if (isString) {
          node.exported = cloneStringLiteral(node.local);
        } else if (!node.exported) {
          node.exported = cloneIdentifier(node.local);
        }
        return this.finishNode(node, "ExportSpecifier");
      }
      parseModuleExportName() {
        if (this.match(134)) {
          const result = this.parseStringLiteral(this.state.value);
          const surrogate = loneSurrogate.exec(result.value);
          if (surrogate) {
            this.raise(Errors.ModuleExportNameHasLoneSurrogate, result, {
              surrogateCharCode: surrogate[0].charCodeAt(0)
            });
          }
          return result;
        }
        return this.parseIdentifier(true);
      }
      isJSONModuleImport(node) {
        if (node.assertions != null) {
          return node.assertions.some(({
            key: key2,
            value
          }) => {
            return value.value === "json" && (key2.type === "Identifier" ? key2.name === "type" : key2.value === "type");
          });
        }
        return false;
      }
      checkImportReflection(node) {
        const {
          specifiers
        } = node;
        const singleBindingType = specifiers.length === 1 ? specifiers[0].type : null;
        if (node.phase === "source") {
          if (singleBindingType !== "ImportDefaultSpecifier") {
            this.raise(Errors.SourcePhaseImportRequiresDefault, specifiers[0].loc.start);
          }
        } else if (node.phase === "defer") {
          if (singleBindingType !== "ImportNamespaceSpecifier") {
            this.raise(Errors.DeferImportRequiresNamespace, specifiers[0].loc.start);
          }
        } else if (node.module) {
          var _node$assertions;
          if (singleBindingType !== "ImportDefaultSpecifier") {
            this.raise(Errors.ImportReflectionNotBinding, specifiers[0].loc.start);
          }
          if (((_node$assertions = node.assertions) == null ? void 0 : _node$assertions.length) > 0) {
            this.raise(Errors.ImportReflectionHasAssertion, specifiers[0].loc.start);
          }
        }
      }
      checkJSONModuleImport(node) {
        if (this.isJSONModuleImport(node) && node.type !== "ExportAllDeclaration") {
          const {
            specifiers
          } = node;
          if (specifiers != null) {
            const nonDefaultNamedSpecifier = specifiers.find((specifier) => {
              let imported;
              if (specifier.type === "ExportSpecifier") {
                imported = specifier.local;
              } else if (specifier.type === "ImportSpecifier") {
                imported = specifier.imported;
              }
              if (imported !== void 0) {
                return imported.type === "Identifier" ? imported.name !== "default" : imported.value !== "default";
              }
            });
            if (nonDefaultNamedSpecifier !== void 0) {
              this.raise(Errors.ImportJSONBindingNotDefault, nonDefaultNamedSpecifier.loc.start);
            }
          }
        }
      }
      isPotentialImportPhase(isExport) {
        if (isExport) return false;
        return this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
      }
      applyImportPhase(node, isExport, phase, loc) {
        if (isExport) {
          return;
        }
        if (phase === "module") {
          this.expectPlugin("importReflection", loc);
          node.module = true;
        } else if (this.hasPlugin("importReflection")) {
          node.module = false;
        }
        if (phase === "source") {
          this.expectPlugin("sourcePhaseImports", loc);
          node.phase = "source";
        } else if (phase === "defer") {
          this.expectPlugin("deferredImportEvaluation", loc);
          node.phase = "defer";
        } else if (this.hasPlugin("sourcePhaseImports")) {
          node.phase = null;
        }
      }
      parseMaybeImportPhase(node, isExport) {
        if (!this.isPotentialImportPhase(isExport)) {
          this.applyImportPhase(node, isExport, null);
          return null;
        }
        const phaseIdentifier = this.parseIdentifier(true);
        const {
          type
        } = this.state;
        const isImportPhase = tokenIsKeywordOrIdentifier(type) ? type !== 98 || this.lookaheadCharCode() === 102 : type !== 12;
        if (isImportPhase) {
          this.resetPreviousIdentifierLeadingComments(phaseIdentifier);
          this.applyImportPhase(node, isExport, phaseIdentifier.name, phaseIdentifier.loc.start);
          return null;
        } else {
          this.applyImportPhase(node, isExport, null);
          return phaseIdentifier;
        }
      }
      isPrecedingIdImportPhase(phase) {
        const {
          type
        } = this.state;
        return tokenIsIdentifier(type) ? type !== 98 || this.lookaheadCharCode() === 102 : type !== 12;
      }
      parseImport(node) {
        if (this.match(134)) {
          return this.parseImportSourceAndAttributes(node);
        }
        return this.parseImportSpecifiersAndAfter(node, this.parseMaybeImportPhase(node, false));
      }
      parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier) {
        node.specifiers = [];
        const hasDefault = this.maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier);
        const parseNext = !hasDefault || this.eat(12);
        const hasStar = parseNext && this.maybeParseStarImportSpecifier(node);
        if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node);
        this.expectContextual(98);
        return this.parseImportSourceAndAttributes(node);
      }
      parseImportSourceAndAttributes(node) {
        var _node$specifiers2;
        (_node$specifiers2 = node.specifiers) != null ? _node$specifiers2 : node.specifiers = [];
        node.source = this.parseImportSource();
        this.maybeParseImportAttributes(node);
        this.checkImportReflection(node);
        this.checkJSONModuleImport(node);
        this.semicolon();
        this.sawUnambiguousESM = true;
        return this.finishNode(node, "ImportDeclaration");
      }
      parseImportSource() {
        if (!this.match(134)) this.unexpected();
        return this.parseExprAtom();
      }
      parseImportSpecifierLocal(node, specifier, type) {
        specifier.local = this.parseIdentifier();
        node.specifiers.push(this.finishImportSpecifier(specifier, type));
      }
      finishImportSpecifier(specifier, type, bindingType = 8201) {
        this.checkLVal(specifier.local, {
          type
        }, bindingType);
        return this.finishNode(specifier, type);
      }
      parseImportAttributes() {
        this.expect(5);
        const attrs = [];
        const attrNames = /* @__PURE__ */ new Set();
        do {
          if (this.match(8)) {
            break;
          }
          const node = this.startNode();
          const keyName = this.state.value;
          if (attrNames.has(keyName)) {
            this.raise(Errors.ModuleAttributesWithDuplicateKeys, this.state.startLoc, {
              key: keyName
            });
          }
          attrNames.add(keyName);
          if (this.match(134)) {
            node.key = this.parseStringLiteral(keyName);
          } else {
            node.key = this.parseIdentifier(true);
          }
          this.expect(14);
          if (!this.match(134)) {
            throw this.raise(Errors.ModuleAttributeInvalidValue, this.state.startLoc);
          }
          node.value = this.parseStringLiteral(this.state.value);
          attrs.push(this.finishNode(node, "ImportAttribute"));
        } while (this.eat(12));
        this.expect(8);
        return attrs;
      }
      parseModuleAttributes() {
        const attrs = [];
        const attributes = /* @__PURE__ */ new Set();
        do {
          const node = this.startNode();
          node.key = this.parseIdentifier(true);
          if (node.key.name !== "type") {
            this.raise(Errors.ModuleAttributeDifferentFromType, node.key);
          }
          if (attributes.has(node.key.name)) {
            this.raise(Errors.ModuleAttributesWithDuplicateKeys, node.key, {
              key: node.key.name
            });
          }
          attributes.add(node.key.name);
          this.expect(14);
          if (!this.match(134)) {
            throw this.raise(Errors.ModuleAttributeInvalidValue, this.state.startLoc);
          }
          node.value = this.parseStringLiteral(this.state.value);
          attrs.push(this.finishNode(node, "ImportAttribute"));
        } while (this.eat(12));
        return attrs;
      }
      maybeParseImportAttributes(node) {
        let attributes;
        {
          var useWith = false;
        }
        if (this.match(76)) {
          if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40) {
            return;
          }
          this.next();
          if (this.hasPlugin("moduleAttributes")) {
            attributes = this.parseModuleAttributes();
            this.addExtra(node, "deprecatedWithLegacySyntax", true);
          } else {
            attributes = this.parseImportAttributes();
          }
          {
            useWith = true;
          }
        } else if (this.isContextual(94) && !this.hasPrecedingLineBreak()) {
          if (!this.hasPlugin("deprecatedImportAssert") && !this.hasPlugin("importAssertions")) {
            this.raise(Errors.ImportAttributesUseAssert, this.state.startLoc);
          }
          if (!this.hasPlugin("importAssertions")) {
            this.addExtra(node, "deprecatedAssertSyntax", true);
          }
          this.next();
          attributes = this.parseImportAttributes();
        } else {
          attributes = [];
        }
        if (!useWith && this.hasPlugin("importAssertions")) {
          node.assertions = attributes;
        } else {
          node.attributes = attributes;
        }
      }
      maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier) {
        if (maybeDefaultIdentifier) {
          const specifier = this.startNodeAtNode(maybeDefaultIdentifier);
          specifier.local = maybeDefaultIdentifier;
          node.specifiers.push(this.finishImportSpecifier(specifier, "ImportDefaultSpecifier"));
          return true;
        } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
          this.parseImportSpecifierLocal(node, this.startNode(), "ImportDefaultSpecifier");
          return true;
        }
        return false;
      }
      maybeParseStarImportSpecifier(node) {
        if (this.match(55)) {
          const specifier = this.startNode();
          this.next();
          this.expectContextual(93);
          this.parseImportSpecifierLocal(node, specifier, "ImportNamespaceSpecifier");
          return true;
        }
        return false;
      }
      parseNamedImportSpecifiers(node) {
        let first = true;
        this.expect(5);
        while (!this.eat(8)) {
          if (first) {
            first = false;
          } else {
            if (this.eat(14)) {
              throw this.raise(Errors.DestructureNamedImport, this.state.startLoc);
            }
            this.expect(12);
            if (this.eat(8)) break;
          }
          const specifier = this.startNode();
          const importedIsString = this.match(134);
          const isMaybeTypeOnly = this.isContextual(130);
          specifier.imported = this.parseModuleExportName();
          const importSpecifier2 = this.parseImportSpecifier(specifier, importedIsString, node.importKind === "type" || node.importKind === "typeof", isMaybeTypeOnly, void 0);
          node.specifiers.push(importSpecifier2);
        }
      }
      parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
        if (this.eatContextual(93)) {
          specifier.local = this.parseIdentifier();
        } else {
          const {
            imported
          } = specifier;
          if (importedIsString) {
            throw this.raise(Errors.ImportBindingIsString, specifier, {
              importName: imported.value
            });
          }
          this.checkReservedWord(imported.name, specifier.loc.start, true, true);
          if (!specifier.local) {
            specifier.local = cloneIdentifier(imported);
          }
        }
        return this.finishImportSpecifier(specifier, "ImportSpecifier", bindingType);
      }
      isThisParam(param) {
        return param.type === "Identifier" && param.name === "this";
      }
    };
    var Parser = class extends StatementParser {
      constructor(options, input, pluginsMap) {
        options = getOptions(options);
        super(options, input);
        this.options = options;
        this.initializeScopes();
        this.plugins = pluginsMap;
        this.filename = options.sourceFilename;
        this.startIndex = options.startIndex;
        let optionFlags = 0;
        if (options.allowAwaitOutsideFunction) {
          optionFlags |= 1;
        }
        if (options.allowReturnOutsideFunction) {
          optionFlags |= 2;
        }
        if (options.allowImportExportEverywhere) {
          optionFlags |= 8;
        }
        if (options.allowSuperOutsideMethod) {
          optionFlags |= 16;
        }
        if (options.allowUndeclaredExports) {
          optionFlags |= 64;
        }
        if (options.allowNewTargetOutsideFunction) {
          optionFlags |= 4;
        }
        if (options.allowYieldOutsideFunction) {
          optionFlags |= 32;
        }
        if (options.ranges) {
          optionFlags |= 128;
        }
        if (options.tokens) {
          optionFlags |= 256;
        }
        if (options.createImportExpressions) {
          optionFlags |= 512;
        }
        if (options.createParenthesizedExpressions) {
          optionFlags |= 1024;
        }
        if (options.errorRecovery) {
          optionFlags |= 2048;
        }
        if (options.attachComment) {
          optionFlags |= 4096;
        }
        if (options.annexB) {
          optionFlags |= 8192;
        }
        this.optionFlags = optionFlags;
      }
      getScopeHandler() {
        return ScopeHandler;
      }
      parse() {
        this.enterInitialScopes();
        const file = this.startNode();
        const program = this.startNode();
        this.nextToken();
        file.errors = null;
        this.parseTopLevel(file, program);
        file.errors = this.state.errors;
        file.comments.length = this.state.commentsLen;
        return file;
      }
    };
    function parse4(input, options) {
      var _options;
      if (((_options = options) == null ? void 0 : _options.sourceType) === "unambiguous") {
        options = Object.assign({}, options);
        try {
          options.sourceType = "module";
          const parser = getParser(options, input);
          const ast = parser.parse();
          if (parser.sawUnambiguousESM) {
            return ast;
          }
          if (parser.ambiguousScriptDifferentAst) {
            try {
              options.sourceType = "script";
              return getParser(options, input).parse();
            } catch (_unused) {
            }
          } else {
            ast.program.sourceType = "script";
          }
          return ast;
        } catch (moduleError) {
          try {
            options.sourceType = "script";
            return getParser(options, input).parse();
          } catch (_unused2) {
          }
          throw moduleError;
        }
      } else {
        return getParser(options, input).parse();
      }
    }
    function parseExpression(input, options) {
      const parser = getParser(options, input);
      if (parser.options.strictMode) {
        parser.state.strict = true;
      }
      return parser.getExpression();
    }
    function generateExportedTokenTypes(internalTokenTypes) {
      const tokenTypes2 = {};
      for (const typeName of Object.keys(internalTokenTypes)) {
        tokenTypes2[typeName] = getExportedToken(internalTokenTypes[typeName]);
      }
      return tokenTypes2;
    }
    var tokTypes = generateExportedTokenTypes(tt);
    function getParser(options, input) {
      let cls = Parser;
      const pluginsMap = /* @__PURE__ */ new Map();
      if (options != null && options.plugins) {
        for (const plugin of options.plugins) {
          let name, opts;
          if (typeof plugin === "string") {
            name = plugin;
          } else {
            [name, opts] = plugin;
          }
          if (!pluginsMap.has(name)) {
            pluginsMap.set(name, opts || {});
          }
        }
        validatePlugins(pluginsMap);
        cls = getParserClass(pluginsMap);
      }
      return new cls(options, input, pluginsMap);
    }
    var parserClassCache = /* @__PURE__ */ new Map();
    function getParserClass(pluginsMap) {
      const pluginList = [];
      for (const name of mixinPluginNames) {
        if (pluginsMap.has(name)) {
          pluginList.push(name);
        }
      }
      const key2 = pluginList.join("|");
      let cls = parserClassCache.get(key2);
      if (!cls) {
        cls = Parser;
        for (const plugin of pluginList) {
          cls = mixinPlugins[plugin](cls);
        }
        parserClassCache.set(key2, cls);
      }
      return cls;
    }
    exports2.parse = parse4;
    exports2.parseExpression = parseExpression;
    exports2.tokTypes = tokTypes;
  }
});

// node_modules/@babel/helpers/node_modules/@babel/traverse/lib/path/replacement.js
var require_replacement = __commonJS({
  "node_modules/@babel/helpers/node_modules/@babel/traverse/lib/path/replacement.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2._replaceWith = _replaceWith;
    exports2.replaceExpressionWithStatements = replaceExpressionWithStatements;
    exports2.replaceInline = replaceInline;
    exports2.replaceWith = replaceWith;
    exports2.replaceWithMultiple = replaceWithMultiple;
    exports2.replaceWithSourceString = replaceWithSourceString;
    var _codeFrame = require_lib3();
    var _index = require_lib6();
    var _index2 = require_path();
    var _cache = require_cache();
    var _modification = require_modification();
    var _parser = require_lib4();
    var _t = require("@babel/types");
    var _context3 = require_context2();
    var {
      FUNCTION_TYPES,
      arrowFunctionExpression: arrowFunctionExpression2,
      assignmentExpression: assignmentExpression2,
      awaitExpression: awaitExpression2,
      blockStatement: blockStatement3,
      buildUndefinedNode,
      callExpression: callExpression3,
      cloneNode: cloneNode2,
      conditionalExpression: conditionalExpression3,
      expressionStatement: expressionStatement2,
      getBindingIdentifiers,
      identifier: identifier4,
      inheritLeadingComments,
      inheritTrailingComments,
      inheritsComments,
      isBlockStatement,
      isEmptyStatement,
      isExpression: isExpression2,
      isExpressionStatement,
      isIfStatement,
      isProgram,
      isStatement: isStatement2,
      isVariableDeclaration: isVariableDeclaration2,
      removeComments,
      returnStatement: returnStatement3,
      sequenceExpression: sequenceExpression2,
      validate: validate2,
      yieldExpression
    } = _t;
    function replaceWithMultiple(nodes) {
      var _getCachedPaths;
      _context3.resync.call(this);
      nodes = _modification._verifyNodeList.call(this, nodes);
      inheritLeadingComments(nodes[0], this.node);
      inheritTrailingComments(nodes[nodes.length - 1], this.node);
      (_getCachedPaths = (0, _cache.getCachedPaths)(this.hub, this.parent)) == null || _getCachedPaths.delete(this.node);
      this.node = this.container[this.key] = null;
      const paths = this.insertAfter(nodes);
      if (this.node) {
        this.requeue();
      } else {
        this.remove();
      }
      return paths;
    }
    function replaceWithSourceString(replacement) {
      _context3.resync.call(this);
      let ast;
      try {
        replacement = `(${replacement})`;
        ast = (0, _parser.parse)(replacement);
      } catch (err) {
        const loc = err.loc;
        if (loc) {
          err.message += " - make sure this is an expression.\n" + (0, _codeFrame.codeFrameColumns)(replacement, {
            start: {
              line: loc.line,
              column: loc.column + 1
            }
          });
          err.code = "BABEL_REPLACE_SOURCE_ERROR";
        }
        throw err;
      }
      const expressionAST = ast.program.body[0].expression;
      _index.default.removeProperties(expressionAST);
      return this.replaceWith(expressionAST);
    }
    function replaceWith(replacementPath) {
      _context3.resync.call(this);
      if (this.removed) {
        throw new Error("You can't replace this node, we've already removed it");
      }
      let replacement = replacementPath instanceof _index2.default ? replacementPath.node : replacementPath;
      if (!replacement) {
        throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
      }
      if (this.node === replacement) {
        return [this];
      }
      if (this.isProgram() && !isProgram(replacement)) {
        throw new Error("You can only replace a Program root node with another Program node");
      }
      if (Array.isArray(replacement)) {
        throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
      }
      if (typeof replacement === "string") {
        throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
      }
      let nodePath = "";
      if (this.isNodeType("Statement") && isExpression2(replacement)) {
        if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement) && !this.parentPath.isExportDefaultDeclaration()) {
          replacement = expressionStatement2(replacement);
          nodePath = "expression";
        }
      }
      if (this.isNodeType("Expression") && isStatement2(replacement)) {
        if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) {
          return this.replaceExpressionWithStatements([replacement]);
        }
      }
      const oldNode = this.node;
      if (oldNode) {
        inheritsComments(replacement, oldNode);
        removeComments(oldNode);
      }
      _replaceWith.call(this, replacement);
      this.type = replacement.type;
      _context3.setScope.call(this);
      this.requeue();
      return [nodePath ? this.get(nodePath) : this];
    }
    function _replaceWith(node) {
      var _getCachedPaths2;
      if (!this.container) {
        throw new ReferenceError("Container is falsy");
      }
      if (this.inList) {
        validate2(this.parent, this.key, [node]);
      } else {
        validate2(this.parent, this.key, node);
      }
      this.debug(`Replace with ${node == null ? void 0 : node.type}`);
      (_getCachedPaths2 = (0, _cache.getCachedPaths)(this.hub, this.parent)) == null || _getCachedPaths2.set(node, this).delete(this.node);
      this.node = this.container[this.key] = node;
    }
    function replaceExpressionWithStatements(nodes) {
      _context3.resync.call(this);
      const declars = [];
      const nodesAsSingleExpression = gatherSequenceExpressions(nodes, declars);
      if (nodesAsSingleExpression) {
        for (const id of declars) this.scope.push({
          id
        });
        return this.replaceWith(nodesAsSingleExpression)[0].get("expressions");
      }
      const functionParent = this.getFunctionParent();
      const isParentAsync = functionParent == null ? void 0 : functionParent.node.async;
      const isParentGenerator = functionParent == null ? void 0 : functionParent.node.generator;
      const container = arrowFunctionExpression2([], blockStatement3(nodes));
      this.replaceWith(callExpression3(container, []));
      const callee = this.get("callee");
      callee.get("body").scope.hoistVariables((id) => this.scope.push({
        id
      }));
      const completionRecords = callee.getCompletionRecords();
      for (const path of completionRecords) {
        if (!path.isExpressionStatement()) continue;
        const loop = path.findParent((path2) => path2.isLoop());
        if (loop) {
          let uid = loop.getData("expressionReplacementReturnUid");
          if (!uid) {
            uid = callee.scope.generateDeclaredUidIdentifier("ret");
            callee.get("body").pushContainer("body", returnStatement3(cloneNode2(uid)));
            loop.setData("expressionReplacementReturnUid", uid);
          } else {
            uid = identifier4(uid.name);
          }
          path.get("expression").replaceWith(assignmentExpression2("=", cloneNode2(uid), path.node.expression));
        } else {
          path.replaceWith(returnStatement3(path.node.expression));
        }
      }
      callee.arrowFunctionToExpression();
      const newCallee = callee;
      const needToAwaitFunction = isParentAsync && _index.default.hasType(this.get("callee.body").node, "AwaitExpression", FUNCTION_TYPES);
      const needToYieldFunction = isParentGenerator && _index.default.hasType(this.get("callee.body").node, "YieldExpression", FUNCTION_TYPES);
      if (needToAwaitFunction) {
        newCallee.set("async", true);
        if (!needToYieldFunction) {
          this.replaceWith(awaitExpression2(this.node));
        }
      }
      if (needToYieldFunction) {
        newCallee.set("generator", true);
        this.replaceWith(yieldExpression(this.node, true));
      }
      return newCallee.get("body.body");
    }
    function gatherSequenceExpressions(nodes, declars) {
      const exprs = [];
      let ensureLastUndefined = true;
      for (const node of nodes) {
        if (!isEmptyStatement(node)) {
          ensureLastUndefined = false;
        }
        if (isExpression2(node)) {
          exprs.push(node);
        } else if (isExpressionStatement(node)) {
          exprs.push(node.expression);
        } else if (isVariableDeclaration2(node)) {
          if (node.kind !== "var") return;
          for (const declar of node.declarations) {
            const bindings = getBindingIdentifiers(declar);
            for (const key2 of Object.keys(bindings)) {
              declars.push(cloneNode2(bindings[key2]));
            }
            if (declar.init) {
              exprs.push(assignmentExpression2("=", declar.id, declar.init));
            }
          }
          ensureLastUndefined = true;
        } else if (isIfStatement(node)) {
          const consequent = node.consequent ? gatherSequenceExpressions([node.consequent], declars) : buildUndefinedNode();
          const alternate = node.alternate ? gatherSequenceExpressions([node.alternate], declars) : buildUndefinedNode();
          if (!consequent || !alternate) return;
          exprs.push(conditionalExpression3(node.test, consequent, alternate));
        } else if (isBlockStatement(node)) {
          const body = gatherSequenceExpressions(node.body, declars);
          if (!body) return;
          exprs.push(body);
        } else if (isEmptyStatement(node)) {
          if (nodes.indexOf(node) === 0) {
            ensureLastUndefined = true;
          }
        } else {
          return;
        }
      }
      if (ensureLastUndefined) exprs.push(buildUndefinedNode());
      if (exprs.length === 1) {
        return exprs[0];
      } else {
        return sequenceExpression2(exprs);
      }
    }
    function replaceInline(nodes) {
      _context3.resync.call(this);
      if (Array.isArray(nodes)) {
        if (Array.isArray(this.container)) {
          nodes = _modification._verifyNodeList.call(this, nodes);
          const paths = _modification._containerInsertAfter.call(this, nodes);
          this.remove();
          return paths;
        } else {
          return this.replaceWithMultiple(nodes);
        }
      } else {
        return this.replaceWith(nodes);
      }
    }
  }
});

// node_modules/@babel/helpers/node_modules/@babel/traverse/lib/path/evaluation.js
var require_evaluation = __commonJS({
  "node_modules/@babel/helpers/node_modules/@babel/traverse/lib/path/evaluation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.evaluate = evaluate;
    exports2.evaluateTruthy = evaluateTruthy;
    var VALID_OBJECT_CALLEES = ["Number", "String", "Math"];
    var VALID_IDENTIFIER_CALLEES = ["isFinite", "isNaN", "parseFloat", "parseInt", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", null, null];
    var INVALID_METHODS = ["random"];
    function isValidObjectCallee(val) {
      return VALID_OBJECT_CALLEES.includes(val);
    }
    function isValidIdentifierCallee(val) {
      return VALID_IDENTIFIER_CALLEES.includes(val);
    }
    function isInvalidMethod(val) {
      return INVALID_METHODS.includes(val);
    }
    function evaluateTruthy() {
      const res = this.evaluate();
      if (res.confident) return !!res.value;
    }
    function deopt(path, state) {
      if (!state.confident) return;
      state.deoptPath = path;
      state.confident = false;
    }
    var Globals = /* @__PURE__ */ new Map([["undefined", void 0], ["Infinity", Infinity], ["NaN", NaN]]);
    function evaluateCached(path, state) {
      const {
        node
      } = path;
      const {
        seen
      } = state;
      if (seen.has(node)) {
        const existing = seen.get(node);
        if (existing.resolved) {
          return existing.value;
        } else {
          deopt(path, state);
          return;
        }
      } else {
        const item = {
          resolved: false
        };
        seen.set(node, item);
        const val = _evaluate(path, state);
        if (state.confident) {
          item.resolved = true;
          item.value = val;
        }
        return val;
      }
    }
    function _evaluate(path, state) {
      if (!state.confident) return;
      if (path.isSequenceExpression()) {
        const exprs = path.get("expressions");
        return evaluateCached(exprs[exprs.length - 1], state);
      }
      if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) {
        return path.node.value;
      }
      if (path.isNullLiteral()) {
        return null;
      }
      if (path.isTemplateLiteral()) {
        return evaluateQuasis(path, path.node.quasis, state);
      }
      if (path.isTaggedTemplateExpression() && path.get("tag").isMemberExpression()) {
        const object = path.get("tag.object");
        const {
          node: {
            name
          }
        } = object;
        const property = path.get("tag.property");
        if (object.isIdentifier() && name === "String" && !path.scope.getBinding(name) && property.isIdentifier() && property.node.name === "raw") {
          return evaluateQuasis(path, path.node.quasi.quasis, state, true);
        }
      }
      if (path.isConditionalExpression()) {
        const testResult = evaluateCached(path.get("test"), state);
        if (!state.confident) return;
        if (testResult) {
          return evaluateCached(path.get("consequent"), state);
        } else {
          return evaluateCached(path.get("alternate"), state);
        }
      }
      if (path.isExpressionWrapper()) {
        return evaluateCached(path.get("expression"), state);
      }
      if (path.isMemberExpression() && !path.parentPath.isCallExpression({
        callee: path.node
      })) {
        const property = path.get("property");
        const object = path.get("object");
        if (object.isLiteral()) {
          const value = object.node.value;
          const type = typeof value;
          let key2 = null;
          if (path.node.computed) {
            key2 = evaluateCached(property, state);
            if (!state.confident) return;
          } else if (property.isIdentifier()) {
            key2 = property.node.name;
          }
          if ((type === "number" || type === "string") && key2 != null && (typeof key2 === "number" || typeof key2 === "string")) {
            return value[key2];
          }
        }
      }
      if (path.isReferencedIdentifier()) {
        const binding = path.scope.getBinding(path.node.name);
        if (binding) {
          if (binding.constantViolations.length > 0 || path.node.start < binding.path.node.end) {
            deopt(binding.path, state);
            return;
          }
          if (binding.hasValue) {
            return binding.value;
          }
        }
        const name = path.node.name;
        if (Globals.has(name)) {
          if (!binding) {
            return Globals.get(name);
          }
          deopt(binding.path, state);
          return;
        }
        const resolved = path.resolve();
        if (resolved === path) {
          deopt(path, state);
          return;
        } else {
          return evaluateCached(resolved, state);
        }
      }
      if (path.isUnaryExpression({
        prefix: true
      })) {
        if (path.node.operator === "void") {
          return void 0;
        }
        const argument = path.get("argument");
        if (path.node.operator === "typeof" && (argument.isFunction() || argument.isClass())) {
          return "function";
        }
        const arg = evaluateCached(argument, state);
        if (!state.confident) return;
        switch (path.node.operator) {
          case "!":
            return !arg;
          case "+":
            return +arg;
          case "-":
            return -arg;
          case "~":
            return ~arg;
          case "typeof":
            return typeof arg;
        }
      }
      if (path.isArrayExpression()) {
        const arr = [];
        const elems = path.get("elements");
        for (const elem of elems) {
          const elemValue = elem.evaluate();
          if (elemValue.confident) {
            arr.push(elemValue.value);
          } else {
            deopt(elemValue.deopt, state);
            return;
          }
        }
        return arr;
      }
      if (path.isObjectExpression()) {
        const obj = {};
        const props = path.get("properties");
        for (const prop of props) {
          if (prop.isObjectMethod() || prop.isSpreadElement()) {
            deopt(prop, state);
            return;
          }
          const keyPath = prop.get("key");
          let key2;
          if (prop.node.computed) {
            key2 = keyPath.evaluate();
            if (!key2.confident) {
              deopt(key2.deopt, state);
              return;
            }
            key2 = key2.value;
          } else if (keyPath.isIdentifier()) {
            key2 = keyPath.node.name;
          } else {
            key2 = keyPath.node.value;
          }
          const valuePath = prop.get("value");
          let value = valuePath.evaluate();
          if (!value.confident) {
            deopt(value.deopt, state);
            return;
          }
          value = value.value;
          obj[key2] = value;
        }
        return obj;
      }
      if (path.isLogicalExpression()) {
        const wasConfident = state.confident;
        const left = evaluateCached(path.get("left"), state);
        const leftConfident = state.confident;
        state.confident = wasConfident;
        const right = evaluateCached(path.get("right"), state);
        const rightConfident = state.confident;
        switch (path.node.operator) {
          case "||":
            state.confident = leftConfident && (!!left || rightConfident);
            if (!state.confident) return;
            return left || right;
          case "&&":
            state.confident = leftConfident && (!left || rightConfident);
            if (!state.confident) return;
            return left && right;
          case "??":
            state.confident = leftConfident && (left != null || rightConfident);
            if (!state.confident) return;
            return left != null ? left : right;
        }
      }
      if (path.isBinaryExpression()) {
        const left = evaluateCached(path.get("left"), state);
        if (!state.confident) return;
        const right = evaluateCached(path.get("right"), state);
        if (!state.confident) return;
        switch (path.node.operator) {
          case "-":
            return left - right;
          case "+":
            return left + right;
          case "/":
            return left / right;
          case "*":
            return left * right;
          case "%":
            return left % right;
          case "**":
            return Math.pow(left, right);
          case "<":
            return left < right;
          case ">":
            return left > right;
          case "<=":
            return left <= right;
          case ">=":
            return left >= right;
          case "==":
            return left == right;
          case "!=":
            return left != right;
          case "===":
            return left === right;
          case "!==":
            return left !== right;
          case "|":
            return left | right;
          case "&":
            return left & right;
          case "^":
            return left ^ right;
          case "<<":
            return left << right;
          case ">>":
            return left >> right;
          case ">>>":
            return left >>> right;
        }
      }
      if (path.isCallExpression()) {
        const callee = path.get("callee");
        let context;
        let func;
        if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name) && (isValidObjectCallee(callee.node.name) || isValidIdentifierCallee(callee.node.name))) {
          func = global[callee.node.name];
        }
        if (callee.isMemberExpression()) {
          const object = callee.get("object");
          const property = callee.get("property");
          if (object.isIdentifier() && property.isIdentifier() && isValidObjectCallee(object.node.name) && !isInvalidMethod(property.node.name)) {
            context = global[object.node.name];
            const key2 = property.node.name;
            if (hasOwnProperty.call(context, key2)) {
              func = context[key2];
            }
          }
          if (object.isLiteral() && property.isIdentifier()) {
            const type = typeof object.node.value;
            if (type === "string" || type === "number") {
              context = object.node.value;
              func = context[property.node.name];
            }
          }
        }
        if (func) {
          const args = path.get("arguments").map((arg) => evaluateCached(arg, state));
          if (!state.confident) return;
          return func.apply(context, args);
        }
      }
      deopt(path, state);
    }
    function evaluateQuasis(path, quasis, state, raw = false) {
      let str = "";
      let i = 0;
      const exprs = path.isTemplateLiteral() ? path.get("expressions") : path.get("quasi.expressions");
      for (const elem of quasis) {
        if (!state.confident) break;
        str += raw ? elem.value.raw : elem.value.cooked;
        const expr = exprs[i++];
        if (expr) str += String(evaluateCached(expr, state));
      }
      if (!state.confident) return;
      return str;
    }
    function evaluate() {
      const state = {
        confident: true,
        deoptPath: null,
        seen: /* @__PURE__ */ new Map()
      };
      let value = evaluateCached(this, state);
      if (!state.confident) value = void 0;
      return {
        confident: state.confident,
        deopt: state.deoptPath,
        value
      };
    }
  }
});

// ../../node_modules/@babel/template/lib/formatters.js
var require_formatters = __commonJS({
  "../../node_modules/@babel/template/lib/formatters.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.statements = exports2.statement = exports2.smart = exports2.program = exports2.expression = void 0;
    var _t = require("@babel/types");
    var {
      assertExpressionStatement
    } = _t;
    function makeStatementFormatter(fn) {
      return {
        code: (str) => `/* @babel/template */;
${str}`,
        validate: () => {
        },
        unwrap: (ast) => {
          return fn(ast.program.body.slice(1));
        }
      };
    }
    var smart = exports2.smart = makeStatementFormatter((body) => {
      if (body.length > 1) {
        return body;
      } else {
        return body[0];
      }
    });
    var statements = exports2.statements = makeStatementFormatter((body) => body);
    var statement = exports2.statement = makeStatementFormatter((body) => {
      if (body.length === 0) {
        throw new Error("Found nothing to return.");
      }
      if (body.length > 1) {
        throw new Error("Found multiple statements but wanted one");
      }
      return body[0];
    });
    var expression = exports2.expression = {
      code: (str) => `(
${str}
)`,
      validate: (ast) => {
        if (ast.program.body.length > 1) {
          throw new Error("Found multiple statements but wanted one");
        }
        if (expression.unwrap(ast).start === 0) {
          throw new Error("Parse result included parens.");
        }
      },
      unwrap: ({
        program: program2
      }) => {
        const [stmt] = program2.body;
        assertExpressionStatement(stmt);
        return stmt.expression;
      }
    };
    var program = exports2.program = {
      code: (str) => str,
      validate: () => {
      },
      unwrap: (ast) => ast.program
    };
  }
});

// ../../node_modules/@babel/template/lib/options.js
var require_options = __commonJS({
  "../../node_modules/@babel/template/lib/options.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.merge = merge3;
    exports2.normalizeReplacements = normalizeReplacements;
    exports2.validate = validate2;
    var _excluded = ["placeholderWhitelist", "placeholderPattern", "preserveComments", "syntacticPlaceholders"];
    function _objectWithoutPropertiesLoose(r, e) {
      if (null == r) return {};
      var t6 = {};
      for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
        if (-1 !== e.indexOf(n)) continue;
        t6[n] = r[n];
      }
      return t6;
    }
    function merge3(a, b) {
      const {
        placeholderWhitelist = a.placeholderWhitelist,
        placeholderPattern = a.placeholderPattern,
        preserveComments = a.preserveComments,
        syntacticPlaceholders = a.syntacticPlaceholders
      } = b;
      return {
        parser: Object.assign({}, a.parser, b.parser),
        placeholderWhitelist,
        placeholderPattern,
        preserveComments,
        syntacticPlaceholders
      };
    }
    function validate2(opts) {
      if (opts != null && typeof opts !== "object") {
        throw new Error("Unknown template options.");
      }
      const _ref = opts || {}, {
        placeholderWhitelist,
        placeholderPattern,
        preserveComments,
        syntacticPlaceholders
      } = _ref, parser = _objectWithoutPropertiesLoose(_ref, _excluded);
      if (placeholderWhitelist != null && !(placeholderWhitelist instanceof Set)) {
        throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");
      }
      if (placeholderPattern != null && !(placeholderPattern instanceof RegExp) && placeholderPattern !== false) {
        throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");
      }
      if (preserveComments != null && typeof preserveComments !== "boolean") {
        throw new Error("'.preserveComments' must be a boolean, null, or undefined");
      }
      if (syntacticPlaceholders != null && typeof syntacticPlaceholders !== "boolean") {
        throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");
      }
      if (syntacticPlaceholders === true && (placeholderWhitelist != null || placeholderPattern != null)) {
        throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
      }
      return {
        parser,
        placeholderWhitelist: placeholderWhitelist || void 0,
        placeholderPattern: placeholderPattern == null ? void 0 : placeholderPattern,
        preserveComments: preserveComments == null ? void 0 : preserveComments,
        syntacticPlaceholders: syntacticPlaceholders == null ? void 0 : syntacticPlaceholders
      };
    }
    function normalizeReplacements(replacements) {
      if (Array.isArray(replacements)) {
        return replacements.reduce((acc, replacement, i) => {
          acc["$" + i] = replacement;
          return acc;
        }, {});
      } else if (typeof replacements === "object" || replacements == null) {
        return replacements || void 0;
      }
      throw new Error("Template replacements must be an array, object, null, or undefined");
    }
  }
});

// ../../node_modules/@babel/template/lib/parse.js
var require_parse = __commonJS({
  "../../node_modules/@babel/template/lib/parse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = parseAndBuildMetadata;
    var _t = require("@babel/types");
    var _parser = require_lib4();
    var _codeFrame = require_lib3();
    var {
      isCallExpression,
      isExpressionStatement,
      isFunction,
      isIdentifier,
      isJSXIdentifier,
      isNewExpression,
      isPlaceholder,
      isStatement: isStatement2,
      isStringLiteral,
      removePropertiesDeep,
      traverse
    } = _t;
    var PATTERN = /^[_$A-Z0-9]+$/;
    function parseAndBuildMetadata(formatter, code, opts) {
      const {
        placeholderWhitelist,
        placeholderPattern,
        preserveComments,
        syntacticPlaceholders
      } = opts;
      const ast = parseWithCodeFrame(code, opts.parser, syntacticPlaceholders);
      removePropertiesDeep(ast, {
        preserveComments
      });
      formatter.validate(ast);
      const state = {
        syntactic: {
          placeholders: [],
          placeholderNames: /* @__PURE__ */ new Set()
        },
        legacy: {
          placeholders: [],
          placeholderNames: /* @__PURE__ */ new Set()
        },
        placeholderWhitelist,
        placeholderPattern,
        syntacticPlaceholders
      };
      traverse(ast, placeholderVisitorHandler, state);
      return Object.assign({
        ast
      }, state.syntactic.placeholders.length ? state.syntactic : state.legacy);
    }
    function placeholderVisitorHandler(node, ancestors, state) {
      var _state$placeholderWhi;
      let name;
      let hasSyntacticPlaceholders = state.syntactic.placeholders.length > 0;
      if (isPlaceholder(node)) {
        if (state.syntacticPlaceholders === false) {
          throw new Error("%%foo%%-style placeholders can't be used when '.syntacticPlaceholders' is false.");
        }
        name = node.name.name;
        hasSyntacticPlaceholders = true;
      } else if (hasSyntacticPlaceholders || state.syntacticPlaceholders) {
        return;
      } else if (isIdentifier(node) || isJSXIdentifier(node)) {
        name = node.name;
      } else if (isStringLiteral(node)) {
        name = node.value;
      } else {
        return;
      }
      if (hasSyntacticPlaceholders && (state.placeholderPattern != null || state.placeholderWhitelist != null)) {
        throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
      }
      if (!hasSyntacticPlaceholders && (state.placeholderPattern === false || !(state.placeholderPattern || PATTERN).test(name)) && !((_state$placeholderWhi = state.placeholderWhitelist) != null && _state$placeholderWhi.has(name))) {
        return;
      }
      ancestors = ancestors.slice();
      const {
        node: parent,
        key: key2
      } = ancestors[ancestors.length - 1];
      let type;
      if (isStringLiteral(node) || isPlaceholder(node, {
        expectedNode: "StringLiteral"
      })) {
        type = "string";
      } else if (isNewExpression(parent) && key2 === "arguments" || isCallExpression(parent) && key2 === "arguments" || isFunction(parent) && key2 === "params") {
        type = "param";
      } else if (isExpressionStatement(parent) && !isPlaceholder(node)) {
        type = "statement";
        ancestors = ancestors.slice(0, -1);
      } else if (isStatement2(node) && isPlaceholder(node)) {
        type = "statement";
      } else {
        type = "other";
      }
      const {
        placeholders,
        placeholderNames
      } = !hasSyntacticPlaceholders ? state.legacy : state.syntactic;
      placeholders.push({
        name,
        type,
        resolve: (ast) => resolveAncestors(ast, ancestors),
        isDuplicate: placeholderNames.has(name)
      });
      placeholderNames.add(name);
    }
    function resolveAncestors(ast, ancestors) {
      let parent = ast;
      for (let i = 0; i < ancestors.length - 1; i++) {
        const {
          key: key3,
          index: index2
        } = ancestors[i];
        if (index2 === void 0) {
          parent = parent[key3];
        } else {
          parent = parent[key3][index2];
        }
      }
      const {
        key: key2,
        index
      } = ancestors[ancestors.length - 1];
      return {
        parent,
        key: key2,
        index
      };
    }
    function parseWithCodeFrame(code, parserOpts, syntacticPlaceholders) {
      const plugins = (parserOpts.plugins || []).slice();
      if (syntacticPlaceholders !== false) {
        plugins.push("placeholders");
      }
      parserOpts = Object.assign({
        allowAwaitOutsideFunction: true,
        allowReturnOutsideFunction: true,
        allowNewTargetOutsideFunction: true,
        allowSuperOutsideMethod: true,
        allowYieldOutsideFunction: true,
        sourceType: "module"
      }, parserOpts, {
        plugins
      });
      try {
        return (0, _parser.parse)(code, parserOpts);
      } catch (err) {
        const loc = err.loc;
        if (loc) {
          err.message += "\n" + (0, _codeFrame.codeFrameColumns)(code, {
            start: loc
          });
          err.code = "BABEL_TEMPLATE_PARSE_ERROR";
        }
        throw err;
      }
    }
  }
});

// ../../node_modules/@babel/template/lib/populate.js
var require_populate = __commonJS({
  "../../node_modules/@babel/template/lib/populate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = populatePlaceholders;
    var _t = require("@babel/types");
    var {
      blockStatement: blockStatement3,
      cloneNode: cloneNode2,
      emptyStatement: emptyStatement2,
      expressionStatement: expressionStatement2,
      identifier: identifier4,
      isStatement: isStatement2,
      isStringLiteral,
      stringLiteral: stringLiteral3,
      validate: validate2
    } = _t;
    function populatePlaceholders(metadata, replacements) {
      const ast = cloneNode2(metadata.ast);
      if (replacements) {
        metadata.placeholders.forEach((placeholder) => {
          if (!hasOwnProperty.call(replacements, placeholder.name)) {
            const placeholderName = placeholder.name;
            throw new Error(`Error: No substitution given for "${placeholderName}". If this is not meant to be a
            placeholder you may want to consider passing one of the following options to @babel/template:
            - { placeholderPattern: false, placeholderWhitelist: new Set(['${placeholderName}'])}
            - { placeholderPattern: /^${placeholderName}$/ }`);
          }
        });
        Object.keys(replacements).forEach((key2) => {
          if (!metadata.placeholderNames.has(key2)) {
            throw new Error(`Unknown substitution "${key2}" given`);
          }
        });
      }
      metadata.placeholders.slice().reverse().forEach((placeholder) => {
        try {
          applyReplacement(placeholder, ast, replacements && replacements[placeholder.name] || null);
        } catch (e) {
          e.message = `@babel/template placeholder "${placeholder.name}": ${e.message}`;
          throw e;
        }
      });
      return ast;
    }
    function applyReplacement(placeholder, ast, replacement) {
      if (placeholder.isDuplicate) {
        if (Array.isArray(replacement)) {
          replacement = replacement.map((node) => cloneNode2(node));
        } else if (typeof replacement === "object") {
          replacement = cloneNode2(replacement);
        }
      }
      const {
        parent,
        key: key2,
        index
      } = placeholder.resolve(ast);
      if (placeholder.type === "string") {
        if (typeof replacement === "string") {
          replacement = stringLiteral3(replacement);
        }
        if (!replacement || !isStringLiteral(replacement)) {
          throw new Error("Expected string substitution");
        }
      } else if (placeholder.type === "statement") {
        if (index === void 0) {
          if (!replacement) {
            replacement = emptyStatement2();
          } else if (Array.isArray(replacement)) {
            replacement = blockStatement3(replacement);
          } else if (typeof replacement === "string") {
            replacement = expressionStatement2(identifier4(replacement));
          } else if (!isStatement2(replacement)) {
            replacement = expressionStatement2(replacement);
          }
        } else {
          if (replacement && !Array.isArray(replacement)) {
            if (typeof replacement === "string") {
              replacement = identifier4(replacement);
            }
            if (!isStatement2(replacement)) {
              replacement = expressionStatement2(replacement);
            }
          }
        }
      } else if (placeholder.type === "param") {
        if (typeof replacement === "string") {
          replacement = identifier4(replacement);
        }
        if (index === void 0) throw new Error("Assertion failure.");
      } else {
        if (typeof replacement === "string") {
          replacement = identifier4(replacement);
        }
        if (Array.isArray(replacement)) {
          throw new Error("Cannot replace single expression with an array.");
        }
      }
      function set(parent2, key3, value) {
        const node = parent2[key3];
        parent2[key3] = value;
        if (node.type === "Identifier" || node.type === "Placeholder") {
          if (node.typeAnnotation) {
            value.typeAnnotation = node.typeAnnotation;
          }
          if (node.optional) {
            value.optional = node.optional;
          }
          if (node.decorators) {
            value.decorators = node.decorators;
          }
        }
      }
      if (index === void 0) {
        validate2(parent, key2, replacement);
        set(parent, key2, replacement);
      } else {
        const items = parent[key2].slice();
        if (placeholder.type === "statement" || placeholder.type === "param") {
          if (replacement == null) {
            items.splice(index, 1);
          } else if (Array.isArray(replacement)) {
            items.splice(index, 1, ...replacement);
          } else {
            set(items, index, replacement);
          }
        } else {
          set(items, index, replacement);
        }
        validate2(parent, key2, items);
        parent[key2] = items;
      }
    }
  }
});

// ../../node_modules/@babel/template/lib/string.js
var require_string = __commonJS({
  "../../node_modules/@babel/template/lib/string.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = stringTemplate;
    var _options = require_options();
    var _parse = require_parse();
    var _populate = require_populate();
    function stringTemplate(formatter, code, opts) {
      code = formatter.code(code);
      let metadata;
      return (arg) => {
        const replacements = (0, _options.normalizeReplacements)(arg);
        if (!metadata) metadata = (0, _parse.default)(formatter, code, opts);
        return formatter.unwrap((0, _populate.default)(metadata, replacements));
      };
    }
  }
});

// ../../node_modules/@babel/template/lib/literal.js
var require_literal = __commonJS({
  "../../node_modules/@babel/template/lib/literal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = literalTemplate;
    var _options = require_options();
    var _parse = require_parse();
    var _populate = require_populate();
    function literalTemplate(formatter, tpl, opts) {
      const {
        metadata,
        names
      } = buildLiteralData(formatter, tpl, opts);
      return (arg) => {
        const defaultReplacements = {};
        arg.forEach((replacement, i) => {
          defaultReplacements[names[i]] = replacement;
        });
        return (arg2) => {
          const replacements = (0, _options.normalizeReplacements)(arg2);
          if (replacements) {
            Object.keys(replacements).forEach((key2) => {
              if (hasOwnProperty.call(defaultReplacements, key2)) {
                throw new Error("Unexpected replacement overlap.");
              }
            });
          }
          return formatter.unwrap((0, _populate.default)(metadata, replacements ? Object.assign(replacements, defaultReplacements) : defaultReplacements));
        };
      };
    }
    function buildLiteralData(formatter, tpl, opts) {
      let prefix = "BABEL_TPL$";
      const raw = tpl.join("");
      do {
        prefix = "$$" + prefix;
      } while (raw.includes(prefix));
      const {
        names,
        code
      } = buildTemplateCode(tpl, prefix);
      const metadata = (0, _parse.default)(formatter, formatter.code(code), {
        parser: opts.parser,
        placeholderWhitelist: new Set(names.concat(opts.placeholderWhitelist ? Array.from(opts.placeholderWhitelist) : [])),
        placeholderPattern: opts.placeholderPattern,
        preserveComments: opts.preserveComments,
        syntacticPlaceholders: opts.syntacticPlaceholders
      });
      return {
        metadata,
        names
      };
    }
    function buildTemplateCode(tpl, prefix) {
      const names = [];
      let code = tpl[0];
      for (let i = 1; i < tpl.length; i++) {
        const value = `${prefix}${i - 1}`;
        names.push(value);
        code += value + tpl[i];
      }
      return {
        names,
        code
      };
    }
  }
});

// ../../node_modules/@babel/template/lib/builder.js
var require_builder = __commonJS({
  "../../node_modules/@babel/template/lib/builder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = createTemplateBuilder;
    var _options = require_options();
    var _string = require_string();
    var _literal = require_literal();
    var NO_PLACEHOLDER = (0, _options.validate)({
      placeholderPattern: false
    });
    function createTemplateBuilder(formatter, defaultOpts) {
      const templateFnCache = /* @__PURE__ */ new WeakMap();
      const templateAstCache = /* @__PURE__ */ new WeakMap();
      const cachedOpts = defaultOpts || (0, _options.validate)(null);
      return Object.assign((tpl, ...args) => {
        if (typeof tpl === "string") {
          if (args.length > 1) throw new Error("Unexpected extra params.");
          return extendedTrace((0, _string.default)(formatter, tpl, (0, _options.merge)(cachedOpts, (0, _options.validate)(args[0]))));
        } else if (Array.isArray(tpl)) {
          let builder = templateFnCache.get(tpl);
          if (!builder) {
            builder = (0, _literal.default)(formatter, tpl, cachedOpts);
            templateFnCache.set(tpl, builder);
          }
          return extendedTrace(builder(args));
        } else if (typeof tpl === "object" && tpl) {
          if (args.length > 0) throw new Error("Unexpected extra params.");
          return createTemplateBuilder(formatter, (0, _options.merge)(cachedOpts, (0, _options.validate)(tpl)));
        }
        throw new Error(`Unexpected template param ${typeof tpl}`);
      }, {
        ast: (tpl, ...args) => {
          if (typeof tpl === "string") {
            if (args.length > 1) throw new Error("Unexpected extra params.");
            return (0, _string.default)(formatter, tpl, (0, _options.merge)((0, _options.merge)(cachedOpts, (0, _options.validate)(args[0])), NO_PLACEHOLDER))();
          } else if (Array.isArray(tpl)) {
            let builder = templateAstCache.get(tpl);
            if (!builder) {
              builder = (0, _literal.default)(formatter, tpl, (0, _options.merge)(cachedOpts, NO_PLACEHOLDER));
              templateAstCache.set(tpl, builder);
            }
            return builder(args)();
          }
          throw new Error(`Unexpected template param ${typeof tpl}`);
        }
      });
    }
    function extendedTrace(fn) {
      let rootStack = "";
      try {
        throw new Error();
      } catch (error) {
        if (error.stack) {
          rootStack = error.stack.split("\n").slice(3).join("\n");
        }
      }
      return (arg) => {
        try {
          return fn(arg);
        } catch (err) {
          err.stack += `
    =============
${rootStack}`;
          throw err;
        }
      };
    }
  }
});

// ../../node_modules/@babel/template/lib/index.js
var require_lib5 = __commonJS({
  "../../node_modules/@babel/template/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.statements = exports2.statement = exports2.smart = exports2.program = exports2.expression = exports2.default = void 0;
    var formatters = require_formatters();
    var _builder = require_builder();
    var smart = exports2.smart = (0, _builder.default)(formatters.smart);
    var statement = exports2.statement = (0, _builder.default)(formatters.statement);
    var statements = exports2.statements = (0, _builder.default)(formatters.statements);
    var expression = exports2.expression = (0, _builder.default)(formatters.expression);
    var program = exports2.program = (0, _builder.default)(formatters.program);
    var _default = exports2.default = Object.assign(smart.bind(void 0), {
      smart,
      statement,
      statements,
      expression,
      program,
      ast: smart.ast
    });
  }
});

// node_modules/@babel/helpers/node_modules/@babel/traverse/lib/path/conversion.js
var require_conversion = __commonJS({
  "node_modules/@babel/helpers/node_modules/@babel/traverse/lib/path/conversion.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.arrowFunctionToExpression = arrowFunctionToExpression;
    exports2.ensureBlock = ensureBlock;
    exports2.ensureFunctionName = ensureFunctionName;
    exports2.splitExportDeclaration = splitExportDeclaration;
    exports2.toComputedKey = toComputedKey;
    exports2.unwrapFunctionEnvironment = unwrapFunctionEnvironment;
    var _t = require("@babel/types");
    var _template = require_lib5();
    var _visitors = require_visitors();
    var _context3 = require_context2();
    var {
      arrowFunctionExpression: arrowFunctionExpression2,
      assignmentExpression: assignmentExpression2,
      binaryExpression: binaryExpression2,
      blockStatement: blockStatement3,
      callExpression: callExpression3,
      conditionalExpression: conditionalExpression3,
      expressionStatement: expressionStatement2,
      identifier: identifier4,
      isIdentifier,
      jsxIdentifier: jsxIdentifier2,
      logicalExpression: logicalExpression2,
      LOGICAL_OPERATORS,
      memberExpression: memberExpression2,
      metaProperty: metaProperty2,
      numericLiteral: numericLiteral2,
      objectExpression: objectExpression2,
      restElement: restElement3,
      returnStatement: returnStatement3,
      sequenceExpression: sequenceExpression2,
      spreadElement: spreadElement3,
      stringLiteral: stringLiteral3,
      super: _super,
      thisExpression,
      toExpression,
      unaryExpression: unaryExpression2,
      toBindingIdentifierName,
      isFunction,
      isAssignmentPattern,
      isRestElement,
      getFunctionName: getFunctionName3,
      cloneNode: cloneNode2,
      variableDeclaration: variableDeclaration3,
      variableDeclarator: variableDeclarator3,
      exportNamedDeclaration,
      exportSpecifier,
      inherits
    } = _t;
    function toComputedKey() {
      let key2;
      if (this.isMemberExpression()) {
        key2 = this.node.property;
      } else if (this.isProperty() || this.isMethod()) {
        key2 = this.node.key;
      } else {
        throw new ReferenceError("todo");
      }
      if (!this.node.computed) {
        if (isIdentifier(key2)) key2 = stringLiteral3(key2.name);
      }
      return key2;
    }
    function ensureBlock() {
      const body = this.get("body");
      const bodyNode = body.node;
      if (Array.isArray(body)) {
        throw new Error("Can't convert array path to a block statement");
      }
      if (!bodyNode) {
        throw new Error("Can't convert node without a body");
      }
      if (body.isBlockStatement()) {
        return bodyNode;
      }
      const statements = [];
      let stringPath = "body";
      let key2;
      let listKey;
      if (body.isStatement()) {
        listKey = "body";
        key2 = 0;
        statements.push(body.node);
      } else {
        stringPath += ".body.0";
        if (this.isFunction()) {
          key2 = "argument";
          statements.push(returnStatement3(body.node));
        } else {
          key2 = "expression";
          statements.push(expressionStatement2(body.node));
        }
      }
      this.node.body = blockStatement3(statements);
      const parentPath = this.get(stringPath);
      _context3.setup.call(body, parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key2);
      return this.node;
    }
    {
      exports2.arrowFunctionToShadowed = function() {
        if (!this.isArrowFunctionExpression()) return;
        this.arrowFunctionToExpression();
      };
    }
    function unwrapFunctionEnvironment() {
      if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {
        throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
      }
      hoistFunctionEnvironment(this);
    }
    function setType2(path, type) {
      path.node.type = type;
    }
    function arrowFunctionToExpression({
      allowInsertArrow = true,
      allowInsertArrowWithRest = allowInsertArrow,
      noNewArrows = !((_arguments$) => (_arguments$ = arguments[0]) == null ? void 0 : _arguments$.specCompliant)()
    } = {}) {
      if (!this.isArrowFunctionExpression()) {
        throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
      }
      let self2 = this;
      if (!noNewArrows) {
        var _self$ensureFunctionN;
        self2 = (_self$ensureFunctionN = self2.ensureFunctionName(false)) != null ? _self$ensureFunctionN : self2;
      }
      const {
        thisBinding,
        fnPath: fn
      } = hoistFunctionEnvironment(self2, noNewArrows, allowInsertArrow, allowInsertArrowWithRest);
      fn.ensureBlock();
      setType2(fn, "FunctionExpression");
      if (!noNewArrows) {
        const checkBinding = thisBinding ? null : fn.scope.generateUidIdentifier("arrowCheckId");
        if (checkBinding) {
          fn.parentPath.scope.push({
            id: checkBinding,
            init: objectExpression2([])
          });
        }
        fn.get("body").unshiftContainer("body", expressionStatement2(callExpression3(this.hub.addHelper("newArrowCheck"), [thisExpression(), checkBinding ? identifier4(checkBinding.name) : identifier4(thisBinding)])));
        fn.replaceWith(callExpression3(memberExpression2(fn.node, identifier4("bind")), [checkBinding ? identifier4(checkBinding.name) : thisExpression()]));
        return fn.get("callee.object");
      }
      return fn;
    }
    var getSuperCallsVisitor = (0, _visitors.environmentVisitor)({
      CallExpression(child, {
        allSuperCalls
      }) {
        if (!child.get("callee").isSuper()) return;
        allSuperCalls.push(child);
      }
    });
    function hoistFunctionEnvironment(fnPath, noNewArrows = true, allowInsertArrow = true, allowInsertArrowWithRest = true) {
      let arrowParent;
      let thisEnvFn = fnPath.findParent((p) => {
        if (p.isArrowFunctionExpression()) {
          var _arrowParent;
          (_arrowParent = arrowParent) != null ? _arrowParent : arrowParent = p;
          return false;
        }
        return p.isFunction() || p.isProgram() || p.isClassProperty({
          static: false
        }) || p.isClassPrivateProperty({
          static: false
        });
      });
      const inConstructor = thisEnvFn.isClassMethod({
        kind: "constructor"
      });
      if (thisEnvFn.isClassProperty() || thisEnvFn.isClassPrivateProperty()) {
        if (arrowParent) {
          thisEnvFn = arrowParent;
        } else if (allowInsertArrow) {
          fnPath.replaceWith(callExpression3(arrowFunctionExpression2([], toExpression(fnPath.node)), []));
          thisEnvFn = fnPath.get("callee");
          fnPath = thisEnvFn.get("body");
        } else {
          throw fnPath.buildCodeFrameError("Unable to transform arrow inside class property");
        }
      }
      const {
        thisPaths,
        argumentsPaths,
        newTargetPaths,
        superProps,
        superCalls
      } = getScopeInformation(fnPath);
      if (inConstructor && superCalls.length > 0) {
        if (!allowInsertArrow) {
          throw superCalls[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super()` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
        }
        if (!allowInsertArrowWithRest) {
          throw superCalls[0].buildCodeFrameError("When using '@babel/plugin-transform-parameters', it's not possible to compile `super()` in an arrow function with default or rest parameters without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
        }
        const allSuperCalls = [];
        thisEnvFn.traverse(getSuperCallsVisitor, {
          allSuperCalls
        });
        const superBinding = getSuperBinding(thisEnvFn);
        allSuperCalls.forEach((superCall) => {
          const callee = identifier4(superBinding);
          callee.loc = superCall.node.callee.loc;
          superCall.get("callee").replaceWith(callee);
        });
      }
      if (argumentsPaths.length > 0) {
        const argumentsBinding = getBinding(thisEnvFn, "arguments", () => {
          const args = () => identifier4("arguments");
          if (thisEnvFn.scope.path.isProgram()) {
            return conditionalExpression3(binaryExpression2("===", unaryExpression2("typeof", args()), stringLiteral3("undefined")), thisEnvFn.scope.buildUndefinedNode(), args());
          } else {
            return args();
          }
        });
        argumentsPaths.forEach((argumentsChild) => {
          const argsRef = identifier4(argumentsBinding);
          argsRef.loc = argumentsChild.node.loc;
          argumentsChild.replaceWith(argsRef);
        });
      }
      if (newTargetPaths.length > 0) {
        const newTargetBinding = getBinding(thisEnvFn, "newtarget", () => metaProperty2(identifier4("new"), identifier4("target")));
        newTargetPaths.forEach((targetChild) => {
          const targetRef = identifier4(newTargetBinding);
          targetRef.loc = targetChild.node.loc;
          targetChild.replaceWith(targetRef);
        });
      }
      if (superProps.length > 0) {
        if (!allowInsertArrow) {
          throw superProps[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super.prop` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
        }
        const flatSuperProps = superProps.reduce((acc, superProp) => acc.concat(standardizeSuperProperty(superProp)), []);
        flatSuperProps.forEach((superProp) => {
          const key2 = superProp.node.computed ? "" : superProp.get("property").node.name;
          const superParentPath = superProp.parentPath;
          const isAssignment = superParentPath.isAssignmentExpression({
            left: superProp.node
          });
          const isCall = superParentPath.isCallExpression({
            callee: superProp.node
          });
          const isTaggedTemplate = superParentPath.isTaggedTemplateExpression({
            tag: superProp.node
          });
          const superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key2);
          const args = [];
          if (superProp.node.computed) {
            args.push(superProp.get("property").node);
          }
          if (isAssignment) {
            const value = superParentPath.node.right;
            args.push(value);
          }
          const call = callExpression3(identifier4(superBinding), args);
          if (isCall) {
            superParentPath.unshiftContainer("arguments", thisExpression());
            superProp.replaceWith(memberExpression2(call, identifier4("call")));
            thisPaths.push(superParentPath.get("arguments.0"));
          } else if (isAssignment) {
            superParentPath.replaceWith(call);
          } else if (isTaggedTemplate) {
            superProp.replaceWith(callExpression3(memberExpression2(call, identifier4("bind"), false), [thisExpression()]));
            thisPaths.push(superProp.get("arguments.0"));
          } else {
            superProp.replaceWith(call);
          }
        });
      }
      let thisBinding;
      if (thisPaths.length > 0 || !noNewArrows) {
        thisBinding = getThisBinding(thisEnvFn, inConstructor);
        if (noNewArrows || inConstructor && hasSuperClass(thisEnvFn)) {
          thisPaths.forEach((thisChild) => {
            const thisRef = thisChild.isJSX() ? jsxIdentifier2(thisBinding) : identifier4(thisBinding);
            thisRef.loc = thisChild.node.loc;
            thisChild.replaceWith(thisRef);
          });
          if (!noNewArrows) thisBinding = null;
        }
      }
      return {
        thisBinding,
        fnPath
      };
    }
    function isLogicalOp(op) {
      return LOGICAL_OPERATORS.includes(op);
    }
    function standardizeSuperProperty(superProp) {
      if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== "=") {
        const assignmentPath = superProp.parentPath;
        const op = assignmentPath.node.operator.slice(0, -1);
        const value = assignmentPath.node.right;
        const isLogicalAssignment = isLogicalOp(op);
        if (superProp.node.computed) {
          const tmp = superProp.scope.generateDeclaredUidIdentifier("tmp");
          const object = superProp.node.object;
          const property = superProp.node.property;
          assignmentPath.get("left").replaceWith(memberExpression2(object, assignmentExpression2("=", tmp, property), true));
          assignmentPath.get("right").replaceWith(rightExpression(isLogicalAssignment ? "=" : op, memberExpression2(object, identifier4(tmp.name), true), value));
        } else {
          const object = superProp.node.object;
          const property = superProp.node.property;
          assignmentPath.get("left").replaceWith(memberExpression2(object, property));
          assignmentPath.get("right").replaceWith(rightExpression(isLogicalAssignment ? "=" : op, memberExpression2(object, identifier4(property.name)), value));
        }
        if (isLogicalAssignment) {
          assignmentPath.replaceWith(logicalExpression2(op, assignmentPath.node.left, assignmentPath.node.right));
        } else {
          assignmentPath.node.operator = "=";
        }
        return [assignmentPath.get("left"), assignmentPath.get("right").get("left")];
      } else if (superProp.parentPath.isUpdateExpression()) {
        const updateExpr = superProp.parentPath;
        const tmp = superProp.scope.generateDeclaredUidIdentifier("tmp");
        const computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier("prop") : null;
        const parts = [assignmentExpression2("=", tmp, memberExpression2(superProp.node.object, computedKey ? assignmentExpression2("=", computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)), assignmentExpression2("=", memberExpression2(superProp.node.object, computedKey ? identifier4(computedKey.name) : superProp.node.property, superProp.node.computed), binaryExpression2(superProp.parentPath.node.operator[0], identifier4(tmp.name), numericLiteral2(1)))];
        if (!superProp.parentPath.node.prefix) {
          parts.push(identifier4(tmp.name));
        }
        updateExpr.replaceWith(sequenceExpression2(parts));
        const left = updateExpr.get("expressions.0.right");
        const right = updateExpr.get("expressions.1.left");
        return [left, right];
      }
      return [superProp];
      function rightExpression(op, left, right) {
        if (op === "=") {
          return assignmentExpression2("=", left, right);
        } else {
          return binaryExpression2(op, left, right);
        }
      }
    }
    function hasSuperClass(thisEnvFn) {
      return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;
    }
    var assignSuperThisVisitor = (0, _visitors.environmentVisitor)({
      CallExpression(child, {
        supers,
        thisBinding
      }) {
        if (!child.get("callee").isSuper()) return;
        if (supers.has(child.node)) return;
        supers.add(child.node);
        child.replaceWithMultiple([child.node, assignmentExpression2("=", identifier4(thisBinding), identifier4("this"))]);
      }
    });
    function getThisBinding(thisEnvFn, inConstructor) {
      return getBinding(thisEnvFn, "this", (thisBinding) => {
        if (!inConstructor || !hasSuperClass(thisEnvFn)) return thisExpression();
        thisEnvFn.traverse(assignSuperThisVisitor, {
          supers: /* @__PURE__ */ new WeakSet(),
          thisBinding
        });
      });
    }
    function getSuperBinding(thisEnvFn) {
      return getBinding(thisEnvFn, "supercall", () => {
        const argsBinding = thisEnvFn.scope.generateUidIdentifier("args");
        return arrowFunctionExpression2([restElement3(argsBinding)], callExpression3(_super(), [spreadElement3(identifier4(argsBinding.name))]));
      });
    }
    function getSuperPropBinding(thisEnvFn, isAssignment, propName) {
      const op = isAssignment ? "set" : "get";
      return getBinding(thisEnvFn, `superprop_${op}:${propName || ""}`, () => {
        const argsList = [];
        let fnBody;
        if (propName) {
          fnBody = memberExpression2(_super(), identifier4(propName));
        } else {
          const method = thisEnvFn.scope.generateUidIdentifier("prop");
          argsList.unshift(method);
          fnBody = memberExpression2(_super(), identifier4(method.name), true);
        }
        if (isAssignment) {
          const valueIdent = thisEnvFn.scope.generateUidIdentifier("value");
          argsList.push(valueIdent);
          fnBody = assignmentExpression2("=", fnBody, identifier4(valueIdent.name));
        }
        return arrowFunctionExpression2(argsList, fnBody);
      });
    }
    function getBinding(thisEnvFn, key2, init) {
      const cacheKey = "binding:" + key2;
      let data = thisEnvFn.getData(cacheKey);
      if (!data) {
        const id = thisEnvFn.scope.generateUidIdentifier(key2);
        data = id.name;
        thisEnvFn.setData(cacheKey, data);
        thisEnvFn.scope.push({
          id,
          init: init(data)
        });
      }
      return data;
    }
    var getScopeInformationVisitor = (0, _visitors.environmentVisitor)({
      ThisExpression(child, {
        thisPaths
      }) {
        thisPaths.push(child);
      },
      JSXIdentifier(child, {
        thisPaths
      }) {
        if (child.node.name !== "this") return;
        if (!child.parentPath.isJSXMemberExpression({
          object: child.node
        }) && !child.parentPath.isJSXOpeningElement({
          name: child.node
        })) {
          return;
        }
        thisPaths.push(child);
      },
      CallExpression(child, {
        superCalls
      }) {
        if (child.get("callee").isSuper()) superCalls.push(child);
      },
      MemberExpression(child, {
        superProps
      }) {
        if (child.get("object").isSuper()) superProps.push(child);
      },
      Identifier(child, {
        argumentsPaths
      }) {
        if (!child.isReferencedIdentifier({
          name: "arguments"
        })) return;
        let curr = child.scope;
        do {
          if (curr.hasOwnBinding("arguments")) {
            curr.rename("arguments");
            return;
          }
          if (curr.path.isFunction() && !curr.path.isArrowFunctionExpression()) {
            break;
          }
        } while (curr = curr.parent);
        argumentsPaths.push(child);
      },
      MetaProperty(child, {
        newTargetPaths
      }) {
        if (!child.get("meta").isIdentifier({
          name: "new"
        })) return;
        if (!child.get("property").isIdentifier({
          name: "target"
        })) return;
        newTargetPaths.push(child);
      }
    });
    function getScopeInformation(fnPath) {
      const thisPaths = [];
      const argumentsPaths = [];
      const newTargetPaths = [];
      const superProps = [];
      const superCalls = [];
      fnPath.traverse(getScopeInformationVisitor, {
        thisPaths,
        argumentsPaths,
        newTargetPaths,
        superProps,
        superCalls
      });
      return {
        thisPaths,
        argumentsPaths,
        newTargetPaths,
        superProps,
        superCalls
      };
    }
    function splitExportDeclaration() {
      if (!this.isExportDeclaration() || this.isExportAllDeclaration()) {
        throw new Error("Only default and named export declarations can be split.");
      }
      if (this.isExportNamedDeclaration() && this.get("specifiers").length > 0) {
        throw new Error("It doesn't make sense to split exported specifiers.");
      }
      const declaration = this.get("declaration");
      if (this.isExportDefaultDeclaration()) {
        const standaloneDeclaration = declaration.isFunctionDeclaration() || declaration.isClassDeclaration();
        const exportExpr = declaration.isFunctionExpression() || declaration.isClassExpression();
        const scope = declaration.isScope() ? declaration.scope.parent : declaration.scope;
        let id = declaration.node.id;
        let needBindingRegistration = false;
        if (!id) {
          needBindingRegistration = true;
          id = scope.generateUidIdentifier("default");
          if (standaloneDeclaration || exportExpr) {
            declaration.node.id = cloneNode2(id);
          }
        } else if (exportExpr && scope.hasBinding(id.name)) {
          needBindingRegistration = true;
          id = scope.generateUidIdentifier(id.name);
        }
        const updatedDeclaration = standaloneDeclaration ? declaration.node : variableDeclaration3("var", [variableDeclarator3(cloneNode2(id), declaration.node)]);
        const updatedExportDeclaration = exportNamedDeclaration(null, [exportSpecifier(cloneNode2(id), identifier4("default"))]);
        this.insertAfter(updatedExportDeclaration);
        this.replaceWith(updatedDeclaration);
        if (needBindingRegistration) {
          scope.registerDeclaration(this);
        }
        return this;
      } else if (this.get("specifiers").length > 0) {
        throw new Error("It doesn't make sense to split exported specifiers.");
      }
      const bindingIdentifiers = declaration.getOuterBindingIdentifiers();
      const specifiers = Object.keys(bindingIdentifiers).map((name) => {
        return exportSpecifier(identifier4(name), identifier4(name));
      });
      const aliasDeclar = exportNamedDeclaration(null, specifiers);
      this.insertAfter(aliasDeclar);
      this.replaceWith(declaration.node);
      return this;
    }
    var refersOuterBindingVisitor = {
      "ReferencedIdentifier|BindingIdentifier"(path, state) {
        if (path.node.name !== state.name) return;
        state.needsRename = true;
        path.stop();
      },
      Scope(path, state) {
        if (path.scope.hasOwnBinding(state.name)) {
          path.skip();
        }
      }
    };
    function ensureFunctionName(supportUnicodeId) {
      if (this.node.id) return this;
      const res = getFunctionName3(this.node, this.parent);
      if (res == null) return this;
      let {
        name
      } = res;
      if (!supportUnicodeId && /[\uD800-\uDFFF]/.test(name)) {
        return null;
      }
      if (name.startsWith("get ") || name.startsWith("set ")) {
        return null;
      }
      name = toBindingIdentifierName(name.replace(/[/ ]/g, "_"));
      const id = identifier4(name);
      inherits(id, res.originalNode);
      const state = {
        needsRename: false,
        name
      };
      const {
        scope
      } = this;
      const binding = scope.getOwnBinding(name);
      if (binding) {
        if (binding.kind === "param") {
          state.needsRename = true;
        } else {
        }
      } else if (scope.parent.hasBinding(name) || scope.hasGlobal(name)) {
        this.traverse(refersOuterBindingVisitor, state);
      }
      if (!state.needsRename) {
        this.node.id = id;
        scope.getProgramParent().references[id.name] = true;
        return this;
      }
      if (scope.hasBinding(id.name) && !scope.hasGlobal(id.name)) {
        scope.rename(id.name);
        this.node.id = id;
        scope.getProgramParent().references[id.name] = true;
        return this;
      }
      if (!isFunction(this.node)) return null;
      const key2 = scope.generateUidIdentifier(id.name);
      const params = [];
      for (let i = 0, len = getFunctionArity(this.node); i < len; i++) {
        params.push(scope.generateUidIdentifier("x"));
      }
      const call = _template.default.expression.ast`
    (function (${key2}) {
      function ${id}(${params}) {
        return ${cloneNode2(key2)}.apply(this, arguments);
      }

      ${cloneNode2(id)}.toString = function () {
        return ${cloneNode2(key2)}.toString();
      }

      return ${cloneNode2(id)};
    })(${toExpression(this.node)})
  `;
      return this.replaceWith(call)[0].get("arguments.0");
    }
    function getFunctionArity(node) {
      const count = node.params.findIndex((param) => isAssignmentPattern(param) || isRestElement(param));
      return count === -1 ? node.params.length : count;
    }
  }
});

// node_modules/@babel/helpers/node_modules/@babel/traverse/lib/path/introspection.js
var require_introspection = __commonJS({
  "node_modules/@babel/helpers/node_modules/@babel/traverse/lib/path/introspection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2._guessExecutionStatusRelativeTo = _guessExecutionStatusRelativeTo;
    exports2._resolve = _resolve;
    exports2.canHaveVariableDeclarationOrExpression = canHaveVariableDeclarationOrExpression;
    exports2.canSwapBetweenExpressionAndStatement = canSwapBetweenExpressionAndStatement;
    exports2.getSource = getSource;
    exports2.isCompletionRecord = isCompletionRecord;
    exports2.isConstantExpression = isConstantExpression;
    exports2.isInStrictMode = isInStrictMode;
    exports2.isNodeType = isNodeType;
    exports2.isStatementOrBlock = isStatementOrBlock;
    exports2.isStatic = isStatic;
    exports2.matchesPattern = matchesPattern;
    exports2.referencesImport = referencesImport;
    exports2.resolve = resolve;
    exports2.willIMaybeExecuteBefore = willIMaybeExecuteBefore;
    var _t = require("@babel/types");
    var {
      STATEMENT_OR_BLOCK_KEYS,
      VISITOR_KEYS,
      isBlockStatement,
      isExpression: isExpression2,
      isIdentifier,
      isLiteral,
      isStringLiteral,
      isType,
      matchesPattern: _matchesPattern
    } = _t;
    function matchesPattern(pattern, allowPartial) {
      return _matchesPattern(this.node, pattern, allowPartial);
    }
    {
      exports2.has = function has(key2) {
        var _this$node;
        const val = (_this$node = this.node) == null ? void 0 : _this$node[key2];
        if (val && Array.isArray(val)) {
          return !!val.length;
        } else {
          return !!val;
        }
      };
    }
    function isStatic() {
      return this.scope.isStatic(this.node);
    }
    {
      exports2.is = exports2.has;
      exports2.isnt = function isnt(key2) {
        return !this.has(key2);
      };
      exports2.equals = function equals(key2, value) {
        return this.node[key2] === value;
      };
    }
    function isNodeType(type) {
      return isType(this.type, type);
    }
    function canHaveVariableDeclarationOrExpression() {
      return (this.key === "init" || this.key === "left") && this.parentPath.isFor();
    }
    function canSwapBetweenExpressionAndStatement(replacement) {
      if (this.key !== "body" || !this.parentPath.isArrowFunctionExpression()) {
        return false;
      }
      if (this.isExpression()) {
        return isBlockStatement(replacement);
      } else if (this.isBlockStatement()) {
        return isExpression2(replacement);
      }
      return false;
    }
    function isCompletionRecord(allowInsideFunction) {
      let path = this;
      let first = true;
      do {
        const {
          type,
          container
        } = path;
        if (!first && (path.isFunction() || type === "StaticBlock")) {
          return !!allowInsideFunction;
        }
        first = false;
        if (Array.isArray(container) && path.key !== container.length - 1) {
          return false;
        }
      } while ((path = path.parentPath) && !path.isProgram() && !path.isDoExpression());
      return true;
    }
    function isStatementOrBlock() {
      if (this.parentPath.isLabeledStatement() || isBlockStatement(this.container)) {
        return false;
      } else {
        return STATEMENT_OR_BLOCK_KEYS.includes(this.key);
      }
    }
    function referencesImport(moduleSource, importName) {
      if (!this.isReferencedIdentifier()) {
        if (this.isJSXMemberExpression() && this.node.property.name === importName || (this.isMemberExpression() || this.isOptionalMemberExpression()) && (this.node.computed ? isStringLiteral(this.node.property, {
          value: importName
        }) : this.node.property.name === importName)) {
          const object = this.get("object");
          return object.isReferencedIdentifier() && object.referencesImport(moduleSource, "*");
        }
        return false;
      }
      const binding = this.scope.getBinding(this.node.name);
      if (!binding || binding.kind !== "module") return false;
      const path = binding.path;
      const parent = path.parentPath;
      if (!parent.isImportDeclaration()) return false;
      if (parent.node.source.value === moduleSource) {
        if (!importName) return true;
      } else {
        return false;
      }
      if (path.isImportDefaultSpecifier() && importName === "default") {
        return true;
      }
      if (path.isImportNamespaceSpecifier() && importName === "*") {
        return true;
      }
      if (path.isImportSpecifier() && isIdentifier(path.node.imported, {
        name: importName
      })) {
        return true;
      }
      return false;
    }
    function getSource() {
      const node = this.node;
      if (node.end) {
        const code = this.hub.getCode();
        if (code) return code.slice(node.start, node.end);
      }
      return "";
    }
    function willIMaybeExecuteBefore(target) {
      return this._guessExecutionStatusRelativeTo(target) !== "after";
    }
    function getOuterFunction(path) {
      return path.isProgram() ? path : (path.parentPath.scope.getFunctionParent() || path.parentPath.scope.getProgramParent()).path;
    }
    function isExecutionUncertain(type, key2) {
      switch (type) {
        case "LogicalExpression":
          return key2 === "right";
        case "ConditionalExpression":
        case "IfStatement":
          return key2 === "consequent" || key2 === "alternate";
        case "WhileStatement":
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForOfStatement":
          return key2 === "body";
        case "ForStatement":
          return key2 === "body" || key2 === "update";
        case "SwitchStatement":
          return key2 === "cases";
        case "TryStatement":
          return key2 === "handler";
        case "AssignmentPattern":
          return key2 === "right";
        case "OptionalMemberExpression":
          return key2 === "property";
        case "OptionalCallExpression":
          return key2 === "arguments";
        default:
          return false;
      }
    }
    function isExecutionUncertainInList(paths, maxIndex) {
      for (let i = 0; i < maxIndex; i++) {
        const path = paths[i];
        if (isExecutionUncertain(path.parent.type, path.parentKey)) {
          return true;
        }
      }
      return false;
    }
    var SYMBOL_CHECKING = Symbol();
    function _guessExecutionStatusRelativeTo(target) {
      return _guessExecutionStatusRelativeToCached(this, target, /* @__PURE__ */ new Map());
    }
    function _guessExecutionStatusRelativeToCached(base, target, cache) {
      const funcParent = {
        this: getOuterFunction(base),
        target: getOuterFunction(target)
      };
      if (funcParent.target.node !== funcParent.this.node) {
        return _guessExecutionStatusRelativeToDifferentFunctionsCached(base, funcParent.target, cache);
      }
      const paths = {
        target: target.getAncestry(),
        this: base.getAncestry()
      };
      if (paths.target.includes(base)) return "after";
      if (paths.this.includes(target)) return "before";
      let commonPath;
      const commonIndex = {
        target: 0,
        this: 0
      };
      while (!commonPath && commonIndex.this < paths.this.length) {
        const path = paths.this[commonIndex.this];
        commonIndex.target = paths.target.indexOf(path);
        if (commonIndex.target >= 0) {
          commonPath = path;
        } else {
          commonIndex.this++;
        }
      }
      if (!commonPath) {
        throw new Error("Internal Babel error - The two compared nodes don't appear to belong to the same program.");
      }
      if (isExecutionUncertainInList(paths.this, commonIndex.this - 1) || isExecutionUncertainInList(paths.target, commonIndex.target - 1)) {
        return "unknown";
      }
      const divergence = {
        this: paths.this[commonIndex.this - 1],
        target: paths.target[commonIndex.target - 1]
      };
      if (divergence.target.listKey && divergence.this.listKey && divergence.target.container === divergence.this.container) {
        return divergence.target.key > divergence.this.key ? "before" : "after";
      }
      const keys = VISITOR_KEYS[commonPath.type];
      const keyPosition = {
        this: keys.indexOf(divergence.this.parentKey),
        target: keys.indexOf(divergence.target.parentKey)
      };
      return keyPosition.target > keyPosition.this ? "before" : "after";
    }
    function _guessExecutionStatusRelativeToDifferentFunctionsInternal(base, target, cache) {
      if (!target.isFunctionDeclaration()) {
        if (_guessExecutionStatusRelativeToCached(base, target, cache) === "before") {
          return "before";
        }
        return "unknown";
      } else if (target.parentPath.isExportDeclaration()) {
        return "unknown";
      }
      const binding = target.scope.getBinding(target.node.id.name);
      if (!binding.references) return "before";
      const referencePaths = binding.referencePaths;
      let allStatus;
      for (const path of referencePaths) {
        const childOfFunction = !!path.find((path2) => path2.node === target.node);
        if (childOfFunction) continue;
        if (path.key !== "callee" || !path.parentPath.isCallExpression()) {
          return "unknown";
        }
        const status = _guessExecutionStatusRelativeToCached(base, path, cache);
        if (allStatus && allStatus !== status) {
          return "unknown";
        } else {
          allStatus = status;
        }
      }
      return allStatus;
    }
    function _guessExecutionStatusRelativeToDifferentFunctionsCached(base, target, cache) {
      let nodeMap = cache.get(base.node);
      let cached;
      if (!nodeMap) {
        cache.set(base.node, nodeMap = /* @__PURE__ */ new Map());
      } else if (cached = nodeMap.get(target.node)) {
        if (cached === SYMBOL_CHECKING) {
          return "unknown";
        }
        return cached;
      }
      nodeMap.set(target.node, SYMBOL_CHECKING);
      const result = _guessExecutionStatusRelativeToDifferentFunctionsInternal(base, target, cache);
      nodeMap.set(target.node, result);
      return result;
    }
    function resolve(dangerous, resolved) {
      return _resolve.call(this, dangerous, resolved) || this;
    }
    function _resolve(dangerous, resolved) {
      var _resolved;
      if ((_resolved = resolved) != null && _resolved.includes(this)) return;
      resolved = resolved || [];
      resolved.push(this);
      if (this.isVariableDeclarator()) {
        if (this.get("id").isIdentifier()) {
          return this.get("init").resolve(dangerous, resolved);
        } else {
        }
      } else if (this.isReferencedIdentifier()) {
        const binding = this.scope.getBinding(this.node.name);
        if (!binding) return;
        if (!binding.constant) return;
        if (binding.kind === "module") return;
        if (binding.path !== this) {
          const ret = binding.path.resolve(dangerous, resolved);
          if (this.find((parent) => parent.node === ret.node)) return;
          return ret;
        }
      } else if (this.isTypeCastExpression()) {
        return this.get("expression").resolve(dangerous, resolved);
      } else if (dangerous && this.isMemberExpression()) {
        const targetKey = this.toComputedKey();
        if (!isLiteral(targetKey)) return;
        const targetName = targetKey.value;
        const target = this.get("object").resolve(dangerous, resolved);
        if (target.isObjectExpression()) {
          const props = target.get("properties");
          for (const prop of props) {
            if (!prop.isProperty()) continue;
            const key2 = prop.get("key");
            let match = prop.isnt("computed") && key2.isIdentifier({
              name: targetName
            });
            match = match || key2.isLiteral({
              value: targetName
            });
            if (match) return prop.get("value").resolve(dangerous, resolved);
          }
        } else if (target.isArrayExpression() && !isNaN(+targetName)) {
          const elems = target.get("elements");
          const elem = elems[targetName];
          if (elem) return elem.resolve(dangerous, resolved);
        }
      }
    }
    function isConstantExpression() {
      if (this.isIdentifier()) {
        const binding = this.scope.getBinding(this.node.name);
        if (!binding) return false;
        return binding.constant;
      }
      if (this.isLiteral()) {
        if (this.isRegExpLiteral()) {
          return false;
        }
        if (this.isTemplateLiteral()) {
          return this.get("expressions").every((expression) => expression.isConstantExpression());
        }
        return true;
      }
      if (this.isUnaryExpression()) {
        if (this.node.operator !== "void") {
          return false;
        }
        return this.get("argument").isConstantExpression();
      }
      if (this.isBinaryExpression()) {
        const {
          operator
        } = this.node;
        return operator !== "in" && operator !== "instanceof" && this.get("left").isConstantExpression() && this.get("right").isConstantExpression();
      }
      if (this.isMemberExpression()) {
        return !this.node.computed && this.get("object").isIdentifier({
          name: "Symbol"
        }) && !this.scope.hasBinding("Symbol", {
          noGlobals: true
        });
      }
      if (this.isCallExpression()) {
        return this.node.arguments.length === 1 && this.get("callee").matchesPattern("Symbol.for") && !this.scope.hasBinding("Symbol", {
          noGlobals: true
        }) && this.get("arguments")[0].isStringLiteral();
      }
      return false;
    }
    function isInStrictMode() {
      const start = this.isProgram() ? this : this.parentPath;
      const strictParent = start.find((path) => {
        if (path.isProgram({
          sourceType: "module"
        })) return true;
        if (path.isClass()) return true;
        if (path.isArrowFunctionExpression() && !path.get("body").isBlockStatement()) {
          return false;
        }
        let body;
        if (path.isFunction()) {
          body = path.node.body;
        } else if (path.isProgram()) {
          body = path.node;
        } else {
          return false;
        }
        for (const directive2 of body.directives) {
          if (directive2.value.value === "use strict") {
            return true;
          }
        }
      });
      return !!strictParent;
    }
  }
});

// node_modules/@babel/helpers/node_modules/@babel/traverse/lib/path/family.js
var require_family = __commonJS({
  "node_modules/@babel/helpers/node_modules/@babel/traverse/lib/path/family.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2._getKey = _getKey;
    exports2._getPattern = _getPattern;
    exports2.get = get;
    exports2.getAllNextSiblings = getAllNextSiblings;
    exports2.getAllPrevSiblings = getAllPrevSiblings;
    exports2.getAssignmentIdentifiers = getAssignmentIdentifiers;
    exports2.getBindingIdentifierPaths = getBindingIdentifierPaths;
    exports2.getBindingIdentifiers = getBindingIdentifiers;
    exports2.getCompletionRecords = getCompletionRecords;
    exports2.getNextSibling = getNextSibling;
    exports2.getOpposite = getOpposite;
    exports2.getOuterBindingIdentifierPaths = getOuterBindingIdentifierPaths;
    exports2.getOuterBindingIdentifiers = getOuterBindingIdentifiers;
    exports2.getPrevSibling = getPrevSibling;
    exports2.getSibling = getSibling;
    var _index = require_path();
    var _t = require("@babel/types");
    var {
      getAssignmentIdentifiers: _getAssignmentIdentifiers,
      getBindingIdentifiers: _getBindingIdentifiers,
      getOuterBindingIdentifiers: _getOuterBindingIdentifiers,
      numericLiteral: numericLiteral2,
      unaryExpression: unaryExpression2
    } = _t;
    var NORMAL_COMPLETION = 0;
    var BREAK_COMPLETION = 1;
    function NormalCompletion(path) {
      return {
        type: NORMAL_COMPLETION,
        path
      };
    }
    function BreakCompletion(path) {
      return {
        type: BREAK_COMPLETION,
        path
      };
    }
    function getOpposite() {
      if (this.key === "left") {
        return this.getSibling("right");
      } else if (this.key === "right") {
        return this.getSibling("left");
      }
      return null;
    }
    function addCompletionRecords(path, records, context) {
      if (path) {
        records.push(..._getCompletionRecords(path, context));
      }
      return records;
    }
    function completionRecordForSwitch(cases, records, context) {
      let lastNormalCompletions = [];
      for (let i = 0; i < cases.length; i++) {
        const casePath = cases[i];
        const caseCompletions = _getCompletionRecords(casePath, context);
        const normalCompletions = [];
        const breakCompletions = [];
        for (const c2 of caseCompletions) {
          if (c2.type === NORMAL_COMPLETION) {
            normalCompletions.push(c2);
          }
          if (c2.type === BREAK_COMPLETION) {
            breakCompletions.push(c2);
          }
        }
        if (normalCompletions.length) {
          lastNormalCompletions = normalCompletions;
        }
        records.push(...breakCompletions);
      }
      records.push(...lastNormalCompletions);
      return records;
    }
    function normalCompletionToBreak(completions) {
      completions.forEach((c2) => {
        c2.type = BREAK_COMPLETION;
      });
    }
    function replaceBreakStatementInBreakCompletion(completions, reachable) {
      completions.forEach((c2) => {
        if (c2.path.isBreakStatement({
          label: null
        })) {
          if (reachable) {
            c2.path.replaceWith(unaryExpression2("void", numericLiteral2(0)));
          } else {
            c2.path.remove();
          }
        }
      });
    }
    function getStatementListCompletion(paths, context) {
      const completions = [];
      if (context.canHaveBreak) {
        let lastNormalCompletions = [];
        for (let i = 0; i < paths.length; i++) {
          const path = paths[i];
          const newContext = Object.assign({}, context, {
            inCaseClause: false
          });
          if (path.isBlockStatement() && (context.inCaseClause || context.shouldPopulateBreak)) {
            newContext.shouldPopulateBreak = true;
          } else {
            newContext.shouldPopulateBreak = false;
          }
          const statementCompletions = _getCompletionRecords(path, newContext);
          if (statementCompletions.length > 0 && statementCompletions.every((c2) => c2.type === BREAK_COMPLETION)) {
            if (lastNormalCompletions.length > 0 && statementCompletions.every((c2) => c2.path.isBreakStatement({
              label: null
            }))) {
              normalCompletionToBreak(lastNormalCompletions);
              completions.push(...lastNormalCompletions);
              if (lastNormalCompletions.some((c2) => c2.path.isDeclaration())) {
                completions.push(...statementCompletions);
                replaceBreakStatementInBreakCompletion(statementCompletions, true);
              }
              replaceBreakStatementInBreakCompletion(statementCompletions, false);
            } else {
              completions.push(...statementCompletions);
              if (!context.shouldPopulateBreak) {
                replaceBreakStatementInBreakCompletion(statementCompletions, true);
              }
            }
            break;
          }
          if (i === paths.length - 1) {
            completions.push(...statementCompletions);
          } else {
            lastNormalCompletions = [];
            for (let i2 = 0; i2 < statementCompletions.length; i2++) {
              const c2 = statementCompletions[i2];
              if (c2.type === BREAK_COMPLETION) {
                completions.push(c2);
              }
              if (c2.type === NORMAL_COMPLETION) {
                lastNormalCompletions.push(c2);
              }
            }
          }
        }
      } else if (paths.length) {
        for (let i = paths.length - 1; i >= 0; i--) {
          const pathCompletions = _getCompletionRecords(paths[i], context);
          if (pathCompletions.length > 1 || pathCompletions.length === 1 && !pathCompletions[0].path.isVariableDeclaration()) {
            completions.push(...pathCompletions);
            break;
          }
        }
      }
      return completions;
    }
    function _getCompletionRecords(path, context) {
      let records = [];
      if (path.isIfStatement()) {
        records = addCompletionRecords(path.get("consequent"), records, context);
        records = addCompletionRecords(path.get("alternate"), records, context);
      } else if (path.isDoExpression() || path.isFor() || path.isWhile() || path.isLabeledStatement()) {
        return addCompletionRecords(path.get("body"), records, context);
      } else if (path.isProgram() || path.isBlockStatement()) {
        return getStatementListCompletion(path.get("body"), context);
      } else if (path.isFunction()) {
        return _getCompletionRecords(path.get("body"), context);
      } else if (path.isTryStatement()) {
        records = addCompletionRecords(path.get("block"), records, context);
        records = addCompletionRecords(path.get("handler"), records, context);
      } else if (path.isCatchClause()) {
        return addCompletionRecords(path.get("body"), records, context);
      } else if (path.isSwitchStatement()) {
        return completionRecordForSwitch(path.get("cases"), records, context);
      } else if (path.isSwitchCase()) {
        return getStatementListCompletion(path.get("consequent"), {
          canHaveBreak: true,
          shouldPopulateBreak: false,
          inCaseClause: true
        });
      } else if (path.isBreakStatement()) {
        records.push(BreakCompletion(path));
      } else {
        records.push(NormalCompletion(path));
      }
      return records;
    }
    function getCompletionRecords() {
      const records = _getCompletionRecords(this, {
        canHaveBreak: false,
        shouldPopulateBreak: false,
        inCaseClause: false
      });
      return records.map((r) => r.path);
    }
    function getSibling(key2) {
      return _index.default.get({
        parentPath: this.parentPath,
        parent: this.parent,
        container: this.container,
        listKey: this.listKey,
        key: key2
      }).setContext(this.context);
    }
    function getPrevSibling() {
      return this.getSibling(this.key - 1);
    }
    function getNextSibling() {
      return this.getSibling(this.key + 1);
    }
    function getAllNextSiblings() {
      let _key = this.key;
      let sibling = this.getSibling(++_key);
      const siblings = [];
      while (sibling.node) {
        siblings.push(sibling);
        sibling = this.getSibling(++_key);
      }
      return siblings;
    }
    function getAllPrevSiblings() {
      let _key = this.key;
      let sibling = this.getSibling(--_key);
      const siblings = [];
      while (sibling.node) {
        siblings.push(sibling);
        sibling = this.getSibling(--_key);
      }
      return siblings;
    }
    function get(key2, context = true) {
      if (context === true) context = this.context;
      const parts = key2.split(".");
      if (parts.length === 1) {
        return _getKey.call(this, key2, context);
      } else {
        return _getPattern.call(this, parts, context);
      }
    }
    function _getKey(key2, context) {
      const node = this.node;
      const container = node[key2];
      if (Array.isArray(container)) {
        return container.map((_, i) => {
          return _index.default.get({
            listKey: key2,
            parentPath: this,
            parent: node,
            container,
            key: i
          }).setContext(context);
        });
      } else {
        return _index.default.get({
          parentPath: this,
          parent: node,
          container: node,
          key: key2
        }).setContext(context);
      }
    }
    function _getPattern(parts, context) {
      let path = this;
      for (const part of parts) {
        if (part === ".") {
          path = path.parentPath;
        } else {
          if (Array.isArray(path)) {
            path = path[part];
          } else {
            path = path.get(part, context);
          }
        }
      }
      return path;
    }
    function getAssignmentIdentifiers() {
      return _getAssignmentIdentifiers(this.node);
    }
    function getBindingIdentifiers(duplicates) {
      return _getBindingIdentifiers(this.node, duplicates);
    }
    function getOuterBindingIdentifiers(duplicates) {
      return _getOuterBindingIdentifiers(this.node, duplicates);
    }
    function getBindingIdentifierPaths(duplicates = false, outerOnly = false) {
      const path = this;
      const search = [path];
      const ids = /* @__PURE__ */ Object.create(null);
      while (search.length) {
        const id = search.shift();
        if (!id) continue;
        if (!id.node) continue;
        const keys = _getBindingIdentifiers.keys[id.node.type];
        if (id.isIdentifier()) {
          if (duplicates) {
            const _ids = ids[id.node.name] = ids[id.node.name] || [];
            _ids.push(id);
          } else {
            ids[id.node.name] = id;
          }
          continue;
        }
        if (id.isExportDeclaration()) {
          const declaration = id.get("declaration");
          if (declaration.isDeclaration()) {
            search.push(declaration);
          }
          continue;
        }
        if (outerOnly) {
          if (id.isFunctionDeclaration()) {
            search.push(id.get("id"));
            continue;
          }
          if (id.isFunctionExpression()) {
            continue;
          }
        }
        if (keys) {
          for (let i = 0; i < keys.length; i++) {
            const key2 = keys[i];
            const child = id.get(key2);
            if (Array.isArray(child)) {
              search.push(...child);
            } else if (child.node) {
              search.push(child);
            }
          }
        }
      }
      return ids;
    }
    function getOuterBindingIdentifierPaths(duplicates = false) {
      return this.getBindingIdentifierPaths(duplicates, true);
    }
  }
});

// node_modules/@babel/helpers/node_modules/@babel/traverse/lib/path/comments.js
var require_comments = __commonJS({
  "node_modules/@babel/helpers/node_modules/@babel/traverse/lib/path/comments.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.addComment = addComment2;
    exports2.addComments = addComments;
    exports2.shareCommentsWithSiblings = shareCommentsWithSiblings;
    var _t = require("@babel/types");
    var {
      addComment: _addComment,
      addComments: _addComments
    } = _t;
    function shareCommentsWithSiblings() {
      if (typeof this.key === "string") return;
      const node = this.node;
      if (!node) return;
      const trailing = node.trailingComments;
      const leading = node.leadingComments;
      if (!trailing && !leading) return;
      const prev = this.getSibling(this.key - 1);
      const next = this.getSibling(this.key + 1);
      const hasPrev = Boolean(prev.node);
      const hasNext = Boolean(next.node);
      if (hasPrev) {
        if (leading) {
          prev.addComments("trailing", removeIfExisting(leading, prev.node.trailingComments));
        }
        if (trailing && !hasNext) prev.addComments("trailing", trailing);
      }
      if (hasNext) {
        if (trailing) {
          next.addComments("leading", removeIfExisting(trailing, next.node.leadingComments));
        }
        if (leading && !hasPrev) next.addComments("leading", leading);
      }
    }
    function removeIfExisting(list, toRemove) {
      if (!(toRemove != null && toRemove.length)) return list;
      const set = new Set(toRemove);
      return list.filter((el) => {
        return !set.has(el);
      });
    }
    function addComment2(type, content, line2) {
      _addComment(this.node, type, content, line2);
    }
    function addComments(type, comments) {
      _addComments(this.node, type, comments);
    }
  }
});

// node_modules/@babel/helpers/node_modules/@babel/traverse/lib/path/index.js
var require_path = __commonJS({
  "node_modules/@babel/helpers/node_modules/@babel/traverse/lib/path/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = exports2.SHOULD_STOP = exports2.SHOULD_SKIP = exports2.REMOVED = void 0;
    var virtualTypes = require_virtual_types();
    var _debug = require_src();
    var _index = require_lib6();
    var _index2 = require_scope();
    var _t = require("@babel/types");
    var t6 = _t;
    var cache = require_cache();
    var _generator = require_lib();
    var NodePath_ancestry = require_ancestry();
    var NodePath_inference = require_inference();
    var NodePath_replacement = require_replacement();
    var NodePath_evaluation = require_evaluation();
    var NodePath_conversion = require_conversion();
    var NodePath_introspection = require_introspection();
    var _context3 = require_context2();
    var NodePath_context = _context3;
    var NodePath_removal = require_removal();
    var NodePath_modification = require_modification();
    var NodePath_family = require_family();
    var NodePath_comments = require_comments();
    var NodePath_virtual_types_validator = require_virtual_types_validator();
    var {
      validate: validate2
    } = _t;
    var debug = _debug("babel");
    var REMOVED = exports2.REMOVED = 1 << 0;
    var SHOULD_STOP = exports2.SHOULD_STOP = 1 << 1;
    var SHOULD_SKIP = exports2.SHOULD_SKIP = 1 << 2;
    var NodePath_Final = exports2.default = class NodePath {
      constructor(hub, parent) {
        this.contexts = [];
        this.state = null;
        this.opts = null;
        this._traverseFlags = 0;
        this.skipKeys = null;
        this.parentPath = null;
        this.container = null;
        this.listKey = null;
        this.key = null;
        this.node = null;
        this.type = null;
        this.parent = parent;
        this.hub = hub;
        this.data = null;
        this.context = null;
        this.scope = null;
      }
      get removed() {
        return (this._traverseFlags & 1) > 0;
      }
      set removed(v) {
        if (v) this._traverseFlags |= 1;
        else this._traverseFlags &= -2;
      }
      get shouldStop() {
        return (this._traverseFlags & 2) > 0;
      }
      set shouldStop(v) {
        if (v) this._traverseFlags |= 2;
        else this._traverseFlags &= -3;
      }
      get shouldSkip() {
        return (this._traverseFlags & 4) > 0;
      }
      set shouldSkip(v) {
        if (v) this._traverseFlags |= 4;
        else this._traverseFlags &= -5;
      }
      static get({
        hub,
        parentPath,
        parent,
        container,
        listKey,
        key: key2
      }) {
        if (!hub && parentPath) {
          hub = parentPath.hub;
        }
        if (!parent) {
          throw new Error("To get a node path the parent needs to exist");
        }
        const targetNode = container[key2];
        const paths = cache.getOrCreateCachedPaths(hub, parent);
        let path = paths.get(targetNode);
        if (!path) {
          path = new NodePath(hub, parent);
          if (targetNode) paths.set(targetNode, path);
        }
        _context3.setup.call(path, parentPath, container, listKey, key2);
        return path;
      }
      getScope(scope) {
        return this.isScope() ? new _index2.default(this) : scope;
      }
      setData(key2, val) {
        if (this.data == null) {
          this.data = /* @__PURE__ */ Object.create(null);
        }
        return this.data[key2] = val;
      }
      getData(key2, def) {
        if (this.data == null) {
          this.data = /* @__PURE__ */ Object.create(null);
        }
        let val = this.data[key2];
        if (val === void 0 && def !== void 0) val = this.data[key2] = def;
        return val;
      }
      hasNode() {
        return this.node != null;
      }
      buildCodeFrameError(msg, Error2 = SyntaxError) {
        return this.hub.buildError(this.node, msg, Error2);
      }
      traverse(visitor, state) {
        (0, _index.default)(this.node, visitor, this.scope, state, this);
      }
      set(key2, node) {
        validate2(this.node, key2, node);
        this.node[key2] = node;
      }
      getPathLocation() {
        const parts = [];
        let path = this;
        do {
          let key2 = path.key;
          if (path.inList) key2 = `${path.listKey}[${key2}]`;
          parts.unshift(key2);
        } while (path = path.parentPath);
        return parts.join(".");
      }
      debug(message) {
        if (!debug.enabled) return;
        debug(`${this.getPathLocation()} ${this.type}: ${message}`);
      }
      toString() {
        return (0, _generator.default)(this.node).code;
      }
      get inList() {
        return !!this.listKey;
      }
      set inList(inList) {
        if (!inList) {
          this.listKey = null;
        }
      }
      get parentKey() {
        return this.listKey || this.key;
      }
    };
    var methods = {
      findParent: NodePath_ancestry.findParent,
      find: NodePath_ancestry.find,
      getFunctionParent: NodePath_ancestry.getFunctionParent,
      getStatementParent: NodePath_ancestry.getStatementParent,
      getEarliestCommonAncestorFrom: NodePath_ancestry.getEarliestCommonAncestorFrom,
      getDeepestCommonAncestorFrom: NodePath_ancestry.getDeepestCommonAncestorFrom,
      getAncestry: NodePath_ancestry.getAncestry,
      isAncestor: NodePath_ancestry.isAncestor,
      isDescendant: NodePath_ancestry.isDescendant,
      inType: NodePath_ancestry.inType,
      getTypeAnnotation: NodePath_inference.getTypeAnnotation,
      isBaseType: NodePath_inference.isBaseType,
      couldBeBaseType: NodePath_inference.couldBeBaseType,
      baseTypeStrictlyMatches: NodePath_inference.baseTypeStrictlyMatches,
      isGenericType: NodePath_inference.isGenericType,
      replaceWithMultiple: NodePath_replacement.replaceWithMultiple,
      replaceWithSourceString: NodePath_replacement.replaceWithSourceString,
      replaceWith: NodePath_replacement.replaceWith,
      replaceExpressionWithStatements: NodePath_replacement.replaceExpressionWithStatements,
      replaceInline: NodePath_replacement.replaceInline,
      evaluateTruthy: NodePath_evaluation.evaluateTruthy,
      evaluate: NodePath_evaluation.evaluate,
      toComputedKey: NodePath_conversion.toComputedKey,
      ensureBlock: NodePath_conversion.ensureBlock,
      unwrapFunctionEnvironment: NodePath_conversion.unwrapFunctionEnvironment,
      arrowFunctionToExpression: NodePath_conversion.arrowFunctionToExpression,
      splitExportDeclaration: NodePath_conversion.splitExportDeclaration,
      ensureFunctionName: NodePath_conversion.ensureFunctionName,
      matchesPattern: NodePath_introspection.matchesPattern,
      isStatic: NodePath_introspection.isStatic,
      isNodeType: NodePath_introspection.isNodeType,
      canHaveVariableDeclarationOrExpression: NodePath_introspection.canHaveVariableDeclarationOrExpression,
      canSwapBetweenExpressionAndStatement: NodePath_introspection.canSwapBetweenExpressionAndStatement,
      isCompletionRecord: NodePath_introspection.isCompletionRecord,
      isStatementOrBlock: NodePath_introspection.isStatementOrBlock,
      referencesImport: NodePath_introspection.referencesImport,
      getSource: NodePath_introspection.getSource,
      willIMaybeExecuteBefore: NodePath_introspection.willIMaybeExecuteBefore,
      _guessExecutionStatusRelativeTo: NodePath_introspection._guessExecutionStatusRelativeTo,
      resolve: NodePath_introspection.resolve,
      isConstantExpression: NodePath_introspection.isConstantExpression,
      isInStrictMode: NodePath_introspection.isInStrictMode,
      isDenylisted: NodePath_context.isDenylisted,
      visit: NodePath_context.visit,
      skip: NodePath_context.skip,
      skipKey: NodePath_context.skipKey,
      stop: NodePath_context.stop,
      setContext: NodePath_context.setContext,
      requeue: NodePath_context.requeue,
      requeueComputedKeyAndDecorators: NodePath_context.requeueComputedKeyAndDecorators,
      remove: NodePath_removal.remove,
      insertBefore: NodePath_modification.insertBefore,
      insertAfter: NodePath_modification.insertAfter,
      unshiftContainer: NodePath_modification.unshiftContainer,
      pushContainer: NodePath_modification.pushContainer,
      getOpposite: NodePath_family.getOpposite,
      getCompletionRecords: NodePath_family.getCompletionRecords,
      getSibling: NodePath_family.getSibling,
      getPrevSibling: NodePath_family.getPrevSibling,
      getNextSibling: NodePath_family.getNextSibling,
      getAllNextSiblings: NodePath_family.getAllNextSiblings,
      getAllPrevSiblings: NodePath_family.getAllPrevSiblings,
      get: NodePath_family.get,
      getAssignmentIdentifiers: NodePath_family.getAssignmentIdentifiers,
      getBindingIdentifiers: NodePath_family.getBindingIdentifiers,
      getOuterBindingIdentifiers: NodePath_family.getOuterBindingIdentifiers,
      getBindingIdentifierPaths: NodePath_family.getBindingIdentifierPaths,
      getOuterBindingIdentifierPaths: NodePath_family.getOuterBindingIdentifierPaths,
      shareCommentsWithSiblings: NodePath_comments.shareCommentsWithSiblings,
      addComment: NodePath_comments.addComment,
      addComments: NodePath_comments.addComments
    };
    Object.assign(NodePath_Final.prototype, methods);
    {
      NodePath_Final.prototype.arrowFunctionToShadowed = NodePath_conversion[String("arrowFunctionToShadowed")];
      Object.assign(NodePath_Final.prototype, {
        has: NodePath_introspection[String("has")],
        is: NodePath_introspection[String("is")],
        isnt: NodePath_introspection[String("isnt")],
        equals: NodePath_introspection[String("equals")],
        hoist: NodePath_modification[String("hoist")],
        updateSiblingKeys: NodePath_modification.updateSiblingKeys,
        call: NodePath_context.call,
        isBlacklisted: NodePath_context[String("isBlacklisted")],
        setScope: NodePath_context.setScope,
        resync: NodePath_context.resync,
        popContext: NodePath_context.popContext,
        pushContext: NodePath_context.pushContext,
        setup: NodePath_context.setup,
        setKey: NodePath_context.setKey
      });
    }
    {
      NodePath_Final.prototype._guessExecutionStatusRelativeToDifferentFunctions = NodePath_introspection._guessExecutionStatusRelativeTo;
      NodePath_Final.prototype._guessExecutionStatusRelativeToDifferentFunctions = NodePath_introspection._guessExecutionStatusRelativeTo;
      Object.assign(NodePath_Final.prototype, {
        _getTypeAnnotation: NodePath_inference._getTypeAnnotation,
        _replaceWith: NodePath_replacement._replaceWith,
        _resolve: NodePath_introspection._resolve,
        _call: NodePath_context._call,
        _resyncParent: NodePath_context._resyncParent,
        _resyncKey: NodePath_context._resyncKey,
        _resyncList: NodePath_context._resyncList,
        _resyncRemoved: NodePath_context._resyncRemoved,
        _getQueueContexts: NodePath_context._getQueueContexts,
        _removeFromScope: NodePath_removal._removeFromScope,
        _callRemovalHooks: NodePath_removal._callRemovalHooks,
        _remove: NodePath_removal._remove,
        _markRemoved: NodePath_removal._markRemoved,
        _assertUnremoved: NodePath_removal._assertUnremoved,
        _containerInsert: NodePath_modification._containerInsert,
        _containerInsertBefore: NodePath_modification._containerInsertBefore,
        _containerInsertAfter: NodePath_modification._containerInsertAfter,
        _verifyNodeList: NodePath_modification._verifyNodeList,
        _getKey: NodePath_family._getKey,
        _getPattern: NodePath_family._getPattern
      });
    }
    for (const type of t6.TYPES) {
      const typeKey = `is${type}`;
      const fn = t6[typeKey];
      NodePath_Final.prototype[typeKey] = function(opts) {
        return fn(this.node, opts);
      };
      NodePath_Final.prototype[`assert${type}`] = function(opts) {
        if (!fn(this.node, opts)) {
          throw new TypeError(`Expected node path of type ${type}`);
        }
      };
    }
    Object.assign(NodePath_Final.prototype, NodePath_virtual_types_validator);
    for (const type of Object.keys(virtualTypes)) {
      if (type[0] === "_") continue;
      if (!t6.TYPES.includes(type)) t6.TYPES.push(type);
    }
  }
});

// node_modules/@babel/helpers/node_modules/@babel/traverse/lib/context.js
var require_context = __commonJS({
  "node_modules/@babel/helpers/node_modules/@babel/traverse/lib/context.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _index = require_path();
    var _t = require("@babel/types");
    var _context3 = require_context2();
    var {
      VISITOR_KEYS
    } = _t;
    var TraversalContext = class {
      constructor(scope, opts, state, parentPath) {
        this.queue = null;
        this.priorityQueue = null;
        this.parentPath = parentPath;
        this.scope = scope;
        this.state = state;
        this.opts = opts;
      }
      shouldVisit(node) {
        const opts = this.opts;
        if (opts.enter || opts.exit) return true;
        if (opts[node.type]) return true;
        const keys = VISITOR_KEYS[node.type];
        if (!(keys != null && keys.length)) return false;
        for (const key2 of keys) {
          if (node[key2]) {
            return true;
          }
        }
        return false;
      }
      create(node, container, key2, listKey) {
        return _index.default.get({
          parentPath: this.parentPath,
          parent: node,
          container,
          key: key2,
          listKey
        });
      }
      maybeQueue(path, notPriority) {
        if (this.queue) {
          if (notPriority) {
            this.queue.push(path);
          } else {
            this.priorityQueue.push(path);
          }
        }
      }
      visitMultiple(container, parent, listKey) {
        if (container.length === 0) return false;
        const queue = [];
        for (let key2 = 0; key2 < container.length; key2++) {
          const node = container[key2];
          if (node && this.shouldVisit(node)) {
            queue.push(this.create(parent, container, key2, listKey));
          }
        }
        return this.visitQueue(queue);
      }
      visitSingle(node, key2) {
        if (this.shouldVisit(node[key2])) {
          return this.visitQueue([this.create(node, node, key2)]);
        } else {
          return false;
        }
      }
      visitQueue(queue) {
        this.queue = queue;
        this.priorityQueue = [];
        const visited = /* @__PURE__ */ new WeakSet();
        let stop = false;
        let visitIndex = 0;
        for (; visitIndex < queue.length; ) {
          const path = queue[visitIndex];
          visitIndex++;
          _context3.resync.call(path);
          if (path.contexts.length === 0 || path.contexts[path.contexts.length - 1] !== this) {
            _context3.pushContext.call(path, this);
          }
          if (path.key === null) continue;
          const {
            node
          } = path;
          if (visited.has(node)) continue;
          if (node) visited.add(node);
          if (path.visit()) {
            stop = true;
            break;
          }
          if (this.priorityQueue.length) {
            stop = this.visitQueue(this.priorityQueue);
            this.priorityQueue = [];
            this.queue = queue;
            if (stop) break;
          }
        }
        for (let i = 0; i < visitIndex; i++) {
          _context3.popContext.call(queue[i]);
        }
        this.queue = null;
        return stop;
      }
      visit(node, key2) {
        const nodes = node[key2];
        if (!nodes) return false;
        if (Array.isArray(nodes)) {
          return this.visitMultiple(nodes, node, key2);
        } else {
          return this.visitSingle(node, key2);
        }
      }
    };
    exports2.default = TraversalContext;
  }
});

// node_modules/@babel/helpers/node_modules/@babel/traverse/lib/traverse-node.js
var require_traverse_node = __commonJS({
  "node_modules/@babel/helpers/node_modules/@babel/traverse/lib/traverse-node.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.traverseNode = traverseNode;
    var _context3 = require_context();
    var _t = require("@babel/types");
    var {
      VISITOR_KEYS
    } = _t;
    function traverseNode(node, opts, scope, state, path, skipKeys, visitSelf) {
      const keys = VISITOR_KEYS[node.type];
      if (!keys) return false;
      const context = new _context3.default(scope, opts, state, path);
      if (visitSelf) {
        if (skipKeys != null && skipKeys[path.parentKey]) return false;
        return context.visitQueue([path]);
      }
      for (const key2 of keys) {
        if (skipKeys != null && skipKeys[key2]) continue;
        if (context.visit(node, key2)) {
          return true;
        }
      }
      return false;
    }
  }
});

// node_modules/@babel/helpers/node_modules/@babel/traverse/lib/path/context.js
var require_context2 = __commonJS({
  "node_modules/@babel/helpers/node_modules/@babel/traverse/lib/path/context.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2._call = _call;
    exports2._getQueueContexts = _getQueueContexts;
    exports2._resyncKey = _resyncKey;
    exports2._resyncList = _resyncList;
    exports2._resyncParent = _resyncParent;
    exports2._resyncRemoved = _resyncRemoved;
    exports2.call = call;
    exports2.isDenylisted = isDenylisted;
    exports2.popContext = popContext;
    exports2.pushContext = pushContext;
    exports2.requeue = requeue;
    exports2.requeueComputedKeyAndDecorators = requeueComputedKeyAndDecorators;
    exports2.resync = resync;
    exports2.setContext = setContext;
    exports2.setKey = setKey;
    exports2.setScope = setScope;
    exports2.setup = setup;
    exports2.skip = skip;
    exports2.skipKey = skipKey;
    exports2.stop = stop;
    exports2.visit = visit4;
    var _traverseNode = require_traverse_node();
    var _index = require_path();
    var _removal = require_removal();
    var t6 = require("@babel/types");
    function call(key2) {
      const opts = this.opts;
      this.debug(key2);
      if (this.node) {
        if (_call.call(this, opts[key2])) return true;
      }
      if (this.node) {
        var _opts$this$node$type;
        return _call.call(this, (_opts$this$node$type = opts[this.node.type]) == null ? void 0 : _opts$this$node$type[key2]);
      }
      return false;
    }
    function _call(fns) {
      if (!fns) return false;
      for (const fn of fns) {
        if (!fn) continue;
        const node = this.node;
        if (!node) return true;
        const ret = fn.call(this.state, this, this.state);
        if (ret && typeof ret === "object" && typeof ret.then === "function") {
          throw new Error(`You appear to be using a plugin with an async traversal visitor, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.`);
        }
        if (ret) {
          throw new Error(`Unexpected return value from visitor method ${fn}`);
        }
        if (this.node !== node) return true;
        if (this._traverseFlags > 0) return true;
      }
      return false;
    }
    function isDenylisted() {
      var _this$opts$denylist;
      const denylist = (_this$opts$denylist = this.opts.denylist) != null ? _this$opts$denylist : this.opts.blacklist;
      return denylist == null ? void 0 : denylist.includes(this.node.type);
    }
    {
      exports2.isBlacklisted = isDenylisted;
    }
    function restoreContext(path, context) {
      if (path.context !== context) {
        path.context = context;
        path.state = context.state;
        path.opts = context.opts;
      }
    }
    function visit4() {
      var _this$opts$shouldSkip, _this$opts;
      if (!this.node) {
        return false;
      }
      if (this.isDenylisted()) {
        return false;
      }
      if ((_this$opts$shouldSkip = (_this$opts = this.opts).shouldSkip) != null && _this$opts$shouldSkip.call(_this$opts, this)) {
        return false;
      }
      const currentContext = this.context;
      if (this.shouldSkip || call.call(this, "enter")) {
        this.debug("Skip...");
        return this.shouldStop;
      }
      restoreContext(this, currentContext);
      this.debug("Recursing into...");
      this.shouldStop = (0, _traverseNode.traverseNode)(this.node, this.opts, this.scope, this.state, this, this.skipKeys);
      restoreContext(this, currentContext);
      call.call(this, "exit");
      return this.shouldStop;
    }
    function skip() {
      this.shouldSkip = true;
    }
    function skipKey(key2) {
      if (this.skipKeys == null) {
        this.skipKeys = {};
      }
      this.skipKeys[key2] = true;
    }
    function stop() {
      this._traverseFlags |= _index.SHOULD_SKIP | _index.SHOULD_STOP;
    }
    function setScope() {
      var _this$opts2, _this$scope;
      if ((_this$opts2 = this.opts) != null && _this$opts2.noScope) return;
      let path = this.parentPath;
      if ((this.key === "key" || this.listKey === "decorators") && path.isMethod() || this.key === "discriminant" && path.isSwitchStatement()) {
        path = path.parentPath;
      }
      let target;
      while (path && !target) {
        var _path$opts;
        if ((_path$opts = path.opts) != null && _path$opts.noScope) return;
        target = path.scope;
        path = path.parentPath;
      }
      this.scope = this.getScope(target);
      (_this$scope = this.scope) == null || _this$scope.init();
    }
    function setContext(context) {
      if (this.skipKeys != null) {
        this.skipKeys = {};
      }
      this._traverseFlags = 0;
      if (context) {
        this.context = context;
        this.state = context.state;
        this.opts = context.opts;
      }
      setScope.call(this);
      return this;
    }
    function resync() {
      if (this.removed) return;
      _resyncParent.call(this);
      _resyncList.call(this);
      _resyncKey.call(this);
    }
    function _resyncParent() {
      if (this.parentPath) {
        this.parent = this.parentPath.node;
      }
    }
    function _resyncKey() {
      if (!this.container) return;
      if (this.node === this.container[this.key]) {
        return;
      }
      if (Array.isArray(this.container)) {
        for (let i = 0; i < this.container.length; i++) {
          if (this.container[i] === this.node) {
            setKey.call(this, i);
            return;
          }
        }
      } else {
        for (const key2 of Object.keys(this.container)) {
          if (this.container[key2] === this.node) {
            setKey.call(this, key2);
            return;
          }
        }
      }
      this.key = null;
    }
    function _resyncList() {
      if (!this.parent || !this.inList) return;
      const newContainer = this.parent[this.listKey];
      if (this.container === newContainer) return;
      this.container = newContainer || null;
    }
    function _resyncRemoved() {
      if (this.key == null || !this.container || this.container[this.key] !== this.node) {
        _removal._markRemoved.call(this);
      }
    }
    function popContext() {
      this.contexts.pop();
      if (this.contexts.length > 0) {
        this.setContext(this.contexts[this.contexts.length - 1]);
      } else {
        this.setContext(void 0);
      }
    }
    function pushContext(context) {
      this.contexts.push(context);
      this.setContext(context);
    }
    function setup(parentPath, container, listKey, key2) {
      this.listKey = listKey;
      this.container = container;
      this.parentPath = parentPath || this.parentPath;
      setKey.call(this, key2);
    }
    function setKey(key2) {
      var _this$node;
      this.key = key2;
      this.node = this.container[this.key];
      this.type = (_this$node = this.node) == null ? void 0 : _this$node.type;
    }
    function requeue(pathToQueue = this) {
      if (pathToQueue.removed) return;
      ;
      const contexts = this.contexts;
      for (const context of contexts) {
        context.maybeQueue(pathToQueue);
      }
    }
    function requeueComputedKeyAndDecorators() {
      const {
        context,
        node
      } = this;
      if (!t6.isPrivate(node) && node.computed) {
        context.maybeQueue(this.get("key"));
      }
      if (node.decorators) {
        for (const decorator of this.get("decorators")) {
          context.maybeQueue(decorator);
        }
      }
    }
    function _getQueueContexts() {
      let path = this;
      let contexts = this.contexts;
      while (!contexts.length) {
        path = path.parentPath;
        if (!path) break;
        contexts = path.contexts;
      }
      return contexts;
    }
  }
});

// node_modules/@babel/helpers/node_modules/@babel/traverse/lib/hub.js
var require_hub = __commonJS({
  "node_modules/@babel/helpers/node_modules/@babel/traverse/lib/hub.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var Hub = class {
      getCode() {
      }
      getScope() {
      }
      addHelper() {
        throw new Error("Helpers are not supported by the default hub.");
      }
      buildError(node, msg, Error2 = TypeError) {
        return new Error2(msg);
      }
    };
    exports2.default = Hub;
  }
});

// node_modules/@babel/helpers/node_modules/@babel/traverse/lib/index.js
var require_lib6 = __commonJS({
  "node_modules/@babel/helpers/node_modules/@babel/traverse/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "Hub", {
      enumerable: true,
      get: function() {
        return _hub.default;
      }
    });
    Object.defineProperty(exports2, "NodePath", {
      enumerable: true,
      get: function() {
        return _index.default;
      }
    });
    Object.defineProperty(exports2, "Scope", {
      enumerable: true,
      get: function() {
        return _index2.default;
      }
    });
    exports2.visitors = exports2.default = void 0;
    require_context2();
    var visitors = require_visitors();
    exports2.visitors = visitors;
    var _t = require("@babel/types");
    var cache = require_cache();
    var _traverseNode = require_traverse_node();
    var _index = require_path();
    var _index2 = require_scope();
    var _hub = require_hub();
    var {
      VISITOR_KEYS,
      removeProperties,
      traverseFast
    } = _t;
    function traverse(parent, opts = {}, scope, state, parentPath, visitSelf) {
      if (!parent) return;
      if (!opts.noScope && !scope) {
        if (parent.type !== "Program" && parent.type !== "File") {
          throw new Error(`You must pass a scope and parentPath unless traversing a Program/File. Instead of that you tried to traverse a ${parent.type} node without passing scope and parentPath.`);
        }
      }
      if (!parentPath && visitSelf) {
        throw new Error("visitSelf can only be used when providing a NodePath.");
      }
      if (!VISITOR_KEYS[parent.type]) {
        return;
      }
      visitors.explode(opts);
      (0, _traverseNode.traverseNode)(parent, opts, scope, state, parentPath, null, visitSelf);
    }
    var _default = exports2.default = traverse;
    traverse.visitors = visitors;
    traverse.verify = visitors.verify;
    traverse.explode = visitors.explode;
    traverse.cheap = function(node, enter) {
      traverseFast(node, enter);
      return;
    };
    traverse.node = function(node, opts, scope, state, path, skipKeys) {
      (0, _traverseNode.traverseNode)(node, opts, scope, state, path, skipKeys);
    };
    traverse.clearNode = function(node, opts) {
      removeProperties(node, opts);
    };
    traverse.removeProperties = function(tree, opts) {
      traverseFast(tree, traverse.clearNode, opts);
      return tree;
    };
    function hasDenylistedType(path, state) {
      if (path.node.type === state.type) {
        state.has = true;
        path.stop();
      }
    }
    traverse.hasType = function(tree, type, denylistTypes) {
      if (denylistTypes != null && denylistTypes.includes(tree.type)) return false;
      if (tree.type === type) return true;
      const state = {
        has: false,
        type
      };
      traverse(tree, {
        noScope: true,
        denylist: denylistTypes,
        enter: hasDenylistedType
      }, null, state);
      return state.has;
    };
    traverse.cache = cache;
  }
});

// node_modules/@babel/helpers/lib/helpers-generated.js
var require_helpers_generated = __commonJS({
  "node_modules/@babel/helpers/lib/helpers-generated.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _template = require_lib5();
    function helper(minVersion, source2) {
      return Object.freeze({
        minVersion,
        ast: () => _template.default.program.ast(source2, {
          preserveComments: true
        })
      });
    }
    var _default = Object.freeze({
      AsyncGenerator: helper("7.0.0-beta.0", 'import OverloadYield from"OverloadYield";export default function AsyncGenerator(gen){var front,back;function resume(key,arg){try{var result=gen[key](arg),value=result.value,overloaded=value instanceof OverloadYield;Promise.resolve(overloaded?value.v:value).then((function(arg){if(overloaded){var nextKey="return"===key?"return":"next";if(!value.k||arg.done)return resume(nextKey,arg);arg=gen[nextKey](arg).value}settle(result.done?"return":"normal",arg)}),(function(err){resume("throw",err)}))}catch(err){settle("throw",err)}}function settle(type,value){switch(type){case"return":front.resolve({value:value,done:!0});break;case"throw":front.reject(value);break;default:front.resolve({value:value,done:!1})}(front=front.next)?resume(front.key,front.arg):back=null}this._invoke=function(key,arg){return new Promise((function(resolve,reject){var request={key:key,arg:arg,resolve:resolve,reject:reject,next:null};back?back=back.next=request:(front=back=request,resume(key,arg))}))},"function"!=typeof gen.return&&(this.return=void 0)}AsyncGenerator.prototype["function"==typeof Symbol&&Symbol.asyncIterator||"@@asyncIterator"]=function(){return this},AsyncGenerator.prototype.next=function(arg){return this._invoke("next",arg)},AsyncGenerator.prototype.throw=function(arg){return this._invoke("throw",arg)},AsyncGenerator.prototype.return=function(arg){return this._invoke("return",arg)};'),
      OverloadYield: helper("7.18.14", "export default function _OverloadYield(value,kind){this.v=value,this.k=kind}"),
      applyDecs: helper("7.17.8", 'function old_createMetadataMethodsForProperty(metadataMap,kind,property,decoratorFinishedRef){return{getMetadata:function(key){old_assertNotFinished(decoratorFinishedRef,"getMetadata"),old_assertMetadataKey(key);var metadataForKey=metadataMap[key];if(void 0!==metadataForKey)if(1===kind){var pub=metadataForKey.public;if(void 0!==pub)return pub[property]}else if(2===kind){var priv=metadataForKey.private;if(void 0!==priv)return priv.get(property)}else if(Object.hasOwnProperty.call(metadataForKey,"constructor"))return metadataForKey.constructor},setMetadata:function(key,value){old_assertNotFinished(decoratorFinishedRef,"setMetadata"),old_assertMetadataKey(key);var metadataForKey=metadataMap[key];if(void 0===metadataForKey&&(metadataForKey=metadataMap[key]={}),1===kind){var pub=metadataForKey.public;void 0===pub&&(pub=metadataForKey.public={}),pub[property]=value}else if(2===kind){var priv=metadataForKey.priv;void 0===priv&&(priv=metadataForKey.private=new Map),priv.set(property,value)}else metadataForKey.constructor=value}}}function old_convertMetadataMapToFinal(obj,metadataMap){var parentMetadataMap=obj[Symbol.metadata||Symbol.for("Symbol.metadata")],metadataKeys=Object.getOwnPropertySymbols(metadataMap);if(0!==metadataKeys.length){for(var i=0;i<metadataKeys.length;i++){var key=metadataKeys[i],metaForKey=metadataMap[key],parentMetaForKey=parentMetadataMap?parentMetadataMap[key]:null,pub=metaForKey.public,parentPub=parentMetaForKey?parentMetaForKey.public:null;pub&&parentPub&&Object.setPrototypeOf(pub,parentPub);var priv=metaForKey.private;if(priv){var privArr=Array.from(priv.values()),parentPriv=parentMetaForKey?parentMetaForKey.private:null;parentPriv&&(privArr=privArr.concat(parentPriv)),metaForKey.private=privArr}parentMetaForKey&&Object.setPrototypeOf(metaForKey,parentMetaForKey)}parentMetadataMap&&Object.setPrototypeOf(metadataMap,parentMetadataMap),obj[Symbol.metadata||Symbol.for("Symbol.metadata")]=metadataMap}}function old_createAddInitializerMethod(initializers,decoratorFinishedRef){return function(initializer){old_assertNotFinished(decoratorFinishedRef,"addInitializer"),old_assertCallable(initializer,"An initializer"),initializers.push(initializer)}}function old_memberDec(dec,name,desc,metadataMap,initializers,kind,isStatic,isPrivate,value){var kindStr;switch(kind){case 1:kindStr="accessor";break;case 2:kindStr="method";break;case 3:kindStr="getter";break;case 4:kindStr="setter";break;default:kindStr="field"}var metadataKind,metadataName,ctx={kind:kindStr,name:isPrivate?"#"+name:name,isStatic:isStatic,isPrivate:isPrivate},decoratorFinishedRef={v:!1};if(0!==kind&&(ctx.addInitializer=old_createAddInitializerMethod(initializers,decoratorFinishedRef)),isPrivate){metadataKind=2,metadataName=Symbol(name);var access={};0===kind?(access.get=desc.get,access.set=desc.set):2===kind?access.get=function(){return desc.value}:(1!==kind&&3!==kind||(access.get=function(){return desc.get.call(this)}),1!==kind&&4!==kind||(access.set=function(v){desc.set.call(this,v)})),ctx.access=access}else metadataKind=1,metadataName=name;try{return dec(value,Object.assign(ctx,old_createMetadataMethodsForProperty(metadataMap,metadataKind,metadataName,decoratorFinishedRef)))}finally{decoratorFinishedRef.v=!0}}function old_assertNotFinished(decoratorFinishedRef,fnName){if(decoratorFinishedRef.v)throw new Error("attempted to call "+fnName+" after decoration was finished")}function old_assertMetadataKey(key){if("symbol"!=typeof key)throw new TypeError("Metadata keys must be symbols, received: "+key)}function old_assertCallable(fn,hint){if("function"!=typeof fn)throw new TypeError(hint+" must be a function")}function old_assertValidReturnValue(kind,value){var type=typeof value;if(1===kind){if("object"!==type||null===value)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==value.get&&old_assertCallable(value.get,"accessor.get"),void 0!==value.set&&old_assertCallable(value.set,"accessor.set"),void 0!==value.init&&old_assertCallable(value.init,"accessor.init"),void 0!==value.initializer&&old_assertCallable(value.initializer,"accessor.initializer")}else if("function"!==type){var hint;throw hint=0===kind?"field":10===kind?"class":"method",new TypeError(hint+" decorators must return a function or void 0")}}function old_getInit(desc){var initializer;return null==(initializer=desc.init)&&(initializer=desc.initializer)&&"undefined"!=typeof console&&console.warn(".initializer has been renamed to .init as of March 2022"),initializer}function old_applyMemberDec(ret,base,decInfo,name,kind,isStatic,isPrivate,metadataMap,initializers){var desc,initializer,value,newValue,get,set,decs=decInfo[0];if(isPrivate?desc=0===kind||1===kind?{get:decInfo[3],set:decInfo[4]}:3===kind?{get:decInfo[3]}:4===kind?{set:decInfo[3]}:{value:decInfo[3]}:0!==kind&&(desc=Object.getOwnPropertyDescriptor(base,name)),1===kind?value={get:desc.get,set:desc.set}:2===kind?value=desc.value:3===kind?value=desc.get:4===kind&&(value=desc.set),"function"==typeof decs)void 0!==(newValue=old_memberDec(decs,name,desc,metadataMap,initializers,kind,isStatic,isPrivate,value))&&(old_assertValidReturnValue(kind,newValue),0===kind?initializer=newValue:1===kind?(initializer=old_getInit(newValue),get=newValue.get||value.get,set=newValue.set||value.set,value={get:get,set:set}):value=newValue);else for(var i=decs.length-1;i>=0;i--){var newInit;if(void 0!==(newValue=old_memberDec(decs[i],name,desc,metadataMap,initializers,kind,isStatic,isPrivate,value)))old_assertValidReturnValue(kind,newValue),0===kind?newInit=newValue:1===kind?(newInit=old_getInit(newValue),get=newValue.get||value.get,set=newValue.set||value.set,value={get:get,set:set}):value=newValue,void 0!==newInit&&(void 0===initializer?initializer=newInit:"function"==typeof initializer?initializer=[initializer,newInit]:initializer.push(newInit))}if(0===kind||1===kind){if(void 0===initializer)initializer=function(instance,init){return init};else if("function"!=typeof initializer){var ownInitializers=initializer;initializer=function(instance,init){for(var value=init,i=0;i<ownInitializers.length;i++)value=ownInitializers[i].call(instance,value);return value}}else{var originalInitializer=initializer;initializer=function(instance,init){return originalInitializer.call(instance,init)}}ret.push(initializer)}0!==kind&&(1===kind?(desc.get=value.get,desc.set=value.set):2===kind?desc.value=value:3===kind?desc.get=value:4===kind&&(desc.set=value),isPrivate?1===kind?(ret.push((function(instance,args){return value.get.call(instance,args)})),ret.push((function(instance,args){return value.set.call(instance,args)}))):2===kind?ret.push(value):ret.push((function(instance,args){return value.call(instance,args)})):Object.defineProperty(base,name,desc))}function old_applyMemberDecs(ret,Class,protoMetadataMap,staticMetadataMap,decInfos){for(var protoInitializers,staticInitializers,existingProtoNonFields=new Map,existingStaticNonFields=new Map,i=0;i<decInfos.length;i++){var decInfo=decInfos[i];if(Array.isArray(decInfo)){var base,metadataMap,initializers,kind=decInfo[1],name=decInfo[2],isPrivate=decInfo.length>3,isStatic=kind>=5;if(isStatic?(base=Class,metadataMap=staticMetadataMap,0!==(kind-=5)&&(initializers=staticInitializers=staticInitializers||[])):(base=Class.prototype,metadataMap=protoMetadataMap,0!==kind&&(initializers=protoInitializers=protoInitializers||[])),0!==kind&&!isPrivate){var existingNonFields=isStatic?existingStaticNonFields:existingProtoNonFields,existingKind=existingNonFields.get(name)||0;if(!0===existingKind||3===existingKind&&4!==kind||4===existingKind&&3!==kind)throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+name);!existingKind&&kind>2?existingNonFields.set(name,kind):existingNonFields.set(name,!0)}old_applyMemberDec(ret,base,decInfo,name,kind,isStatic,isPrivate,metadataMap,initializers)}}old_pushInitializers(ret,protoInitializers),old_pushInitializers(ret,staticInitializers)}function old_pushInitializers(ret,initializers){initializers&&ret.push((function(instance){for(var i=0;i<initializers.length;i++)initializers[i].call(instance);return instance}))}function old_applyClassDecs(ret,targetClass,metadataMap,classDecs){if(classDecs.length>0){for(var initializers=[],newClass=targetClass,name=targetClass.name,i=classDecs.length-1;i>=0;i--){var decoratorFinishedRef={v:!1};try{var ctx=Object.assign({kind:"class",name:name,addInitializer:old_createAddInitializerMethod(initializers,decoratorFinishedRef)},old_createMetadataMethodsForProperty(metadataMap,0,name,decoratorFinishedRef)),nextNewClass=classDecs[i](newClass,ctx)}finally{decoratorFinishedRef.v=!0}void 0!==nextNewClass&&(old_assertValidReturnValue(10,nextNewClass),newClass=nextNewClass)}ret.push(newClass,(function(){for(var i=0;i<initializers.length;i++)initializers[i].call(newClass)}))}}export default function applyDecs(targetClass,memberDecs,classDecs){var ret=[],staticMetadataMap={},protoMetadataMap={};return old_applyMemberDecs(ret,targetClass,protoMetadataMap,staticMetadataMap,memberDecs),old_convertMetadataMapToFinal(targetClass.prototype,protoMetadataMap),old_applyClassDecs(ret,targetClass,staticMetadataMap,classDecs),old_convertMetadataMapToFinal(targetClass,staticMetadataMap),ret}'),
      applyDecs2203: helper("7.19.0", 'function createAddInitializerMethod(initializers,decoratorFinishedRef){return function(initializer){assertNotFinished(decoratorFinishedRef,"addInitializer"),assertCallable(initializer,"An initializer"),initializers.push(initializer)}}function memberDec(dec,name,desc,initializers,kind,isStatic,isPrivate,value){var kindStr;switch(kind){case 1:kindStr="accessor";break;case 2:kindStr="method";break;case 3:kindStr="getter";break;case 4:kindStr="setter";break;default:kindStr="field"}var get,set,ctx={kind:kindStr,name:isPrivate?"#"+name:name,static:isStatic,private:isPrivate},decoratorFinishedRef={v:!1};0!==kind&&(ctx.addInitializer=createAddInitializerMethod(initializers,decoratorFinishedRef)),0===kind?isPrivate?(get=desc.get,set=desc.set):(get=function(){return this[name]},set=function(v){this[name]=v}):2===kind?get=function(){return desc.value}:(1!==kind&&3!==kind||(get=function(){return desc.get.call(this)}),1!==kind&&4!==kind||(set=function(v){desc.set.call(this,v)})),ctx.access=get&&set?{get:get,set:set}:get?{get:get}:{set:set};try{return dec(value,ctx)}finally{decoratorFinishedRef.v=!0}}function assertNotFinished(decoratorFinishedRef,fnName){if(decoratorFinishedRef.v)throw new Error("attempted to call "+fnName+" after decoration was finished")}function assertCallable(fn,hint){if("function"!=typeof fn)throw new TypeError(hint+" must be a function")}function assertValidReturnValue(kind,value){var type=typeof value;if(1===kind){if("object"!==type||null===value)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==value.get&&assertCallable(value.get,"accessor.get"),void 0!==value.set&&assertCallable(value.set,"accessor.set"),void 0!==value.init&&assertCallable(value.init,"accessor.init")}else if("function"!==type){var hint;throw hint=0===kind?"field":10===kind?"class":"method",new TypeError(hint+" decorators must return a function or void 0")}}function applyMemberDec(ret,base,decInfo,name,kind,isStatic,isPrivate,initializers){var desc,init,value,newValue,get,set,decs=decInfo[0];if(isPrivate?desc=0===kind||1===kind?{get:decInfo[3],set:decInfo[4]}:3===kind?{get:decInfo[3]}:4===kind?{set:decInfo[3]}:{value:decInfo[3]}:0!==kind&&(desc=Object.getOwnPropertyDescriptor(base,name)),1===kind?value={get:desc.get,set:desc.set}:2===kind?value=desc.value:3===kind?value=desc.get:4===kind&&(value=desc.set),"function"==typeof decs)void 0!==(newValue=memberDec(decs,name,desc,initializers,kind,isStatic,isPrivate,value))&&(assertValidReturnValue(kind,newValue),0===kind?init=newValue:1===kind?(init=newValue.init,get=newValue.get||value.get,set=newValue.set||value.set,value={get:get,set:set}):value=newValue);else for(var i=decs.length-1;i>=0;i--){var newInit;if(void 0!==(newValue=memberDec(decs[i],name,desc,initializers,kind,isStatic,isPrivate,value)))assertValidReturnValue(kind,newValue),0===kind?newInit=newValue:1===kind?(newInit=newValue.init,get=newValue.get||value.get,set=newValue.set||value.set,value={get:get,set:set}):value=newValue,void 0!==newInit&&(void 0===init?init=newInit:"function"==typeof init?init=[init,newInit]:init.push(newInit))}if(0===kind||1===kind){if(void 0===init)init=function(instance,init){return init};else if("function"!=typeof init){var ownInitializers=init;init=function(instance,init){for(var value=init,i=0;i<ownInitializers.length;i++)value=ownInitializers[i].call(instance,value);return value}}else{var originalInitializer=init;init=function(instance,init){return originalInitializer.call(instance,init)}}ret.push(init)}0!==kind&&(1===kind?(desc.get=value.get,desc.set=value.set):2===kind?desc.value=value:3===kind?desc.get=value:4===kind&&(desc.set=value),isPrivate?1===kind?(ret.push((function(instance,args){return value.get.call(instance,args)})),ret.push((function(instance,args){return value.set.call(instance,args)}))):2===kind?ret.push(value):ret.push((function(instance,args){return value.call(instance,args)})):Object.defineProperty(base,name,desc))}function applyMemberDecs(ret,Class,decInfos){for(var protoInitializers,staticInitializers,existingProtoNonFields=new Map,existingStaticNonFields=new Map,i=0;i<decInfos.length;i++){var decInfo=decInfos[i];if(Array.isArray(decInfo)){var base,initializers,kind=decInfo[1],name=decInfo[2],isPrivate=decInfo.length>3,isStatic=kind>=5;if(isStatic?(base=Class,0!==(kind-=5)&&(initializers=staticInitializers=staticInitializers||[])):(base=Class.prototype,0!==kind&&(initializers=protoInitializers=protoInitializers||[])),0!==kind&&!isPrivate){var existingNonFields=isStatic?existingStaticNonFields:existingProtoNonFields,existingKind=existingNonFields.get(name)||0;if(!0===existingKind||3===existingKind&&4!==kind||4===existingKind&&3!==kind)throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+name);!existingKind&&kind>2?existingNonFields.set(name,kind):existingNonFields.set(name,!0)}applyMemberDec(ret,base,decInfo,name,kind,isStatic,isPrivate,initializers)}}pushInitializers(ret,protoInitializers),pushInitializers(ret,staticInitializers)}function pushInitializers(ret,initializers){initializers&&ret.push((function(instance){for(var i=0;i<initializers.length;i++)initializers[i].call(instance);return instance}))}function applyClassDecs(ret,targetClass,classDecs){if(classDecs.length>0){for(var initializers=[],newClass=targetClass,name=targetClass.name,i=classDecs.length-1;i>=0;i--){var decoratorFinishedRef={v:!1};try{var nextNewClass=classDecs[i](newClass,{kind:"class",name:name,addInitializer:createAddInitializerMethod(initializers,decoratorFinishedRef)})}finally{decoratorFinishedRef.v=!0}void 0!==nextNewClass&&(assertValidReturnValue(10,nextNewClass),newClass=nextNewClass)}ret.push(newClass,(function(){for(var i=0;i<initializers.length;i++)initializers[i].call(newClass)}))}}export default function applyDecs2203(targetClass,memberDecs,classDecs){var ret=[];return applyMemberDecs(ret,targetClass,memberDecs),applyClassDecs(ret,targetClass,classDecs),ret}'),
      asyncGeneratorDelegate: helper("7.0.0-beta.0", 'import OverloadYield from"OverloadYield";export default function _asyncGeneratorDelegate(inner){var iter={},waiting=!1;function pump(key,value){return waiting=!0,value=new Promise((function(resolve){resolve(inner[key](value))})),{done:!1,value:new OverloadYield(value,1)}}return iter["undefined"!=typeof Symbol&&Symbol.iterator||"@@iterator"]=function(){return this},iter.next=function(value){return waiting?(waiting=!1,value):pump("next",value)},"function"==typeof inner.throw&&(iter.throw=function(value){if(waiting)throw waiting=!1,value;return pump("throw",value)}),"function"==typeof inner.return&&(iter.return=function(value){return waiting?(waiting=!1,value):pump("return",value)}),iter}'),
      asyncIterator: helper("7.15.9", 'export default function _asyncIterator(iterable){var method,async,sync,retry=2;for("undefined"!=typeof Symbol&&(async=Symbol.asyncIterator,sync=Symbol.iterator);retry--;){if(async&&null!=(method=iterable[async]))return method.call(iterable);if(sync&&null!=(method=iterable[sync]))return new AsyncFromSyncIterator(method.call(iterable));async="@@asyncIterator",sync="@@iterator"}throw new TypeError("Object is not async iterable")}function AsyncFromSyncIterator(s){function AsyncFromSyncIteratorContinuation(r){if(Object(r)!==r)return Promise.reject(new TypeError(r+" is not an object."));var done=r.done;return Promise.resolve(r.value).then((function(value){return{value:value,done:done}}))}return AsyncFromSyncIterator=function(s){this.s=s,this.n=s.next},AsyncFromSyncIterator.prototype={s:null,n:null,next:function(){return AsyncFromSyncIteratorContinuation(this.n.apply(this.s,arguments))},return:function(value){var ret=this.s.return;return void 0===ret?Promise.resolve({value:value,done:!0}):AsyncFromSyncIteratorContinuation(ret.apply(this.s,arguments))},throw:function(value){var thr=this.s.return;return void 0===thr?Promise.reject(value):AsyncFromSyncIteratorContinuation(thr.apply(this.s,arguments))}},new AsyncFromSyncIterator(s)}'),
      awaitAsyncGenerator: helper("7.0.0-beta.0", 'import OverloadYield from"OverloadYield";export default function _awaitAsyncGenerator(value){return new OverloadYield(value,0)}'),
      jsx: helper("7.0.0-beta.0", 'var REACT_ELEMENT_TYPE;export default function _createRawReactElement(type,props,key,children){REACT_ELEMENT_TYPE||(REACT_ELEMENT_TYPE="function"==typeof Symbol&&Symbol.for&&Symbol.for("react.element")||60103);var defaultProps=type&&type.defaultProps,childrenLength=arguments.length-3;if(props||0===childrenLength||(props={children:void 0}),1===childrenLength)props.children=children;else if(childrenLength>1){for(var childArray=new Array(childrenLength),i=0;i<childrenLength;i++)childArray[i]=arguments[i+3];props.children=childArray}if(props&&defaultProps)for(var propName in defaultProps)void 0===props[propName]&&(props[propName]=defaultProps[propName]);else props||(props=defaultProps||{});return{$$typeof:REACT_ELEMENT_TYPE,type:type,key:void 0===key?null:""+key,ref:null,props:props,_owner:null}}'),
      objectSpread2: helper("7.5.0", 'import defineProperty from"defineProperty";function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter((function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable}))),keys.push.apply(keys,symbols)}return keys}export default function _objectSpread2(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?ownKeys(Object(source),!0).forEach((function(key){defineProperty(target,key,source[key])})):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys(Object(source)).forEach((function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key))}))}return target}'),
      regeneratorRuntime: helper("7.18.0", `export default function _regeneratorRuntime(){"use strict";
/*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */_regeneratorRuntime=function(){return exports};var exports={},Op=Object.prototype,hasOwn=Op.hasOwnProperty,$Symbol="function"==typeof Symbol?Symbol:{},iteratorSymbol=$Symbol.iterator||"@@iterator",asyncIteratorSymbol=$Symbol.asyncIterator||"@@asyncIterator",toStringTagSymbol=$Symbol.toStringTag||"@@toStringTag";function define(obj,key,value){return Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}),obj[key]}try{define({},"")}catch(err){define=function(obj,key,value){return obj[key]=value}}function wrap(innerFn,outerFn,self,tryLocsList){var protoGenerator=outerFn&&outerFn.prototype instanceof Generator?outerFn:Generator,generator=Object.create(protoGenerator.prototype),context=new Context(tryLocsList||[]);return generator._invoke=function(innerFn,self,context){var state="suspendedStart";return function(method,arg){if("executing"===state)throw new Error("Generator is already running");if("completed"===state){if("throw"===method)throw arg;return doneResult()}for(context.method=method,context.arg=arg;;){var delegate=context.delegate;if(delegate){var delegateResult=maybeInvokeDelegate(delegate,context);if(delegateResult){if(delegateResult===ContinueSentinel)continue;return delegateResult}}if("next"===context.method)context.sent=context._sent=context.arg;else if("throw"===context.method){if("suspendedStart"===state)throw state="completed",context.arg;context.dispatchException(context.arg)}else"return"===context.method&&context.abrupt("return",context.arg);state="executing";var record=tryCatch(innerFn,self,context);if("normal"===record.type){if(state=context.done?"completed":"suspendedYield",record.arg===ContinueSentinel)continue;return{value:record.arg,done:context.done}}"throw"===record.type&&(state="completed",context.method="throw",context.arg=record.arg)}}}(innerFn,self,context),generator}function tryCatch(fn,obj,arg){try{return{type:"normal",arg:fn.call(obj,arg)}}catch(err){return{type:"throw",arg:err}}}exports.wrap=wrap;var ContinueSentinel={};function Generator(){}function GeneratorFunction(){}function GeneratorFunctionPrototype(){}var IteratorPrototype={};define(IteratorPrototype,iteratorSymbol,(function(){return this}));var getProto=Object.getPrototypeOf,NativeIteratorPrototype=getProto&&getProto(getProto(values([])));NativeIteratorPrototype&&NativeIteratorPrototype!==Op&&hasOwn.call(NativeIteratorPrototype,iteratorSymbol)&&(IteratorPrototype=NativeIteratorPrototype);var Gp=GeneratorFunctionPrototype.prototype=Generator.prototype=Object.create(IteratorPrototype);function defineIteratorMethods(prototype){["next","throw","return"].forEach((function(method){define(prototype,method,(function(arg){return this._invoke(method,arg)}))}))}function AsyncIterator(generator,PromiseImpl){function invoke(method,arg,resolve,reject){var record=tryCatch(generator[method],generator,arg);if("throw"!==record.type){var result=record.arg,value=result.value;return value&&"object"==typeof value&&hasOwn.call(value,"__await")?PromiseImpl.resolve(value.__await).then((function(value){invoke("next",value,resolve,reject)}),(function(err){invoke("throw",err,resolve,reject)})):PromiseImpl.resolve(value).then((function(unwrapped){result.value=unwrapped,resolve(result)}),(function(error){return invoke("throw",error,resolve,reject)}))}reject(record.arg)}var previousPromise;this._invoke=function(method,arg){function callInvokeWithMethodAndArg(){return new PromiseImpl((function(resolve,reject){invoke(method,arg,resolve,reject)}))}return previousPromise=previousPromise?previousPromise.then(callInvokeWithMethodAndArg,callInvokeWithMethodAndArg):callInvokeWithMethodAndArg()}}function maybeInvokeDelegate(delegate,context){var method=delegate.iterator[context.method];if(undefined===method){if(context.delegate=null,"throw"===context.method){if(delegate.iterator.return&&(context.method="return",context.arg=undefined,maybeInvokeDelegate(delegate,context),"throw"===context.method))return ContinueSentinel;context.method="throw",context.arg=new TypeError("The iterator does not provide a 'throw' method")}return ContinueSentinel}var record=tryCatch(method,delegate.iterator,context.arg);if("throw"===record.type)return context.method="throw",context.arg=record.arg,context.delegate=null,ContinueSentinel;var info=record.arg;return info?info.done?(context[delegate.resultName]=info.value,context.next=delegate.nextLoc,"return"!==context.method&&(context.method="next",context.arg=undefined),context.delegate=null,ContinueSentinel):info:(context.method="throw",context.arg=new TypeError("iterator result is not an object"),context.delegate=null,ContinueSentinel)}function pushTryEntry(locs){var entry={tryLoc:locs[0]};1 in locs&&(entry.catchLoc=locs[1]),2 in locs&&(entry.finallyLoc=locs[2],entry.afterLoc=locs[3]),this.tryEntries.push(entry)}function resetTryEntry(entry){var record=entry.completion||{};record.type="normal",delete record.arg,entry.completion=record}function Context(tryLocsList){this.tryEntries=[{tryLoc:"root"}],tryLocsList.forEach(pushTryEntry,this),this.reset(!0)}function values(iterable){if(iterable){var iteratorMethod=iterable[iteratorSymbol];if(iteratorMethod)return iteratorMethod.call(iterable);if("function"==typeof iterable.next)return iterable;if(!isNaN(iterable.length)){var i=-1,next=function next(){for(;++i<iterable.length;)if(hasOwn.call(iterable,i))return next.value=iterable[i],next.done=!1,next;return next.value=undefined,next.done=!0,next};return next.next=next}}return{next:doneResult}}function doneResult(){return{value:undefined,done:!0}}return GeneratorFunction.prototype=GeneratorFunctionPrototype,define(Gp,"constructor",GeneratorFunctionPrototype),define(GeneratorFunctionPrototype,"constructor",GeneratorFunction),GeneratorFunction.displayName=define(GeneratorFunctionPrototype,toStringTagSymbol,"GeneratorFunction"),exports.isGeneratorFunction=function(genFun){var ctor="function"==typeof genFun&&genFun.constructor;return!!ctor&&(ctor===GeneratorFunction||"GeneratorFunction"===(ctor.displayName||ctor.name))},exports.mark=function(genFun){return Object.setPrototypeOf?Object.setPrototypeOf(genFun,GeneratorFunctionPrototype):(genFun.__proto__=GeneratorFunctionPrototype,define(genFun,toStringTagSymbol,"GeneratorFunction")),genFun.prototype=Object.create(Gp),genFun},exports.awrap=function(arg){return{__await:arg}},defineIteratorMethods(AsyncIterator.prototype),define(AsyncIterator.prototype,asyncIteratorSymbol,(function(){return this})),exports.AsyncIterator=AsyncIterator,exports.async=function(innerFn,outerFn,self,tryLocsList,PromiseImpl){void 0===PromiseImpl&&(PromiseImpl=Promise);var iter=new AsyncIterator(wrap(innerFn,outerFn,self,tryLocsList),PromiseImpl);return exports.isGeneratorFunction(outerFn)?iter:iter.next().then((function(result){return result.done?result.value:iter.next()}))},defineIteratorMethods(Gp),define(Gp,toStringTagSymbol,"Generator"),define(Gp,iteratorSymbol,(function(){return this})),define(Gp,"toString",(function(){return"[object Generator]"})),exports.keys=function(object){var keys=[];for(var key in object)keys.push(key);return keys.reverse(),function next(){for(;keys.length;){var key=keys.pop();if(key in object)return next.value=key,next.done=!1,next}return next.done=!0,next}},exports.values=values,Context.prototype={constructor:Context,reset:function(skipTempReset){if(this.prev=0,this.next=0,this.sent=this._sent=undefined,this.done=!1,this.delegate=null,this.method="next",this.arg=undefined,this.tryEntries.forEach(resetTryEntry),!skipTempReset)for(var name in this)"t"===name.charAt(0)&&hasOwn.call(this,name)&&!isNaN(+name.slice(1))&&(this[name]=undefined)},stop:function(){this.done=!0;var rootRecord=this.tryEntries[0].completion;if("throw"===rootRecord.type)throw rootRecord.arg;return this.rval},dispatchException:function(exception){if(this.done)throw exception;var context=this;function handle(loc,caught){return record.type="throw",record.arg=exception,context.next=loc,caught&&(context.method="next",context.arg=undefined),!!caught}for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i],record=entry.completion;if("root"===entry.tryLoc)return handle("end");if(entry.tryLoc<=this.prev){var hasCatch=hasOwn.call(entry,"catchLoc"),hasFinally=hasOwn.call(entry,"finallyLoc");if(hasCatch&&hasFinally){if(this.prev<entry.catchLoc)return handle(entry.catchLoc,!0);if(this.prev<entry.finallyLoc)return handle(entry.finallyLoc)}else if(hasCatch){if(this.prev<entry.catchLoc)return handle(entry.catchLoc,!0)}else{if(!hasFinally)throw new Error("try statement without catch or finally");if(this.prev<entry.finallyLoc)return handle(entry.finallyLoc)}}}},abrupt:function(type,arg){for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i];if(entry.tryLoc<=this.prev&&hasOwn.call(entry,"finallyLoc")&&this.prev<entry.finallyLoc){var finallyEntry=entry;break}}finallyEntry&&("break"===type||"continue"===type)&&finallyEntry.tryLoc<=arg&&arg<=finallyEntry.finallyLoc&&(finallyEntry=null);var record=finallyEntry?finallyEntry.completion:{};return record.type=type,record.arg=arg,finallyEntry?(this.method="next",this.next=finallyEntry.finallyLoc,ContinueSentinel):this.complete(record)},complete:function(record,afterLoc){if("throw"===record.type)throw record.arg;return"break"===record.type||"continue"===record.type?this.next=record.arg:"return"===record.type?(this.rval=this.arg=record.arg,this.method="return",this.next="end"):"normal"===record.type&&afterLoc&&(this.next=afterLoc),ContinueSentinel},finish:function(finallyLoc){for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i];if(entry.finallyLoc===finallyLoc)return this.complete(entry.completion,entry.afterLoc),resetTryEntry(entry),ContinueSentinel}},catch:function(tryLoc){for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i];if(entry.tryLoc===tryLoc){var record=entry.completion;if("throw"===record.type){var thrown=record.arg;resetTryEntry(entry)}return thrown}}throw new Error("illegal catch attempt")},delegateYield:function(iterable,resultName,nextLoc){return this.delegate={iterator:values(iterable),resultName:resultName,nextLoc:nextLoc},"next"===this.method&&(this.arg=undefined),ContinueSentinel}},exports}`),
      typeof: helper("7.0.0-beta.0", 'export default function _typeof(obj){"@babel/helpers - typeof";return _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"==typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj},_typeof(obj)}'),
      wrapRegExp: helper("7.19.0", 'import setPrototypeOf from"setPrototypeOf";import inherits from"inherits";export default function _wrapRegExp(){_wrapRegExp=function(re,groups){return new BabelRegExp(re,void 0,groups)};var _super=RegExp.prototype,_groups=new WeakMap;function BabelRegExp(re,flags,groups){var _this=new RegExp(re,flags);return _groups.set(_this,groups||_groups.get(re)),setPrototypeOf(_this,BabelRegExp.prototype)}function buildGroups(result,re){var g=_groups.get(re);return Object.keys(g).reduce((function(groups,name){var i=g[name];if("number"==typeof i)groups[name]=result[i];else{for(var k=0;void 0===result[i[k]]&&k+1<i.length;)k++;groups[name]=result[i[k]]}return groups}),Object.create(null))}return inherits(BabelRegExp,RegExp),BabelRegExp.prototype.exec=function(str){var result=_super.exec.call(this,str);return result&&(result.groups=buildGroups(result,this)),result},BabelRegExp.prototype[Symbol.replace]=function(str,substitution){if("string"==typeof substitution){var groups=_groups.get(this);return _super[Symbol.replace].call(this,str,substitution.replace(/\\$<([^>]+)>/g,(function(_,name){return"$"+groups[name]})))}if("function"==typeof substitution){var _this=this;return _super[Symbol.replace].call(this,str,(function(){var args=arguments;return"object"!=typeof args[args.length-1]&&(args=[].slice.call(args)).push(buildGroups(args,_this)),substitution.apply(this,args)}))}return _super[Symbol.replace].call(this,str,substitution)},_wrapRegExp.apply(this,arguments)}')
    });
    exports2.default = _default;
  }
});

// node_modules/@babel/helpers/lib/helpers.js
var require_helpers = __commonJS({
  "node_modules/@babel/helpers/lib/helpers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _template = require_lib5();
    var _helpersGenerated = require_helpers_generated();
    var helpers = Object.assign({
      __proto__: null
    }, _helpersGenerated.default);
    var _default = helpers;
    exports2.default = _default;
    var helper = (minVersion) => (tpl) => ({
      minVersion,
      ast: () => _template.default.program.ast(tpl)
    });
    {
      helpers.AwaitValue = helper("7.0.0-beta.0")`
    export default function _AwaitValue(value) {
      this.wrapped = value;
    }
  `;
    }
    helpers.wrapAsyncGenerator = helper("7.0.0-beta.0")`
  import AsyncGenerator from "AsyncGenerator";

  export default function _wrapAsyncGenerator(fn) {
    return function () {
      return new AsyncGenerator(fn.apply(this, arguments));
    };
  }
`;
    helpers.asyncToGenerator = helper("7.0.0-beta.0")`
  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  export default function _asyncToGenerator(fn) {
    return function () {
      var self = this, args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);
        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }
`;
    helpers.classCallCheck = helper("7.0.0-beta.0")`
  export default function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
`;
    helpers.createClass = helper("7.0.0-beta.0")`
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i ++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  export default function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", { writable: false });
    return Constructor;
  }
`;
    helpers.defineEnumerableProperties = helper("7.0.0-beta.0")`
  export default function _defineEnumerableProperties(obj, descs) {
    for (var key in descs) {
      var desc = descs[key];
      desc.configurable = desc.enumerable = true;
      if ("value" in desc) desc.writable = true;
      Object.defineProperty(obj, key, desc);
    }

    // Symbols are not enumerated over by for-in loops. If native
    // Symbols are available, fetch all of the descs object's own
    // symbol properties and define them on our target object too.
    if (Object.getOwnPropertySymbols) {
      var objectSymbols = Object.getOwnPropertySymbols(descs);
      for (var i = 0; i < objectSymbols.length; i++) {
        var sym = objectSymbols[i];
        var desc = descs[sym];
        desc.configurable = desc.enumerable = true;
        if ("value" in desc) desc.writable = true;
        Object.defineProperty(obj, sym, desc);
      }
    }
    return obj;
  }
`;
    helpers.defaults = helper("7.0.0-beta.0")`
  export default function _defaults(obj, defaults) {
    var keys = Object.getOwnPropertyNames(defaults);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var value = Object.getOwnPropertyDescriptor(defaults, key);
      if (value && value.configurable && obj[key] === undefined) {
        Object.defineProperty(obj, key, value);
      }
    }
    return obj;
  }
`;
    helpers.defineProperty = helper("7.0.0-beta.0")`
  export default function _defineProperty(obj, key, value) {
    // Shortcircuit the slow defineProperty path when possible.
    // We are trying to avoid issues where setters defined on the
    // prototype cause side effects under the fast path of simple
    // assignment. By checking for existence of the property with
    // the in operator, we can optimize most of this overhead away.
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
`;
    helpers.extends = helper("7.0.0-beta.0")`
  export default function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };

    return _extends.apply(this, arguments);
  }
`;
    helpers.objectSpread = helper("7.0.0-beta.0")`
  import defineProperty from "defineProperty";

  export default function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = (arguments[i] != null) ? Object(arguments[i]) : {};
      var ownKeys = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === 'function') {
        ownKeys.push.apply(ownKeys, Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys.forEach(function(key) {
        defineProperty(target, key, source[key]);
      });
    }
    return target;
  }
`;
    helpers.inherits = helper("7.0.0-beta.0")`
  import setPrototypeOf from "setPrototypeOf";

  export default function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    // We can't use defineProperty to set the prototype in a single step because it
    // doesn't work in Chrome <= 36. https://github.com/babel/babel/issues/14056
    // V8 bug: https://bugs.chromium.org/p/v8/issues/detail?id=3334
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    Object.defineProperty(subClass, "prototype", { writable: false });
    if (superClass) setPrototypeOf(subClass, superClass);
  }
`;
    helpers.inheritsLoose = helper("7.0.0-beta.0")`
  import setPrototypeOf from "setPrototypeOf";

  export default function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    setPrototypeOf(subClass, superClass);
  }
`;
    helpers.getPrototypeOf = helper("7.0.0-beta.0")`
  export default function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf
      ? Object.getPrototypeOf.bind()
      : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        };
    return _getPrototypeOf(o);
  }
`;
    helpers.setPrototypeOf = helper("7.0.0-beta.0")`
  export default function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf
      ? Object.setPrototypeOf.bind()
      : function _setPrototypeOf(o, p) {
          o.__proto__ = p;
          return o;
        };
    return _setPrototypeOf(o, p);
  }
`;
    helpers.isNativeReflectConstruct = helper("7.9.0")`
  export default function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;

    // core-js@3
    if (Reflect.construct.sham) return false;

    // Proxy can't be polyfilled. Every browser implemented
    // proxies before or at the same time as Reflect.construct,
    // so if they support Proxy they also support Reflect.construct.
    if (typeof Proxy === "function") return true;

    // Since Reflect.construct can't be properly polyfilled, some
    // implementations (e.g. core-js@2) don't set the correct internal slots.
    // Those polyfills don't allow us to subclass built-ins, so we need to
    // use our fallback implementation.
    try {
      // If the internal slots aren't set, this throws an error similar to
      //   TypeError: this is not a Boolean object.

      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
      return true;
    } catch (e) {
      return false;
    }
  }
`;
    helpers.construct = helper("7.0.0-beta.0")`
  import setPrototypeOf from "setPrototypeOf";
  import isNativeReflectConstruct from "isNativeReflectConstruct";

  export default function _construct(Parent, args, Class) {
    if (isNativeReflectConstruct()) {
      _construct = Reflect.construct.bind();
    } else {
      // NOTE: If Parent !== Class, the correct __proto__ is set *after*
      //       calling the constructor.
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }
    // Avoid issues with Class being present but undefined when it wasn't
    // present in the original call.
    return _construct.apply(null, arguments);
  }
`;
    helpers.isNativeFunction = helper("7.0.0-beta.0")`
  export default function _isNativeFunction(fn) {
    // Note: This function returns "true" for core-js functions.
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }
`;
    helpers.wrapNativeSuper = helper("7.0.0-beta.0")`
  import getPrototypeOf from "getPrototypeOf";
  import setPrototypeOf from "setPrototypeOf";
  import isNativeFunction from "isNativeFunction";
  import construct from "construct";

  export default function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;

    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !isNativeFunction(Class)) return Class;
      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }
      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);
        _cache.set(Class, Wrapper);
      }
      function Wrapper() {
        return construct(Class, arguments, getPrototypeOf(this).constructor)
      }
      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true,
        }
      });

      return setPrototypeOf(Wrapper, Class);
    }

    return _wrapNativeSuper(Class)
  }
`;
    helpers.instanceof = helper("7.0.0-beta.0")`
  export default function _instanceof(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
      return !!right[Symbol.hasInstance](left);
    } else {
      return left instanceof right;
    }
  }
`;
    helpers.interopRequireDefault = helper("7.0.0-beta.0")`
  export default function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
`;
    helpers.interopRequireWildcard = helper("7.14.0")`
  function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;

    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function (nodeInterop) {
      return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
  }

  export default function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
      return obj;
    }

    if (obj === null || (typeof obj !== "object" && typeof obj !== "function")) {
      return { default: obj }
    }

    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }

    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) {
      if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor
          ? Object.getOwnPropertyDescriptor(obj, key)
          : null;
        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
    newObj.default = obj;
    if (cache) {
      cache.set(obj, newObj);
    }
    return newObj;
  }
`;
    helpers.newArrowCheck = helper("7.0.0-beta.0")`
  export default function _newArrowCheck(innerThis, boundThis) {
    if (innerThis !== boundThis) {
      throw new TypeError("Cannot instantiate an arrow function");
    }
  }
`;
    helpers.objectDestructuringEmpty = helper("7.0.0-beta.0")`
  export default function _objectDestructuringEmpty(obj) {
    if (obj == null) throw new TypeError("Cannot destructure undefined");
  }
`;
    helpers.objectWithoutPropertiesLoose = helper("7.0.0-beta.0")`
  export default function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};

    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }
`;
    helpers.objectWithoutProperties = helper("7.0.0-beta.0")`
  import objectWithoutPropertiesLoose from "objectWithoutPropertiesLoose";

  export default function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};

    var target = objectWithoutPropertiesLoose(source, excluded);
    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }
`;
    helpers.assertThisInitialized = helper("7.0.0-beta.0")`
  export default function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
  }
`;
    helpers.possibleConstructorReturn = helper("7.0.0-beta.0")`
  import assertThisInitialized from "assertThisInitialized";

  export default function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }

    return assertThisInitialized(self);
  }
`;
    helpers.createSuper = helper("7.9.0")`
  import getPrototypeOf from "getPrototypeOf";
  import isNativeReflectConstruct from "isNativeReflectConstruct";
  import possibleConstructorReturn from "possibleConstructorReturn";

  export default function _createSuper(Derived) {
    var hasNativeReflectConstruct = isNativeReflectConstruct();

    return function _createSuperInternal() {
      var Super = getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        // NOTE: This doesn't work if this.__proto__.constructor has been modified.
        var NewTarget = getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return possibleConstructorReturn(this, result);
    }
  }
 `;
    helpers.superPropBase = helper("7.0.0-beta.0")`
  import getPrototypeOf from "getPrototypeOf";

  export default function _superPropBase(object, property) {
    // Yes, this throws if object is null to being with, that's on purpose.
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = getPrototypeOf(object);
      if (object === null) break;
    }
    return object;
  }
`;
    helpers.get = helper("7.0.0-beta.0")`
  import superPropBase from "superPropBase";

  export default function _get() {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get.bind();
    } else {
      _get = function _get(target, property, receiver) {
        var base = superPropBase(target, property);

        if (!base) return;

        var desc = Object.getOwnPropertyDescriptor(base, property);
        if (desc.get) {
          // STEP 3. If receiver is not present, then set receiver to target.
          return desc.get.call(arguments.length < 3 ? target : receiver);
        }

        return desc.value;
      };
    }
    return _get.apply(this, arguments);
  }
`;
    helpers.set = helper("7.0.0-beta.0")`
  import superPropBase from "superPropBase";
  import defineProperty from "defineProperty";

  function set(target, property, value, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.set) {
      set = Reflect.set;
    } else {
      set = function set(target, property, value, receiver) {
        var base = superPropBase(target, property);
        var desc;

        if (base) {
          desc = Object.getOwnPropertyDescriptor(base, property);
          if (desc.set) {
            desc.set.call(receiver, value);
            return true;
          } else if (!desc.writable) {
            // Both getter and non-writable fall into this.
            return false;
          }
        }

        // Without a super that defines the property, spec boils down to
        // "define on receiver" for some reason.
        desc = Object.getOwnPropertyDescriptor(receiver, property);
        if (desc) {
          if (!desc.writable) {
            // Setter, getter, and non-writable fall into this.
            return false;
          }

          desc.value = value;
          Object.defineProperty(receiver, property, desc);
        } else {
          // Avoid setters that may be defined on Sub's prototype, but not on
          // the instance.
          defineProperty(receiver, property, value);
        }

        return true;
      };
    }

    return set(target, property, value, receiver);
  }

  export default function _set(target, property, value, receiver, isStrict) {
    var s = set(target, property, value, receiver || target);
    if (!s && isStrict) {
      throw new Error('failed to set property');
    }

    return value;
  }
`;
    helpers.taggedTemplateLiteral = helper("7.0.0-beta.0")`
  export default function _taggedTemplateLiteral(strings, raw) {
    if (!raw) { raw = strings.slice(0); }
    return Object.freeze(Object.defineProperties(strings, {
        raw: { value: Object.freeze(raw) }
    }));
  }
`;
    helpers.taggedTemplateLiteralLoose = helper("7.0.0-beta.0")`
  export default function _taggedTemplateLiteralLoose(strings, raw) {
    if (!raw) { raw = strings.slice(0); }
    strings.raw = raw;
    return strings;
  }
`;
    helpers.readOnlyError = helper("7.0.0-beta.0")`
  export default function _readOnlyError(name) {
    throw new TypeError("\\"" + name + "\\" is read-only");
  }
`;
    helpers.writeOnlyError = helper("7.12.13")`
  export default function _writeOnlyError(name) {
    throw new TypeError("\\"" + name + "\\" is write-only");
  }
`;
    helpers.classNameTDZError = helper("7.0.0-beta.0")`
  export default function _classNameTDZError(name) {
    throw new Error("Class \\"" + name + "\\" cannot be referenced in computed property keys.");
  }
`;
    helpers.temporalUndefined = helper("7.0.0-beta.0")`
  // This function isn't mean to be called, but to be used as a reference.
  // We can't use a normal object because it isn't hoisted.
  export default function _temporalUndefined() {}
`;
    helpers.tdz = helper("7.5.5")`
  export default function _tdzError(name) {
    throw new ReferenceError(name + " is not defined - temporal dead zone");
  }
`;
    helpers.temporalRef = helper("7.0.0-beta.0")`
  import undef from "temporalUndefined";
  import err from "tdz";

  export default function _temporalRef(val, name) {
    return val === undef ? err(name) : val;
  }
`;
    helpers.slicedToArray = helper("7.0.0-beta.0")`
  import arrayWithHoles from "arrayWithHoles";
  import iterableToArrayLimit from "iterableToArrayLimit";
  import unsupportedIterableToArray from "unsupportedIterableToArray";
  import nonIterableRest from "nonIterableRest";

  export default function _slicedToArray(arr, i) {
    return (
      arrayWithHoles(arr) ||
      iterableToArrayLimit(arr, i) ||
      unsupportedIterableToArray(arr, i) ||
      nonIterableRest()
    );
  }
`;
    helpers.slicedToArrayLoose = helper("7.0.0-beta.0")`
  import arrayWithHoles from "arrayWithHoles";
  import iterableToArrayLimitLoose from "iterableToArrayLimitLoose";
  import unsupportedIterableToArray from "unsupportedIterableToArray";
  import nonIterableRest from "nonIterableRest";

  export default function _slicedToArrayLoose(arr, i) {
    return (
      arrayWithHoles(arr) ||
      iterableToArrayLimitLoose(arr, i) ||
      unsupportedIterableToArray(arr, i) ||
      nonIterableRest()
    );
  }
`;
    helpers.toArray = helper("7.0.0-beta.0")`
  import arrayWithHoles from "arrayWithHoles";
  import iterableToArray from "iterableToArray";
  import unsupportedIterableToArray from "unsupportedIterableToArray";
  import nonIterableRest from "nonIterableRest";

  export default function _toArray(arr) {
    return (
      arrayWithHoles(arr) ||
      iterableToArray(arr) ||
      unsupportedIterableToArray(arr) ||
      nonIterableRest()
    );
  }
`;
    helpers.toConsumableArray = helper("7.0.0-beta.0")`
  import arrayWithoutHoles from "arrayWithoutHoles";
  import iterableToArray from "iterableToArray";
  import unsupportedIterableToArray from "unsupportedIterableToArray";
  import nonIterableSpread from "nonIterableSpread";

  export default function _toConsumableArray(arr) {
    return (
      arrayWithoutHoles(arr) ||
      iterableToArray(arr) ||
      unsupportedIterableToArray(arr) ||
      nonIterableSpread()
    );
  }
`;
    helpers.arrayWithoutHoles = helper("7.0.0-beta.0")`
  import arrayLikeToArray from "arrayLikeToArray";

  export default function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return arrayLikeToArray(arr);
  }
`;
    helpers.arrayWithHoles = helper("7.0.0-beta.0")`
  export default function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }
`;
    helpers.maybeArrayLike = helper("7.9.0")`
  import arrayLikeToArray from "arrayLikeToArray";

  export default function _maybeArrayLike(next, arr, i) {
    if (arr && !Array.isArray(arr) && typeof arr.length === "number") {
      var len = arr.length;
      return arrayLikeToArray(arr, i !== void 0 && i < len ? i : len);
    }
    return next(arr, i);
  }
`;
    helpers.iterableToArray = helper("7.0.0-beta.0")`
  export default function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }
`;
    helpers.iterableToArrayLimit = helper("7.0.0-beta.0")`
  export default function _iterableToArrayLimit(arr, i) {
    // this is an expanded form of \`for...of\` that properly supports abrupt completions of
    // iterators etc. variable names have been minimised to reduce the size of this massive
    // helper. sometimes spec compliance is annoying :(
    //
    // _n = _iteratorNormalCompletion
    // _d = _didIteratorError
    // _e = _iteratorError
    // _i = _iterator
    // _s = _step

    var _i = arr == null ? null : (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
    if (_i == null) return;

    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
`;
    helpers.iterableToArrayLimitLoose = helper("7.0.0-beta.0")`
  export default function _iterableToArrayLimitLoose(arr, i) {
    var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
    if (_i == null) return;

    var _arr = [];
    for (_i = _i.call(arr), _step; !(_step = _i.next()).done;) {
      _arr.push(_step.value);
      if (i && _arr.length === i) break;
    }
    return _arr;
  }
`;
    helpers.unsupportedIterableToArray = helper("7.9.0")`
  import arrayLikeToArray from "arrayLikeToArray";

  export default function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return arrayLikeToArray(o, minLen);
  }
`;
    helpers.arrayLikeToArray = helper("7.9.0")`
  export default function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
    return arr2;
  }
`;
    helpers.nonIterableSpread = helper("7.0.0-beta.0")`
  export default function _nonIterableSpread() {
    throw new TypeError(
      "Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
`;
    helpers.nonIterableRest = helper("7.0.0-beta.0")`
  export default function _nonIterableRest() {
    throw new TypeError(
      "Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
`;
    helpers.createForOfIteratorHelper = helper("7.9.0")`
  import unsupportedIterableToArray from "unsupportedIterableToArray";

  // s: start (create the iterator)
  // n: next
  // e: error (called whenever something throws)
  // f: finish (always called at the end)

  export default function _createForOfIteratorHelper(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

    if (!it) {
      // Fallback for engines without symbol support
      if (
        Array.isArray(o) ||
        (it = unsupportedIterableToArray(o)) ||
        (allowArrayLike && o && typeof o.length === "number")
      ) {
        if (it) o = it;
        var i = 0;
        var F = function(){};
        return {
          s: F,
          n: function() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          },
          e: function(e) { throw e; },
          f: F,
        };
      }

      throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    var normalCompletion = true, didErr = false, err;

    return {
      s: function() {
        it = it.call(o);
      },
      n: function() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function(e) {
        didErr = true;
        err = e;
      },
      f: function() {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      }
    };
  }
`;
    helpers.createForOfIteratorHelperLoose = helper("7.9.0")`
  import unsupportedIterableToArray from "unsupportedIterableToArray";

  export default function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

    if (it) return (it = it.call(o)).next.bind(it);

    // Fallback for engines without symbol support
    if (
      Array.isArray(o) ||
      (it = unsupportedIterableToArray(o)) ||
      (allowArrayLike && o && typeof o.length === "number")
    ) {
      if (it) o = it;
      var i = 0;
      return function() {
        if (i >= o.length) return { done: true };
        return { done: false, value: o[i++] };
      }
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
`;
    helpers.skipFirstGeneratorNext = helper("7.0.0-beta.0")`
  export default function _skipFirstGeneratorNext(fn) {
    return function () {
      var it = fn.apply(this, arguments);
      it.next();
      return it;
    }
  }
`;
    helpers.toPrimitive = helper("7.1.5")`
  export default function _toPrimitive(
    input,
    hint /*: "default" | "string" | "number" | void */
  ) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
`;
    helpers.toPropertyKey = helper("7.1.5")`
  import toPrimitive from "toPrimitive";

  export default function _toPropertyKey(arg) {
    var key = toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
`;
    helpers.initializerWarningHelper = helper("7.0.0-beta.0")`
    export default function _initializerWarningHelper(descriptor, context){
        throw new Error(
          'Decorating class property failed. Please ensure that ' +
          'proposal-class-properties is enabled and runs after the decorators transform.'
        );
    }
`;
    helpers.initializerDefineProperty = helper("7.0.0-beta.0")`
    export default function _initializerDefineProperty(target, property, descriptor, context){
        if (!descriptor) return;

        Object.defineProperty(target, property, {
            enumerable: descriptor.enumerable,
            configurable: descriptor.configurable,
            writable: descriptor.writable,
            value: descriptor.initializer ? descriptor.initializer.call(context) : void 0,
        });
    }
`;
    helpers.applyDecoratedDescriptor = helper("7.0.0-beta.0")`
    export default function _applyDecoratedDescriptor(target, property, decorators, descriptor, context){
        var desc = {};
        Object.keys(descriptor).forEach(function(key){
            desc[key] = descriptor[key];
        });
        desc.enumerable = !!desc.enumerable;
        desc.configurable = !!desc.configurable;
        if ('value' in desc || desc.initializer){
            desc.writable = true;
        }

        desc = decorators.slice().reverse().reduce(function(desc, decorator){
            return decorator(target, property, desc) || desc;
        }, desc);

        if (context && desc.initializer !== void 0){
            desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
            desc.initializer = undefined;
        }

        if (desc.initializer === void 0){
            Object.defineProperty(target, property, desc);
            desc = null;
        }

        return desc;
    }
`;
    helpers.classPrivateFieldLooseKey = helper("7.0.0-beta.0")`
  var id = 0;
  export default function _classPrivateFieldKey(name) {
    return "__private_" + (id++) + "_" + name;
  }
`;
    helpers.classPrivateFieldLooseBase = helper("7.0.0-beta.0")`
  export default function _classPrivateFieldBase(receiver, privateKey) {
    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
      throw new TypeError("attempted to use private field on non-instance");
    }
    return receiver;
  }
`;
    helpers.classPrivateFieldGet = helper("7.0.0-beta.0")`
  import classApplyDescriptorGet from "classApplyDescriptorGet";
  import classExtractFieldDescriptor from "classExtractFieldDescriptor";
  export default function _classPrivateFieldGet(receiver, privateMap) {
    var descriptor = classExtractFieldDescriptor(receiver, privateMap, "get");
    return classApplyDescriptorGet(receiver, descriptor);
  }
`;
    helpers.classPrivateFieldSet = helper("7.0.0-beta.0")`
  import classApplyDescriptorSet from "classApplyDescriptorSet";
  import classExtractFieldDescriptor from "classExtractFieldDescriptor";
  export default function _classPrivateFieldSet(receiver, privateMap, value) {
    var descriptor = classExtractFieldDescriptor(receiver, privateMap, "set");
    classApplyDescriptorSet(receiver, descriptor, value);
    return value;
  }
`;
    helpers.classPrivateFieldDestructureSet = helper("7.4.4")`
  import classApplyDescriptorDestructureSet from "classApplyDescriptorDestructureSet";
  import classExtractFieldDescriptor from "classExtractFieldDescriptor";
  export default function _classPrivateFieldDestructureSet(receiver, privateMap) {
    var descriptor = classExtractFieldDescriptor(receiver, privateMap, "set");
    return classApplyDescriptorDestructureSet(receiver, descriptor);
  }
`;
    helpers.classExtractFieldDescriptor = helper("7.13.10")`
  export default function _classExtractFieldDescriptor(receiver, privateMap, action) {
    if (!privateMap.has(receiver)) {
      throw new TypeError("attempted to " + action + " private field on non-instance");
    }
    return privateMap.get(receiver);
  }
`;
    helpers.classStaticPrivateFieldSpecGet = helper("7.0.2")`
  import classApplyDescriptorGet from "classApplyDescriptorGet";
  import classCheckPrivateStaticAccess from "classCheckPrivateStaticAccess";
  import classCheckPrivateStaticFieldDescriptor from "classCheckPrivateStaticFieldDescriptor";
  export default function _classStaticPrivateFieldSpecGet(receiver, classConstructor, descriptor) {
    classCheckPrivateStaticAccess(receiver, classConstructor);
    classCheckPrivateStaticFieldDescriptor(descriptor, "get");
    return classApplyDescriptorGet(receiver, descriptor);
  }
`;
    helpers.classStaticPrivateFieldSpecSet = helper("7.0.2")`
  import classApplyDescriptorSet from "classApplyDescriptorSet";
  import classCheckPrivateStaticAccess from "classCheckPrivateStaticAccess";
  import classCheckPrivateStaticFieldDescriptor from "classCheckPrivateStaticFieldDescriptor";
  export default function _classStaticPrivateFieldSpecSet(receiver, classConstructor, descriptor, value) {
    classCheckPrivateStaticAccess(receiver, classConstructor);
    classCheckPrivateStaticFieldDescriptor(descriptor, "set");
    classApplyDescriptorSet(receiver, descriptor, value);
    return value;
  }
`;
    helpers.classStaticPrivateMethodGet = helper("7.3.2")`
  import classCheckPrivateStaticAccess from "classCheckPrivateStaticAccess";
  export default function _classStaticPrivateMethodGet(receiver, classConstructor, method) {
    classCheckPrivateStaticAccess(receiver, classConstructor);
    return method;
  }
`;
    helpers.classStaticPrivateMethodSet = helper("7.3.2")`
  export default function _classStaticPrivateMethodSet() {
    throw new TypeError("attempted to set read only static private field");
  }
`;
    helpers.classApplyDescriptorGet = helper("7.13.10")`
  export default function _classApplyDescriptorGet(receiver, descriptor) {
    if (descriptor.get) {
      return descriptor.get.call(receiver);
    }
    return descriptor.value;
  }
`;
    helpers.classApplyDescriptorSet = helper("7.13.10")`
  export default function _classApplyDescriptorSet(receiver, descriptor, value) {
    if (descriptor.set) {
      descriptor.set.call(receiver, value);
    } else {
      if (!descriptor.writable) {
        // This should only throw in strict mode, but class bodies are
        // always strict and private fields can only be used inside
        // class bodies.
        throw new TypeError("attempted to set read only private field");
      }
      descriptor.value = value;
    }
  }
`;
    helpers.classApplyDescriptorDestructureSet = helper("7.13.10")`
  export default function _classApplyDescriptorDestructureSet(receiver, descriptor) {
    if (descriptor.set) {
      if (!("__destrObj" in descriptor)) {
        descriptor.__destrObj = {
          set value(v) {
            descriptor.set.call(receiver, v)
          },
        };
      }
      return descriptor.__destrObj;
    } else {
      if (!descriptor.writable) {
        // This should only throw in strict mode, but class bodies are
        // always strict and private fields can only be used inside
        // class bodies.
        throw new TypeError("attempted to set read only private field");
      }

      return descriptor;
    }
  }
`;
    helpers.classStaticPrivateFieldDestructureSet = helper("7.13.10")`
  import classApplyDescriptorDestructureSet from "classApplyDescriptorDestructureSet";
  import classCheckPrivateStaticAccess from "classCheckPrivateStaticAccess";
  import classCheckPrivateStaticFieldDescriptor from "classCheckPrivateStaticFieldDescriptor";
  export default function _classStaticPrivateFieldDestructureSet(receiver, classConstructor, descriptor) {
    classCheckPrivateStaticAccess(receiver, classConstructor);
    classCheckPrivateStaticFieldDescriptor(descriptor, "set");
    return classApplyDescriptorDestructureSet(receiver, descriptor);
  }
`;
    helpers.classCheckPrivateStaticAccess = helper("7.13.10")`
  export default function _classCheckPrivateStaticAccess(receiver, classConstructor) {
    if (receiver !== classConstructor) {
      throw new TypeError("Private static access of wrong provenance");
    }
  }
`;
    helpers.classCheckPrivateStaticFieldDescriptor = helper("7.13.10")`
  export default function _classCheckPrivateStaticFieldDescriptor(descriptor, action) {
    if (descriptor === undefined) {
      throw new TypeError("attempted to " + action + " private static field before its declaration");
    }
  }
`;
    helpers.decorate = helper("7.1.5")`
  import toArray from "toArray";
  import toPropertyKey from "toPropertyKey";

  // These comments are stripped by @babel/template
  /*::
  type PropertyDescriptor =
    | {
        value: any,
        writable: boolean,
        configurable: boolean,
        enumerable: boolean,
      }
    | {
        get?: () => any,
        set?: (v: any) => void,
        configurable: boolean,
        enumerable: boolean,
      };

  type FieldDescriptor ={
    writable: boolean,
    configurable: boolean,
    enumerable: boolean,
  };

  type Placement = "static" | "prototype" | "own";
  type Key = string | symbol; // PrivateName is not supported yet.

  type ElementDescriptor =
    | {
        kind: "method",
        key: Key,
        placement: Placement,
        descriptor: PropertyDescriptor
      }
    | {
        kind: "field",
        key: Key,
        placement: Placement,
        descriptor: FieldDescriptor,
        initializer?: () => any,
      };

  // This is exposed to the user code
  type ElementObjectInput = ElementDescriptor & {
    [@@toStringTag]?: "Descriptor"
  };

  // This is exposed to the user code
  type ElementObjectOutput = ElementDescriptor & {
    [@@toStringTag]?: "Descriptor"
    extras?: ElementDescriptor[],
    finisher?: ClassFinisher,
  };

  // This is exposed to the user code
  type ClassObject = {
    [@@toStringTag]?: "Descriptor",
    kind: "class",
    elements: ElementDescriptor[],
  };

  type ElementDecorator = (descriptor: ElementObjectInput) => ?ElementObjectOutput;
  type ClassDecorator = (descriptor: ClassObject) => ?ClassObject;
  type ClassFinisher = <A, B>(cl: Class<A>) => Class<B>;

  // Only used by Babel in the transform output, not part of the spec.
  type ElementDefinition =
    | {
        kind: "method",
        value: any,
        key: Key,
        static?: boolean,
        decorators?: ElementDecorator[],
      }
    | {
        kind: "field",
        value: () => any,
        key: Key,
        static?: boolean,
        decorators?: ElementDecorator[],
    };

  declare function ClassFactory<C>(initialize: (instance: C) => void): {
    F: Class<C>,
    d: ElementDefinition[]
  }

  */

  /*::
  // Various combinations with/without extras and with one or many finishers

  type ElementFinisherExtras = {
    element: ElementDescriptor,
    finisher?: ClassFinisher,
    extras?: ElementDescriptor[],
  };

  type ElementFinishersExtras = {
    element: ElementDescriptor,
    finishers: ClassFinisher[],
    extras: ElementDescriptor[],
  };

  type ElementsFinisher = {
    elements: ElementDescriptor[],
    finisher?: ClassFinisher,
  };

  type ElementsFinishers = {
    elements: ElementDescriptor[],
    finishers: ClassFinisher[],
  };

  */

  /*::

  type Placements = {
    static: Key[],
    prototype: Key[],
    own: Key[],
  };

  */

  // ClassDefinitionEvaluation (Steps 26-*)
  export default function _decorate(
    decorators /*: ClassDecorator[] */,
    factory /*: ClassFactory */,
    superClass /*: ?Class<*> */,
    mixins /*: ?Array<Function> */,
  ) /*: Class<*> */ {
    var api = _getDecoratorsApi();
    if (mixins) {
      for (var i = 0; i < mixins.length; i++) {
        api = mixins[i](api);
      }
    }

    var r = factory(function initialize(O) {
      api.initializeInstanceElements(O, decorated.elements);
    }, superClass);
    var decorated = api.decorateClass(
      _coalesceClassElements(r.d.map(_createElementDescriptor)),
      decorators,
    );

    api.initializeClassElements(r.F, decorated.elements);

    return api.runClassFinishers(r.F, decorated.finishers);
  }

  function _getDecoratorsApi() {
    _getDecoratorsApi = function() {
      return api;
    };

    var api = {
      elementsDefinitionOrder: [["method"], ["field"]],

      // InitializeInstanceElements
      initializeInstanceElements: function(
        /*::<C>*/ O /*: C */,
        elements /*: ElementDescriptor[] */,
      ) {
        ["method", "field"].forEach(function(kind) {
          elements.forEach(function(element /*: ElementDescriptor */) {
            if (element.kind === kind && element.placement === "own") {
              this.defineClassElement(O, element);
            }
          }, this);
        }, this);
      },

      // InitializeClassElements
      initializeClassElements: function(
        /*::<C>*/ F /*: Class<C> */,
        elements /*: ElementDescriptor[] */,
      ) {
        var proto = F.prototype;

        ["method", "field"].forEach(function(kind) {
          elements.forEach(function(element /*: ElementDescriptor */) {
            var placement = element.placement;
            if (
              element.kind === kind &&
              (placement === "static" || placement === "prototype")
            ) {
              var receiver = placement === "static" ? F : proto;
              this.defineClassElement(receiver, element);
            }
          }, this);
        }, this);
      },

      // DefineClassElement
      defineClassElement: function(
        /*::<C>*/ receiver /*: C | Class<C> */,
        element /*: ElementDescriptor */,
      ) {
        var descriptor /*: PropertyDescriptor */ = element.descriptor;
        if (element.kind === "field") {
          var initializer = element.initializer;
          descriptor = {
            enumerable: descriptor.enumerable,
            writable: descriptor.writable,
            configurable: descriptor.configurable,
            value: initializer === void 0 ? void 0 : initializer.call(receiver),
          };
        }
        Object.defineProperty(receiver, element.key, descriptor);
      },

      // DecorateClass
      decorateClass: function(
        elements /*: ElementDescriptor[] */,
        decorators /*: ClassDecorator[] */,
      ) /*: ElementsFinishers */ {
        var newElements /*: ElementDescriptor[] */ = [];
        var finishers /*: ClassFinisher[] */ = [];
        var placements /*: Placements */ = {
          static: [],
          prototype: [],
          own: [],
        };

        elements.forEach(function(element /*: ElementDescriptor */) {
          this.addElementPlacement(element, placements);
        }, this);

        elements.forEach(function(element /*: ElementDescriptor */) {
          if (!_hasDecorators(element)) return newElements.push(element);

          var elementFinishersExtras /*: ElementFinishersExtras */ = this.decorateElement(
            element,
            placements,
          );
          newElements.push(elementFinishersExtras.element);
          newElements.push.apply(newElements, elementFinishersExtras.extras);
          finishers.push.apply(finishers, elementFinishersExtras.finishers);
        }, this);

        if (!decorators) {
          return { elements: newElements, finishers: finishers };
        }

        var result /*: ElementsFinishers */ = this.decorateConstructor(
          newElements,
          decorators,
        );
        finishers.push.apply(finishers, result.finishers);
        result.finishers = finishers;

        return result;
      },

      // AddElementPlacement
      addElementPlacement: function(
        element /*: ElementDescriptor */,
        placements /*: Placements */,
        silent /*: boolean */,
      ) {
        var keys = placements[element.placement];
        if (!silent && keys.indexOf(element.key) !== -1) {
          throw new TypeError("Duplicated element (" + element.key + ")");
        }
        keys.push(element.key);
      },

      // DecorateElement
      decorateElement: function(
        element /*: ElementDescriptor */,
        placements /*: Placements */,
      ) /*: ElementFinishersExtras */ {
        var extras /*: ElementDescriptor[] */ = [];
        var finishers /*: ClassFinisher[] */ = [];

        for (
          var decorators = element.decorators, i = decorators.length - 1;
          i >= 0;
          i--
        ) {
          // (inlined) RemoveElementPlacement
          var keys = placements[element.placement];
          keys.splice(keys.indexOf(element.key), 1);

          var elementObject /*: ElementObjectInput */ = this.fromElementDescriptor(
            element,
          );
          var elementFinisherExtras /*: ElementFinisherExtras */ = this.toElementFinisherExtras(
            (0, decorators[i])(elementObject) /*: ElementObjectOutput */ ||
              elementObject,
          );

          element = elementFinisherExtras.element;
          this.addElementPlacement(element, placements);

          if (elementFinisherExtras.finisher) {
            finishers.push(elementFinisherExtras.finisher);
          }

          var newExtras /*: ElementDescriptor[] | void */ =
            elementFinisherExtras.extras;
          if (newExtras) {
            for (var j = 0; j < newExtras.length; j++) {
              this.addElementPlacement(newExtras[j], placements);
            }
            extras.push.apply(extras, newExtras);
          }
        }

        return { element: element, finishers: finishers, extras: extras };
      },

      // DecorateConstructor
      decorateConstructor: function(
        elements /*: ElementDescriptor[] */,
        decorators /*: ClassDecorator[] */,
      ) /*: ElementsFinishers */ {
        var finishers /*: ClassFinisher[] */ = [];

        for (var i = decorators.length - 1; i >= 0; i--) {
          var obj /*: ClassObject */ = this.fromClassDescriptor(elements);
          var elementsAndFinisher /*: ElementsFinisher */ = this.toClassDescriptor(
            (0, decorators[i])(obj) /*: ClassObject */ || obj,
          );

          if (elementsAndFinisher.finisher !== undefined) {
            finishers.push(elementsAndFinisher.finisher);
          }

          if (elementsAndFinisher.elements !== undefined) {
            elements = elementsAndFinisher.elements;

            for (var j = 0; j < elements.length - 1; j++) {
              for (var k = j + 1; k < elements.length; k++) {
                if (
                  elements[j].key === elements[k].key &&
                  elements[j].placement === elements[k].placement
                ) {
                  throw new TypeError(
                    "Duplicated element (" + elements[j].key + ")",
                  );
                }
              }
            }
          }
        }

        return { elements: elements, finishers: finishers };
      },

      // FromElementDescriptor
      fromElementDescriptor: function(
        element /*: ElementDescriptor */,
      ) /*: ElementObject */ {
        var obj /*: ElementObject */ = {
          kind: element.kind,
          key: element.key,
          placement: element.placement,
          descriptor: element.descriptor,
        };

        var desc = {
          value: "Descriptor",
          configurable: true,
        };
        Object.defineProperty(obj, Symbol.toStringTag, desc);

        if (element.kind === "field") obj.initializer = element.initializer;

        return obj;
      },

      // ToElementDescriptors
      toElementDescriptors: function(
        elementObjects /*: ElementObject[] */,
      ) /*: ElementDescriptor[] */ {
        if (elementObjects === undefined) return;
        return toArray(elementObjects).map(function(elementObject) {
          var element = this.toElementDescriptor(elementObject);
          this.disallowProperty(elementObject, "finisher", "An element descriptor");
          this.disallowProperty(elementObject, "extras", "An element descriptor");
          return element;
        }, this);
      },

      // ToElementDescriptor
      toElementDescriptor: function(
        elementObject /*: ElementObject */,
      ) /*: ElementDescriptor */ {
        var kind = String(elementObject.kind);
        if (kind !== "method" && kind !== "field") {
          throw new TypeError(
            'An element descriptor\\'s .kind property must be either "method" or' +
              ' "field", but a decorator created an element descriptor with' +
              ' .kind "' +
              kind +
              '"',
          );
        }

        var key = toPropertyKey(elementObject.key);

        var placement = String(elementObject.placement);
        if (
          placement !== "static" &&
          placement !== "prototype" &&
          placement !== "own"
        ) {
          throw new TypeError(
            'An element descriptor\\'s .placement property must be one of "static",' +
              ' "prototype" or "own", but a decorator created an element descriptor' +
              ' with .placement "' +
              placement +
              '"',
          );
        }

        var descriptor /*: PropertyDescriptor */ = elementObject.descriptor;

        this.disallowProperty(elementObject, "elements", "An element descriptor");

        var element /*: ElementDescriptor */ = {
          kind: kind,
          key: key,
          placement: placement,
          descriptor: Object.assign({}, descriptor),
        };

        if (kind !== "field") {
          this.disallowProperty(elementObject, "initializer", "A method descriptor");
        } else {
          this.disallowProperty(
            descriptor,
            "get",
            "The property descriptor of a field descriptor",
          );
          this.disallowProperty(
            descriptor,
            "set",
            "The property descriptor of a field descriptor",
          );
          this.disallowProperty(
            descriptor,
            "value",
            "The property descriptor of a field descriptor",
          );

          element.initializer = elementObject.initializer;
        }

        return element;
      },

      toElementFinisherExtras: function(
        elementObject /*: ElementObject */,
      ) /*: ElementFinisherExtras */ {
        var element /*: ElementDescriptor */ = this.toElementDescriptor(
          elementObject,
        );
        var finisher /*: ClassFinisher */ = _optionalCallableProperty(
          elementObject,
          "finisher",
        );
        var extras /*: ElementDescriptors[] */ = this.toElementDescriptors(
          elementObject.extras,
        );

        return { element: element, finisher: finisher, extras: extras };
      },

      // FromClassDescriptor
      fromClassDescriptor: function(
        elements /*: ElementDescriptor[] */,
      ) /*: ClassObject */ {
        var obj = {
          kind: "class",
          elements: elements.map(this.fromElementDescriptor, this),
        };

        var desc = { value: "Descriptor", configurable: true };
        Object.defineProperty(obj, Symbol.toStringTag, desc);

        return obj;
      },

      // ToClassDescriptor
      toClassDescriptor: function(
        obj /*: ClassObject */,
      ) /*: ElementsFinisher */ {
        var kind = String(obj.kind);
        if (kind !== "class") {
          throw new TypeError(
            'A class descriptor\\'s .kind property must be "class", but a decorator' +
              ' created a class descriptor with .kind "' +
              kind +
              '"',
          );
        }

        this.disallowProperty(obj, "key", "A class descriptor");
        this.disallowProperty(obj, "placement", "A class descriptor");
        this.disallowProperty(obj, "descriptor", "A class descriptor");
        this.disallowProperty(obj, "initializer", "A class descriptor");
        this.disallowProperty(obj, "extras", "A class descriptor");

        var finisher = _optionalCallableProperty(obj, "finisher");
        var elements = this.toElementDescriptors(obj.elements);

        return { elements: elements, finisher: finisher };
      },

      // RunClassFinishers
      runClassFinishers: function(
        constructor /*: Class<*> */,
        finishers /*: ClassFinisher[] */,
      ) /*: Class<*> */ {
        for (var i = 0; i < finishers.length; i++) {
          var newConstructor /*: ?Class<*> */ = (0, finishers[i])(constructor);
          if (newConstructor !== undefined) {
            // NOTE: This should check if IsConstructor(newConstructor) is false.
            if (typeof newConstructor !== "function") {
              throw new TypeError("Finishers must return a constructor.");
            }
            constructor = newConstructor;
          }
        }
        return constructor;
      },

      disallowProperty: function(obj, name, objectType) {
        if (obj[name] !== undefined) {
          throw new TypeError(objectType + " can't have a ." + name + " property.");
        }
      }
    };

    return api;
  }

  // ClassElementEvaluation
  function _createElementDescriptor(
    def /*: ElementDefinition */,
  ) /*: ElementDescriptor */ {
    var key = toPropertyKey(def.key);

    var descriptor /*: PropertyDescriptor */;
    if (def.kind === "method") {
      descriptor = {
        value: def.value,
        writable: true,
        configurable: true,
        enumerable: false,
      };
    } else if (def.kind === "get") {
      descriptor = { get: def.value, configurable: true, enumerable: false };
    } else if (def.kind === "set") {
      descriptor = { set: def.value, configurable: true, enumerable: false };
    } else if (def.kind === "field") {
      descriptor = { configurable: true, writable: true, enumerable: true };
    }

    var element /*: ElementDescriptor */ = {
      kind: def.kind === "field" ? "field" : "method",
      key: key,
      placement: def.static
        ? "static"
        : def.kind === "field"
        ? "own"
        : "prototype",
      descriptor: descriptor,
    };
    if (def.decorators) element.decorators = def.decorators;
    if (def.kind === "field") element.initializer = def.value;

    return element;
  }

  // CoalesceGetterSetter
  function _coalesceGetterSetter(
    element /*: ElementDescriptor */,
    other /*: ElementDescriptor */,
  ) {
    if (element.descriptor.get !== undefined) {
      other.descriptor.get = element.descriptor.get;
    } else {
      other.descriptor.set = element.descriptor.set;
    }
  }

  // CoalesceClassElements
  function _coalesceClassElements(
    elements /*: ElementDescriptor[] */,
  ) /*: ElementDescriptor[] */ {
    var newElements /*: ElementDescriptor[] */ = [];

    var isSameElement = function(
      other /*: ElementDescriptor */,
    ) /*: boolean */ {
      return (
        other.kind === "method" &&
        other.key === element.key &&
        other.placement === element.placement
      );
    };

    for (var i = 0; i < elements.length; i++) {
      var element /*: ElementDescriptor */ = elements[i];
      var other /*: ElementDescriptor */;

      if (
        element.kind === "method" &&
        (other = newElements.find(isSameElement))
      ) {
        if (
          _isDataDescriptor(element.descriptor) ||
          _isDataDescriptor(other.descriptor)
        ) {
          if (_hasDecorators(element) || _hasDecorators(other)) {
            throw new ReferenceError(
              "Duplicated methods (" + element.key + ") can't be decorated.",
            );
          }
          other.descriptor = element.descriptor;
        } else {
          if (_hasDecorators(element)) {
            if (_hasDecorators(other)) {
              throw new ReferenceError(
                "Decorators can't be placed on different accessors with for " +
                  "the same property (" +
                  element.key +
                  ").",
              );
            }
            other.decorators = element.decorators;
          }
          _coalesceGetterSetter(element, other);
        }
      } else {
        newElements.push(element);
      }
    }

    return newElements;
  }

  function _hasDecorators(element /*: ElementDescriptor */) /*: boolean */ {
    return element.decorators && element.decorators.length;
  }

  function _isDataDescriptor(desc /*: PropertyDescriptor */) /*: boolean */ {
    return (
      desc !== undefined &&
      !(desc.value === undefined && desc.writable === undefined)
    );
  }

  function _optionalCallableProperty /*::<T>*/(
    obj /*: T */,
    name /*: $Keys<T> */,
  ) /*: ?Function */ {
    var value = obj[name];
    if (value !== undefined && typeof value !== "function") {
      throw new TypeError("Expected '" + name + "' to be a function");
    }
    return value;
  }

`;
    helpers.classPrivateMethodGet = helper("7.1.6")`
  export default function _classPrivateMethodGet(receiver, privateSet, fn) {
    if (!privateSet.has(receiver)) {
      throw new TypeError("attempted to get private field on non-instance");
    }
    return fn;
  }
`;
    helpers.checkPrivateRedeclaration = helper("7.14.1")`
  export default function _checkPrivateRedeclaration(obj, privateCollection) {
    if (privateCollection.has(obj)) {
      throw new TypeError("Cannot initialize the same private elements twice on an object");
    }
  }
`;
    helpers.classPrivateFieldInitSpec = helper("7.14.1")`
  import checkPrivateRedeclaration from "checkPrivateRedeclaration";

  export default function _classPrivateFieldInitSpec(obj, privateMap, value) {
    checkPrivateRedeclaration(obj, privateMap);
    privateMap.set(obj, value);
  }
`;
    helpers.classPrivateMethodInitSpec = helper("7.14.1")`
  import checkPrivateRedeclaration from "checkPrivateRedeclaration";

  export default function _classPrivateMethodInitSpec(obj, privateSet) {
    checkPrivateRedeclaration(obj, privateSet);
    privateSet.add(obj);
  }
`;
    {
      helpers.classPrivateMethodSet = helper("7.1.6")`
    export default function _classPrivateMethodSet() {
      throw new TypeError("attempted to reassign private method");
    }
  `;
    }
    helpers.identity = helper("7.17.0")`
  export default function _identity(x) {
    return x;
  }
`;
  }
});

// node_modules/@babel/helpers/lib/index.js
var require_lib7 = __commonJS({
  "node_modules/@babel/helpers/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    exports2.ensure = ensure;
    exports2.get = get;
    exports2.getDependencies = getDependencies;
    exports2.list = void 0;
    exports2.minVersion = minVersion;
    var _traverse = require_lib6();
    var _t = require("@babel/types");
    var _helpers = require_helpers();
    var {
      assignmentExpression: assignmentExpression2,
      cloneNode: cloneNode2,
      expressionStatement: expressionStatement2,
      file,
      identifier: identifier4
    } = _t;
    function makePath(path) {
      const parts = [];
      for (; path.parentPath; path = path.parentPath) {
        parts.push(path.key);
        if (path.inList) parts.push(path.listKey);
      }
      return parts.reverse().join(".");
    }
    var FileClass = void 0;
    function getHelperMetadata(file2) {
      const globals = /* @__PURE__ */ new Set();
      const localBindingNames = /* @__PURE__ */ new Set();
      const dependencies = /* @__PURE__ */ new Map();
      let exportName;
      let exportPath;
      const exportBindingAssignments = [];
      const importPaths = [];
      const importBindingsReferences = [];
      const dependencyVisitor = {
        ImportDeclaration(child) {
          const name = child.node.source.value;
          if (!_helpers.default[name]) {
            throw child.buildCodeFrameError(`Unknown helper ${name}`);
          }
          if (child.get("specifiers").length !== 1 || !child.get("specifiers.0").isImportDefaultSpecifier()) {
            throw child.buildCodeFrameError("Helpers can only import a default value");
          }
          const bindingIdentifier = child.node.specifiers[0].local;
          dependencies.set(bindingIdentifier, name);
          importPaths.push(makePath(child));
        },
        ExportDefaultDeclaration(child) {
          const decl = child.get("declaration");
          if (!decl.isFunctionDeclaration() || !decl.node.id) {
            throw decl.buildCodeFrameError("Helpers can only export named function declarations");
          }
          exportName = decl.node.id.name;
          exportPath = makePath(child);
        },
        ExportAllDeclaration(child) {
          throw child.buildCodeFrameError("Helpers can only export default");
        },
        ExportNamedDeclaration(child) {
          throw child.buildCodeFrameError("Helpers can only export default");
        },
        Statement(child) {
          if (child.isModuleDeclaration()) return;
          child.skip();
        }
      };
      const referenceVisitor = {
        Program(path) {
          const bindings = path.scope.getAllBindings();
          Object.keys(bindings).forEach((name) => {
            if (name === exportName) return;
            if (dependencies.has(bindings[name].identifier)) return;
            localBindingNames.add(name);
          });
        },
        ReferencedIdentifier(child) {
          const name = child.node.name;
          const binding = child.scope.getBinding(name);
          if (!binding) {
            globals.add(name);
          } else if (dependencies.has(binding.identifier)) {
            importBindingsReferences.push(makePath(child));
          }
        },
        AssignmentExpression(child) {
          const left = child.get("left");
          if (!(exportName in left.getBindingIdentifiers())) return;
          if (!left.isIdentifier()) {
            throw left.buildCodeFrameError("Only simple assignments to exports are allowed in helpers");
          }
          const binding = child.scope.getBinding(exportName);
          if (binding != null && binding.scope.path.isProgram()) {
            exportBindingAssignments.push(makePath(child));
          }
        }
      };
      (0, _traverse.default)(file2.ast, dependencyVisitor, file2.scope);
      (0, _traverse.default)(file2.ast, referenceVisitor, file2.scope);
      if (!exportPath) throw new Error("Helpers must have a default export.");
      exportBindingAssignments.reverse();
      return {
        globals: Array.from(globals),
        localBindingNames: Array.from(localBindingNames),
        dependencies,
        exportBindingAssignments,
        exportPath,
        exportName,
        importBindingsReferences,
        importPaths
      };
    }
    function permuteHelperAST(file2, metadata, id, localBindings, getDependency) {
      if (localBindings && !id) {
        throw new Error("Unexpected local bindings for module-based helpers.");
      }
      if (!id) return;
      const {
        localBindingNames,
        dependencies,
        exportBindingAssignments,
        exportPath,
        exportName,
        importBindingsReferences,
        importPaths
      } = metadata;
      const dependenciesRefs = {};
      dependencies.forEach((name, id2) => {
        dependenciesRefs[id2.name] = typeof getDependency === "function" && getDependency(name) || id2;
      });
      const toRename = {};
      const bindings = new Set(localBindings || []);
      localBindingNames.forEach((name) => {
        let newName = name;
        while (bindings.has(newName)) newName = "_" + newName;
        if (newName !== name) toRename[name] = newName;
      });
      if (id.type === "Identifier" && exportName !== id.name) {
        toRename[exportName] = id.name;
      }
      const {
        path
      } = file2;
      const exp = path.get(exportPath);
      const imps = importPaths.map((p) => path.get(p));
      const impsBindingRefs = importBindingsReferences.map((p) => path.get(p));
      const decl = exp.get("declaration");
      if (id.type === "Identifier") {
        exp.replaceWith(decl);
      } else if (id.type === "MemberExpression") {
        exportBindingAssignments.forEach((assignPath) => {
          const assign = path.get(assignPath);
          assign.replaceWith(assignmentExpression2("=", id, assign.node));
        });
        exp.replaceWith(decl);
        path.pushContainer("body", expressionStatement2(assignmentExpression2("=", id, identifier4(exportName))));
      } else {
        throw new Error("Unexpected helper format.");
      }
      Object.keys(toRename).forEach((name) => {
        path.scope.rename(name, toRename[name]);
      });
      for (const path2 of imps) path2.remove();
      for (const path2 of impsBindingRefs) {
        const node = cloneNode2(dependenciesRefs[path2.node.name]);
        path2.replaceWith(node);
      }
    }
    var helperData = /* @__PURE__ */ Object.create(null);
    function loadHelper(name) {
      if (!helperData[name]) {
        const helper = _helpers.default[name];
        if (!helper) {
          throw Object.assign(new ReferenceError(`Unknown helper ${name}`), {
            code: "BABEL_HELPER_UNKNOWN",
            helper: name
          });
        }
        const fn = () => {
          {
            if (!FileClass) {
              const fakeFile = {
                ast: file(helper.ast()),
                path: null
              };
              (0, _traverse.default)(fakeFile.ast, {
                Program: (path) => (fakeFile.path = path).stop()
              });
              return fakeFile;
            }
          }
          return new FileClass({
            filename: `babel-helper://${name}`
          }, {
            ast: file(helper.ast()),
            code: "[internal Babel helper code]",
            inputMap: null
          });
        };
        let metadata = null;
        helperData[name] = {
          minVersion: helper.minVersion,
          build(getDependency, id, localBindings) {
            const file2 = fn();
            metadata || (metadata = getHelperMetadata(file2));
            permuteHelperAST(file2, metadata, id, localBindings, getDependency);
            return {
              nodes: file2.ast.program.body,
              globals: metadata.globals
            };
          },
          getDependencies() {
            metadata || (metadata = getHelperMetadata(fn()));
            return Array.from(metadata.dependencies.values());
          }
        };
      }
      return helperData[name];
    }
    function get(name, getDependency, id, localBindings) {
      return loadHelper(name).build(getDependency, id, localBindings);
    }
    function minVersion(name) {
      return loadHelper(name).minVersion;
    }
    function getDependencies(name) {
      return loadHelper(name).getDependencies();
    }
    function ensure(name, newFileClass) {
      FileClass || (FileClass = newFileClass);
      loadHelper(name);
    }
    var list = Object.keys(_helpers.default).map((name) => name.replace(/^_/, ""));
    exports2.list = list;
    var _default = get;
    exports2.default = _default;
  }
});

// node_modules/@babel/core/node_modules/@babel/traverse/lib/path/lib/virtual-types.js
var require_virtual_types2 = __commonJS({
  "node_modules/@babel/core/node_modules/@babel/traverse/lib/path/lib/virtual-types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Var = exports2.User = exports2.Statement = exports2.SpreadProperty = exports2.Scope = exports2.RestProperty = exports2.ReferencedMemberExpression = exports2.ReferencedIdentifier = exports2.Referenced = exports2.Pure = exports2.NumericLiteralTypeAnnotation = exports2.Generated = exports2.ForAwaitStatement = exports2.Flow = exports2.Expression = exports2.ExistentialTypeParam = exports2.BlockScoped = exports2.BindingIdentifier = void 0;
    var ReferencedIdentifier = exports2.ReferencedIdentifier = ["Identifier", "JSXIdentifier"];
    var ReferencedMemberExpression = exports2.ReferencedMemberExpression = ["MemberExpression"];
    var BindingIdentifier = exports2.BindingIdentifier = ["Identifier"];
    var Statement = exports2.Statement = ["Statement"];
    var Expression = exports2.Expression = ["Expression"];
    var Scope = exports2.Scope = ["Scopable", "Pattern"];
    var Referenced = exports2.Referenced = null;
    var BlockScoped = exports2.BlockScoped = null;
    var Var = exports2.Var = ["VariableDeclaration"];
    var User = exports2.User = null;
    var Generated = exports2.Generated = null;
    var Pure = exports2.Pure = null;
    var Flow = exports2.Flow = ["Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier"];
    var RestProperty = exports2.RestProperty = ["RestElement"];
    var SpreadProperty = exports2.SpreadProperty = ["RestElement"];
    var ExistentialTypeParam = exports2.ExistentialTypeParam = ["ExistsTypeAnnotation"];
    var NumericLiteralTypeAnnotation = exports2.NumericLiteralTypeAnnotation = ["NumberLiteralTypeAnnotation"];
    var ForAwaitStatement = exports2.ForAwaitStatement = ["ForOfStatement"];
  }
});

// node_modules/@babel/core/node_modules/@babel/traverse/lib/path/lib/virtual-types-validator.js
var require_virtual_types_validator2 = __commonJS({
  "node_modules/@babel/core/node_modules/@babel/traverse/lib/path/lib/virtual-types-validator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isBindingIdentifier = isBindingIdentifier;
    exports2.isBlockScoped = isBlockScoped;
    exports2.isExpression = isExpression2;
    exports2.isFlow = isFlow;
    exports2.isForAwaitStatement = isForAwaitStatement;
    exports2.isGenerated = isGenerated;
    exports2.isPure = isPure;
    exports2.isReferenced = isReferenced;
    exports2.isReferencedIdentifier = isReferencedIdentifier;
    exports2.isReferencedMemberExpression = isReferencedMemberExpression;
    exports2.isRestProperty = isRestProperty;
    exports2.isScope = isScope;
    exports2.isSpreadProperty = isSpreadProperty;
    exports2.isStatement = isStatement2;
    exports2.isUser = isUser;
    exports2.isVar = isVar;
    var _t = require("@babel/types");
    var {
      isBinding,
      isBlockScoped: nodeIsBlockScoped,
      isExportDeclaration,
      isExpression: nodeIsExpression,
      isFlow: nodeIsFlow,
      isForStatement,
      isForXStatement,
      isIdentifier,
      isImportDeclaration,
      isImportSpecifier,
      isJSXIdentifier,
      isJSXMemberExpression,
      isMemberExpression: isMemberExpression2,
      isRestElement: nodeIsRestElement,
      isReferenced: nodeIsReferenced,
      isScope: nodeIsScope,
      isStatement: nodeIsStatement,
      isVar: nodeIsVar,
      isVariableDeclaration: isVariableDeclaration2,
      react,
      isForOfStatement
    } = _t;
    var {
      isCompatTag
    } = react;
    function isReferencedIdentifier(opts) {
      const {
        node,
        parent
      } = this;
      if (!isIdentifier(node, opts) && !isJSXMemberExpression(parent, opts)) {
        if (isJSXIdentifier(node, opts)) {
          if (isCompatTag(node.name)) return false;
        } else {
          return false;
        }
      }
      return nodeIsReferenced(node, parent, this.parentPath.parent);
    }
    function isReferencedMemberExpression() {
      const {
        node,
        parent
      } = this;
      return isMemberExpression2(node) && nodeIsReferenced(node, parent);
    }
    function isBindingIdentifier() {
      const {
        node,
        parent
      } = this;
      const grandparent = this.parentPath.parent;
      return isIdentifier(node) && isBinding(node, parent, grandparent);
    }
    function isStatement2() {
      const {
        node,
        parent
      } = this;
      if (nodeIsStatement(node)) {
        if (isVariableDeclaration2(node)) {
          if (isForXStatement(parent, {
            left: node
          })) return false;
          if (isForStatement(parent, {
            init: node
          })) return false;
        }
        return true;
      } else {
        return false;
      }
    }
    function isExpression2() {
      if (this.isIdentifier()) {
        return this.isReferencedIdentifier();
      } else {
        return nodeIsExpression(this.node);
      }
    }
    function isScope() {
      return nodeIsScope(this.node, this.parent);
    }
    function isReferenced() {
      return nodeIsReferenced(this.node, this.parent);
    }
    function isBlockScoped() {
      return nodeIsBlockScoped(this.node);
    }
    function isVar() {
      return nodeIsVar(this.node);
    }
    function isUser() {
      return this.node && !!this.node.loc;
    }
    function isGenerated() {
      return !this.isUser();
    }
    function isPure(constantsOnly) {
      return this.scope.isPure(this.node, constantsOnly);
    }
    function isFlow() {
      const {
        node
      } = this;
      if (nodeIsFlow(node)) {
        return true;
      } else if (isImportDeclaration(node)) {
        return node.importKind === "type" || node.importKind === "typeof";
      } else if (isExportDeclaration(node)) {
        return node.exportKind === "type";
      } else if (isImportSpecifier(node)) {
        return node.importKind === "type" || node.importKind === "typeof";
      } else {
        return false;
      }
    }
    function isRestProperty() {
      var _this$parentPath;
      return nodeIsRestElement(this.node) && ((_this$parentPath = this.parentPath) == null ? void 0 : _this$parentPath.isObjectPattern());
    }
    function isSpreadProperty() {
      var _this$parentPath2;
      return nodeIsRestElement(this.node) && ((_this$parentPath2 = this.parentPath) == null ? void 0 : _this$parentPath2.isObjectExpression());
    }
    function isForAwaitStatement() {
      return isForOfStatement(this.node, {
        await: true
      });
    }
    {
      exports2.isExistentialTypeParam = function isExistentialTypeParam() {
        throw new Error("`path.isExistentialTypeParam` has been renamed to `path.isExistsTypeAnnotation()` in Babel 7.");
      };
      exports2.isNumericLiteralTypeAnnotation = function isNumericLiteralTypeAnnotation() {
        throw new Error("`path.isNumericLiteralTypeAnnotation()` has been renamed to `path.isNumberLiteralTypeAnnotation()` in Babel 7.");
      };
    }
  }
});

// node_modules/@babel/core/node_modules/@babel/traverse/lib/visitors.js
var require_visitors2 = __commonJS({
  "node_modules/@babel/core/node_modules/@babel/traverse/lib/visitors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.environmentVisitor = environmentVisitor;
    exports2.explode = explode$1;
    exports2.isExplodedVisitor = isExplodedVisitor;
    exports2.merge = merge3;
    exports2.verify = verify$1;
    var virtualTypes = require_virtual_types2();
    var virtualTypesValidators = require_virtual_types_validator2();
    var _t = require("@babel/types");
    var _context3 = require_context4();
    var {
      DEPRECATED_KEYS,
      DEPRECATED_ALIASES,
      FLIPPED_ALIAS_KEYS,
      TYPES,
      __internal__deprecationWarning: deprecationWarning
    } = _t;
    function isVirtualType(type) {
      return type in virtualTypes;
    }
    function isExplodedVisitor(visitor) {
      return visitor == null ? void 0 : visitor._exploded;
    }
    function explode$1(visitor) {
      if (isExplodedVisitor(visitor)) return visitor;
      visitor._exploded = true;
      for (const nodeType of Object.keys(visitor)) {
        if (shouldIgnoreKey(nodeType)) continue;
        const parts = nodeType.split("|");
        if (parts.length === 1) continue;
        const fns = visitor[nodeType];
        delete visitor[nodeType];
        for (const part of parts) {
          visitor[part] = fns;
        }
      }
      verify$1(visitor);
      delete visitor.__esModule;
      ensureEntranceObjects(visitor);
      ensureCallbackArrays(visitor);
      for (const nodeType of Object.keys(visitor)) {
        if (shouldIgnoreKey(nodeType)) continue;
        if (!isVirtualType(nodeType)) continue;
        const fns = visitor[nodeType];
        for (const type of Object.keys(fns)) {
          fns[type] = wrapCheck(nodeType, fns[type]);
        }
        delete visitor[nodeType];
        const types = virtualTypes[nodeType];
        if (types !== null) {
          for (const type of types) {
            if (visitor[type]) {
              mergePair(visitor[type], fns);
            } else {
              visitor[type] = fns;
            }
          }
        } else {
          mergePair(visitor, fns);
        }
      }
      for (const nodeType of Object.keys(visitor)) {
        if (shouldIgnoreKey(nodeType)) continue;
        let aliases = FLIPPED_ALIAS_KEYS[nodeType];
        if (nodeType in DEPRECATED_KEYS) {
          const deprecatedKey = DEPRECATED_KEYS[nodeType];
          deprecationWarning(nodeType, deprecatedKey, "Visitor ");
          aliases = [deprecatedKey];
        } else if (nodeType in DEPRECATED_ALIASES) {
          const deprecatedAlias = DEPRECATED_ALIASES[nodeType];
          deprecationWarning(nodeType, deprecatedAlias, "Visitor ");
          aliases = FLIPPED_ALIAS_KEYS[deprecatedAlias];
        }
        if (!aliases) continue;
        const fns = visitor[nodeType];
        delete visitor[nodeType];
        for (const alias of aliases) {
          const existing = visitor[alias];
          if (existing) {
            mergePair(existing, fns);
          } else {
            visitor[alias] = Object.assign({}, fns);
          }
        }
      }
      for (const nodeType of Object.keys(visitor)) {
        if (shouldIgnoreKey(nodeType)) continue;
        ensureCallbackArrays(visitor[nodeType]);
      }
      return visitor;
    }
    function verify$1(visitor) {
      if (visitor._verified) return;
      if (typeof visitor === "function") {
        throw new Error("You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Function }`?");
      }
      for (const nodeType of Object.keys(visitor)) {
        if (nodeType === "enter" || nodeType === "exit") {
          validateVisitorMethods(nodeType, visitor[nodeType]);
        }
        if (shouldIgnoreKey(nodeType)) continue;
        if (!TYPES.includes(nodeType)) {
          throw new Error(`You gave us a visitor for the node type ${nodeType} but it's not a valid type in @babel/traverse ${"7.27.0"}`);
        }
        const visitors = visitor[nodeType];
        if (typeof visitors === "object") {
          for (const visitorKey of Object.keys(visitors)) {
            if (visitorKey === "enter" || visitorKey === "exit") {
              validateVisitorMethods(`${nodeType}.${visitorKey}`, visitors[visitorKey]);
            } else {
              throw new Error(`You passed \`traverse()\` a visitor object with the property ${nodeType} that has the invalid property ${visitorKey}`);
            }
          }
        }
      }
      visitor._verified = true;
    }
    function validateVisitorMethods(path, val) {
      const fns = [].concat(val);
      for (const fn of fns) {
        if (typeof fn !== "function") {
          throw new TypeError(`Non-function found defined in ${path} with type ${typeof fn}`);
        }
      }
    }
    function merge3(visitors, states = [], wrapper) {
      const mergedVisitor = {
        _verified: true,
        _exploded: true
      };
      {
        Object.defineProperty(mergedVisitor, "_exploded", {
          enumerable: false
        });
        Object.defineProperty(mergedVisitor, "_verified", {
          enumerable: false
        });
      }
      for (let i = 0; i < visitors.length; i++) {
        const visitor = explode$1(visitors[i]);
        const state = states[i];
        let topVisitor = visitor;
        if (state || wrapper) {
          topVisitor = wrapWithStateOrWrapper(topVisitor, state, wrapper);
        }
        mergePair(mergedVisitor, topVisitor);
        for (const key2 of Object.keys(visitor)) {
          if (shouldIgnoreKey(key2)) continue;
          let typeVisitor = visitor[key2];
          if (state || wrapper) {
            typeVisitor = wrapWithStateOrWrapper(typeVisitor, state, wrapper);
          }
          const nodeVisitor = mergedVisitor[key2] || (mergedVisitor[key2] = {});
          mergePair(nodeVisitor, typeVisitor);
        }
      }
      return mergedVisitor;
    }
    function wrapWithStateOrWrapper(oldVisitor, state, wrapper) {
      const newVisitor = {};
      for (const phase of ["enter", "exit"]) {
        let fns = oldVisitor[phase];
        if (!Array.isArray(fns)) continue;
        fns = fns.map(function(fn) {
          let newFn = fn;
          if (state) {
            newFn = function(path) {
              fn.call(state, path, state);
            };
          }
          if (wrapper) {
            newFn = wrapper(state == null ? void 0 : state.key, phase, newFn);
          }
          if (newFn !== fn) {
            newFn.toString = () => fn.toString();
          }
          return newFn;
        });
        newVisitor[phase] = fns;
      }
      return newVisitor;
    }
    function ensureEntranceObjects(obj) {
      for (const key2 of Object.keys(obj)) {
        if (shouldIgnoreKey(key2)) continue;
        const fns = obj[key2];
        if (typeof fns === "function") {
          obj[key2] = {
            enter: fns
          };
        }
      }
    }
    function ensureCallbackArrays(obj) {
      if (obj.enter && !Array.isArray(obj.enter)) obj.enter = [obj.enter];
      if (obj.exit && !Array.isArray(obj.exit)) obj.exit = [obj.exit];
    }
    function wrapCheck(nodeType, fn) {
      const fnKey = `is${nodeType}`;
      const validator = virtualTypesValidators[fnKey];
      const newFn = function(path) {
        if (validator.call(path)) {
          return fn.apply(this, arguments);
        }
      };
      newFn.toString = () => fn.toString();
      return newFn;
    }
    function shouldIgnoreKey(key2) {
      if (key2[0] === "_") return true;
      if (key2 === "enter" || key2 === "exit" || key2 === "shouldSkip") return true;
      if (key2 === "denylist" || key2 === "noScope" || key2 === "skipKeys") {
        return true;
      }
      {
        if (key2 === "blacklist") {
          return true;
        }
      }
      return false;
    }
    function mergePair(dest, src) {
      for (const phase of ["enter", "exit"]) {
        if (!src[phase]) continue;
        dest[phase] = [].concat(dest[phase] || [], src[phase]);
      }
    }
    var _environmentVisitor = {
      FunctionParent(path) {
        if (path.isArrowFunctionExpression()) return;
        path.skip();
        if (path.isMethod()) {
          if (!path.requeueComputedKeyAndDecorators) {
            _context3.requeueComputedKeyAndDecorators.call(path);
          } else {
            path.requeueComputedKeyAndDecorators();
          }
        }
      },
      Property(path) {
        if (path.isObjectProperty()) return;
        path.skip();
        if (!path.requeueComputedKeyAndDecorators) {
          _context3.requeueComputedKeyAndDecorators.call(path);
        } else {
          path.requeueComputedKeyAndDecorators();
        }
      }
    };
    function environmentVisitor(visitor) {
      return merge3([_environmentVisitor, visitor]);
    }
  }
});

// node_modules/@babel/core/node_modules/@babel/traverse/lib/scope/lib/renamer.js
var require_renamer2 = __commonJS({
  "node_modules/@babel/core/node_modules/@babel/traverse/lib/scope/lib/renamer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var t6 = require("@babel/types");
    var _t = t6;
    var _traverseNode = require_traverse_node2();
    var _visitors = require_visitors2();
    var _context3 = require_context4();
    var {
      getAssignmentIdentifiers
    } = _t;
    var renameVisitor = {
      ReferencedIdentifier({
        node
      }, state) {
        if (node.name === state.oldName) {
          node.name = state.newName;
        }
      },
      Scope(path, state) {
        if (!path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {
          path.skip();
          if (path.isMethod()) {
            if (!path.requeueComputedKeyAndDecorators) {
              _context3.requeueComputedKeyAndDecorators.call(path);
            } else {
              path.requeueComputedKeyAndDecorators();
            }
          }
        }
      },
      ObjectProperty({
        node,
        scope
      }, state) {
        const {
          name
        } = node.key;
        if (node.shorthand && (name === state.oldName || name === state.newName) && scope.getBindingIdentifier(name) === state.binding.identifier) {
          node.shorthand = false;
          {
            var _node$extra;
            if ((_node$extra = node.extra) != null && _node$extra.shorthand) node.extra.shorthand = false;
          }
        }
      },
      "AssignmentExpression|Declaration|VariableDeclarator"(path, state) {
        if (path.isVariableDeclaration()) return;
        const ids = path.isAssignmentExpression() ? getAssignmentIdentifiers(path.node) : path.getOuterBindingIdentifiers();
        for (const name in ids) {
          if (name === state.oldName) ids[name].name = state.newName;
        }
      }
    };
    var Renamer = class {
      constructor(binding, oldName, newName) {
        this.newName = newName;
        this.oldName = oldName;
        this.binding = binding;
      }
      maybeConvertFromExportDeclaration(parentDeclar) {
        const maybeExportDeclar = parentDeclar.parentPath;
        if (!maybeExportDeclar.isExportDeclaration()) {
          return;
        }
        if (maybeExportDeclar.isExportDefaultDeclaration()) {
          const {
            declaration
          } = maybeExportDeclar.node;
          if (t6.isDeclaration(declaration) && !declaration.id) {
            return;
          }
        }
        if (maybeExportDeclar.isExportAllDeclaration()) {
          return;
        }
        maybeExportDeclar.splitExportDeclaration();
      }
      maybeConvertFromClassFunctionDeclaration(path) {
        return path;
      }
      maybeConvertFromClassFunctionExpression(path) {
        return path;
      }
      rename() {
        const {
          binding,
          oldName,
          newName
        } = this;
        const {
          scope,
          path
        } = binding;
        const parentDeclar = path.find((path2) => path2.isDeclaration() || path2.isFunctionExpression() || path2.isClassExpression());
        if (parentDeclar) {
          const bindingIds = parentDeclar.getOuterBindingIdentifiers();
          if (bindingIds[oldName] === binding.identifier) {
            this.maybeConvertFromExportDeclaration(parentDeclar);
          }
        }
        const blockToTraverse = arguments[0] || scope.block;
        const skipKeys = {
          discriminant: true
        };
        if (t6.isMethod(blockToTraverse)) {
          if (blockToTraverse.computed) {
            skipKeys.key = true;
          }
          if (!t6.isObjectMethod(blockToTraverse)) {
            skipKeys.decorators = true;
          }
        }
        (0, _traverseNode.traverseNode)(blockToTraverse, (0, _visitors.explode)(renameVisitor), scope, this, scope.path, skipKeys);
        if (!arguments[0]) {
          scope.removeOwnBinding(oldName);
          scope.bindings[newName] = binding;
          this.binding.identifier.name = newName;
        }
        if (parentDeclar) {
          this.maybeConvertFromClassFunctionDeclaration(path);
          this.maybeConvertFromClassFunctionExpression(path);
        }
      }
    };
    exports2.default = Renamer;
  }
});

// node_modules/@babel/core/node_modules/@babel/traverse/lib/scope/binding.js
var require_binding2 = __commonJS({
  "node_modules/@babel/core/node_modules/@babel/traverse/lib/scope/binding.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var Binding = class {
      constructor({
        identifier: identifier4,
        scope,
        path,
        kind
      }) {
        this.identifier = void 0;
        this.scope = void 0;
        this.path = void 0;
        this.kind = void 0;
        this.constantViolations = [];
        this.constant = true;
        this.referencePaths = [];
        this.referenced = false;
        this.references = 0;
        this.identifier = identifier4;
        this.scope = scope;
        this.path = path;
        this.kind = kind;
        if ((kind === "var" || kind === "hoisted") && isInitInLoop(path)) {
          this.reassign(path);
        }
        this.clearValue();
      }
      deoptValue() {
        this.clearValue();
        this.hasDeoptedValue = true;
      }
      setValue(value) {
        if (this.hasDeoptedValue) return;
        this.hasValue = true;
        this.value = value;
      }
      clearValue() {
        this.hasDeoptedValue = false;
        this.hasValue = false;
        this.value = null;
      }
      reassign(path) {
        this.constant = false;
        if (this.constantViolations.includes(path)) {
          return;
        }
        this.constantViolations.push(path);
      }
      reference(path) {
        if (this.referencePaths.includes(path)) {
          return;
        }
        this.referenced = true;
        this.references++;
        this.referencePaths.push(path);
      }
      dereference() {
        this.references--;
        this.referenced = !!this.references;
      }
    };
    exports2.default = Binding;
    function isInitInLoop(path) {
      const isFunctionDeclarationOrHasInit = !path.isVariableDeclarator() || path.node.init;
      for (let {
        parentPath,
        key: key2
      } = path; parentPath; {
        parentPath,
        key: key2
      } = parentPath) {
        if (parentPath.isFunctionParent()) return false;
        if (key2 === "left" && parentPath.isForXStatement() || isFunctionDeclarationOrHasInit && key2 === "body" && parentPath.isLoop()) {
          return true;
        }
      }
      return false;
    }
  }
});

// node_modules/@babel/core/node_modules/@babel/traverse/lib/cache.js
var require_cache2 = __commonJS({
  "node_modules/@babel/core/node_modules/@babel/traverse/lib/cache.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.clear = clear;
    exports2.clearPath = clearPath;
    exports2.clearScope = clearScope;
    exports2.getCachedPaths = getCachedPaths;
    exports2.getOrCreateCachedPaths = getOrCreateCachedPaths;
    exports2.scope = exports2.path = void 0;
    var pathsCache = exports2.path = /* @__PURE__ */ new WeakMap();
    var scope = exports2.scope = /* @__PURE__ */ new WeakMap();
    function clear() {
      clearPath();
      clearScope();
    }
    function clearPath() {
      exports2.path = pathsCache = /* @__PURE__ */ new WeakMap();
    }
    function clearScope() {
      exports2.scope = scope = /* @__PURE__ */ new WeakMap();
    }
    var nullHub = Object.freeze({});
    function getCachedPaths(hub, parent) {
      var _pathsCache$get;
      {
        hub = null;
      }
      return (_pathsCache$get = pathsCache.get(hub != null ? hub : nullHub)) == null ? void 0 : _pathsCache$get.get(parent);
    }
    function getOrCreateCachedPaths(hub, parent) {
      {
        hub = null;
      }
      let parents = pathsCache.get(hub != null ? hub : nullHub);
      if (!parents) pathsCache.set(hub != null ? hub : nullHub, parents = /* @__PURE__ */ new WeakMap());
      let paths = parents.get(parent);
      if (!paths) parents.set(parent, paths = /* @__PURE__ */ new Map());
      return paths;
    }
  }
});

// node_modules/@babel/core/node_modules/@babel/traverse/lib/scope/index.js
var require_scope2 = __commonJS({
  "node_modules/@babel/core/node_modules/@babel/traverse/lib/scope/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _renamer = require_renamer2();
    var _index = require_lib9();
    var _binding = require_binding2();
    var _globals4 = require_globals2();
    var _t = require("@babel/types");
    var t6 = _t;
    var _cache = require_cache2();
    var {
      assignmentExpression: assignmentExpression2,
      callExpression: callExpression3,
      cloneNode: cloneNode2,
      getBindingIdentifiers,
      identifier: identifier4,
      isArrayExpression,
      isBinary,
      isCallExpression,
      isClass,
      isClassBody,
      isClassDeclaration,
      isExportAllDeclaration,
      isExportDefaultDeclaration,
      isExportNamedDeclaration,
      isFunctionDeclaration,
      isIdentifier,
      isImportDeclaration,
      isLiteral,
      isMemberExpression: isMemberExpression2,
      isMethod,
      isModuleSpecifier,
      isNullLiteral,
      isObjectExpression,
      isProperty,
      isPureish,
      isRegExpLiteral,
      isSuper,
      isTaggedTemplateExpression,
      isTemplateLiteral,
      isThisExpression,
      isUnaryExpression,
      isVariableDeclaration: isVariableDeclaration2,
      expressionStatement: expressionStatement2,
      matchesPattern,
      memberExpression: memberExpression2,
      numericLiteral: numericLiteral2,
      toIdentifier,
      variableDeclaration: variableDeclaration3,
      variableDeclarator: variableDeclarator3,
      isRecordExpression,
      isTupleExpression,
      isObjectProperty,
      isTopicReference,
      isMetaProperty,
      isPrivateName,
      isExportDeclaration,
      buildUndefinedNode,
      sequenceExpression: sequenceExpression2
    } = _t;
    function gatherNodeParts(node, parts) {
      switch (node == null ? void 0 : node.type) {
        default:
          if (isImportDeclaration(node) || isExportDeclaration(node)) {
            var _node$specifiers;
            if ((isExportAllDeclaration(node) || isExportNamedDeclaration(node) || isImportDeclaration(node)) && node.source) {
              gatherNodeParts(node.source, parts);
            } else if ((isExportNamedDeclaration(node) || isImportDeclaration(node)) && (_node$specifiers = node.specifiers) != null && _node$specifiers.length) {
              for (const e of node.specifiers) gatherNodeParts(e, parts);
            } else if ((isExportDefaultDeclaration(node) || isExportNamedDeclaration(node)) && node.declaration) {
              gatherNodeParts(node.declaration, parts);
            }
          } else if (isModuleSpecifier(node)) {
            gatherNodeParts(node.local, parts);
          } else if (isLiteral(node) && !isNullLiteral(node) && !isRegExpLiteral(node) && !isTemplateLiteral(node)) {
            parts.push(node.value);
          }
          break;
        case "MemberExpression":
        case "OptionalMemberExpression":
        case "JSXMemberExpression":
          gatherNodeParts(node.object, parts);
          gatherNodeParts(node.property, parts);
          break;
        case "Identifier":
        case "JSXIdentifier":
          parts.push(node.name);
          break;
        case "CallExpression":
        case "OptionalCallExpression":
        case "NewExpression":
          gatherNodeParts(node.callee, parts);
          break;
        case "ObjectExpression":
        case "ObjectPattern":
          for (const e of node.properties) {
            gatherNodeParts(e, parts);
          }
          break;
        case "SpreadElement":
        case "RestElement":
          gatherNodeParts(node.argument, parts);
          break;
        case "ObjectProperty":
        case "ObjectMethod":
        case "ClassProperty":
        case "ClassMethod":
        case "ClassPrivateProperty":
        case "ClassPrivateMethod":
          gatherNodeParts(node.key, parts);
          break;
        case "ThisExpression":
          parts.push("this");
          break;
        case "Super":
          parts.push("super");
          break;
        case "Import":
          parts.push("import");
          break;
        case "DoExpression":
          parts.push("do");
          break;
        case "YieldExpression":
          parts.push("yield");
          gatherNodeParts(node.argument, parts);
          break;
        case "AwaitExpression":
          parts.push("await");
          gatherNodeParts(node.argument, parts);
          break;
        case "AssignmentExpression":
          gatherNodeParts(node.left, parts);
          break;
        case "VariableDeclarator":
          gatherNodeParts(node.id, parts);
          break;
        case "FunctionExpression":
        case "FunctionDeclaration":
        case "ClassExpression":
        case "ClassDeclaration":
          gatherNodeParts(node.id, parts);
          break;
        case "PrivateName":
          gatherNodeParts(node.id, parts);
          break;
        case "ParenthesizedExpression":
          gatherNodeParts(node.expression, parts);
          break;
        case "UnaryExpression":
        case "UpdateExpression":
          gatherNodeParts(node.argument, parts);
          break;
        case "MetaProperty":
          gatherNodeParts(node.meta, parts);
          gatherNodeParts(node.property, parts);
          break;
        case "JSXElement":
          gatherNodeParts(node.openingElement, parts);
          break;
        case "JSXOpeningElement":
          gatherNodeParts(node.name, parts);
          break;
        case "JSXFragment":
          gatherNodeParts(node.openingFragment, parts);
          break;
        case "JSXOpeningFragment":
          parts.push("Fragment");
          break;
        case "JSXNamespacedName":
          gatherNodeParts(node.namespace, parts);
          gatherNodeParts(node.name, parts);
          break;
      }
    }
    function resetScope(scope) {
      scope.references = /* @__PURE__ */ Object.create(null);
      scope.bindings = /* @__PURE__ */ Object.create(null);
      scope.globals = /* @__PURE__ */ Object.create(null);
      scope.uids = /* @__PURE__ */ Object.create(null);
    }
    {
      NOT_LOCAL_BINDING = Symbol.for("should not be considered a local binding");
    }
    var NOT_LOCAL_BINDING;
    var collectorVisitor = {
      ForStatement(path) {
        const declar = path.get("init");
        if (declar.isVar()) {
          const {
            scope
          } = path;
          const parentScope = scope.getFunctionParent() || scope.getProgramParent();
          parentScope.registerBinding("var", declar);
        }
      },
      Declaration(path) {
        if (path.isBlockScoped()) return;
        if (path.isImportDeclaration()) return;
        if (path.isExportDeclaration()) return;
        const parent = path.scope.getFunctionParent() || path.scope.getProgramParent();
        parent.registerDeclaration(path);
      },
      ImportDeclaration(path) {
        const parent = path.scope.getBlockParent();
        parent.registerDeclaration(path);
      },
      TSImportEqualsDeclaration(path) {
        const parent = path.scope.getBlockParent();
        parent.registerDeclaration(path);
      },
      ReferencedIdentifier(path, state) {
        if (t6.isTSQualifiedName(path.parent) && path.parent.right === path.node) {
          return;
        }
        if (path.parentPath.isTSImportEqualsDeclaration()) return;
        state.references.push(path);
      },
      ForXStatement(path, state) {
        const left = path.get("left");
        if (left.isPattern() || left.isIdentifier()) {
          state.constantViolations.push(path);
        } else if (left.isVar()) {
          const {
            scope
          } = path;
          const parentScope = scope.getFunctionParent() || scope.getProgramParent();
          parentScope.registerBinding("var", left);
        }
      },
      ExportDeclaration: {
        exit(path) {
          const {
            node,
            scope
          } = path;
          if (isExportAllDeclaration(node)) return;
          const declar = node.declaration;
          if (isClassDeclaration(declar) || isFunctionDeclaration(declar)) {
            const id = declar.id;
            if (!id) return;
            const binding = scope.getBinding(id.name);
            binding == null || binding.reference(path);
          } else if (isVariableDeclaration2(declar)) {
            for (const decl of declar.declarations) {
              for (const name of Object.keys(getBindingIdentifiers(decl))) {
                const binding = scope.getBinding(name);
                binding == null || binding.reference(path);
              }
            }
          }
        }
      },
      LabeledStatement(path) {
        path.scope.getBlockParent().registerDeclaration(path);
      },
      AssignmentExpression(path, state) {
        state.assignments.push(path);
      },
      UpdateExpression(path, state) {
        state.constantViolations.push(path);
      },
      UnaryExpression(path, state) {
        if (path.node.operator === "delete") {
          state.constantViolations.push(path);
        }
      },
      BlockScoped(path) {
        let scope = path.scope;
        if (scope.path === path) scope = scope.parent;
        const parent = scope.getBlockParent();
        parent.registerDeclaration(path);
        if (path.isClassDeclaration() && path.node.id) {
          const id = path.node.id;
          const name = id.name;
          path.scope.bindings[name] = path.scope.parent.getBinding(name);
        }
      },
      CatchClause(path) {
        path.scope.registerBinding("let", path);
      },
      Function(path) {
        const params = path.get("params");
        for (const param of params) {
          path.scope.registerBinding("param", param);
        }
        if (path.isFunctionExpression() && path.node.id && !path.node.id[NOT_LOCAL_BINDING]) {
          path.scope.registerBinding("local", path.get("id"), path);
        }
      },
      ClassExpression(path) {
        if (path.node.id && !path.node.id[NOT_LOCAL_BINDING]) {
          path.scope.registerBinding("local", path.get("id"), path);
        }
      },
      TSTypeAnnotation(path) {
        path.skip();
      }
    };
    var scopeVisitor;
    var uid = 0;
    var Scope = class _Scope {
      constructor(path) {
        this.uid = void 0;
        this.path = void 0;
        this.block = void 0;
        this.inited = void 0;
        this.labels = void 0;
        this.bindings = void 0;
        this.references = void 0;
        this.globals = void 0;
        this.uids = void 0;
        this.data = void 0;
        this.crawling = void 0;
        const {
          node
        } = path;
        const cached = _cache.scope.get(node);
        if ((cached == null ? void 0 : cached.path) === path) {
          return cached;
        }
        _cache.scope.set(node, this);
        this.uid = uid++;
        this.block = node;
        this.path = path;
        this.labels = /* @__PURE__ */ new Map();
        this.inited = false;
      }
      get parent() {
        var _parent;
        let parent, path = this.path;
        do {
          var _path;
          const shouldSkip = path.key === "key" || path.listKey === "decorators";
          path = path.parentPath;
          if (shouldSkip && path.isMethod()) path = path.parentPath;
          if ((_path = path) != null && _path.isScope()) parent = path;
        } while (path && !parent);
        return (_parent = parent) == null ? void 0 : _parent.scope;
      }
      generateDeclaredUidIdentifier(name) {
        const id = this.generateUidIdentifier(name);
        this.push({
          id
        });
        return cloneNode2(id);
      }
      generateUidIdentifier(name) {
        return identifier4(this.generateUid(name));
      }
      generateUid(name = "temp") {
        name = toIdentifier(name).replace(/^_+/, "").replace(/\d+$/g, "");
        let uid2;
        let i = 1;
        do {
          uid2 = `_${name}`;
          if (i > 1) uid2 += i;
          i++;
        } while (this.hasLabel(uid2) || this.hasBinding(uid2) || this.hasGlobal(uid2) || this.hasReference(uid2));
        const program = this.getProgramParent();
        program.references[uid2] = true;
        program.uids[uid2] = true;
        return uid2;
      }
      generateUidBasedOnNode(node, defaultName) {
        const parts = [];
        gatherNodeParts(node, parts);
        let id = parts.join("$");
        id = id.replace(/^_/, "") || defaultName || "ref";
        return this.generateUid(id.slice(0, 20));
      }
      generateUidIdentifierBasedOnNode(node, defaultName) {
        return identifier4(this.generateUidBasedOnNode(node, defaultName));
      }
      isStatic(node) {
        if (isThisExpression(node) || isSuper(node) || isTopicReference(node)) {
          return true;
        }
        if (isIdentifier(node)) {
          const binding = this.getBinding(node.name);
          if (binding) {
            return binding.constant;
          } else {
            return this.hasBinding(node.name);
          }
        }
        return false;
      }
      maybeGenerateMemoised(node, dontPush) {
        if (this.isStatic(node)) {
          return null;
        } else {
          const id = this.generateUidIdentifierBasedOnNode(node);
          if (!dontPush) {
            this.push({
              id
            });
            return cloneNode2(id);
          }
          return id;
        }
      }
      checkBlockScopedCollisions(local, kind, name, id) {
        if (kind === "param") return;
        if (local.kind === "local") return;
        const duplicate = kind === "let" || local.kind === "let" || local.kind === "const" || local.kind === "module" || local.kind === "param" && kind === "const";
        if (duplicate) {
          throw this.path.hub.buildError(id, `Duplicate declaration "${name}"`, TypeError);
        }
      }
      rename(oldName, newName) {
        const binding = this.getBinding(oldName);
        if (binding) {
          newName || (newName = this.generateUidIdentifier(oldName).name);
          const renamer = new _renamer.default(binding, oldName, newName);
          {
            renamer.rename(arguments[2]);
          }
        }
      }
      dump() {
        const sep = "-".repeat(60);
        console.log(sep);
        let scope = this;
        do {
          console.log("#", scope.block.type);
          for (const name of Object.keys(scope.bindings)) {
            const binding = scope.bindings[name];
            console.log(" -", name, {
              constant: binding.constant,
              references: binding.references,
              violations: binding.constantViolations.length,
              kind: binding.kind
            });
          }
        } while (scope = scope.parent);
        console.log(sep);
      }
      hasLabel(name) {
        return !!this.getLabel(name);
      }
      getLabel(name) {
        return this.labels.get(name);
      }
      registerLabel(path) {
        this.labels.set(path.node.label.name, path);
      }
      registerDeclaration(path) {
        if (path.isLabeledStatement()) {
          this.registerLabel(path);
        } else if (path.isFunctionDeclaration()) {
          this.registerBinding("hoisted", path.get("id"), path);
        } else if (path.isVariableDeclaration()) {
          const declarations = path.get("declarations");
          const {
            kind
          } = path.node;
          for (const declar of declarations) {
            this.registerBinding(kind === "using" || kind === "await using" ? "const" : kind, declar);
          }
        } else if (path.isClassDeclaration()) {
          if (path.node.declare) return;
          this.registerBinding("let", path);
        } else if (path.isImportDeclaration()) {
          const isTypeDeclaration = path.node.importKind === "type" || path.node.importKind === "typeof";
          const specifiers = path.get("specifiers");
          for (const specifier of specifiers) {
            const isTypeSpecifier = isTypeDeclaration || specifier.isImportSpecifier() && (specifier.node.importKind === "type" || specifier.node.importKind === "typeof");
            this.registerBinding(isTypeSpecifier ? "unknown" : "module", specifier);
          }
        } else if (path.isExportDeclaration()) {
          const declar = path.get("declaration");
          if (declar.isClassDeclaration() || declar.isFunctionDeclaration() || declar.isVariableDeclaration()) {
            this.registerDeclaration(declar);
          }
        } else {
          this.registerBinding("unknown", path);
        }
      }
      buildUndefinedNode() {
        return buildUndefinedNode();
      }
      registerConstantViolation(path) {
        const ids = path.getAssignmentIdentifiers();
        for (const name of Object.keys(ids)) {
          var _this$getBinding;
          (_this$getBinding = this.getBinding(name)) == null || _this$getBinding.reassign(path);
        }
      }
      registerBinding(kind, path, bindingPath = path) {
        if (!kind) throw new ReferenceError("no `kind`");
        if (path.isVariableDeclaration()) {
          const declarators = path.get("declarations");
          for (const declar of declarators) {
            this.registerBinding(kind, declar);
          }
          return;
        }
        const parent = this.getProgramParent();
        const ids = path.getOuterBindingIdentifiers(true);
        for (const name of Object.keys(ids)) {
          parent.references[name] = true;
          for (const id of ids[name]) {
            const local = this.getOwnBinding(name);
            if (local) {
              if (local.identifier === id) continue;
              this.checkBlockScopedCollisions(local, kind, name, id);
            }
            if (local) {
              local.reassign(bindingPath);
            } else {
              this.bindings[name] = new _binding.default({
                identifier: id,
                scope: this,
                path: bindingPath,
                kind
              });
            }
          }
        }
      }
      addGlobal(node) {
        this.globals[node.name] = node;
      }
      hasUid(name) {
        let scope = this;
        do {
          if (scope.uids[name]) return true;
        } while (scope = scope.parent);
        return false;
      }
      hasGlobal(name) {
        let scope = this;
        do {
          if (scope.globals[name]) return true;
        } while (scope = scope.parent);
        return false;
      }
      hasReference(name) {
        return !!this.getProgramParent().references[name];
      }
      isPure(node, constantsOnly) {
        if (isIdentifier(node)) {
          const binding = this.getBinding(node.name);
          if (!binding) return false;
          if (constantsOnly) return binding.constant;
          return true;
        } else if (isThisExpression(node) || isMetaProperty(node) || isTopicReference(node) || isPrivateName(node)) {
          return true;
        } else if (isClass(node)) {
          var _node$decorators;
          if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {
            return false;
          }
          if (((_node$decorators = node.decorators) == null ? void 0 : _node$decorators.length) > 0) {
            return false;
          }
          return this.isPure(node.body, constantsOnly);
        } else if (isClassBody(node)) {
          for (const method of node.body) {
            if (!this.isPure(method, constantsOnly)) return false;
          }
          return true;
        } else if (isBinary(node)) {
          return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);
        } else if (isArrayExpression(node) || isTupleExpression(node)) {
          for (const elem of node.elements) {
            if (elem !== null && !this.isPure(elem, constantsOnly)) return false;
          }
          return true;
        } else if (isObjectExpression(node) || isRecordExpression(node)) {
          for (const prop of node.properties) {
            if (!this.isPure(prop, constantsOnly)) return false;
          }
          return true;
        } else if (isMethod(node)) {
          var _node$decorators2;
          if (node.computed && !this.isPure(node.key, constantsOnly)) return false;
          if (((_node$decorators2 = node.decorators) == null ? void 0 : _node$decorators2.length) > 0) {
            return false;
          }
          return true;
        } else if (isProperty(node)) {
          var _node$decorators3;
          if (node.computed && !this.isPure(node.key, constantsOnly)) return false;
          if (((_node$decorators3 = node.decorators) == null ? void 0 : _node$decorators3.length) > 0) {
            return false;
          }
          if (isObjectProperty(node) || node.static) {
            if (node.value !== null && !this.isPure(node.value, constantsOnly)) {
              return false;
            }
          }
          return true;
        } else if (isUnaryExpression(node)) {
          return this.isPure(node.argument, constantsOnly);
        } else if (isTemplateLiteral(node)) {
          for (const expression of node.expressions) {
            if (!this.isPure(expression, constantsOnly)) return false;
          }
          return true;
        } else if (isTaggedTemplateExpression(node)) {
          return matchesPattern(node.tag, "String.raw") && !this.hasBinding("String", {
            noGlobals: true
          }) && this.isPure(node.quasi, constantsOnly);
        } else if (isMemberExpression2(node)) {
          return !node.computed && isIdentifier(node.object) && node.object.name === "Symbol" && isIdentifier(node.property) && node.property.name !== "for" && !this.hasBinding("Symbol", {
            noGlobals: true
          });
        } else if (isCallExpression(node)) {
          return matchesPattern(node.callee, "Symbol.for") && !this.hasBinding("Symbol", {
            noGlobals: true
          }) && node.arguments.length === 1 && t6.isStringLiteral(node.arguments[0]);
        } else {
          return isPureish(node);
        }
      }
      setData(key2, val) {
        return this.data[key2] = val;
      }
      getData(key2) {
        let scope = this;
        do {
          const data = scope.data[key2];
          if (data != null) return data;
        } while (scope = scope.parent);
      }
      removeData(key2) {
        let scope = this;
        do {
          const data = scope.data[key2];
          if (data != null) scope.data[key2] = null;
        } while (scope = scope.parent);
      }
      init() {
        if (!this.inited) {
          this.inited = true;
          this.crawl();
        }
      }
      crawl() {
        const path = this.path;
        resetScope(this);
        this.data = /* @__PURE__ */ Object.create(null);
        let scope = this;
        do {
          if (scope.crawling) return;
          if (scope.path.isProgram()) {
            break;
          }
        } while (scope = scope.parent);
        const programParent = scope;
        const state = {
          references: [],
          constantViolations: [],
          assignments: []
        };
        this.crawling = true;
        scopeVisitor || (scopeVisitor = _index.default.visitors.merge([{
          Scope(path2) {
            resetScope(path2.scope);
          }
        }, collectorVisitor]));
        if (path.type !== "Program") {
          for (const visit4 of scopeVisitor.enter) {
            visit4.call(state, path, state);
          }
          const typeVisitors = scopeVisitor[path.type];
          if (typeVisitors) {
            for (const visit4 of typeVisitors.enter) {
              visit4.call(state, path, state);
            }
          }
        }
        path.traverse(scopeVisitor, state);
        this.crawling = false;
        for (const path2 of state.assignments) {
          const ids = path2.getAssignmentIdentifiers();
          for (const name of Object.keys(ids)) {
            if (path2.scope.getBinding(name)) continue;
            programParent.addGlobal(ids[name]);
          }
          path2.scope.registerConstantViolation(path2);
        }
        for (const ref of state.references) {
          const binding = ref.scope.getBinding(ref.node.name);
          if (binding) {
            binding.reference(ref);
          } else {
            programParent.addGlobal(ref.node);
          }
        }
        for (const path2 of state.constantViolations) {
          path2.scope.registerConstantViolation(path2);
        }
      }
      push(opts) {
        let path = this.path;
        if (path.isPattern()) {
          path = this.getPatternParent().path;
        } else if (!path.isBlockStatement() && !path.isProgram()) {
          path = this.getBlockParent().path;
        }
        if (path.isSwitchStatement()) {
          path = (this.getFunctionParent() || this.getProgramParent()).path;
        }
        const {
          init,
          unique,
          kind = "var",
          id
        } = opts;
        if (!init && !unique && (kind === "var" || kind === "let") && path.isFunction() && !path.node.name && isCallExpression(path.parent, {
          callee: path.node
        }) && path.parent.arguments.length <= path.node.params.length && isIdentifier(id)) {
          path.pushContainer("params", id);
          path.scope.registerBinding("param", path.get("params")[path.node.params.length - 1]);
          return;
        }
        if (path.isLoop() || path.isCatchClause() || path.isFunction()) {
          path.ensureBlock();
          path = path.get("body");
        }
        const blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;
        const dataKey = `declaration:${kind}:${blockHoist}`;
        let declarPath = !unique && path.getData(dataKey);
        if (!declarPath) {
          const declar = variableDeclaration3(kind, []);
          declar._blockHoist = blockHoist;
          [declarPath] = path.unshiftContainer("body", [declar]);
          if (!unique) path.setData(dataKey, declarPath);
        }
        const declarator = variableDeclarator3(id, init);
        const len = declarPath.node.declarations.push(declarator);
        path.scope.registerBinding(kind, declarPath.get("declarations")[len - 1]);
      }
      getProgramParent() {
        let scope = this;
        do {
          if (scope.path.isProgram()) {
            return scope;
          }
        } while (scope = scope.parent);
        throw new Error("Couldn't find a Program");
      }
      getFunctionParent() {
        let scope = this;
        do {
          if (scope.path.isFunctionParent()) {
            return scope;
          }
        } while (scope = scope.parent);
        return null;
      }
      getBlockParent() {
        let scope = this;
        do {
          if (scope.path.isBlockParent()) {
            return scope;
          }
        } while (scope = scope.parent);
        throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
      }
      getPatternParent() {
        let scope = this;
        do {
          if (!scope.path.isPattern()) {
            return scope.getBlockParent();
          }
        } while (scope = scope.parent.parent);
        throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
      }
      getAllBindings() {
        const ids = /* @__PURE__ */ Object.create(null);
        let scope = this;
        do {
          for (const key2 of Object.keys(scope.bindings)) {
            if (key2 in ids === false) {
              ids[key2] = scope.bindings[key2];
            }
          }
          scope = scope.parent;
        } while (scope);
        return ids;
      }
      bindingIdentifierEquals(name, node) {
        return this.getBindingIdentifier(name) === node;
      }
      getBinding(name) {
        let scope = this;
        let previousPath;
        do {
          const binding = scope.getOwnBinding(name);
          if (binding) {
            var _previousPath;
            if ((_previousPath = previousPath) != null && _previousPath.isPattern() && binding.kind !== "param" && binding.kind !== "local") {
            } else {
              return binding;
            }
          } else if (!binding && name === "arguments" && scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {
            break;
          }
          previousPath = scope.path;
        } while (scope = scope.parent);
      }
      getOwnBinding(name) {
        return this.bindings[name];
      }
      getBindingIdentifier(name) {
        var _this$getBinding2;
        return (_this$getBinding2 = this.getBinding(name)) == null ? void 0 : _this$getBinding2.identifier;
      }
      getOwnBindingIdentifier(name) {
        const binding = this.bindings[name];
        return binding == null ? void 0 : binding.identifier;
      }
      hasOwnBinding(name) {
        return !!this.getOwnBinding(name);
      }
      hasBinding(name, opts) {
        if (!name) return false;
        let noGlobals;
        let noUids;
        let upToScope;
        if (typeof opts === "object") {
          noGlobals = opts.noGlobals;
          noUids = opts.noUids;
          upToScope = opts.upToScope;
        } else if (typeof opts === "boolean") {
          noGlobals = opts;
        }
        let scope = this;
        do {
          if (upToScope === scope) {
            break;
          }
          if (scope.hasOwnBinding(name)) {
            return true;
          }
        } while (scope = scope.parent);
        if (!noUids && this.hasUid(name)) return true;
        if (!noGlobals && _Scope.globals.includes(name)) return true;
        if (!noGlobals && _Scope.contextVariables.includes(name)) return true;
        return false;
      }
      parentHasBinding(name, opts) {
        var _this$parent;
        return (_this$parent = this.parent) == null ? void 0 : _this$parent.hasBinding(name, opts);
      }
      moveBindingTo(name, scope) {
        const info = this.getBinding(name);
        if (info) {
          info.scope.removeOwnBinding(name);
          info.scope = scope;
          scope.bindings[name] = info;
        }
      }
      removeOwnBinding(name) {
        delete this.bindings[name];
      }
      removeBinding(name) {
        var _this$getBinding3;
        (_this$getBinding3 = this.getBinding(name)) == null || _this$getBinding3.scope.removeOwnBinding(name);
        let scope = this;
        do {
          if (scope.uids[name]) {
            scope.uids[name] = false;
          }
        } while (scope = scope.parent);
      }
      hoistVariables(emit2 = (id) => this.push({
        id
      })) {
        this.crawl();
        const seen = /* @__PURE__ */ new Set();
        for (const name of Object.keys(this.bindings)) {
          const binding = this.bindings[name];
          if (!binding) continue;
          const {
            path
          } = binding;
          if (!path.isVariableDeclarator()) continue;
          const {
            parent,
            parentPath
          } = path;
          if (parent.kind !== "var" || seen.has(parent)) continue;
          seen.add(path.parent);
          let firstId;
          const init = [];
          for (const decl of parent.declarations) {
            firstId != null ? firstId : firstId = decl.id;
            if (decl.init) {
              init.push(assignmentExpression2("=", decl.id, decl.init));
            }
            const ids = Object.keys(getBindingIdentifiers(decl, false, true, true));
            for (const name2 of ids) {
              emit2(identifier4(name2), decl.init != null);
            }
          }
          if (parentPath.parentPath.isFor({
            left: parent
          })) {
            parentPath.replaceWith(firstId);
          } else if (init.length === 0) {
            parentPath.remove();
          } else {
            const expr = init.length === 1 ? init[0] : sequenceExpression2(init);
            if (parentPath.parentPath.isForStatement({
              init: parent
            })) {
              parentPath.replaceWith(expr);
            } else {
              parentPath.replaceWith(expressionStatement2(expr));
            }
          }
        }
      }
    };
    exports2.default = Scope;
    Scope.globals = Object.keys(_globals4.builtin);
    Scope.contextVariables = ["arguments", "undefined", "Infinity", "NaN"];
    {
      Scope.prototype._renameFromMap = function _renameFromMap(map, oldName, newName, value) {
        if (map[oldName]) {
          map[newName] = value;
          map[oldName] = null;
        }
      };
      Scope.prototype.traverse = function(node, opts, state) {
        (0, _index.default)(node, opts, this, state, this.path);
      };
      Scope.prototype._generateUid = function _generateUid(name, i) {
        let id = name;
        if (i > 1) id += i;
        return `_${id}`;
      };
      Scope.prototype.toArray = function toArray(node, i, arrayLikeIsIterable) {
        if (isIdentifier(node)) {
          const binding = this.getBinding(node.name);
          if (binding != null && binding.constant && binding.path.isGenericType("Array")) {
            return node;
          }
        }
        if (isArrayExpression(node)) {
          return node;
        }
        if (isIdentifier(node, {
          name: "arguments"
        })) {
          return callExpression3(memberExpression2(memberExpression2(memberExpression2(identifier4("Array"), identifier4("prototype")), identifier4("slice")), identifier4("call")), [node]);
        }
        let helperName;
        const args = [node];
        if (i === true) {
          helperName = "toConsumableArray";
        } else if (typeof i === "number") {
          args.push(numericLiteral2(i));
          helperName = "slicedToArray";
        } else {
          helperName = "toArray";
        }
        if (arrayLikeIsIterable) {
          args.unshift(this.path.hub.addHelper(helperName));
          helperName = "maybeArrayLike";
        }
        return callExpression3(this.path.hub.addHelper(helperName), args);
      };
      Scope.prototype.getAllBindingsOfKind = function getAllBindingsOfKind(...kinds) {
        const ids = /* @__PURE__ */ Object.create(null);
        for (const kind of kinds) {
          let scope = this;
          do {
            for (const name of Object.keys(scope.bindings)) {
              const binding = scope.bindings[name];
              if (binding.kind === kind) ids[name] = binding;
            }
            scope = scope.parent;
          } while (scope);
        }
        return ids;
      };
      Object.defineProperties(Scope.prototype, {
        parentBlock: {
          configurable: true,
          enumerable: true,
          get() {
            return this.path.parent;
          }
        },
        hub: {
          configurable: true,
          enumerable: true,
          get() {
            return this.path.hub;
          }
        }
      });
    }
  }
});

// node_modules/@babel/core/node_modules/@babel/generator/lib/source-map.js
var require_source_map2 = __commonJS({
  "node_modules/@babel/core/node_modules/@babel/generator/lib/source-map.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _genMapping = require_gen_mapping_umd();
    var _traceMapping = require_trace_mapping_umd();
    var SourceMap = class {
      constructor(opts, code) {
        var _opts$sourceFileName;
        this._map = void 0;
        this._rawMappings = void 0;
        this._sourceFileName = void 0;
        this._lastGenLine = 0;
        this._lastSourceLine = 0;
        this._lastSourceColumn = 0;
        this._inputMap = void 0;
        const map = this._map = new _genMapping.GenMapping({
          sourceRoot: opts.sourceRoot
        });
        this._sourceFileName = (_opts$sourceFileName = opts.sourceFileName) == null ? void 0 : _opts$sourceFileName.replace(/\\/g, "/");
        this._rawMappings = void 0;
        if (opts.inputSourceMap) {
          this._inputMap = new _traceMapping.TraceMap(opts.inputSourceMap);
          const resolvedSources = this._inputMap.resolvedSources;
          if (resolvedSources.length) {
            for (let i = 0; i < resolvedSources.length; i++) {
              var _this$_inputMap$sourc;
              (0, _genMapping.setSourceContent)(map, resolvedSources[i], (_this$_inputMap$sourc = this._inputMap.sourcesContent) == null ? void 0 : _this$_inputMap$sourc[i]);
            }
          }
        }
        if (typeof code === "string" && !opts.inputSourceMap) {
          (0, _genMapping.setSourceContent)(map, this._sourceFileName, code);
        } else if (typeof code === "object") {
          for (const sourceFileName of Object.keys(code)) {
            (0, _genMapping.setSourceContent)(map, sourceFileName.replace(/\\/g, "/"), code[sourceFileName]);
          }
        }
      }
      get() {
        return (0, _genMapping.toEncodedMap)(this._map);
      }
      getDecoded() {
        return (0, _genMapping.toDecodedMap)(this._map);
      }
      getRawMappings() {
        return this._rawMappings || (this._rawMappings = (0, _genMapping.allMappings)(this._map));
      }
      mark(generated, line2, column2, identifierName, identifierNamePos, filename) {
        var _originalMapping;
        this._rawMappings = void 0;
        let originalMapping;
        if (line2 != null) {
          if (this._inputMap) {
            originalMapping = (0, _traceMapping.originalPositionFor)(this._inputMap, {
              line: line2,
              column: column2
            });
            if (!originalMapping.name && identifierNamePos) {
              const originalIdentifierMapping = (0, _traceMapping.originalPositionFor)(this._inputMap, identifierNamePos);
              if (originalIdentifierMapping.name) {
                identifierName = originalIdentifierMapping.name;
              }
            }
          } else {
            originalMapping = {
              source: (filename == null ? void 0 : filename.replace(/\\/g, "/")) || this._sourceFileName,
              line: line2,
              column: column2
            };
          }
        }
        (0, _genMapping.maybeAddMapping)(this._map, {
          name: identifierName,
          generated,
          source: (_originalMapping = originalMapping) == null ? void 0 : _originalMapping.source,
          original: originalMapping
        });
      }
    };
    exports2.default = SourceMap;
  }
});

// node_modules/@babel/core/node_modules/@babel/generator/lib/buffer.js
var require_buffer2 = __commonJS({
  "node_modules/@babel/core/node_modules/@babel/generator/lib/buffer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var Buffer2 = class {
      constructor(map, indentChar) {
        this._map = null;
        this._buf = "";
        this._str = "";
        this._appendCount = 0;
        this._last = 0;
        this._queue = [];
        this._queueCursor = 0;
        this._canMarkIdName = true;
        this._indentChar = "";
        this._fastIndentations = [];
        this._position = {
          line: 1,
          column: 0
        };
        this._sourcePosition = {
          identifierName: void 0,
          identifierNamePos: void 0,
          line: void 0,
          column: void 0,
          filename: void 0
        };
        this._map = map;
        this._indentChar = indentChar;
        for (let i = 0; i < 64; i++) {
          this._fastIndentations.push(indentChar.repeat(i));
        }
        this._allocQueue();
      }
      _allocQueue() {
        const queue = this._queue;
        for (let i = 0; i < 16; i++) {
          queue.push({
            char: 0,
            repeat: 1,
            line: void 0,
            column: void 0,
            identifierName: void 0,
            identifierNamePos: void 0,
            filename: ""
          });
        }
      }
      _pushQueue(char, repeat, line2, column2, filename) {
        const cursor = this._queueCursor;
        if (cursor === this._queue.length) {
          this._allocQueue();
        }
        const item = this._queue[cursor];
        item.char = char;
        item.repeat = repeat;
        item.line = line2;
        item.column = column2;
        item.filename = filename;
        this._queueCursor++;
      }
      _popQueue() {
        if (this._queueCursor === 0) {
          throw new Error("Cannot pop from empty queue");
        }
        return this._queue[--this._queueCursor];
      }
      get() {
        this._flush();
        const map = this._map;
        const result = {
          code: (this._buf + this._str).trimRight(),
          decodedMap: map == null ? void 0 : map.getDecoded(),
          get __mergedMap() {
            return this.map;
          },
          get map() {
            const resultMap = map ? map.get() : null;
            result.map = resultMap;
            return resultMap;
          },
          set map(value) {
            Object.defineProperty(result, "map", {
              value,
              writable: true
            });
          },
          get rawMappings() {
            const mappings = map == null ? void 0 : map.getRawMappings();
            result.rawMappings = mappings;
            return mappings;
          },
          set rawMappings(value) {
            Object.defineProperty(result, "rawMappings", {
              value,
              writable: true
            });
          }
        };
        return result;
      }
      append(str, maybeNewline) {
        this._flush();
        this._append(str, this._sourcePosition, maybeNewline);
      }
      appendChar(char) {
        this._flush();
        this._appendChar(char, 1, this._sourcePosition);
      }
      queue(char) {
        if (char === 10) {
          while (this._queueCursor !== 0) {
            const char2 = this._queue[this._queueCursor - 1].char;
            if (char2 !== 32 && char2 !== 9) {
              break;
            }
            this._queueCursor--;
          }
        }
        const sourcePosition = this._sourcePosition;
        this._pushQueue(char, 1, sourcePosition.line, sourcePosition.column, sourcePosition.filename);
      }
      queueIndentation(repeat) {
        if (repeat === 0) return;
        this._pushQueue(-1, repeat, void 0, void 0, void 0);
      }
      _flush() {
        const queueCursor = this._queueCursor;
        const queue = this._queue;
        for (let i = 0; i < queueCursor; i++) {
          const item = queue[i];
          this._appendChar(item.char, item.repeat, item);
        }
        this._queueCursor = 0;
      }
      _appendChar(char, repeat, sourcePos) {
        this._last = char;
        if (char === -1) {
          const fastIndentation = this._fastIndentations[repeat];
          if (fastIndentation !== void 0) {
            this._str += fastIndentation;
          } else {
            this._str += repeat > 1 ? this._indentChar.repeat(repeat) : this._indentChar;
          }
        } else {
          this._str += repeat > 1 ? String.fromCharCode(char).repeat(repeat) : String.fromCharCode(char);
        }
        if (char !== 10) {
          this._mark(sourcePos.line, sourcePos.column, sourcePos.identifierName, sourcePos.identifierNamePos, sourcePos.filename);
          this._position.column += repeat;
        } else {
          this._position.line++;
          this._position.column = 0;
        }
        if (this._canMarkIdName) {
          sourcePos.identifierName = void 0;
          sourcePos.identifierNamePos = void 0;
        }
      }
      _append(str, sourcePos, maybeNewline) {
        const len = str.length;
        const position = this._position;
        this._last = str.charCodeAt(len - 1);
        if (++this._appendCount > 4096) {
          +this._str;
          this._buf += this._str;
          this._str = str;
          this._appendCount = 0;
        } else {
          this._str += str;
        }
        if (!maybeNewline && !this._map) {
          position.column += len;
          return;
        }
        const {
          column: column2,
          identifierName,
          identifierNamePos,
          filename
        } = sourcePos;
        let line2 = sourcePos.line;
        if ((identifierName != null || identifierNamePos != null) && this._canMarkIdName) {
          sourcePos.identifierName = void 0;
          sourcePos.identifierNamePos = void 0;
        }
        let i = str.indexOf("\n");
        let last = 0;
        if (i !== 0) {
          this._mark(line2, column2, identifierName, identifierNamePos, filename);
        }
        while (i !== -1) {
          position.line++;
          position.column = 0;
          last = i + 1;
          if (last < len && line2 !== void 0) {
            this._mark(++line2, 0, null, null, filename);
          }
          i = str.indexOf("\n", last);
        }
        position.column += len - last;
      }
      _mark(line2, column2, identifierName, identifierNamePos, filename) {
        var _this$_map;
        (_this$_map = this._map) == null || _this$_map.mark(this._position, line2, column2, identifierName, identifierNamePos, filename);
      }
      removeTrailingNewline() {
        const queueCursor = this._queueCursor;
        if (queueCursor !== 0 && this._queue[queueCursor - 1].char === 10) {
          this._queueCursor--;
        }
      }
      removeLastSemicolon() {
        const queueCursor = this._queueCursor;
        if (queueCursor !== 0 && this._queue[queueCursor - 1].char === 59) {
          this._queueCursor--;
        }
      }
      getLastChar() {
        const queueCursor = this._queueCursor;
        return queueCursor !== 0 ? this._queue[queueCursor - 1].char : this._last;
      }
      getNewlineCount() {
        const queueCursor = this._queueCursor;
        let count = 0;
        if (queueCursor === 0) return this._last === 10 ? 1 : 0;
        for (let i = queueCursor - 1; i >= 0; i--) {
          if (this._queue[i].char !== 10) {
            break;
          }
          count++;
        }
        return count === queueCursor && this._last === 10 ? count + 1 : count;
      }
      endsWithCharAndNewline() {
        const queue = this._queue;
        const queueCursor = this._queueCursor;
        if (queueCursor !== 0) {
          const lastCp = queue[queueCursor - 1].char;
          if (lastCp !== 10) return;
          if (queueCursor > 1) {
            return queue[queueCursor - 2].char;
          } else {
            return this._last;
          }
        }
      }
      hasContent() {
        return this._queueCursor !== 0 || !!this._last;
      }
      exactSource(loc, cb) {
        if (!this._map) {
          cb();
          return;
        }
        this.source("start", loc);
        const identifierName = loc.identifierName;
        const sourcePos = this._sourcePosition;
        if (identifierName) {
          this._canMarkIdName = false;
          sourcePos.identifierName = identifierName;
        }
        cb();
        if (identifierName) {
          this._canMarkIdName = true;
          sourcePos.identifierName = void 0;
          sourcePos.identifierNamePos = void 0;
        }
        this.source("end", loc);
      }
      source(prop, loc) {
        if (!this._map) return;
        this._normalizePosition(prop, loc, 0);
      }
      sourceWithOffset(prop, loc, columnOffset) {
        if (!this._map) return;
        this._normalizePosition(prop, loc, columnOffset);
      }
      _normalizePosition(prop, loc, columnOffset) {
        const pos2 = loc[prop];
        const target = this._sourcePosition;
        if (pos2) {
          target.line = pos2.line;
          target.column = Math.max(pos2.column + columnOffset, 0);
          target.filename = loc.filename;
        }
      }
      getCurrentColumn() {
        const queue = this._queue;
        const queueCursor = this._queueCursor;
        let lastIndex = -1;
        let len = 0;
        for (let i = 0; i < queueCursor; i++) {
          const item = queue[i];
          if (item.char === 10) {
            lastIndex = len;
          }
          len += item.repeat;
        }
        return lastIndex === -1 ? this._position.column + len : len - 1 - lastIndex;
      }
      getCurrentLine() {
        let count = 0;
        const queue = this._queue;
        for (let i = 0; i < this._queueCursor; i++) {
          if (queue[i].char === 10) {
            count++;
          }
        }
        return this._position.line + count;
      }
    };
    exports2.default = Buffer2;
  }
});

// node_modules/@babel/core/node_modules/@babel/generator/lib/node/whitespace.js
var require_whitespace2 = __commonJS({
  "node_modules/@babel/core/node_modules/@babel/generator/lib/node/whitespace.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.nodes = void 0;
    var _t = require("@babel/types");
    var {
      FLIPPED_ALIAS_KEYS,
      isArrayExpression,
      isAssignmentExpression,
      isBinary,
      isBlockStatement,
      isCallExpression,
      isFunction,
      isIdentifier,
      isLiteral,
      isMemberExpression: isMemberExpression2,
      isObjectExpression,
      isOptionalCallExpression,
      isOptionalMemberExpression: isOptionalMemberExpression2,
      isStringLiteral
    } = _t;
    function crawlInternal(node, state) {
      if (!node) return state;
      if (isMemberExpression2(node) || isOptionalMemberExpression2(node)) {
        crawlInternal(node.object, state);
        if (node.computed) crawlInternal(node.property, state);
      } else if (isBinary(node) || isAssignmentExpression(node)) {
        crawlInternal(node.left, state);
        crawlInternal(node.right, state);
      } else if (isCallExpression(node) || isOptionalCallExpression(node)) {
        state.hasCall = true;
        crawlInternal(node.callee, state);
      } else if (isFunction(node)) {
        state.hasFunction = true;
      } else if (isIdentifier(node)) {
        state.hasHelper = state.hasHelper || node.callee && isHelper(node.callee);
      }
      return state;
    }
    function crawl(node) {
      return crawlInternal(node, {
        hasCall: false,
        hasFunction: false,
        hasHelper: false
      });
    }
    function isHelper(node) {
      if (!node) return false;
      if (isMemberExpression2(node)) {
        return isHelper(node.object) || isHelper(node.property);
      } else if (isIdentifier(node)) {
        return node.name === "require" || node.name.charCodeAt(0) === 95;
      } else if (isCallExpression(node)) {
        return isHelper(node.callee);
      } else if (isBinary(node) || isAssignmentExpression(node)) {
        return isIdentifier(node.left) && isHelper(node.left) || isHelper(node.right);
      } else {
        return false;
      }
    }
    function isType(node) {
      return isLiteral(node) || isObjectExpression(node) || isArrayExpression(node) || isIdentifier(node) || isMemberExpression2(node);
    }
    var nodes = exports2.nodes = {
      AssignmentExpression(node) {
        const state = crawl(node.right);
        if (state.hasCall && state.hasHelper || state.hasFunction) {
          return state.hasFunction ? 1 | 2 : 2;
        }
      },
      SwitchCase(node, parent) {
        return (!!node.consequent.length || parent.cases[0] === node ? 1 : 0) | (!node.consequent.length && parent.cases[parent.cases.length - 1] === node ? 2 : 0);
      },
      LogicalExpression(node) {
        if (isFunction(node.left) || isFunction(node.right)) {
          return 2;
        }
      },
      Literal(node) {
        if (isStringLiteral(node) && node.value === "use strict") {
          return 2;
        }
      },
      CallExpression(node) {
        if (isFunction(node.callee) || isHelper(node)) {
          return 1 | 2;
        }
      },
      OptionalCallExpression(node) {
        if (isFunction(node.callee)) {
          return 1 | 2;
        }
      },
      VariableDeclaration(node) {
        for (let i = 0; i < node.declarations.length; i++) {
          const declar = node.declarations[i];
          let enabled = isHelper(declar.id) && !isType(declar.init);
          if (!enabled && declar.init) {
            const state = crawl(declar.init);
            enabled = isHelper(declar.init) && state.hasCall || state.hasFunction;
          }
          if (enabled) {
            return 1 | 2;
          }
        }
      },
      IfStatement(node) {
        if (isBlockStatement(node.consequent)) {
          return 1 | 2;
        }
      }
    };
    nodes.ObjectProperty = nodes.ObjectTypeProperty = nodes.ObjectMethod = function(node, parent) {
      if (parent.properties[0] === node) {
        return 1;
      }
    };
    nodes.ObjectTypeCallProperty = function(node, parent) {
      var _parent$properties;
      if (parent.callProperties[0] === node && !((_parent$properties = parent.properties) != null && _parent$properties.length)) {
        return 1;
      }
    };
    nodes.ObjectTypeIndexer = function(node, parent) {
      var _parent$properties2, _parent$callPropertie;
      if (parent.indexers[0] === node && !((_parent$properties2 = parent.properties) != null && _parent$properties2.length) && !((_parent$callPropertie = parent.callProperties) != null && _parent$callPropertie.length)) {
        return 1;
      }
    };
    nodes.ObjectTypeInternalSlot = function(node, parent) {
      var _parent$properties3, _parent$callPropertie2, _parent$indexers;
      if (parent.internalSlots[0] === node && !((_parent$properties3 = parent.properties) != null && _parent$properties3.length) && !((_parent$callPropertie2 = parent.callProperties) != null && _parent$callPropertie2.length) && !((_parent$indexers = parent.indexers) != null && _parent$indexers.length)) {
        return 1;
      }
    };
    [["Function", true], ["Class", true], ["Loop", true], ["LabeledStatement", true], ["SwitchStatement", true], ["TryStatement", true]].forEach(function([type, amounts]) {
      [type].concat(FLIPPED_ALIAS_KEYS[type] || []).forEach(function(type2) {
        const ret = amounts ? 1 | 2 : 0;
        nodes[type2] = () => ret;
      });
    });
  }
});

// node_modules/@babel/core/node_modules/@babel/generator/lib/node/parentheses.js
var require_parentheses2 = __commonJS({
  "node_modules/@babel/core/node_modules/@babel/generator/lib/node/parentheses.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.AssignmentExpression = AssignmentExpression;
    exports2.Binary = Binary;
    exports2.BinaryExpression = BinaryExpression;
    exports2.ClassExpression = ClassExpression;
    exports2.ArrowFunctionExpression = exports2.ConditionalExpression = ConditionalExpression;
    exports2.DoExpression = DoExpression;
    exports2.FunctionExpression = FunctionExpression10;
    exports2.FunctionTypeAnnotation = FunctionTypeAnnotation;
    exports2.Identifier = Identifier25;
    exports2.LogicalExpression = LogicalExpression;
    exports2.NullableTypeAnnotation = NullableTypeAnnotation;
    exports2.ObjectExpression = ObjectExpression;
    exports2.OptionalIndexedAccessType = OptionalIndexedAccessType;
    exports2.OptionalCallExpression = exports2.OptionalMemberExpression = OptionalMemberExpression;
    exports2.SequenceExpression = SequenceExpression;
    exports2.TSSatisfiesExpression = exports2.TSAsExpression = TSAsExpression;
    exports2.TSConditionalType = TSConditionalType;
    exports2.TSConstructorType = exports2.TSFunctionType = TSFunctionType;
    exports2.TSInferType = TSInferType;
    exports2.TSInstantiationExpression = TSInstantiationExpression;
    exports2.TSIntersectionType = TSIntersectionType;
    exports2.UnaryLike = exports2.TSTypeAssertion = UnaryLike;
    exports2.TSTypeOperator = TSTypeOperator;
    exports2.TSUnionType = TSUnionType;
    exports2.IntersectionTypeAnnotation = exports2.UnionTypeAnnotation = UnionTypeAnnotation;
    exports2.UpdateExpression = UpdateExpression;
    exports2.AwaitExpression = exports2.YieldExpression = YieldExpression;
    var _t = require("@babel/types");
    var _index = require_node3();
    var {
      isArrayTypeAnnotation,
      isBinaryExpression,
      isCallExpression,
      isForOfStatement,
      isIndexedAccessType,
      isMemberExpression: isMemberExpression2,
      isObjectPattern,
      isOptionalMemberExpression: isOptionalMemberExpression2,
      isYieldExpression,
      isStatement: isStatement2
    } = _t;
    var PRECEDENCE = /* @__PURE__ */ new Map([["||", 0], ["??", 0], ["|>", 0], ["&&", 1], ["|", 2], ["^", 3], ["&", 4], ["==", 5], ["===", 5], ["!=", 5], ["!==", 5], ["<", 6], [">", 6], ["<=", 6], [">=", 6], ["in", 6], ["instanceof", 6], [">>", 7], ["<<", 7], [">>>", 7], ["+", 8], ["-", 8], ["*", 9], ["/", 9], ["%", 9], ["**", 10]]);
    function getBinaryPrecedence(node, nodeType) {
      if (nodeType === "BinaryExpression" || nodeType === "LogicalExpression") {
        return PRECEDENCE.get(node.operator);
      }
      if (nodeType === "TSAsExpression" || nodeType === "TSSatisfiesExpression") {
        return PRECEDENCE.get("in");
      }
    }
    function isTSTypeExpression(nodeType) {
      return nodeType === "TSAsExpression" || nodeType === "TSSatisfiesExpression" || nodeType === "TSTypeAssertion";
    }
    var isClassExtendsClause = (node, parent) => {
      const parentType = parent.type;
      return (parentType === "ClassDeclaration" || parentType === "ClassExpression") && parent.superClass === node;
    };
    var hasPostfixPart = (node, parent) => {
      const parentType = parent.type;
      return (parentType === "MemberExpression" || parentType === "OptionalMemberExpression") && parent.object === node || (parentType === "CallExpression" || parentType === "OptionalCallExpression" || parentType === "NewExpression") && parent.callee === node || parentType === "TaggedTemplateExpression" && parent.tag === node || parentType === "TSNonNullExpression";
    };
    function NullableTypeAnnotation(node, parent) {
      return isArrayTypeAnnotation(parent);
    }
    function FunctionTypeAnnotation(node, parent, tokenContext) {
      const parentType = parent.type;
      return parentType === "UnionTypeAnnotation" || parentType === "IntersectionTypeAnnotation" || parentType === "ArrayTypeAnnotation" || Boolean(tokenContext & _index.TokenContext.arrowFlowReturnType);
    }
    function UpdateExpression(node, parent) {
      return hasPostfixPart(node, parent) || isClassExtendsClause(node, parent);
    }
    function needsParenBeforeExpressionBrace(tokenContext) {
      return Boolean(tokenContext & (_index.TokenContext.expressionStatement | _index.TokenContext.arrowBody));
    }
    function ObjectExpression(node, parent, tokenContext) {
      return needsParenBeforeExpressionBrace(tokenContext);
    }
    function DoExpression(node, parent, tokenContext) {
      return !node.async && Boolean(tokenContext & _index.TokenContext.expressionStatement);
    }
    function Binary(node, parent) {
      const parentType = parent.type;
      if (node.type === "BinaryExpression" && node.operator === "**" && parentType === "BinaryExpression" && parent.operator === "**") {
        return parent.left === node;
      }
      if (isClassExtendsClause(node, parent)) {
        return true;
      }
      if (hasPostfixPart(node, parent) || parentType === "UnaryExpression" || parentType === "SpreadElement" || parentType === "AwaitExpression") {
        return true;
      }
      const parentPos = getBinaryPrecedence(parent, parentType);
      if (parentPos != null) {
        const nodePos = getBinaryPrecedence(node, node.type);
        if (parentPos === nodePos && parentType === "BinaryExpression" && parent.right === node || parentPos > nodePos) {
          return true;
        }
      }
      return void 0;
    }
    function UnionTypeAnnotation(node, parent) {
      const parentType = parent.type;
      return parentType === "ArrayTypeAnnotation" || parentType === "NullableTypeAnnotation" || parentType === "IntersectionTypeAnnotation" || parentType === "UnionTypeAnnotation";
    }
    function OptionalIndexedAccessType(node, parent) {
      return isIndexedAccessType(parent) && parent.objectType === node;
    }
    function TSAsExpression(node, parent) {
      if ((parent.type === "AssignmentExpression" || parent.type === "AssignmentPattern") && parent.left === node) {
        return true;
      }
      if (parent.type === "BinaryExpression" && (parent.operator === "|" || parent.operator === "&") && node === parent.left) {
        return true;
      }
      return Binary(node, parent);
    }
    function TSConditionalType(node, parent) {
      const parentType = parent.type;
      if (parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node || parentType === "TSOptionalType" || parentType === "TSTypeOperator" || parentType === "TSTypeParameter") {
        return true;
      }
      if ((parentType === "TSIntersectionType" || parentType === "TSUnionType") && parent.types[0] === node) {
        return true;
      }
      if (parentType === "TSConditionalType" && (parent.checkType === node || parent.extendsType === node)) {
        return true;
      }
      return false;
    }
    function TSUnionType(node, parent) {
      const parentType = parent.type;
      return parentType === "TSIntersectionType" || parentType === "TSTypeOperator" || parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node || parentType === "TSOptionalType";
    }
    function TSIntersectionType(node, parent) {
      const parentType = parent.type;
      return parentType === "TSTypeOperator" || parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node || parentType === "TSOptionalType";
    }
    function TSInferType(node, parent) {
      const parentType = parent.type;
      if (parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node || parentType === "TSOptionalType") {
        return true;
      }
      if (node.typeParameter.constraint) {
        if ((parentType === "TSIntersectionType" || parentType === "TSUnionType") && parent.types[0] === node) {
          return true;
        }
      }
      return false;
    }
    function TSTypeOperator(node, parent) {
      const parentType = parent.type;
      return parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node || parentType === "TSOptionalType";
    }
    function TSInstantiationExpression(node, parent) {
      const parentType = parent.type;
      return (parentType === "CallExpression" || parentType === "OptionalCallExpression" || parentType === "NewExpression" || parentType === "TSInstantiationExpression") && !!parent.typeParameters;
    }
    function TSFunctionType(node, parent) {
      const parentType = parent.type;
      return parentType === "TSIntersectionType" || parentType === "TSUnionType" || parentType === "TSTypeOperator" || parentType === "TSOptionalType" || parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node || parentType === "TSConditionalType" && (parent.checkType === node || parent.extendsType === node);
    }
    function BinaryExpression(node, parent, tokenContext, inForStatementInit) {
      return node.operator === "in" && inForStatementInit;
    }
    function SequenceExpression(node, parent) {
      const parentType = parent.type;
      if (parentType === "SequenceExpression" || parentType === "ParenthesizedExpression" || parentType === "MemberExpression" && parent.property === node || parentType === "OptionalMemberExpression" && parent.property === node || parentType === "TemplateLiteral") {
        return false;
      }
      if (parentType === "ClassDeclaration") {
        return true;
      }
      if (parentType === "ForOfStatement") {
        return parent.right === node;
      }
      if (parentType === "ExportDefaultDeclaration") {
        return true;
      }
      return !isStatement2(parent);
    }
    function YieldExpression(node, parent) {
      const parentType = parent.type;
      return parentType === "BinaryExpression" || parentType === "LogicalExpression" || parentType === "UnaryExpression" || parentType === "SpreadElement" || hasPostfixPart(node, parent) || parentType === "AwaitExpression" && isYieldExpression(node) || parentType === "ConditionalExpression" && node === parent.test || isClassExtendsClause(node, parent) || isTSTypeExpression(parentType);
    }
    function ClassExpression(node, parent, tokenContext) {
      return Boolean(tokenContext & (_index.TokenContext.expressionStatement | _index.TokenContext.exportDefault));
    }
    function UnaryLike(node, parent) {
      return hasPostfixPart(node, parent) || isBinaryExpression(parent) && parent.operator === "**" && parent.left === node || isClassExtendsClause(node, parent);
    }
    function FunctionExpression10(node, parent, tokenContext) {
      return Boolean(tokenContext & (_index.TokenContext.expressionStatement | _index.TokenContext.exportDefault));
    }
    function ConditionalExpression(node, parent) {
      const parentType = parent.type;
      if (parentType === "UnaryExpression" || parentType === "SpreadElement" || parentType === "BinaryExpression" || parentType === "LogicalExpression" || parentType === "ConditionalExpression" && parent.test === node || parentType === "AwaitExpression" || isTSTypeExpression(parentType)) {
        return true;
      }
      return UnaryLike(node, parent);
    }
    function OptionalMemberExpression(node, parent) {
      return isCallExpression(parent) && parent.callee === node || isMemberExpression2(parent) && parent.object === node;
    }
    function AssignmentExpression(node, parent, tokenContext) {
      if (needsParenBeforeExpressionBrace(tokenContext) && isObjectPattern(node.left)) {
        return true;
      } else {
        return ConditionalExpression(node, parent);
      }
    }
    function LogicalExpression(node, parent) {
      const parentType = parent.type;
      if (isTSTypeExpression(parentType)) return true;
      if (parentType !== "LogicalExpression") return false;
      switch (node.operator) {
        case "||":
          return parent.operator === "??" || parent.operator === "&&";
        case "&&":
          return parent.operator === "??";
        case "??":
          return parent.operator !== "??";
      }
    }
    function Identifier25(node, parent, tokenContext, _inForInit, getRawIdentifier) {
      var _node$extra;
      const parentType = parent.type;
      if ((_node$extra = node.extra) != null && _node$extra.parenthesized && parentType === "AssignmentExpression" && parent.left === node) {
        const rightType = parent.right.type;
        if ((rightType === "FunctionExpression" || rightType === "ClassExpression") && parent.right.id == null) {
          return true;
        }
      }
      if (getRawIdentifier && getRawIdentifier(node) !== node.name) {
        return false;
      }
      if (node.name === "let") {
        const isFollowedByBracket = isMemberExpression2(parent, {
          object: node,
          computed: true
        }) || isOptionalMemberExpression2(parent, {
          object: node,
          computed: true,
          optional: false
        });
        if (isFollowedByBracket && tokenContext & (_index.TokenContext.expressionStatement | _index.TokenContext.forHead | _index.TokenContext.forInHead)) {
          return true;
        }
        return Boolean(tokenContext & _index.TokenContext.forOfHead);
      }
      return node.name === "async" && isForOfStatement(parent, {
        left: node,
        await: false
      });
    }
  }
});

// node_modules/@babel/core/node_modules/@babel/generator/lib/node/index.js
var require_node3 = __commonJS({
  "node_modules/@babel/core/node_modules/@babel/generator/lib/node/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.TokenContext = void 0;
    exports2.isLastChild = isLastChild;
    exports2.needsParens = needsParens;
    exports2.needsWhitespace = needsWhitespace;
    exports2.needsWhitespaceAfter = needsWhitespaceAfter;
    exports2.needsWhitespaceBefore = needsWhitespaceBefore;
    var whitespace = require_whitespace2();
    var parens = require_parentheses2();
    var _t = require("@babel/types");
    var {
      FLIPPED_ALIAS_KEYS,
      VISITOR_KEYS,
      isCallExpression,
      isDecorator,
      isExpressionStatement,
      isMemberExpression: isMemberExpression2,
      isNewExpression,
      isParenthesizedExpression
    } = _t;
    var TokenContext = exports2.TokenContext = {
      expressionStatement: 1,
      arrowBody: 2,
      exportDefault: 4,
      forHead: 8,
      forInHead: 16,
      forOfHead: 32,
      arrowFlowReturnType: 64
    };
    function expandAliases(obj) {
      const map = /* @__PURE__ */ new Map();
      function add(type, func) {
        const fn = map.get(type);
        map.set(type, fn ? function(node, parent, stack2, inForInit, getRawIdentifier) {
          var _fn;
          return (_fn = fn(node, parent, stack2, inForInit, getRawIdentifier)) != null ? _fn : func(node, parent, stack2, inForInit, getRawIdentifier);
        } : func);
      }
      for (const type of Object.keys(obj)) {
        const aliases = FLIPPED_ALIAS_KEYS[type];
        if (aliases) {
          for (const alias of aliases) {
            add(alias, obj[type]);
          }
        } else {
          add(type, obj[type]);
        }
      }
      return map;
    }
    var expandedParens = expandAliases(parens);
    var expandedWhitespaceNodes = expandAliases(whitespace.nodes);
    function isOrHasCallExpression(node) {
      if (isCallExpression(node)) {
        return true;
      }
      return isMemberExpression2(node) && isOrHasCallExpression(node.object);
    }
    function needsWhitespace(node, parent, type) {
      var _expandedWhitespaceNo;
      if (!node) return false;
      if (isExpressionStatement(node)) {
        node = node.expression;
      }
      const flag = (_expandedWhitespaceNo = expandedWhitespaceNodes.get(node.type)) == null ? void 0 : _expandedWhitespaceNo(node, parent);
      if (typeof flag === "number") {
        return (flag & type) !== 0;
      }
      return false;
    }
    function needsWhitespaceBefore(node, parent) {
      return needsWhitespace(node, parent, 1);
    }
    function needsWhitespaceAfter(node, parent) {
      return needsWhitespace(node, parent, 2);
    }
    function needsParens(node, parent, tokenContext, inForInit, getRawIdentifier) {
      var _expandedParens$get;
      if (!parent) return false;
      if (isNewExpression(parent) && parent.callee === node) {
        if (isOrHasCallExpression(node)) return true;
      }
      if (isDecorator(parent)) {
        return !isDecoratorMemberExpression(node) && !(isCallExpression(node) && isDecoratorMemberExpression(node.callee)) && !isParenthesizedExpression(node);
      }
      return (_expandedParens$get = expandedParens.get(node.type)) == null ? void 0 : _expandedParens$get(node, parent, tokenContext, inForInit, getRawIdentifier);
    }
    function isDecoratorMemberExpression(node) {
      switch (node.type) {
        case "Identifier":
          return true;
        case "MemberExpression":
          return !node.computed && node.property.type === "Identifier" && isDecoratorMemberExpression(node.object);
        default:
          return false;
      }
    }
    function isLastChild(parent, child) {
      const visitorKeys = VISITOR_KEYS[parent.type];
      for (let i = visitorKeys.length - 1; i >= 0; i--) {
        const val = parent[visitorKeys[i]];
        if (val === child) {
          return true;
        } else if (Array.isArray(val)) {
          let j = val.length - 1;
          while (j >= 0 && val[j] === null) j--;
          return j >= 0 && val[j] === child;
        } else if (val) {
          return false;
        }
      }
      return false;
    }
  }
});

// node_modules/@babel/core/node_modules/@babel/generator/lib/token-map.js
var require_token_map2 = __commonJS({
  "node_modules/@babel/core/node_modules/@babel/generator/lib/token-map.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.TokenMap = void 0;
    var _t = require("@babel/types");
    var {
      traverseFast,
      VISITOR_KEYS
    } = _t;
    var TokenMap = class {
      constructor(ast, tokens, source2) {
        this._tokens = void 0;
        this._source = void 0;
        this._nodesToTokenIndexes = /* @__PURE__ */ new Map();
        this._nodesOccurrencesCountCache = /* @__PURE__ */ new Map();
        this._tokensCache = /* @__PURE__ */ new Map();
        this._tokens = tokens;
        this._source = source2;
        traverseFast(ast, (node) => {
          const indexes = this._getTokensIndexesOfNode(node);
          if (indexes.length > 0) this._nodesToTokenIndexes.set(node, indexes);
        });
        this._tokensCache = null;
      }
      has(node) {
        return this._nodesToTokenIndexes.has(node);
      }
      getIndexes(node) {
        return this._nodesToTokenIndexes.get(node);
      }
      find(node, condition) {
        const indexes = this._nodesToTokenIndexes.get(node);
        if (indexes) {
          for (let k = 0; k < indexes.length; k++) {
            const index = indexes[k];
            const tok = this._tokens[index];
            if (condition(tok, index)) return tok;
          }
        }
        return null;
      }
      findLastIndex(node, condition) {
        const indexes = this._nodesToTokenIndexes.get(node);
        if (indexes) {
          for (let k = indexes.length - 1; k >= 0; k--) {
            const index = indexes[k];
            const tok = this._tokens[index];
            if (condition(tok, index)) return index;
          }
        }
        return -1;
      }
      findMatching(node, test, occurrenceCount = 0) {
        const indexes = this._nodesToTokenIndexes.get(node);
        if (indexes) {
          let i = 0;
          const count = occurrenceCount;
          if (count > 1) {
            const cache = this._nodesOccurrencesCountCache.get(node);
            if (cache && cache.test === test && cache.count < count) {
              i = cache.i + 1;
              occurrenceCount -= cache.count + 1;
            }
          }
          for (; i < indexes.length; i++) {
            const tok = this._tokens[indexes[i]];
            if (this.matchesOriginal(tok, test)) {
              if (occurrenceCount === 0) {
                if (count > 0) {
                  this._nodesOccurrencesCountCache.set(node, {
                    test,
                    count,
                    i
                  });
                }
                return tok;
              }
              occurrenceCount--;
            }
          }
        }
        return null;
      }
      matchesOriginal(token2, test) {
        if (token2.end - token2.start !== test.length) return false;
        if (token2.value != null) return token2.value === test;
        return this._source.startsWith(test, token2.start);
      }
      startMatches(node, test) {
        const indexes = this._nodesToTokenIndexes.get(node);
        if (!indexes) return false;
        const tok = this._tokens[indexes[0]];
        if (tok.start !== node.start) return false;
        return this.matchesOriginal(tok, test);
      }
      endMatches(node, test) {
        const indexes = this._nodesToTokenIndexes.get(node);
        if (!indexes) return false;
        const tok = this._tokens[indexes[indexes.length - 1]];
        if (tok.end !== node.end) return false;
        return this.matchesOriginal(tok, test);
      }
      _getTokensIndexesOfNode(node) {
        if (node.start == null || node.end == null) return [];
        const {
          first,
          last
        } = this._findTokensOfNode(node, 0, this._tokens.length - 1);
        let low = first;
        const children = childrenIterator(node);
        if ((node.type === "ExportNamedDeclaration" || node.type === "ExportDefaultDeclaration") && node.declaration && node.declaration.type === "ClassDeclaration") {
          children.next();
        }
        const indexes = [];
        for (const child of children) {
          if (child == null) continue;
          if (child.start == null || child.end == null) continue;
          const childTok = this._findTokensOfNode(child, low, last);
          const high = childTok.first;
          for (let k = low; k < high; k++) indexes.push(k);
          low = childTok.last + 1;
        }
        for (let k = low; k <= last; k++) indexes.push(k);
        return indexes;
      }
      _findTokensOfNode(node, low, high) {
        const cached = this._tokensCache.get(node);
        if (cached) return cached;
        const first = this._findFirstTokenOfNode(node.start, low, high);
        const last = this._findLastTokenOfNode(node.end, first, high);
        this._tokensCache.set(node, {
          first,
          last
        });
        return {
          first,
          last
        };
      }
      _findFirstTokenOfNode(start, low, high) {
        while (low <= high) {
          const mid = high + low >> 1;
          if (start < this._tokens[mid].start) {
            high = mid - 1;
          } else if (start > this._tokens[mid].start) {
            low = mid + 1;
          } else {
            return mid;
          }
        }
        return low;
      }
      _findLastTokenOfNode(end, low, high) {
        while (low <= high) {
          const mid = high + low >> 1;
          if (end < this._tokens[mid].end) {
            high = mid - 1;
          } else if (end > this._tokens[mid].end) {
            low = mid + 1;
          } else {
            return mid;
          }
        }
        return high;
      }
    };
    exports2.TokenMap = TokenMap;
    function* childrenIterator(node) {
      if (node.type === "TemplateLiteral") {
        yield node.quasis[0];
        for (let i = 1; i < node.quasis.length; i++) {
          yield node.expressions[i - 1];
          yield node.quasis[i];
        }
        return;
      }
      const keys = VISITOR_KEYS[node.type];
      for (const key2 of keys) {
        const child = node[key2];
        if (!child) continue;
        if (Array.isArray(child)) {
          yield* __yieldStar(child);
        } else {
          yield child;
        }
      }
    }
  }
});

// node_modules/@babel/core/node_modules/@babel/generator/lib/generators/template-literals.js
var require_template_literals2 = __commonJS({
  "node_modules/@babel/core/node_modules/@babel/generator/lib/generators/template-literals.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.TaggedTemplateExpression = TaggedTemplateExpression;
    exports2.TemplateElement = TemplateElement;
    exports2.TemplateLiteral = TemplateLiteral;
    exports2._printTemplate = _printTemplate;
    function TaggedTemplateExpression(node) {
      this.print(node.tag);
      {
        this.print(node.typeParameters);
      }
      this.print(node.quasi);
    }
    function TemplateElement() {
      throw new Error("TemplateElement printing is handled in TemplateLiteral");
    }
    function _printTemplate(node, substitutions) {
      const quasis = node.quasis;
      let partRaw = "`";
      for (let i = 0; i < quasis.length - 1; i++) {
        partRaw += quasis[i].value.raw;
        this.token(partRaw + "${", true);
        this.print(substitutions[i]);
        partRaw = "}";
        if (this.tokenMap) {
          const token2 = this.tokenMap.findMatching(node, "}", i);
          if (token2) this._catchUpTo(token2.loc.start);
        }
      }
      partRaw += quasis[quasis.length - 1].value.raw;
      this.token(partRaw + "`", true);
    }
    function TemplateLiteral(node) {
      this._printTemplate(node, node.expressions);
    }
  }
});

// node_modules/@babel/core/node_modules/@babel/generator/lib/generators/expressions.js
var require_expressions2 = __commonJS({
  "node_modules/@babel/core/node_modules/@babel/generator/lib/generators/expressions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.LogicalExpression = exports2.BinaryExpression = exports2.AssignmentExpression = AssignmentExpression;
    exports2.AssignmentPattern = AssignmentPattern;
    exports2.AwaitExpression = AwaitExpression;
    exports2.BindExpression = BindExpression;
    exports2.CallExpression = CallExpression4;
    exports2.ConditionalExpression = ConditionalExpression;
    exports2.Decorator = Decorator;
    exports2.DoExpression = DoExpression;
    exports2.EmptyStatement = EmptyStatement;
    exports2.ExpressionStatement = ExpressionStatement;
    exports2.Import = Import;
    exports2.MemberExpression = MemberExpression;
    exports2.MetaProperty = MetaProperty;
    exports2.ModuleExpression = ModuleExpression;
    exports2.NewExpression = NewExpression;
    exports2.OptionalCallExpression = OptionalCallExpression;
    exports2.OptionalMemberExpression = OptionalMemberExpression;
    exports2.ParenthesizedExpression = ParenthesizedExpression;
    exports2.PrivateName = PrivateName;
    exports2.SequenceExpression = SequenceExpression;
    exports2.Super = Super;
    exports2.ThisExpression = ThisExpression;
    exports2.UnaryExpression = UnaryExpression;
    exports2.UpdateExpression = UpdateExpression;
    exports2.V8IntrinsicIdentifier = V8IntrinsicIdentifier;
    exports2.YieldExpression = YieldExpression;
    exports2._shouldPrintDecoratorsBeforeExport = _shouldPrintDecoratorsBeforeExport;
    var _t = require("@babel/types");
    var _index = require_node3();
    var {
      isCallExpression,
      isLiteral,
      isMemberExpression: isMemberExpression2,
      isNewExpression,
      isPattern
    } = _t;
    function UnaryExpression(node) {
      const {
        operator
      } = node;
      if (operator === "void" || operator === "delete" || operator === "typeof" || operator === "throw") {
        this.word(operator);
        this.space();
      } else {
        this.token(operator);
      }
      this.print(node.argument);
    }
    function DoExpression(node) {
      if (node.async) {
        this.word("async", true);
        this.space();
      }
      this.word("do");
      this.space();
      this.print(node.body);
    }
    function ParenthesizedExpression(node) {
      this.tokenChar(40);
      const exit = this.enterDelimited();
      this.print(node.expression);
      exit();
      this.rightParens(node);
    }
    function UpdateExpression(node) {
      if (node.prefix) {
        this.token(node.operator);
        this.print(node.argument);
      } else {
        this.print(node.argument, true);
        this.token(node.operator);
      }
    }
    function ConditionalExpression(node) {
      this.print(node.test);
      this.space();
      this.tokenChar(63);
      this.space();
      this.print(node.consequent);
      this.space();
      this.tokenChar(58);
      this.space();
      this.print(node.alternate);
    }
    function NewExpression(node, parent) {
      this.word("new");
      this.space();
      this.print(node.callee);
      if (this.format.minified && node.arguments.length === 0 && !node.optional && !isCallExpression(parent, {
        callee: node
      }) && !isMemberExpression2(parent) && !isNewExpression(parent)) {
        return;
      }
      this.print(node.typeArguments);
      {
        this.print(node.typeParameters);
      }
      if (node.optional) {
        this.token("?.");
      }
      if (node.arguments.length === 0 && this.tokenMap && !this.tokenMap.endMatches(node, ")")) {
        return;
      }
      this.tokenChar(40);
      const exit = this.enterDelimited();
      this.printList(node.arguments, this.shouldPrintTrailingComma(")"));
      exit();
      this.rightParens(node);
    }
    function SequenceExpression(node) {
      this.printList(node.expressions);
    }
    function ThisExpression() {
      this.word("this");
    }
    function Super() {
      this.word("super");
    }
    function _shouldPrintDecoratorsBeforeExport(node) {
      if (typeof this.format.decoratorsBeforeExport === "boolean") {
        return this.format.decoratorsBeforeExport;
      }
      return typeof node.start === "number" && node.start === node.declaration.start;
    }
    function Decorator(node) {
      this.tokenChar(64);
      this.print(node.expression);
      this.newline();
    }
    function OptionalMemberExpression(node) {
      let {
        computed
      } = node;
      const {
        optional,
        property
      } = node;
      this.print(node.object);
      if (!computed && isMemberExpression2(property)) {
        throw new TypeError("Got a MemberExpression for MemberExpression property");
      }
      if (isLiteral(property) && typeof property.value === "number") {
        computed = true;
      }
      if (optional) {
        this.token("?.");
      }
      if (computed) {
        this.tokenChar(91);
        this.print(property);
        this.tokenChar(93);
      } else {
        if (!optional) {
          this.tokenChar(46);
        }
        this.print(property);
      }
    }
    function OptionalCallExpression(node) {
      this.print(node.callee);
      {
        this.print(node.typeParameters);
      }
      if (node.optional) {
        this.token("?.");
      }
      this.print(node.typeArguments);
      this.tokenChar(40);
      const exit = this.enterDelimited();
      this.printList(node.arguments);
      exit();
      this.rightParens(node);
    }
    function CallExpression4(node) {
      this.print(node.callee);
      this.print(node.typeArguments);
      {
        this.print(node.typeParameters);
      }
      this.tokenChar(40);
      const exit = this.enterDelimited();
      this.printList(node.arguments, this.shouldPrintTrailingComma(")"));
      exit();
      this.rightParens(node);
    }
    function Import() {
      this.word("import");
    }
    function AwaitExpression(node) {
      this.word("await");
      if (node.argument) {
        this.space();
        this.printTerminatorless(node.argument);
      }
    }
    function YieldExpression(node) {
      this.word("yield", true);
      if (node.delegate) {
        this.tokenChar(42);
        if (node.argument) {
          this.space();
          this.print(node.argument);
        }
      } else {
        if (node.argument) {
          this.space();
          this.printTerminatorless(node.argument);
        }
      }
    }
    function EmptyStatement() {
      this.semicolon(true);
    }
    function ExpressionStatement(node) {
      this.tokenContext |= _index.TokenContext.expressionStatement;
      this.print(node.expression);
      this.semicolon();
    }
    function AssignmentPattern(node) {
      this.print(node.left);
      if (node.left.type === "Identifier" || isPattern(node.left)) {
        if (node.left.optional) this.tokenChar(63);
        this.print(node.left.typeAnnotation);
      }
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node.right);
    }
    function AssignmentExpression(node) {
      this.print(node.left);
      this.space();
      if (node.operator === "in" || node.operator === "instanceof") {
        this.word(node.operator);
      } else {
        this.token(node.operator);
        this._endsWithDiv = node.operator === "/";
      }
      this.space();
      this.print(node.right);
    }
    function BindExpression(node) {
      this.print(node.object);
      this.token("::");
      this.print(node.callee);
    }
    function MemberExpression(node) {
      this.print(node.object);
      if (!node.computed && isMemberExpression2(node.property)) {
        throw new TypeError("Got a MemberExpression for MemberExpression property");
      }
      let computed = node.computed;
      if (isLiteral(node.property) && typeof node.property.value === "number") {
        computed = true;
      }
      if (computed) {
        const exit = this.enterDelimited();
        this.tokenChar(91);
        this.print(node.property);
        this.tokenChar(93);
        exit();
      } else {
        this.tokenChar(46);
        this.print(node.property);
      }
    }
    function MetaProperty(node) {
      this.print(node.meta);
      this.tokenChar(46);
      this.print(node.property);
    }
    function PrivateName(node) {
      this.tokenChar(35);
      this.print(node.id);
    }
    function V8IntrinsicIdentifier(node) {
      this.tokenChar(37);
      this.word(node.name);
    }
    function ModuleExpression(node) {
      this.word("module", true);
      this.space();
      this.tokenChar(123);
      this.indent();
      const {
        body
      } = node;
      if (body.body.length || body.directives.length) {
        this.newline();
      }
      this.print(body);
      this.dedent();
      this.rightBrace(node);
    }
  }
});

// node_modules/@babel/core/node_modules/@babel/generator/lib/generators/statements.js
var require_statements2 = __commonJS({
  "node_modules/@babel/core/node_modules/@babel/generator/lib/generators/statements.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.BreakStatement = BreakStatement;
    exports2.CatchClause = CatchClause;
    exports2.ContinueStatement = ContinueStatement;
    exports2.DebuggerStatement = DebuggerStatement;
    exports2.DoWhileStatement = DoWhileStatement;
    exports2.ForOfStatement = exports2.ForInStatement = void 0;
    exports2.ForStatement = ForStatement;
    exports2.IfStatement = IfStatement;
    exports2.LabeledStatement = LabeledStatement;
    exports2.ReturnStatement = ReturnStatement;
    exports2.SwitchCase = SwitchCase;
    exports2.SwitchStatement = SwitchStatement;
    exports2.ThrowStatement = ThrowStatement;
    exports2.TryStatement = TryStatement;
    exports2.VariableDeclaration = VariableDeclaration;
    exports2.VariableDeclarator = VariableDeclarator;
    exports2.WhileStatement = WhileStatement;
    exports2.WithStatement = WithStatement;
    var _t = require("@babel/types");
    var _index = require_node3();
    var {
      isFor,
      isForStatement,
      isIfStatement,
      isStatement: isStatement2
    } = _t;
    function WithStatement(node) {
      this.word("with");
      this.space();
      this.tokenChar(40);
      this.print(node.object);
      this.tokenChar(41);
      this.printBlock(node);
    }
    function IfStatement(node) {
      this.word("if");
      this.space();
      this.tokenChar(40);
      this.print(node.test);
      this.tokenChar(41);
      this.space();
      const needsBlock = node.alternate && isIfStatement(getLastStatement(node.consequent));
      if (needsBlock) {
        this.tokenChar(123);
        this.newline();
        this.indent();
      }
      this.printAndIndentOnComments(node.consequent);
      if (needsBlock) {
        this.dedent();
        this.newline();
        this.tokenChar(125);
      }
      if (node.alternate) {
        if (this.endsWith(125)) this.space();
        this.word("else");
        this.space();
        this.printAndIndentOnComments(node.alternate);
      }
    }
    function getLastStatement(statement) {
      const {
        body
      } = statement;
      if (isStatement2(body) === false) {
        return statement;
      }
      return getLastStatement(body);
    }
    function ForStatement(node) {
      this.word("for");
      this.space();
      this.tokenChar(40);
      {
        const exit = this.enterForStatementInit();
        this.tokenContext |= _index.TokenContext.forHead;
        this.print(node.init);
        exit();
      }
      this.tokenChar(59);
      if (node.test) {
        this.space();
        this.print(node.test);
      }
      this.token(";", false, 1);
      if (node.update) {
        this.space();
        this.print(node.update);
      }
      this.tokenChar(41);
      this.printBlock(node);
    }
    function WhileStatement(node) {
      this.word("while");
      this.space();
      this.tokenChar(40);
      this.print(node.test);
      this.tokenChar(41);
      this.printBlock(node);
    }
    function ForXStatement(node) {
      this.word("for");
      this.space();
      const isForOf = node.type === "ForOfStatement";
      if (isForOf && node.await) {
        this.word("await");
        this.space();
      }
      this.noIndentInnerCommentsHere();
      this.tokenChar(40);
      {
        const exit = isForOf ? null : this.enterForStatementInit();
        this.tokenContext |= isForOf ? _index.TokenContext.forOfHead : _index.TokenContext.forInHead;
        this.print(node.left);
        exit == null || exit();
      }
      this.space();
      this.word(isForOf ? "of" : "in");
      this.space();
      this.print(node.right);
      this.tokenChar(41);
      this.printBlock(node);
    }
    var ForInStatement = exports2.ForInStatement = ForXStatement;
    var ForOfStatement = exports2.ForOfStatement = ForXStatement;
    function DoWhileStatement(node) {
      this.word("do");
      this.space();
      this.print(node.body);
      this.space();
      this.word("while");
      this.space();
      this.tokenChar(40);
      this.print(node.test);
      this.tokenChar(41);
      this.semicolon();
    }
    function printStatementAfterKeyword(printer, node) {
      if (node) {
        printer.space();
        printer.printTerminatorless(node);
      }
      printer.semicolon();
    }
    function BreakStatement(node) {
      this.word("break");
      printStatementAfterKeyword(this, node.label);
    }
    function ContinueStatement(node) {
      this.word("continue");
      printStatementAfterKeyword(this, node.label);
    }
    function ReturnStatement(node) {
      this.word("return");
      printStatementAfterKeyword(this, node.argument);
    }
    function ThrowStatement(node) {
      this.word("throw");
      printStatementAfterKeyword(this, node.argument);
    }
    function LabeledStatement(node) {
      this.print(node.label);
      this.tokenChar(58);
      this.space();
      this.print(node.body);
    }
    function TryStatement(node) {
      this.word("try");
      this.space();
      this.print(node.block);
      this.space();
      if (node.handlers) {
        this.print(node.handlers[0]);
      } else {
        this.print(node.handler);
      }
      if (node.finalizer) {
        this.space();
        this.word("finally");
        this.space();
        this.print(node.finalizer);
      }
    }
    function CatchClause(node) {
      this.word("catch");
      this.space();
      if (node.param) {
        this.tokenChar(40);
        this.print(node.param);
        this.print(node.param.typeAnnotation);
        this.tokenChar(41);
        this.space();
      }
      this.print(node.body);
    }
    function SwitchStatement(node) {
      this.word("switch");
      this.space();
      this.tokenChar(40);
      this.print(node.discriminant);
      this.tokenChar(41);
      this.space();
      this.tokenChar(123);
      this.printSequence(node.cases, true, void 0, function addNewlines(leading, cas) {
        if (!leading && node.cases[node.cases.length - 1] === cas) return -1;
      });
      this.rightBrace(node);
    }
    function SwitchCase(node) {
      if (node.test) {
        this.word("case");
        this.space();
        this.print(node.test);
        this.tokenChar(58);
      } else {
        this.word("default");
        this.tokenChar(58);
      }
      if (node.consequent.length) {
        this.newline();
        this.printSequence(node.consequent, true);
      }
    }
    function DebuggerStatement() {
      this.word("debugger");
      this.semicolon();
    }
    function VariableDeclaration(node, parent) {
      if (node.declare) {
        this.word("declare");
        this.space();
      }
      const {
        kind
      } = node;
      if (kind === "await using") {
        this.word("await");
        this.space();
        this.word("using", true);
      } else {
        this.word(kind, kind === "using");
      }
      this.space();
      let hasInits = false;
      if (!isFor(parent)) {
        for (const declar of node.declarations) {
          if (declar.init) {
            hasInits = true;
          }
        }
      }
      this.printList(node.declarations, void 0, void 0, node.declarations.length > 1, hasInits ? function(occurrenceCount) {
        this.token(",", false, occurrenceCount);
        this.newline();
      } : void 0);
      if (isFor(parent)) {
        if (isForStatement(parent)) {
          if (parent.init === node) return;
        } else {
          if (parent.left === node) return;
        }
      }
      this.semicolon();
    }
    function VariableDeclarator(node) {
      this.print(node.id);
      if (node.definite) this.tokenChar(33);
      this.print(node.id.typeAnnotation);
      if (node.init) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node.init);
      }
    }
  }
});

// node_modules/@babel/core/node_modules/@babel/generator/lib/generators/classes.js
var require_classes2 = __commonJS({
  "node_modules/@babel/core/node_modules/@babel/generator/lib/generators/classes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ClassAccessorProperty = ClassAccessorProperty;
    exports2.ClassBody = ClassBody;
    exports2.ClassExpression = exports2.ClassDeclaration = ClassDeclaration;
    exports2.ClassMethod = ClassMethod;
    exports2.ClassPrivateMethod = ClassPrivateMethod;
    exports2.ClassPrivateProperty = ClassPrivateProperty;
    exports2.ClassProperty = ClassProperty;
    exports2.StaticBlock = StaticBlock;
    exports2._classMethodHead = _classMethodHead;
    var _t = require("@babel/types");
    var {
      isExportDefaultDeclaration,
      isExportNamedDeclaration
    } = _t;
    function ClassDeclaration(node, parent) {
      const inExport = isExportDefaultDeclaration(parent) || isExportNamedDeclaration(parent);
      if (!inExport || !this._shouldPrintDecoratorsBeforeExport(parent)) {
        this.printJoin(node.decorators);
      }
      if (node.declare) {
        this.word("declare");
        this.space();
      }
      if (node.abstract) {
        this.word("abstract");
        this.space();
      }
      this.word("class");
      if (node.id) {
        this.space();
        this.print(node.id);
      }
      this.print(node.typeParameters);
      if (node.superClass) {
        this.space();
        this.word("extends");
        this.space();
        this.print(node.superClass);
        this.print(node.superTypeParameters);
      }
      if (node.implements) {
        this.space();
        this.word("implements");
        this.space();
        this.printList(node.implements);
      }
      this.space();
      this.print(node.body);
    }
    function ClassBody(node) {
      this.tokenChar(123);
      if (node.body.length === 0) {
        this.tokenChar(125);
      } else {
        this.newline();
        const separator = classBodyEmptySemicolonsPrinter(this, node);
        separator == null || separator(-1);
        const exit = this.enterDelimited();
        this.printJoin(node.body, true, true, separator, true);
        exit();
        if (!this.endsWith(10)) this.newline();
        this.rightBrace(node);
      }
    }
    function classBodyEmptySemicolonsPrinter(printer, node) {
      if (!printer.tokenMap || node.start == null || node.end == null) {
        return null;
      }
      const indexes = printer.tokenMap.getIndexes(node);
      if (!indexes) return null;
      let k = 1;
      let occurrenceCount = 0;
      let nextLocIndex = 0;
      const advanceNextLocIndex = () => {
        while (nextLocIndex < node.body.length && node.body[nextLocIndex].start == null) {
          nextLocIndex++;
        }
      };
      advanceNextLocIndex();
      return (i) => {
        if (nextLocIndex <= i) {
          nextLocIndex = i + 1;
          advanceNextLocIndex();
        }
        const end = nextLocIndex === node.body.length ? node.end : node.body[nextLocIndex].start;
        let tok;
        while (k < indexes.length && printer.tokenMap.matchesOriginal(tok = printer._tokens[indexes[k]], ";") && tok.start < end) {
          printer.token(";", void 0, occurrenceCount++);
          k++;
        }
      };
    }
    function ClassProperty(node) {
      this.printJoin(node.decorators);
      if (!node.static && !this.format.preserveFormat) {
        var _node$key$loc;
        const endLine = (_node$key$loc = node.key.loc) == null || (_node$key$loc = _node$key$loc.end) == null ? void 0 : _node$key$loc.line;
        if (endLine) this.catchUp(endLine);
      }
      this.tsPrintClassMemberModifiers(node);
      if (node.computed) {
        this.tokenChar(91);
        this.print(node.key);
        this.tokenChar(93);
      } else {
        this._variance(node);
        this.print(node.key);
      }
      if (node.optional) {
        this.tokenChar(63);
      }
      if (node.definite) {
        this.tokenChar(33);
      }
      this.print(node.typeAnnotation);
      if (node.value) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node.value);
      }
      this.semicolon();
    }
    function ClassAccessorProperty(node) {
      var _node$key$loc2;
      this.printJoin(node.decorators);
      const endLine = (_node$key$loc2 = node.key.loc) == null || (_node$key$loc2 = _node$key$loc2.end) == null ? void 0 : _node$key$loc2.line;
      if (endLine) this.catchUp(endLine);
      this.tsPrintClassMemberModifiers(node);
      this.word("accessor", true);
      this.space();
      if (node.computed) {
        this.tokenChar(91);
        this.print(node.key);
        this.tokenChar(93);
      } else {
        this._variance(node);
        this.print(node.key);
      }
      if (node.optional) {
        this.tokenChar(63);
      }
      if (node.definite) {
        this.tokenChar(33);
      }
      this.print(node.typeAnnotation);
      if (node.value) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node.value);
      }
      this.semicolon();
    }
    function ClassPrivateProperty(node) {
      this.printJoin(node.decorators);
      this.tsPrintClassMemberModifiers(node);
      this.print(node.key);
      if (node.optional) {
        this.tokenChar(63);
      }
      if (node.definite) {
        this.tokenChar(33);
      }
      this.print(node.typeAnnotation);
      if (node.value) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node.value);
      }
      this.semicolon();
    }
    function ClassMethod(node) {
      this._classMethodHead(node);
      this.space();
      this.print(node.body);
    }
    function ClassPrivateMethod(node) {
      this._classMethodHead(node);
      this.space();
      this.print(node.body);
    }
    function _classMethodHead(node) {
      this.printJoin(node.decorators);
      if (!this.format.preserveFormat) {
        var _node$key$loc3;
        const endLine = (_node$key$loc3 = node.key.loc) == null || (_node$key$loc3 = _node$key$loc3.end) == null ? void 0 : _node$key$loc3.line;
        if (endLine) this.catchUp(endLine);
      }
      this.tsPrintClassMemberModifiers(node);
      this._methodHead(node);
    }
    function StaticBlock(node) {
      this.word("static");
      this.space();
      this.tokenChar(123);
      if (node.body.length === 0) {
        this.tokenChar(125);
      } else {
        this.newline();
        this.printSequence(node.body, true);
        this.rightBrace(node);
      }
    }
  }
});

// node_modules/@babel/core/node_modules/@babel/generator/lib/generators/methods.js
var require_methods2 = __commonJS({
  "node_modules/@babel/core/node_modules/@babel/generator/lib/generators/methods.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ArrowFunctionExpression = ArrowFunctionExpression;
    exports2.FunctionDeclaration = exports2.FunctionExpression = FunctionExpression10;
    exports2._functionHead = _functionHead;
    exports2._methodHead = _methodHead;
    exports2._param = _param;
    exports2._parameters = _parameters;
    exports2._params = _params;
    exports2._predicate = _predicate;
    exports2._shouldPrintArrowParamsParens = _shouldPrintArrowParamsParens;
    var _t = require("@babel/types");
    var _index = require_node3();
    var {
      isIdentifier
    } = _t;
    function _params(node, idNode, parentNode) {
      this.print(node.typeParameters);
      const nameInfo = _getFuncIdName.call(this, idNode, parentNode);
      if (nameInfo) {
        this.sourceIdentifierName(nameInfo.name, nameInfo.pos);
      }
      this.tokenChar(40);
      this._parameters(node.params, ")");
      const noLineTerminator = node.type === "ArrowFunctionExpression";
      this.print(node.returnType, noLineTerminator);
      this._noLineTerminator = noLineTerminator;
    }
    function _parameters(parameters, endToken) {
      const exit = this.enterDelimited();
      const trailingComma = this.shouldPrintTrailingComma(endToken);
      const paramLength = parameters.length;
      for (let i = 0; i < paramLength; i++) {
        this._param(parameters[i]);
        if (trailingComma || i < paramLength - 1) {
          this.token(",", null, i);
          this.space();
        }
      }
      this.token(endToken);
      exit();
    }
    function _param(parameter) {
      this.printJoin(parameter.decorators);
      this.print(parameter);
      if (parameter.optional) {
        this.tokenChar(63);
      }
      this.print(parameter.typeAnnotation);
    }
    function _methodHead(node) {
      const kind = node.kind;
      const key2 = node.key;
      if (kind === "get" || kind === "set") {
        this.word(kind);
        this.space();
      }
      if (node.async) {
        this.word("async", true);
        this.space();
      }
      if (kind === "method" || kind === "init") {
        if (node.generator) {
          this.tokenChar(42);
        }
      }
      if (node.computed) {
        this.tokenChar(91);
        this.print(key2);
        this.tokenChar(93);
      } else {
        this.print(key2);
      }
      if (node.optional) {
        this.tokenChar(63);
      }
      this._params(node, node.computed && node.key.type !== "StringLiteral" ? void 0 : node.key, void 0);
    }
    function _predicate(node, noLineTerminatorAfter) {
      if (node.predicate) {
        if (!node.returnType) {
          this.tokenChar(58);
        }
        this.space();
        this.print(node.predicate, noLineTerminatorAfter);
      }
    }
    function _functionHead(node, parent) {
      if (node.async) {
        this.word("async");
        if (!this.format.preserveFormat) {
          this._endsWithInnerRaw = false;
        }
        this.space();
      }
      this.word("function");
      if (node.generator) {
        if (!this.format.preserveFormat) {
          this._endsWithInnerRaw = false;
        }
        this.tokenChar(42);
      }
      this.space();
      if (node.id) {
        this.print(node.id);
      }
      this._params(node, node.id, parent);
      if (node.type !== "TSDeclareFunction") {
        this._predicate(node);
      }
    }
    function FunctionExpression10(node, parent) {
      this._functionHead(node, parent);
      this.space();
      this.print(node.body);
    }
    function ArrowFunctionExpression(node, parent) {
      if (node.async) {
        this.word("async", true);
        this.space();
      }
      if (this._shouldPrintArrowParamsParens(node)) {
        this._params(node, void 0, parent);
      } else {
        this.print(node.params[0], true);
      }
      this._predicate(node, true);
      this.space();
      this.printInnerComments();
      this.token("=>");
      this.space();
      this.tokenContext |= _index.TokenContext.arrowBody;
      this.print(node.body);
    }
    function _shouldPrintArrowParamsParens(node) {
      var _firstParam$leadingCo, _firstParam$trailingC;
      if (node.params.length !== 1) return true;
      if (node.typeParameters || node.returnType || node.predicate) {
        return true;
      }
      const firstParam = node.params[0];
      if (!isIdentifier(firstParam) || firstParam.typeAnnotation || firstParam.optional || (_firstParam$leadingCo = firstParam.leadingComments) != null && _firstParam$leadingCo.length || (_firstParam$trailingC = firstParam.trailingComments) != null && _firstParam$trailingC.length) {
        return true;
      }
      if (this.tokenMap) {
        if (node.loc == null) return true;
        if (this.tokenMap.findMatching(node, "(") !== null) return true;
        const arrowToken = this.tokenMap.findMatching(node, "=>");
        if ((arrowToken == null ? void 0 : arrowToken.loc) == null) return true;
        return arrowToken.loc.start.line !== node.loc.start.line;
      }
      if (this.format.retainLines) return true;
      return false;
    }
    function _getFuncIdName(idNode, parent) {
      let id = idNode;
      if (!id && parent) {
        const parentType = parent.type;
        if (parentType === "VariableDeclarator") {
          id = parent.id;
        } else if (parentType === "AssignmentExpression" || parentType === "AssignmentPattern") {
          id = parent.left;
        } else if (parentType === "ObjectProperty" || parentType === "ClassProperty") {
          if (!parent.computed || parent.key.type === "StringLiteral") {
            id = parent.key;
          }
        } else if (parentType === "ClassPrivateProperty" || parentType === "ClassAccessorProperty") {
          id = parent.key;
        }
      }
      if (!id) return;
      let nameInfo;
      if (id.type === "Identifier") {
        var _id$loc, _id$loc2;
        nameInfo = {
          pos: (_id$loc = id.loc) == null ? void 0 : _id$loc.start,
          name: ((_id$loc2 = id.loc) == null ? void 0 : _id$loc2.identifierName) || id.name
        };
      } else if (id.type === "PrivateName") {
        var _id$loc3;
        nameInfo = {
          pos: (_id$loc3 = id.loc) == null ? void 0 : _id$loc3.start,
          name: "#" + id.id.name
        };
      } else if (id.type === "StringLiteral") {
        var _id$loc4;
        nameInfo = {
          pos: (_id$loc4 = id.loc) == null ? void 0 : _id$loc4.start,
          name: id.value
        };
      }
      return nameInfo;
    }
  }
});

// node_modules/@babel/core/node_modules/@babel/generator/lib/generators/modules.js
var require_modules2 = __commonJS({
  "node_modules/@babel/core/node_modules/@babel/generator/lib/generators/modules.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ExportAllDeclaration = ExportAllDeclaration;
    exports2.ExportDefaultDeclaration = ExportDefaultDeclaration;
    exports2.ExportDefaultSpecifier = ExportDefaultSpecifier;
    exports2.ExportNamedDeclaration = ExportNamedDeclaration;
    exports2.ExportNamespaceSpecifier = ExportNamespaceSpecifier;
    exports2.ExportSpecifier = ExportSpecifier;
    exports2.ImportAttribute = ImportAttribute;
    exports2.ImportDeclaration = ImportDeclaration;
    exports2.ImportDefaultSpecifier = ImportDefaultSpecifier;
    exports2.ImportExpression = ImportExpression;
    exports2.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
    exports2.ImportSpecifier = ImportSpecifier;
    exports2._printAttributes = _printAttributes;
    var _t = require("@babel/types");
    var _index = require_node3();
    var {
      isClassDeclaration,
      isExportDefaultSpecifier,
      isExportNamespaceSpecifier,
      isImportDefaultSpecifier,
      isImportNamespaceSpecifier,
      isStatement: isStatement2
    } = _t;
    function ImportSpecifier(node) {
      if (node.importKind === "type" || node.importKind === "typeof") {
        this.word(node.importKind);
        this.space();
      }
      this.print(node.imported);
      if (node.local && node.local.name !== node.imported.name) {
        this.space();
        this.word("as");
        this.space();
        this.print(node.local);
      }
    }
    function ImportDefaultSpecifier(node) {
      this.print(node.local);
    }
    function ExportDefaultSpecifier(node) {
      this.print(node.exported);
    }
    function ExportSpecifier(node) {
      if (node.exportKind === "type") {
        this.word("type");
        this.space();
      }
      this.print(node.local);
      if (node.exported && node.local.name !== node.exported.name) {
        this.space();
        this.word("as");
        this.space();
        this.print(node.exported);
      }
    }
    function ExportNamespaceSpecifier(node) {
      this.tokenChar(42);
      this.space();
      this.word("as");
      this.space();
      this.print(node.exported);
    }
    var warningShown = false;
    function _printAttributes(node, hasPreviousBrace) {
      var _node$extra;
      const {
        importAttributesKeyword
      } = this.format;
      const {
        attributes,
        assertions
      } = node;
      if (attributes && !importAttributesKeyword && node.extra && (node.extra.deprecatedAssertSyntax || node.extra.deprecatedWithLegacySyntax) && !warningShown) {
        warningShown = true;
        console.warn(`You are using import attributes, without specifying the desired output syntax.
Please specify the "importAttributesKeyword" generator option, whose value can be one of:
 - "with"        : \`import { a } from "b" with { type: "json" };\`
 - "assert"      : \`import { a } from "b" assert { type: "json" };\`
 - "with-legacy" : \`import { a } from "b" with type: "json";\`
`);
      }
      const useAssertKeyword = importAttributesKeyword === "assert" || !importAttributesKeyword && assertions;
      this.word(useAssertKeyword ? "assert" : "with");
      this.space();
      if (!useAssertKeyword && (importAttributesKeyword === "with-legacy" || !importAttributesKeyword && (_node$extra = node.extra) != null && _node$extra.deprecatedWithLegacySyntax)) {
        this.printList(attributes || assertions);
        return;
      }
      const occurrenceCount = hasPreviousBrace ? 1 : 0;
      this.token("{", null, occurrenceCount);
      this.space();
      this.printList(attributes || assertions, this.shouldPrintTrailingComma("}"));
      this.space();
      this.token("}", null, occurrenceCount);
    }
    function ExportAllDeclaration(node) {
      var _node$attributes, _node$assertions;
      this.word("export");
      this.space();
      if (node.exportKind === "type") {
        this.word("type");
        this.space();
      }
      this.tokenChar(42);
      this.space();
      this.word("from");
      this.space();
      if ((_node$attributes = node.attributes) != null && _node$attributes.length || (_node$assertions = node.assertions) != null && _node$assertions.length) {
        this.print(node.source, true);
        this.space();
        this._printAttributes(node, false);
      } else {
        this.print(node.source);
      }
      this.semicolon();
    }
    function maybePrintDecoratorsBeforeExport(printer, node) {
      if (isClassDeclaration(node.declaration) && printer._shouldPrintDecoratorsBeforeExport(node)) {
        printer.printJoin(node.declaration.decorators);
      }
    }
    function ExportNamedDeclaration(node) {
      maybePrintDecoratorsBeforeExport(this, node);
      this.word("export");
      this.space();
      if (node.declaration) {
        const declar = node.declaration;
        this.print(declar);
        if (!isStatement2(declar)) this.semicolon();
      } else {
        if (node.exportKind === "type") {
          this.word("type");
          this.space();
        }
        const specifiers = node.specifiers.slice(0);
        let hasSpecial = false;
        for (; ; ) {
          const first = specifiers[0];
          if (isExportDefaultSpecifier(first) || isExportNamespaceSpecifier(first)) {
            hasSpecial = true;
            this.print(specifiers.shift());
            if (specifiers.length) {
              this.tokenChar(44);
              this.space();
            }
          } else {
            break;
          }
        }
        let hasBrace = false;
        if (specifiers.length || !specifiers.length && !hasSpecial) {
          hasBrace = true;
          this.tokenChar(123);
          if (specifiers.length) {
            this.space();
            this.printList(specifiers, this.shouldPrintTrailingComma("}"));
            this.space();
          }
          this.tokenChar(125);
        }
        if (node.source) {
          var _node$attributes2, _node$assertions2;
          this.space();
          this.word("from");
          this.space();
          if ((_node$attributes2 = node.attributes) != null && _node$attributes2.length || (_node$assertions2 = node.assertions) != null && _node$assertions2.length) {
            this.print(node.source, true);
            this.space();
            this._printAttributes(node, hasBrace);
          } else {
            this.print(node.source);
          }
        }
        this.semicolon();
      }
    }
    function ExportDefaultDeclaration(node) {
      maybePrintDecoratorsBeforeExport(this, node);
      this.word("export");
      this.noIndentInnerCommentsHere();
      this.space();
      this.word("default");
      this.space();
      this.tokenContext |= _index.TokenContext.exportDefault;
      const declar = node.declaration;
      this.print(declar);
      if (!isStatement2(declar)) this.semicolon();
    }
    function ImportDeclaration(node) {
      var _node$attributes3, _node$assertions3;
      this.word("import");
      this.space();
      const isTypeKind = node.importKind === "type" || node.importKind === "typeof";
      if (isTypeKind) {
        this.noIndentInnerCommentsHere();
        this.word(node.importKind);
        this.space();
      } else if (node.module) {
        this.noIndentInnerCommentsHere();
        this.word("module");
        this.space();
      } else if (node.phase) {
        this.noIndentInnerCommentsHere();
        this.word(node.phase);
        this.space();
      }
      const specifiers = node.specifiers.slice(0);
      const hasSpecifiers = !!specifiers.length;
      while (hasSpecifiers) {
        const first = specifiers[0];
        if (isImportDefaultSpecifier(first) || isImportNamespaceSpecifier(first)) {
          this.print(specifiers.shift());
          if (specifiers.length) {
            this.tokenChar(44);
            this.space();
          }
        } else {
          break;
        }
      }
      let hasBrace = false;
      if (specifiers.length) {
        hasBrace = true;
        this.tokenChar(123);
        this.space();
        this.printList(specifiers, this.shouldPrintTrailingComma("}"));
        this.space();
        this.tokenChar(125);
      } else if (isTypeKind && !hasSpecifiers) {
        hasBrace = true;
        this.tokenChar(123);
        this.tokenChar(125);
      }
      if (hasSpecifiers || isTypeKind) {
        this.space();
        this.word("from");
        this.space();
      }
      if ((_node$attributes3 = node.attributes) != null && _node$attributes3.length || (_node$assertions3 = node.assertions) != null && _node$assertions3.length) {
        this.print(node.source, true);
        this.space();
        this._printAttributes(node, hasBrace);
      } else {
        this.print(node.source);
      }
      this.semicolon();
    }
    function ImportAttribute(node) {
      this.print(node.key);
      this.tokenChar(58);
      this.space();
      this.print(node.value);
    }
    function ImportNamespaceSpecifier(node) {
      this.tokenChar(42);
      this.space();
      this.word("as");
      this.space();
      this.print(node.local);
    }
    function ImportExpression(node) {
      this.word("import");
      if (node.phase) {
        this.tokenChar(46);
        this.word(node.phase);
      }
      this.tokenChar(40);
      this.print(node.source);
      if (node.options != null) {
        this.tokenChar(44);
        this.space();
        this.print(node.options);
      }
      this.tokenChar(41);
    }
  }
});

// node_modules/@babel/core/node_modules/jsesc/jsesc.js
var require_jsesc2 = __commonJS({
  "node_modules/@babel/core/node_modules/jsesc/jsesc.js"(exports2, module2) {
    "use strict";
    var object = {};
    var hasOwnProperty3 = object.hasOwnProperty;
    var forOwn = (object2, callback) => {
      for (const key2 in object2) {
        if (hasOwnProperty3.call(object2, key2)) {
          callback(key2, object2[key2]);
        }
      }
    };
    var extend = (destination, source2) => {
      if (!source2) {
        return destination;
      }
      forOwn(source2, (key2, value) => {
        destination[key2] = value;
      });
      return destination;
    };
    var forEach = (array, callback) => {
      const length = array.length;
      let index = -1;
      while (++index < length) {
        callback(array[index]);
      }
    };
    var fourHexEscape = (hex) => {
      return "\\u" + ("0000" + hex).slice(-4);
    };
    var hexadecimal = (code, lowercase) => {
      let hexadecimal2 = code.toString(16);
      if (lowercase) return hexadecimal2;
      return hexadecimal2.toUpperCase();
    };
    var toString = object.toString;
    var isArray = Array.isArray;
    var isBuffer = (value) => {
      return typeof Buffer === "function" && Buffer.isBuffer(value);
    };
    var isObject = (value) => {
      return toString.call(value) == "[object Object]";
    };
    var isString = (value) => {
      return typeof value == "string" || toString.call(value) == "[object String]";
    };
    var isNumber = (value) => {
      return typeof value == "number" || toString.call(value) == "[object Number]";
    };
    var isBigInt = (value) => {
      return typeof value == "bigint";
    };
    var isFunction = (value) => {
      return typeof value == "function";
    };
    var isMap = (value) => {
      return toString.call(value) == "[object Map]";
    };
    var isSet = (value) => {
      return toString.call(value) == "[object Set]";
    };
    var singleEscapes = {
      "\\": "\\\\",
      "\b": "\\b",
      "\f": "\\f",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t"
      // `\v` is omitted intentionally, because in IE < 9, '\v' == 'v'.
      // '\v': '\\x0B'
    };
    var regexSingleEscape = /[\\\b\f\n\r\t]/;
    var regexDigit = /[0-9]/;
    var regexWhitespace = /[\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
    var escapeEverythingRegex = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^]/g;
    var escapeNonAsciiRegex = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^ !#-&\(-\[\]-_a-~]/g;
    var jsesc = (argument, options) => {
      const increaseIndentation = () => {
        oldIndent = indent;
        ++options.indentLevel;
        indent = options.indent.repeat(options.indentLevel);
      };
      const defaults = {
        "escapeEverything": false,
        "minimal": false,
        "isScriptContext": false,
        "quotes": "single",
        "wrap": false,
        "es6": false,
        "json": false,
        "compact": true,
        "lowercaseHex": false,
        "numbers": "decimal",
        "indent": "	",
        "indentLevel": 0,
        "__inline1__": false,
        "__inline2__": false
      };
      const json = options && options.json;
      if (json) {
        defaults.quotes = "double";
        defaults.wrap = true;
      }
      options = extend(defaults, options);
      if (options.quotes != "single" && options.quotes != "double" && options.quotes != "backtick") {
        options.quotes = "single";
      }
      const quote = options.quotes == "double" ? '"' : options.quotes == "backtick" ? "`" : "'";
      const compact = options.compact;
      const lowercaseHex = options.lowercaseHex;
      let indent = options.indent.repeat(options.indentLevel);
      let oldIndent = "";
      const inline1 = options.__inline1__;
      const inline2 = options.__inline2__;
      const newLine = compact ? "" : "\n";
      let result;
      let isEmpty = true;
      const useBinNumbers = options.numbers == "binary";
      const useOctNumbers = options.numbers == "octal";
      const useDecNumbers = options.numbers == "decimal";
      const useHexNumbers = options.numbers == "hexadecimal";
      if (json && argument && isFunction(argument.toJSON)) {
        argument = argument.toJSON();
      }
      if (!isString(argument)) {
        if (isMap(argument)) {
          if (argument.size == 0) {
            return "new Map()";
          }
          if (!compact) {
            options.__inline1__ = true;
            options.__inline2__ = false;
          }
          return "new Map(" + jsesc(Array.from(argument), options) + ")";
        }
        if (isSet(argument)) {
          if (argument.size == 0) {
            return "new Set()";
          }
          return "new Set(" + jsesc(Array.from(argument), options) + ")";
        }
        if (isBuffer(argument)) {
          if (argument.length == 0) {
            return "Buffer.from([])";
          }
          return "Buffer.from(" + jsesc(Array.from(argument), options) + ")";
        }
        if (isArray(argument)) {
          result = [];
          options.wrap = true;
          if (inline1) {
            options.__inline1__ = false;
            options.__inline2__ = true;
          }
          if (!inline2) {
            increaseIndentation();
          }
          forEach(argument, (value) => {
            isEmpty = false;
            if (inline2) {
              options.__inline2__ = false;
            }
            result.push(
              (compact || inline2 ? "" : indent) + jsesc(value, options)
            );
          });
          if (isEmpty) {
            return "[]";
          }
          if (inline2) {
            return "[" + result.join(", ") + "]";
          }
          return "[" + newLine + result.join("," + newLine) + newLine + (compact ? "" : oldIndent) + "]";
        } else if (isNumber(argument) || isBigInt(argument)) {
          if (json) {
            return JSON.stringify(Number(argument));
          }
          let result2;
          if (useDecNumbers) {
            result2 = String(argument);
          } else if (useHexNumbers) {
            let hexadecimal2 = argument.toString(16);
            if (!lowercaseHex) {
              hexadecimal2 = hexadecimal2.toUpperCase();
            }
            result2 = "0x" + hexadecimal2;
          } else if (useBinNumbers) {
            result2 = "0b" + argument.toString(2);
          } else if (useOctNumbers) {
            result2 = "0o" + argument.toString(8);
          }
          if (isBigInt(argument)) {
            return result2 + "n";
          }
          return result2;
        } else if (isBigInt(argument)) {
          if (json) {
            return JSON.stringify(Number(argument));
          }
          return argument + "n";
        } else if (!isObject(argument)) {
          if (json) {
            return JSON.stringify(argument) || "null";
          }
          return String(argument);
        } else {
          result = [];
          options.wrap = true;
          increaseIndentation();
          forOwn(argument, (key2, value) => {
            isEmpty = false;
            result.push(
              (compact ? "" : indent) + jsesc(key2, options) + ":" + (compact ? "" : " ") + jsesc(value, options)
            );
          });
          if (isEmpty) {
            return "{}";
          }
          return "{" + newLine + result.join("," + newLine) + newLine + (compact ? "" : oldIndent) + "}";
        }
      }
      const regex = options.escapeEverything ? escapeEverythingRegex : escapeNonAsciiRegex;
      result = argument.replace(regex, (char, pair, lone, quoteChar, index, string) => {
        if (pair) {
          if (options.minimal) return pair;
          const first = pair.charCodeAt(0);
          const second = pair.charCodeAt(1);
          if (options.es6) {
            const codePoint = (first - 55296) * 1024 + second - 56320 + 65536;
            const hex2 = hexadecimal(codePoint, lowercaseHex);
            return "\\u{" + hex2 + "}";
          }
          return fourHexEscape(hexadecimal(first, lowercaseHex)) + fourHexEscape(hexadecimal(second, lowercaseHex));
        }
        if (lone) {
          return fourHexEscape(hexadecimal(lone.charCodeAt(0), lowercaseHex));
        }
        if (char == "\0" && !json && !regexDigit.test(string.charAt(index + 1))) {
          return "\\0";
        }
        if (quoteChar) {
          if (quoteChar == quote || options.escapeEverything) {
            return "\\" + quoteChar;
          }
          return quoteChar;
        }
        if (regexSingleEscape.test(char)) {
          return singleEscapes[char];
        }
        if (options.minimal && !regexWhitespace.test(char)) {
          return char;
        }
        const hex = hexadecimal(char.charCodeAt(0), lowercaseHex);
        if (json || hex.length > 2) {
          return fourHexEscape(hex);
        }
        return "\\x" + ("00" + hex).slice(-2);
      });
      if (quote == "`") {
        result = result.replace(/\$\{/g, "\\${");
      }
      if (options.isScriptContext) {
        result = result.replace(/<\/(script|style)/gi, "<\\/$1").replace(/<!--/g, json ? "\\u003C!--" : "\\x3C!--");
      }
      if (options.wrap) {
        result = quote + result + quote;
      }
      return result;
    };
    jsesc.version = "3.0.2";
    module2.exports = jsesc;
  }
});

// node_modules/@babel/core/node_modules/@babel/generator/lib/generators/types.js
var require_types2 = __commonJS({
  "node_modules/@babel/core/node_modules/@babel/generator/lib/generators/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ArgumentPlaceholder = ArgumentPlaceholder;
    exports2.ArrayPattern = exports2.ArrayExpression = ArrayExpression6;
    exports2.BigIntLiteral = BigIntLiteral;
    exports2.BooleanLiteral = BooleanLiteral;
    exports2.Identifier = Identifier25;
    exports2.NullLiteral = NullLiteral;
    exports2.NumericLiteral = NumericLiteral;
    exports2.ObjectPattern = exports2.ObjectExpression = ObjectExpression;
    exports2.ObjectMethod = ObjectMethod4;
    exports2.ObjectProperty = ObjectProperty4;
    exports2.PipelineBareFunction = PipelineBareFunction;
    exports2.PipelinePrimaryTopicReference = PipelinePrimaryTopicReference;
    exports2.PipelineTopicExpression = PipelineTopicExpression;
    exports2.RecordExpression = RecordExpression;
    exports2.RegExpLiteral = RegExpLiteral;
    exports2.SpreadElement = exports2.RestElement = RestElement;
    exports2.StringLiteral = StringLiteral;
    exports2.TopicReference = TopicReference;
    exports2.TupleExpression = TupleExpression;
    exports2._getRawIdentifier = _getRawIdentifier;
    var _t = require("@babel/types");
    var _jsesc = require_jsesc2();
    var {
      isAssignmentPattern,
      isIdentifier
    } = _t;
    var lastRawIdentNode = null;
    var lastRawIdentResult = "";
    function _getRawIdentifier(node) {
      if (node === lastRawIdentNode) return lastRawIdentResult;
      lastRawIdentNode = node;
      const {
        name
      } = node;
      const token2 = this.tokenMap.find(node, (tok) => tok.value === name);
      if (token2) {
        lastRawIdentResult = this._originalCode.slice(token2.start, token2.end);
        return lastRawIdentResult;
      }
      return lastRawIdentResult = node.name;
    }
    function Identifier25(node) {
      var _node$loc;
      this.sourceIdentifierName(((_node$loc = node.loc) == null ? void 0 : _node$loc.identifierName) || node.name);
      this.word(this.tokenMap ? this._getRawIdentifier(node) : node.name);
    }
    function ArgumentPlaceholder() {
      this.tokenChar(63);
    }
    function RestElement(node) {
      this.token("...");
      this.print(node.argument);
    }
    function ObjectExpression(node) {
      const props = node.properties;
      this.tokenChar(123);
      if (props.length) {
        const exit = this.enterDelimited();
        this.space();
        this.printList(props, this.shouldPrintTrailingComma("}"), true, true);
        this.space();
        exit();
      }
      this.sourceWithOffset("end", node.loc, -1);
      this.tokenChar(125);
    }
    function ObjectMethod4(node) {
      this.printJoin(node.decorators);
      this._methodHead(node);
      this.space();
      this.print(node.body);
    }
    function ObjectProperty4(node) {
      this.printJoin(node.decorators);
      if (node.computed) {
        this.tokenChar(91);
        this.print(node.key);
        this.tokenChar(93);
      } else {
        if (isAssignmentPattern(node.value) && isIdentifier(node.key) && node.key.name === node.value.left.name) {
          this.print(node.value);
          return;
        }
        this.print(node.key);
        if (node.shorthand && isIdentifier(node.key) && isIdentifier(node.value) && node.key.name === node.value.name) {
          return;
        }
      }
      this.tokenChar(58);
      this.space();
      this.print(node.value);
    }
    function ArrayExpression6(node) {
      const elems = node.elements;
      const len = elems.length;
      this.tokenChar(91);
      const exit = this.enterDelimited();
      for (let i = 0; i < elems.length; i++) {
        const elem = elems[i];
        if (elem) {
          if (i > 0) this.space();
          this.print(elem);
          if (i < len - 1 || this.shouldPrintTrailingComma("]")) {
            this.token(",", false, i);
          }
        } else {
          this.token(",", false, i);
        }
      }
      exit();
      this.tokenChar(93);
    }
    function RecordExpression(node) {
      const props = node.properties;
      let startToken;
      let endToken;
      {
        if (this.format.recordAndTupleSyntaxType === "bar") {
          startToken = "{|";
          endToken = "|}";
        } else if (this.format.recordAndTupleSyntaxType !== "hash" && this.format.recordAndTupleSyntaxType != null) {
          throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)} received).`);
        } else {
          startToken = "#{";
          endToken = "}";
        }
      }
      this.token(startToken);
      if (props.length) {
        this.space();
        this.printList(props, this.shouldPrintTrailingComma(endToken), true, true);
        this.space();
      }
      this.token(endToken);
    }
    function TupleExpression(node) {
      const elems = node.elements;
      const len = elems.length;
      let startToken;
      let endToken;
      {
        if (this.format.recordAndTupleSyntaxType === "bar") {
          startToken = "[|";
          endToken = "|]";
        } else if (this.format.recordAndTupleSyntaxType === "hash") {
          startToken = "#[";
          endToken = "]";
        } else {
          throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);
        }
      }
      this.token(startToken);
      for (let i = 0; i < elems.length; i++) {
        const elem = elems[i];
        if (elem) {
          if (i > 0) this.space();
          this.print(elem);
          if (i < len - 1 || this.shouldPrintTrailingComma(endToken)) {
            this.token(",", false, i);
          }
        }
      }
      this.token(endToken);
    }
    function RegExpLiteral(node) {
      this.word(`/${node.pattern}/${node.flags}`);
    }
    function BooleanLiteral(node) {
      this.word(node.value ? "true" : "false");
    }
    function NullLiteral() {
      this.word("null");
    }
    function NumericLiteral(node) {
      const raw = this.getPossibleRaw(node);
      const opts = this.format.jsescOption;
      const value = node.value;
      const str = value + "";
      if (opts.numbers) {
        this.number(_jsesc(value, opts), value);
      } else if (raw == null) {
        this.number(str, value);
      } else if (this.format.minified) {
        this.number(raw.length < str.length ? raw : str, value);
      } else {
        this.number(raw, value);
      }
    }
    function StringLiteral(node) {
      const raw = this.getPossibleRaw(node);
      if (!this.format.minified && raw !== void 0) {
        this.token(raw);
        return;
      }
      const val = _jsesc(node.value, this.format.jsescOption);
      this.token(val);
    }
    function BigIntLiteral(node) {
      const raw = this.getPossibleRaw(node);
      if (!this.format.minified && raw !== void 0) {
        this.word(raw);
        return;
      }
      this.word(node.value + "n");
    }
    var validTopicTokenSet = /* @__PURE__ */ new Set(["^^", "@@", "^", "%", "#"]);
    function TopicReference() {
      const {
        topicToken
      } = this.format;
      if (validTopicTokenSet.has(topicToken)) {
        this.token(topicToken);
      } else {
        const givenTopicTokenJSON = JSON.stringify(topicToken);
        const validTopics = Array.from(validTopicTokenSet, (v) => JSON.stringify(v));
        throw new Error(`The "topicToken" generator option must be one of ${validTopics.join(", ")} (${givenTopicTokenJSON} received instead).`);
      }
    }
    function PipelineTopicExpression(node) {
      this.print(node.expression);
    }
    function PipelineBareFunction(node) {
      this.print(node.callee);
    }
    function PipelinePrimaryTopicReference() {
      this.tokenChar(35);
    }
  }
});

// node_modules/@babel/core/node_modules/@babel/generator/lib/generators/flow.js
var require_flow2 = __commonJS({
  "node_modules/@babel/core/node_modules/@babel/generator/lib/generators/flow.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.AnyTypeAnnotation = AnyTypeAnnotation;
    exports2.ArrayTypeAnnotation = ArrayTypeAnnotation;
    exports2.BooleanLiteralTypeAnnotation = BooleanLiteralTypeAnnotation;
    exports2.BooleanTypeAnnotation = BooleanTypeAnnotation;
    exports2.DeclareClass = DeclareClass;
    exports2.DeclareExportAllDeclaration = DeclareExportAllDeclaration;
    exports2.DeclareExportDeclaration = DeclareExportDeclaration;
    exports2.DeclareFunction = DeclareFunction;
    exports2.DeclareInterface = DeclareInterface;
    exports2.DeclareModule = DeclareModule;
    exports2.DeclareModuleExports = DeclareModuleExports;
    exports2.DeclareOpaqueType = DeclareOpaqueType;
    exports2.DeclareTypeAlias = DeclareTypeAlias;
    exports2.DeclareVariable = DeclareVariable;
    exports2.DeclaredPredicate = DeclaredPredicate;
    exports2.EmptyTypeAnnotation = EmptyTypeAnnotation;
    exports2.EnumBooleanBody = EnumBooleanBody;
    exports2.EnumBooleanMember = EnumBooleanMember;
    exports2.EnumDeclaration = EnumDeclaration;
    exports2.EnumDefaultedMember = EnumDefaultedMember;
    exports2.EnumNumberBody = EnumNumberBody;
    exports2.EnumNumberMember = EnumNumberMember;
    exports2.EnumStringBody = EnumStringBody;
    exports2.EnumStringMember = EnumStringMember;
    exports2.EnumSymbolBody = EnumSymbolBody;
    exports2.ExistsTypeAnnotation = ExistsTypeAnnotation;
    exports2.FunctionTypeAnnotation = FunctionTypeAnnotation;
    exports2.FunctionTypeParam = FunctionTypeParam;
    exports2.IndexedAccessType = IndexedAccessType;
    exports2.InferredPredicate = InferredPredicate;
    exports2.InterfaceDeclaration = InterfaceDeclaration;
    exports2.GenericTypeAnnotation = exports2.ClassImplements = exports2.InterfaceExtends = InterfaceExtends;
    exports2.InterfaceTypeAnnotation = InterfaceTypeAnnotation;
    exports2.IntersectionTypeAnnotation = IntersectionTypeAnnotation;
    exports2.MixedTypeAnnotation = MixedTypeAnnotation;
    exports2.NullLiteralTypeAnnotation = NullLiteralTypeAnnotation;
    exports2.NullableTypeAnnotation = NullableTypeAnnotation;
    Object.defineProperty(exports2, "NumberLiteralTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _types2.NumericLiteral;
      }
    });
    exports2.NumberTypeAnnotation = NumberTypeAnnotation;
    exports2.ObjectTypeAnnotation = ObjectTypeAnnotation;
    exports2.ObjectTypeCallProperty = ObjectTypeCallProperty;
    exports2.ObjectTypeIndexer = ObjectTypeIndexer;
    exports2.ObjectTypeInternalSlot = ObjectTypeInternalSlot;
    exports2.ObjectTypeProperty = ObjectTypeProperty;
    exports2.ObjectTypeSpreadProperty = ObjectTypeSpreadProperty;
    exports2.OpaqueType = OpaqueType;
    exports2.OptionalIndexedAccessType = OptionalIndexedAccessType;
    exports2.QualifiedTypeIdentifier = QualifiedTypeIdentifier;
    Object.defineProperty(exports2, "StringLiteralTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _types2.StringLiteral;
      }
    });
    exports2.StringTypeAnnotation = StringTypeAnnotation;
    exports2.SymbolTypeAnnotation = SymbolTypeAnnotation;
    exports2.ThisTypeAnnotation = ThisTypeAnnotation;
    exports2.TupleTypeAnnotation = TupleTypeAnnotation;
    exports2.TypeAlias = TypeAlias;
    exports2.TypeAnnotation = TypeAnnotation;
    exports2.TypeCastExpression = TypeCastExpression;
    exports2.TypeParameter = TypeParameter;
    exports2.TypeParameterDeclaration = exports2.TypeParameterInstantiation = TypeParameterInstantiation;
    exports2.TypeofTypeAnnotation = TypeofTypeAnnotation;
    exports2.UnionTypeAnnotation = UnionTypeAnnotation;
    exports2.Variance = Variance;
    exports2.VoidTypeAnnotation = VoidTypeAnnotation;
    exports2._interfaceish = _interfaceish;
    exports2._variance = _variance;
    var _t = require("@babel/types");
    var _modules = require_modules2();
    var _index = require_node3();
    var _types2 = require_types2();
    var {
      isDeclareExportDeclaration,
      isStatement: isStatement2
    } = _t;
    function AnyTypeAnnotation() {
      this.word("any");
    }
    function ArrayTypeAnnotation(node) {
      this.print(node.elementType, true);
      this.tokenChar(91);
      this.tokenChar(93);
    }
    function BooleanTypeAnnotation() {
      this.word("boolean");
    }
    function BooleanLiteralTypeAnnotation(node) {
      this.word(node.value ? "true" : "false");
    }
    function NullLiteralTypeAnnotation() {
      this.word("null");
    }
    function DeclareClass(node, parent) {
      if (!isDeclareExportDeclaration(parent)) {
        this.word("declare");
        this.space();
      }
      this.word("class");
      this.space();
      this._interfaceish(node);
    }
    function DeclareFunction(node, parent) {
      if (!isDeclareExportDeclaration(parent)) {
        this.word("declare");
        this.space();
      }
      this.word("function");
      this.space();
      this.print(node.id);
      this.print(node.id.typeAnnotation.typeAnnotation);
      if (node.predicate) {
        this.space();
        this.print(node.predicate);
      }
      this.semicolon();
    }
    function InferredPredicate() {
      this.tokenChar(37);
      this.word("checks");
    }
    function DeclaredPredicate(node) {
      this.tokenChar(37);
      this.word("checks");
      this.tokenChar(40);
      this.print(node.value);
      this.tokenChar(41);
    }
    function DeclareInterface(node) {
      this.word("declare");
      this.space();
      this.InterfaceDeclaration(node);
    }
    function DeclareModule(node) {
      this.word("declare");
      this.space();
      this.word("module");
      this.space();
      this.print(node.id);
      this.space();
      this.print(node.body);
    }
    function DeclareModuleExports(node) {
      this.word("declare");
      this.space();
      this.word("module");
      this.tokenChar(46);
      this.word("exports");
      this.print(node.typeAnnotation);
    }
    function DeclareTypeAlias(node) {
      this.word("declare");
      this.space();
      this.TypeAlias(node);
    }
    function DeclareOpaqueType(node, parent) {
      if (!isDeclareExportDeclaration(parent)) {
        this.word("declare");
        this.space();
      }
      this.OpaqueType(node);
    }
    function DeclareVariable(node, parent) {
      if (!isDeclareExportDeclaration(parent)) {
        this.word("declare");
        this.space();
      }
      this.word("var");
      this.space();
      this.print(node.id);
      this.print(node.id.typeAnnotation);
      this.semicolon();
    }
    function DeclareExportDeclaration(node) {
      this.word("declare");
      this.space();
      this.word("export");
      this.space();
      if (node.default) {
        this.word("default");
        this.space();
      }
      FlowExportDeclaration.call(this, node);
    }
    function DeclareExportAllDeclaration(node) {
      this.word("declare");
      this.space();
      _modules.ExportAllDeclaration.call(this, node);
    }
    function EnumDeclaration(node) {
      const {
        id,
        body
      } = node;
      this.word("enum");
      this.space();
      this.print(id);
      this.print(body);
    }
    function enumExplicitType(context, name, hasExplicitType) {
      if (hasExplicitType) {
        context.space();
        context.word("of");
        context.space();
        context.word(name);
      }
      context.space();
    }
    function enumBody(context, node) {
      const {
        members
      } = node;
      context.token("{");
      context.indent();
      context.newline();
      for (const member of members) {
        context.print(member);
        context.newline();
      }
      if (node.hasUnknownMembers) {
        context.token("...");
        context.newline();
      }
      context.dedent();
      context.token("}");
    }
    function EnumBooleanBody(node) {
      const {
        explicitType
      } = node;
      enumExplicitType(this, "boolean", explicitType);
      enumBody(this, node);
    }
    function EnumNumberBody(node) {
      const {
        explicitType
      } = node;
      enumExplicitType(this, "number", explicitType);
      enumBody(this, node);
    }
    function EnumStringBody(node) {
      const {
        explicitType
      } = node;
      enumExplicitType(this, "string", explicitType);
      enumBody(this, node);
    }
    function EnumSymbolBody(node) {
      enumExplicitType(this, "symbol", true);
      enumBody(this, node);
    }
    function EnumDefaultedMember(node) {
      const {
        id
      } = node;
      this.print(id);
      this.tokenChar(44);
    }
    function enumInitializedMember(context, node) {
      context.print(node.id);
      context.space();
      context.token("=");
      context.space();
      context.print(node.init);
      context.token(",");
    }
    function EnumBooleanMember(node) {
      enumInitializedMember(this, node);
    }
    function EnumNumberMember(node) {
      enumInitializedMember(this, node);
    }
    function EnumStringMember(node) {
      enumInitializedMember(this, node);
    }
    function FlowExportDeclaration(node) {
      if (node.declaration) {
        const declar = node.declaration;
        this.print(declar);
        if (!isStatement2(declar)) this.semicolon();
      } else {
        this.tokenChar(123);
        if (node.specifiers.length) {
          this.space();
          this.printList(node.specifiers);
          this.space();
        }
        this.tokenChar(125);
        if (node.source) {
          this.space();
          this.word("from");
          this.space();
          this.print(node.source);
        }
        this.semicolon();
      }
    }
    function ExistsTypeAnnotation() {
      this.tokenChar(42);
    }
    function FunctionTypeAnnotation(node, parent) {
      this.print(node.typeParameters);
      this.tokenChar(40);
      if (node.this) {
        this.word("this");
        this.tokenChar(58);
        this.space();
        this.print(node.this.typeAnnotation);
        if (node.params.length || node.rest) {
          this.tokenChar(44);
          this.space();
        }
      }
      this.printList(node.params);
      if (node.rest) {
        if (node.params.length) {
          this.tokenChar(44);
          this.space();
        }
        this.token("...");
        this.print(node.rest);
      }
      this.tokenChar(41);
      const type = parent == null ? void 0 : parent.type;
      if (type != null && (type === "ObjectTypeCallProperty" || type === "ObjectTypeInternalSlot" || type === "DeclareFunction" || type === "ObjectTypeProperty" && parent.method)) {
        this.tokenChar(58);
      } else {
        this.space();
        this.token("=>");
      }
      this.space();
      this.print(node.returnType);
    }
    function FunctionTypeParam(node) {
      this.print(node.name);
      if (node.optional) this.tokenChar(63);
      if (node.name) {
        this.tokenChar(58);
        this.space();
      }
      this.print(node.typeAnnotation);
    }
    function InterfaceExtends(node) {
      this.print(node.id);
      this.print(node.typeParameters, true);
    }
    function _interfaceish(node) {
      var _node$extends;
      this.print(node.id);
      this.print(node.typeParameters);
      if ((_node$extends = node.extends) != null && _node$extends.length) {
        this.space();
        this.word("extends");
        this.space();
        this.printList(node.extends);
      }
      if (node.type === "DeclareClass") {
        var _node$mixins, _node$implements;
        if ((_node$mixins = node.mixins) != null && _node$mixins.length) {
          this.space();
          this.word("mixins");
          this.space();
          this.printList(node.mixins);
        }
        if ((_node$implements = node.implements) != null && _node$implements.length) {
          this.space();
          this.word("implements");
          this.space();
          this.printList(node.implements);
        }
      }
      this.space();
      this.print(node.body);
    }
    function _variance(node) {
      var _node$variance;
      const kind = (_node$variance = node.variance) == null ? void 0 : _node$variance.kind;
      if (kind != null) {
        if (kind === "plus") {
          this.tokenChar(43);
        } else if (kind === "minus") {
          this.tokenChar(45);
        }
      }
    }
    function InterfaceDeclaration(node) {
      this.word("interface");
      this.space();
      this._interfaceish(node);
    }
    function andSeparator(occurrenceCount) {
      this.space();
      this.token("&", false, occurrenceCount);
      this.space();
    }
    function InterfaceTypeAnnotation(node) {
      var _node$extends2;
      this.word("interface");
      if ((_node$extends2 = node.extends) != null && _node$extends2.length) {
        this.space();
        this.word("extends");
        this.space();
        this.printList(node.extends);
      }
      this.space();
      this.print(node.body);
    }
    function IntersectionTypeAnnotation(node) {
      this.printJoin(node.types, void 0, void 0, andSeparator);
    }
    function MixedTypeAnnotation() {
      this.word("mixed");
    }
    function EmptyTypeAnnotation() {
      this.word("empty");
    }
    function NullableTypeAnnotation(node) {
      this.tokenChar(63);
      this.print(node.typeAnnotation);
    }
    function NumberTypeAnnotation() {
      this.word("number");
    }
    function StringTypeAnnotation() {
      this.word("string");
    }
    function ThisTypeAnnotation() {
      this.word("this");
    }
    function TupleTypeAnnotation(node) {
      this.tokenChar(91);
      this.printList(node.types);
      this.tokenChar(93);
    }
    function TypeofTypeAnnotation(node) {
      this.word("typeof");
      this.space();
      this.print(node.argument);
    }
    function TypeAlias(node) {
      this.word("type");
      this.space();
      this.print(node.id);
      this.print(node.typeParameters);
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node.right);
      this.semicolon();
    }
    function TypeAnnotation(node, parent) {
      this.tokenChar(58);
      this.space();
      if (parent.type === "ArrowFunctionExpression") {
        this.tokenContext |= _index.TokenContext.arrowFlowReturnType;
      } else if (node.optional) {
        this.tokenChar(63);
      }
      this.print(node.typeAnnotation);
    }
    function TypeParameterInstantiation(node) {
      this.tokenChar(60);
      this.printList(node.params);
      this.tokenChar(62);
    }
    function TypeParameter(node) {
      this._variance(node);
      this.word(node.name);
      if (node.bound) {
        this.print(node.bound);
      }
      if (node.default) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node.default);
      }
    }
    function OpaqueType(node) {
      this.word("opaque");
      this.space();
      this.word("type");
      this.space();
      this.print(node.id);
      this.print(node.typeParameters);
      if (node.supertype) {
        this.tokenChar(58);
        this.space();
        this.print(node.supertype);
      }
      if (node.impltype) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node.impltype);
      }
      this.semicolon();
    }
    function ObjectTypeAnnotation(node) {
      if (node.exact) {
        this.token("{|");
      } else {
        this.tokenChar(123);
      }
      const props = [...node.properties, ...node.callProperties || [], ...node.indexers || [], ...node.internalSlots || []];
      if (props.length) {
        this.newline();
        this.space();
        this.printJoin(props, true, true, void 0, void 0, function addNewlines(leading) {
          if (leading && !props[0]) return 1;
        }, () => {
          if (props.length !== 1 || node.inexact) {
            this.tokenChar(44);
            this.space();
          }
        });
        this.space();
      }
      if (node.inexact) {
        this.indent();
        this.token("...");
        if (props.length) {
          this.newline();
        }
        this.dedent();
      }
      if (node.exact) {
        this.token("|}");
      } else {
        this.tokenChar(125);
      }
    }
    function ObjectTypeInternalSlot(node) {
      if (node.static) {
        this.word("static");
        this.space();
      }
      this.tokenChar(91);
      this.tokenChar(91);
      this.print(node.id);
      this.tokenChar(93);
      this.tokenChar(93);
      if (node.optional) this.tokenChar(63);
      if (!node.method) {
        this.tokenChar(58);
        this.space();
      }
      this.print(node.value);
    }
    function ObjectTypeCallProperty(node) {
      if (node.static) {
        this.word("static");
        this.space();
      }
      this.print(node.value);
    }
    function ObjectTypeIndexer(node) {
      if (node.static) {
        this.word("static");
        this.space();
      }
      this._variance(node);
      this.tokenChar(91);
      if (node.id) {
        this.print(node.id);
        this.tokenChar(58);
        this.space();
      }
      this.print(node.key);
      this.tokenChar(93);
      this.tokenChar(58);
      this.space();
      this.print(node.value);
    }
    function ObjectTypeProperty(node) {
      if (node.proto) {
        this.word("proto");
        this.space();
      }
      if (node.static) {
        this.word("static");
        this.space();
      }
      if (node.kind === "get" || node.kind === "set") {
        this.word(node.kind);
        this.space();
      }
      this._variance(node);
      this.print(node.key);
      if (node.optional) this.tokenChar(63);
      if (!node.method) {
        this.tokenChar(58);
        this.space();
      }
      this.print(node.value);
    }
    function ObjectTypeSpreadProperty(node) {
      this.token("...");
      this.print(node.argument);
    }
    function QualifiedTypeIdentifier(node) {
      this.print(node.qualification);
      this.tokenChar(46);
      this.print(node.id);
    }
    function SymbolTypeAnnotation() {
      this.word("symbol");
    }
    function orSeparator(occurrenceCount) {
      this.space();
      this.token("|", false, occurrenceCount);
      this.space();
    }
    function UnionTypeAnnotation(node) {
      this.printJoin(node.types, void 0, void 0, orSeparator);
    }
    function TypeCastExpression(node) {
      this.tokenChar(40);
      this.print(node.expression);
      this.print(node.typeAnnotation);
      this.tokenChar(41);
    }
    function Variance(node) {
      if (node.kind === "plus") {
        this.tokenChar(43);
      } else {
        this.tokenChar(45);
      }
    }
    function VoidTypeAnnotation() {
      this.word("void");
    }
    function IndexedAccessType(node) {
      this.print(node.objectType, true);
      this.tokenChar(91);
      this.print(node.indexType);
      this.tokenChar(93);
    }
    function OptionalIndexedAccessType(node) {
      this.print(node.objectType);
      if (node.optional) {
        this.token("?.");
      }
      this.tokenChar(91);
      this.print(node.indexType);
      this.tokenChar(93);
    }
  }
});

// node_modules/@babel/core/node_modules/@babel/generator/lib/generators/base.js
var require_base2 = __commonJS({
  "node_modules/@babel/core/node_modules/@babel/generator/lib/generators/base.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.BlockStatement = BlockStatement;
    exports2.Directive = Directive;
    exports2.DirectiveLiteral = DirectiveLiteral;
    exports2.File = File;
    exports2.InterpreterDirective = InterpreterDirective;
    exports2.Placeholder = Placeholder;
    exports2.Program = Program;
    function File(node) {
      if (node.program) {
        this.print(node.program.interpreter);
      }
      this.print(node.program);
    }
    function Program(node) {
      var _node$directives;
      this.noIndentInnerCommentsHere();
      this.printInnerComments();
      const directivesLen = (_node$directives = node.directives) == null ? void 0 : _node$directives.length;
      if (directivesLen) {
        var _node$directives$trai;
        const newline = node.body.length ? 2 : 1;
        this.printSequence(node.directives, void 0, newline);
        if (!((_node$directives$trai = node.directives[directivesLen - 1].trailingComments) != null && _node$directives$trai.length)) {
          this.newline(newline);
        }
      }
      this.printSequence(node.body);
    }
    function BlockStatement(node) {
      var _node$directives2;
      this.tokenChar(123);
      const exit = this.enterDelimited();
      const directivesLen = (_node$directives2 = node.directives) == null ? void 0 : _node$directives2.length;
      if (directivesLen) {
        var _node$directives$trai2;
        const newline = node.body.length ? 2 : 1;
        this.printSequence(node.directives, true, newline);
        if (!((_node$directives$trai2 = node.directives[directivesLen - 1].trailingComments) != null && _node$directives$trai2.length)) {
          this.newline(newline);
        }
      }
      this.printSequence(node.body, true);
      exit();
      this.rightBrace(node);
    }
    function Directive(node) {
      this.print(node.value);
      this.semicolon();
    }
    var unescapedSingleQuoteRE = /(?:^|[^\\])(?:\\\\)*'/;
    var unescapedDoubleQuoteRE = /(?:^|[^\\])(?:\\\\)*"/;
    function DirectiveLiteral(node) {
      const raw = this.getPossibleRaw(node);
      if (!this.format.minified && raw !== void 0) {
        this.token(raw);
        return;
      }
      const {
        value
      } = node;
      if (!unescapedDoubleQuoteRE.test(value)) {
        this.token(`"${value}"`);
      } else if (!unescapedSingleQuoteRE.test(value)) {
        this.token(`'${value}'`);
      } else {
        throw new Error("Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.");
      }
    }
    function InterpreterDirective(node) {
      this.token(`#!${node.value}`);
      this.newline(1, true);
    }
    function Placeholder(node) {
      this.token("%%");
      this.print(node.name);
      this.token("%%");
      if (node.expectedNode === "Statement") {
        this.semicolon();
      }
    }
  }
});

// node_modules/@babel/core/node_modules/@babel/generator/lib/generators/jsx.js
var require_jsx2 = __commonJS({
  "node_modules/@babel/core/node_modules/@babel/generator/lib/generators/jsx.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.JSXAttribute = JSXAttribute;
    exports2.JSXClosingElement = JSXClosingElement;
    exports2.JSXClosingFragment = JSXClosingFragment;
    exports2.JSXElement = JSXElement;
    exports2.JSXEmptyExpression = JSXEmptyExpression;
    exports2.JSXExpressionContainer = JSXExpressionContainer;
    exports2.JSXFragment = JSXFragment;
    exports2.JSXIdentifier = JSXIdentifier;
    exports2.JSXMemberExpression = JSXMemberExpression;
    exports2.JSXNamespacedName = JSXNamespacedName;
    exports2.JSXOpeningElement = JSXOpeningElement;
    exports2.JSXOpeningFragment = JSXOpeningFragment;
    exports2.JSXSpreadAttribute = JSXSpreadAttribute;
    exports2.JSXSpreadChild = JSXSpreadChild;
    exports2.JSXText = JSXText;
    function JSXAttribute(node) {
      this.print(node.name);
      if (node.value) {
        this.tokenChar(61);
        this.print(node.value);
      }
    }
    function JSXIdentifier(node) {
      this.word(node.name);
    }
    function JSXNamespacedName(node) {
      this.print(node.namespace);
      this.tokenChar(58);
      this.print(node.name);
    }
    function JSXMemberExpression(node) {
      this.print(node.object);
      this.tokenChar(46);
      this.print(node.property);
    }
    function JSXSpreadAttribute(node) {
      this.tokenChar(123);
      this.token("...");
      this.print(node.argument);
      this.rightBrace(node);
    }
    function JSXExpressionContainer(node) {
      this.tokenChar(123);
      this.print(node.expression);
      this.rightBrace(node);
    }
    function JSXSpreadChild(node) {
      this.tokenChar(123);
      this.token("...");
      this.print(node.expression);
      this.rightBrace(node);
    }
    function JSXText(node) {
      const raw = this.getPossibleRaw(node);
      if (raw !== void 0) {
        this.token(raw, true);
      } else {
        this.token(node.value, true);
      }
    }
    function JSXElement(node) {
      const open = node.openingElement;
      this.print(open);
      if (open.selfClosing) return;
      this.indent();
      for (const child of node.children) {
        this.print(child);
      }
      this.dedent();
      this.print(node.closingElement);
    }
    function spaceSeparator() {
      this.space();
    }
    function JSXOpeningElement(node) {
      this.tokenChar(60);
      this.print(node.name);
      {
        if (node.typeArguments) {
          this.print(node.typeArguments);
        }
        this.print(node.typeParameters);
      }
      if (node.attributes.length > 0) {
        this.space();
        this.printJoin(node.attributes, void 0, void 0, spaceSeparator);
      }
      if (node.selfClosing) {
        this.space();
        this.tokenChar(47);
      }
      this.tokenChar(62);
    }
    function JSXClosingElement(node) {
      this.tokenChar(60);
      this.tokenChar(47);
      this.print(node.name);
      this.tokenChar(62);
    }
    function JSXEmptyExpression() {
      this.printInnerComments();
    }
    function JSXFragment(node) {
      this.print(node.openingFragment);
      this.indent();
      for (const child of node.children) {
        this.print(child);
      }
      this.dedent();
      this.print(node.closingFragment);
    }
    function JSXOpeningFragment() {
      this.tokenChar(60);
      this.tokenChar(62);
    }
    function JSXClosingFragment() {
      this.token("</");
      this.tokenChar(62);
    }
  }
});

// node_modules/@babel/core/node_modules/@babel/generator/lib/generators/typescript.js
var require_typescript2 = __commonJS({
  "node_modules/@babel/core/node_modules/@babel/generator/lib/generators/typescript.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.TSAnyKeyword = TSAnyKeyword;
    exports2.TSArrayType = TSArrayType;
    exports2.TSSatisfiesExpression = exports2.TSAsExpression = TSTypeExpression;
    exports2.TSBigIntKeyword = TSBigIntKeyword;
    exports2.TSBooleanKeyword = TSBooleanKeyword;
    exports2.TSCallSignatureDeclaration = TSCallSignatureDeclaration;
    exports2.TSInterfaceHeritage = exports2.TSClassImplements = TSClassImplements;
    exports2.TSConditionalType = TSConditionalType;
    exports2.TSConstructSignatureDeclaration = TSConstructSignatureDeclaration;
    exports2.TSConstructorType = TSConstructorType;
    exports2.TSDeclareFunction = TSDeclareFunction;
    exports2.TSDeclareMethod = TSDeclareMethod;
    exports2.TSEnumBody = TSEnumBody;
    exports2.TSEnumDeclaration = TSEnumDeclaration;
    exports2.TSEnumMember = TSEnumMember;
    exports2.TSExportAssignment = TSExportAssignment;
    exports2.TSExternalModuleReference = TSExternalModuleReference;
    exports2.TSFunctionType = TSFunctionType;
    exports2.TSImportEqualsDeclaration = TSImportEqualsDeclaration;
    exports2.TSImportType = TSImportType;
    exports2.TSIndexSignature = TSIndexSignature;
    exports2.TSIndexedAccessType = TSIndexedAccessType;
    exports2.TSInferType = TSInferType;
    exports2.TSInstantiationExpression = TSInstantiationExpression;
    exports2.TSInterfaceBody = TSInterfaceBody;
    exports2.TSInterfaceDeclaration = TSInterfaceDeclaration;
    exports2.TSIntersectionType = TSIntersectionType;
    exports2.TSIntrinsicKeyword = TSIntrinsicKeyword;
    exports2.TSLiteralType = TSLiteralType;
    exports2.TSMappedType = TSMappedType;
    exports2.TSMethodSignature = TSMethodSignature;
    exports2.TSModuleBlock = TSModuleBlock;
    exports2.TSModuleDeclaration = TSModuleDeclaration;
    exports2.TSNamedTupleMember = TSNamedTupleMember;
    exports2.TSNamespaceExportDeclaration = TSNamespaceExportDeclaration;
    exports2.TSNeverKeyword = TSNeverKeyword;
    exports2.TSNonNullExpression = TSNonNullExpression;
    exports2.TSNullKeyword = TSNullKeyword;
    exports2.TSNumberKeyword = TSNumberKeyword;
    exports2.TSObjectKeyword = TSObjectKeyword;
    exports2.TSOptionalType = TSOptionalType;
    exports2.TSParameterProperty = TSParameterProperty;
    exports2.TSParenthesizedType = TSParenthesizedType;
    exports2.TSPropertySignature = TSPropertySignature;
    exports2.TSQualifiedName = TSQualifiedName;
    exports2.TSRestType = TSRestType;
    exports2.TSStringKeyword = TSStringKeyword;
    exports2.TSSymbolKeyword = TSSymbolKeyword;
    exports2.TSTemplateLiteralType = TSTemplateLiteralType;
    exports2.TSThisType = TSThisType;
    exports2.TSTupleType = TSTupleType;
    exports2.TSTypeAliasDeclaration = TSTypeAliasDeclaration;
    exports2.TSTypeAnnotation = TSTypeAnnotation;
    exports2.TSTypeAssertion = TSTypeAssertion;
    exports2.TSTypeLiteral = TSTypeLiteral;
    exports2.TSTypeOperator = TSTypeOperator;
    exports2.TSTypeParameter = TSTypeParameter;
    exports2.TSTypeParameterDeclaration = exports2.TSTypeParameterInstantiation = TSTypeParameterInstantiation;
    exports2.TSTypePredicate = TSTypePredicate;
    exports2.TSTypeQuery = TSTypeQuery;
    exports2.TSTypeReference = TSTypeReference;
    exports2.TSUndefinedKeyword = TSUndefinedKeyword;
    exports2.TSUnionType = TSUnionType;
    exports2.TSUnknownKeyword = TSUnknownKeyword;
    exports2.TSVoidKeyword = TSVoidKeyword;
    exports2.tsPrintClassMemberModifiers = tsPrintClassMemberModifiers;
    exports2.tsPrintFunctionOrConstructorType = tsPrintFunctionOrConstructorType;
    exports2.tsPrintPropertyOrMethodName = tsPrintPropertyOrMethodName;
    exports2.tsPrintSignatureDeclarationBase = tsPrintSignatureDeclarationBase;
    function TSTypeAnnotation(node, parent) {
      this.token((parent.type === "TSFunctionType" || parent.type === "TSConstructorType") && parent.typeAnnotation === node ? "=>" : ":");
      this.space();
      if (node.optional) this.tokenChar(63);
      this.print(node.typeAnnotation);
    }
    function TSTypeParameterInstantiation(node, parent) {
      this.tokenChar(60);
      let printTrailingSeparator = parent.type === "ArrowFunctionExpression" && node.params.length === 1;
      if (this.tokenMap && node.start != null && node.end != null) {
        printTrailingSeparator && (printTrailingSeparator = !!this.tokenMap.find(node, (t6) => this.tokenMap.matchesOriginal(t6, ",")));
        printTrailingSeparator || (printTrailingSeparator = this.shouldPrintTrailingComma(">"));
      }
      this.printList(node.params, printTrailingSeparator);
      this.tokenChar(62);
    }
    function TSTypeParameter(node) {
      if (node.in) {
        this.word("in");
        this.space();
      }
      if (node.out) {
        this.word("out");
        this.space();
      }
      this.word(node.name);
      if (node.constraint) {
        this.space();
        this.word("extends");
        this.space();
        this.print(node.constraint);
      }
      if (node.default) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node.default);
      }
    }
    function TSParameterProperty(node) {
      if (node.accessibility) {
        this.word(node.accessibility);
        this.space();
      }
      if (node.readonly) {
        this.word("readonly");
        this.space();
      }
      this._param(node.parameter);
    }
    function TSDeclareFunction(node, parent) {
      if (node.declare) {
        this.word("declare");
        this.space();
      }
      this._functionHead(node, parent);
      this.semicolon();
    }
    function TSDeclareMethod(node) {
      this._classMethodHead(node);
      this.semicolon();
    }
    function TSQualifiedName(node) {
      this.print(node.left);
      this.tokenChar(46);
      this.print(node.right);
    }
    function TSCallSignatureDeclaration(node) {
      this.tsPrintSignatureDeclarationBase(node);
      maybePrintTrailingCommaOrSemicolon(this, node);
    }
    function maybePrintTrailingCommaOrSemicolon(printer, node) {
      if (!printer.tokenMap || !node.start || !node.end) {
        printer.semicolon();
        return;
      }
      if (printer.tokenMap.endMatches(node, ",")) {
        printer.token(",");
      } else if (printer.tokenMap.endMatches(node, ";")) {
        printer.semicolon();
      }
    }
    function TSConstructSignatureDeclaration(node) {
      this.word("new");
      this.space();
      this.tsPrintSignatureDeclarationBase(node);
      maybePrintTrailingCommaOrSemicolon(this, node);
    }
    function TSPropertySignature(node) {
      const {
        readonly
      } = node;
      if (readonly) {
        this.word("readonly");
        this.space();
      }
      this.tsPrintPropertyOrMethodName(node);
      this.print(node.typeAnnotation);
      maybePrintTrailingCommaOrSemicolon(this, node);
    }
    function tsPrintPropertyOrMethodName(node) {
      if (node.computed) {
        this.tokenChar(91);
      }
      this.print(node.key);
      if (node.computed) {
        this.tokenChar(93);
      }
      if (node.optional) {
        this.tokenChar(63);
      }
    }
    function TSMethodSignature(node) {
      const {
        kind
      } = node;
      if (kind === "set" || kind === "get") {
        this.word(kind);
        this.space();
      }
      this.tsPrintPropertyOrMethodName(node);
      this.tsPrintSignatureDeclarationBase(node);
      maybePrintTrailingCommaOrSemicolon(this, node);
    }
    function TSIndexSignature(node) {
      const {
        readonly,
        static: isStatic
      } = node;
      if (isStatic) {
        this.word("static");
        this.space();
      }
      if (readonly) {
        this.word("readonly");
        this.space();
      }
      this.tokenChar(91);
      this._parameters(node.parameters, "]");
      this.print(node.typeAnnotation);
      maybePrintTrailingCommaOrSemicolon(this, node);
    }
    function TSAnyKeyword() {
      this.word("any");
    }
    function TSBigIntKeyword() {
      this.word("bigint");
    }
    function TSUnknownKeyword() {
      this.word("unknown");
    }
    function TSNumberKeyword() {
      this.word("number");
    }
    function TSObjectKeyword() {
      this.word("object");
    }
    function TSBooleanKeyword() {
      this.word("boolean");
    }
    function TSStringKeyword() {
      this.word("string");
    }
    function TSSymbolKeyword() {
      this.word("symbol");
    }
    function TSVoidKeyword() {
      this.word("void");
    }
    function TSUndefinedKeyword() {
      this.word("undefined");
    }
    function TSNullKeyword() {
      this.word("null");
    }
    function TSNeverKeyword() {
      this.word("never");
    }
    function TSIntrinsicKeyword() {
      this.word("intrinsic");
    }
    function TSThisType() {
      this.word("this");
    }
    function TSFunctionType(node) {
      this.tsPrintFunctionOrConstructorType(node);
    }
    function TSConstructorType(node) {
      if (node.abstract) {
        this.word("abstract");
        this.space();
      }
      this.word("new");
      this.space();
      this.tsPrintFunctionOrConstructorType(node);
    }
    function tsPrintFunctionOrConstructorType(node) {
      const {
        typeParameters
      } = node;
      const parameters = node.parameters;
      this.print(typeParameters);
      this.tokenChar(40);
      this._parameters(parameters, ")");
      this.space();
      const returnType = node.typeAnnotation;
      this.print(returnType);
    }
    function TSTypeReference(node) {
      const typeArguments = node.typeParameters;
      this.print(node.typeName, !!typeArguments);
      this.print(typeArguments);
    }
    function TSTypePredicate(node) {
      if (node.asserts) {
        this.word("asserts");
        this.space();
      }
      this.print(node.parameterName);
      if (node.typeAnnotation) {
        this.space();
        this.word("is");
        this.space();
        this.print(node.typeAnnotation.typeAnnotation);
      }
    }
    function TSTypeQuery(node) {
      this.word("typeof");
      this.space();
      this.print(node.exprName);
      const typeArguments = node.typeParameters;
      if (typeArguments) {
        this.print(typeArguments);
      }
    }
    function TSTypeLiteral(node) {
      printBraced(this, node, () => this.printJoin(node.members, true, true));
    }
    function TSArrayType(node) {
      this.print(node.elementType, true);
      this.tokenChar(91);
      this.tokenChar(93);
    }
    function TSTupleType(node) {
      this.tokenChar(91);
      this.printList(node.elementTypes, this.shouldPrintTrailingComma("]"));
      this.tokenChar(93);
    }
    function TSOptionalType(node) {
      this.print(node.typeAnnotation);
      this.tokenChar(63);
    }
    function TSRestType(node) {
      this.token("...");
      this.print(node.typeAnnotation);
    }
    function TSNamedTupleMember(node) {
      this.print(node.label);
      if (node.optional) this.tokenChar(63);
      this.tokenChar(58);
      this.space();
      this.print(node.elementType);
    }
    function TSUnionType(node) {
      tsPrintUnionOrIntersectionType(this, node, "|");
    }
    function TSIntersectionType(node) {
      tsPrintUnionOrIntersectionType(this, node, "&");
    }
    function tsPrintUnionOrIntersectionType(printer, node, sep) {
      var _printer$tokenMap;
      let hasLeadingToken = 0;
      if ((_printer$tokenMap = printer.tokenMap) != null && _printer$tokenMap.startMatches(node, sep)) {
        hasLeadingToken = 1;
        printer.token(sep);
      }
      printer.printJoin(node.types, void 0, void 0, function(i) {
        this.space();
        this.token(sep, null, i + hasLeadingToken);
        this.space();
      });
    }
    function TSConditionalType(node) {
      this.print(node.checkType);
      this.space();
      this.word("extends");
      this.space();
      this.print(node.extendsType);
      this.space();
      this.tokenChar(63);
      this.space();
      this.print(node.trueType);
      this.space();
      this.tokenChar(58);
      this.space();
      this.print(node.falseType);
    }
    function TSInferType(node) {
      this.word("infer");
      this.print(node.typeParameter);
    }
    function TSParenthesizedType(node) {
      this.tokenChar(40);
      this.print(node.typeAnnotation);
      this.tokenChar(41);
    }
    function TSTypeOperator(node) {
      this.word(node.operator);
      this.space();
      this.print(node.typeAnnotation);
    }
    function TSIndexedAccessType(node) {
      this.print(node.objectType, true);
      this.tokenChar(91);
      this.print(node.indexType);
      this.tokenChar(93);
    }
    function TSMappedType(node) {
      const {
        nameType,
        optional,
        readonly,
        typeAnnotation: typeAnnotation2
      } = node;
      this.tokenChar(123);
      const exit = this.enterDelimited();
      this.space();
      if (readonly) {
        tokenIfPlusMinus(this, readonly);
        this.word("readonly");
        this.space();
      }
      this.tokenChar(91);
      {
        this.word(node.typeParameter.name);
      }
      this.space();
      this.word("in");
      this.space();
      {
        this.print(node.typeParameter.constraint);
      }
      if (nameType) {
        this.space();
        this.word("as");
        this.space();
        this.print(nameType);
      }
      this.tokenChar(93);
      if (optional) {
        tokenIfPlusMinus(this, optional);
        this.tokenChar(63);
      }
      if (typeAnnotation2) {
        this.tokenChar(58);
        this.space();
        this.print(typeAnnotation2);
      }
      this.space();
      exit();
      this.tokenChar(125);
    }
    function tokenIfPlusMinus(self2, tok) {
      if (tok !== true) {
        self2.token(tok);
      }
    }
    function TSTemplateLiteralType(node) {
      this._printTemplate(node, node.types);
    }
    function TSLiteralType(node) {
      this.print(node.literal);
    }
    function TSClassImplements(node) {
      this.print(node.expression);
      this.print(node.typeArguments);
    }
    function TSInterfaceDeclaration(node) {
      const {
        declare,
        id,
        typeParameters,
        extends: extendz,
        body
      } = node;
      if (declare) {
        this.word("declare");
        this.space();
      }
      this.word("interface");
      this.space();
      this.print(id);
      this.print(typeParameters);
      if (extendz != null && extendz.length) {
        this.space();
        this.word("extends");
        this.space();
        this.printList(extendz);
      }
      this.space();
      this.print(body);
    }
    function TSInterfaceBody(node) {
      printBraced(this, node, () => this.printJoin(node.body, true, true));
    }
    function TSTypeAliasDeclaration(node) {
      const {
        declare,
        id,
        typeParameters,
        typeAnnotation: typeAnnotation2
      } = node;
      if (declare) {
        this.word("declare");
        this.space();
      }
      this.word("type");
      this.space();
      this.print(id);
      this.print(typeParameters);
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(typeAnnotation2);
      this.semicolon();
    }
    function TSTypeExpression(node) {
      const {
        type,
        expression,
        typeAnnotation: typeAnnotation2
      } = node;
      this.print(expression, true);
      this.space();
      this.word(type === "TSAsExpression" ? "as" : "satisfies");
      this.space();
      this.print(typeAnnotation2);
    }
    function TSTypeAssertion(node) {
      const {
        typeAnnotation: typeAnnotation2,
        expression
      } = node;
      this.tokenChar(60);
      this.print(typeAnnotation2);
      this.tokenChar(62);
      this.space();
      this.print(expression);
    }
    function TSInstantiationExpression(node) {
      this.print(node.expression);
      {
        this.print(node.typeParameters);
      }
    }
    function TSEnumDeclaration(node) {
      const {
        declare,
        const: isConst,
        id
      } = node;
      if (declare) {
        this.word("declare");
        this.space();
      }
      if (isConst) {
        this.word("const");
        this.space();
      }
      this.word("enum");
      this.space();
      this.print(id);
      this.space();
      {
        TSEnumBody.call(this, node);
      }
    }
    function TSEnumBody(node) {
      printBraced(this, node, () => {
        var _this$shouldPrintTrai;
        return this.printList(node.members, (_this$shouldPrintTrai = this.shouldPrintTrailingComma("}")) != null ? _this$shouldPrintTrai : true, true, true);
      });
    }
    function TSEnumMember(node) {
      const {
        id,
        initializer
      } = node;
      this.print(id);
      if (initializer) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(initializer);
      }
    }
    function TSModuleDeclaration(node) {
      const {
        declare,
        id,
        kind
      } = node;
      if (declare) {
        this.word("declare");
        this.space();
      }
      {
        if (!node.global) {
          this.word(kind != null ? kind : id.type === "Identifier" ? "namespace" : "module");
          this.space();
        }
        this.print(id);
        if (!node.body) {
          this.semicolon();
          return;
        }
        let body = node.body;
        while (body.type === "TSModuleDeclaration") {
          this.tokenChar(46);
          this.print(body.id);
          body = body.body;
        }
        this.space();
        this.print(body);
      }
    }
    function TSModuleBlock(node) {
      printBraced(this, node, () => this.printSequence(node.body, true));
    }
    function TSImportType(node) {
      const {
        argument,
        qualifier,
        options
      } = node;
      this.word("import");
      this.tokenChar(40);
      this.print(argument);
      if (options) {
        this.tokenChar(44);
        this.print(options);
      }
      this.tokenChar(41);
      if (qualifier) {
        this.tokenChar(46);
        this.print(qualifier);
      }
      const typeArguments = node.typeParameters;
      if (typeArguments) {
        this.print(typeArguments);
      }
    }
    function TSImportEqualsDeclaration(node) {
      const {
        id,
        moduleReference
      } = node;
      if (node.isExport) {
        this.word("export");
        this.space();
      }
      this.word("import");
      this.space();
      this.print(id);
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(moduleReference);
      this.semicolon();
    }
    function TSExternalModuleReference(node) {
      this.token("require(");
      this.print(node.expression);
      this.tokenChar(41);
    }
    function TSNonNullExpression(node) {
      this.print(node.expression);
      this.tokenChar(33);
    }
    function TSExportAssignment(node) {
      this.word("export");
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node.expression);
      this.semicolon();
    }
    function TSNamespaceExportDeclaration(node) {
      this.word("export");
      this.space();
      this.word("as");
      this.space();
      this.word("namespace");
      this.space();
      this.print(node.id);
      this.semicolon();
    }
    function tsPrintSignatureDeclarationBase(node) {
      const {
        typeParameters
      } = node;
      const parameters = node.parameters;
      this.print(typeParameters);
      this.tokenChar(40);
      this._parameters(parameters, ")");
      const returnType = node.typeAnnotation;
      this.print(returnType);
    }
    function tsPrintClassMemberModifiers(node) {
      const isPrivateField = node.type === "ClassPrivateProperty";
      const isPublicField = node.type === "ClassAccessorProperty" || node.type === "ClassProperty";
      printModifiersList(this, node, [isPublicField && node.declare && "declare", !isPrivateField && node.accessibility]);
      if (node.static) {
        this.word("static");
        this.space();
      }
      printModifiersList(this, node, [!isPrivateField && node.abstract && "abstract", !isPrivateField && node.override && "override", (isPublicField || isPrivateField) && node.readonly && "readonly"]);
    }
    function printBraced(printer, node, cb) {
      printer.token("{");
      const exit = printer.enterDelimited();
      cb();
      exit();
      printer.rightBrace(node);
    }
    function printModifiersList(printer, node, modifiers) {
      var _printer$tokenMap2;
      const modifiersSet = /* @__PURE__ */ new Set();
      for (const modifier of modifiers) {
        if (modifier) modifiersSet.add(modifier);
      }
      (_printer$tokenMap2 = printer.tokenMap) == null || _printer$tokenMap2.find(node, (tok) => {
        if (modifiersSet.has(tok.value)) {
          printer.token(tok.value);
          printer.space();
          modifiersSet.delete(tok.value);
          return modifiersSet.size === 0;
        }
      });
      for (const modifier of modifiersSet) {
        printer.word(modifier);
        printer.space();
      }
    }
  }
});

// node_modules/@babel/core/node_modules/@babel/generator/lib/generators/index.js
var require_generators2 = __commonJS({
  "node_modules/@babel/core/node_modules/@babel/generator/lib/generators/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _templateLiterals = require_template_literals2();
    Object.keys(_templateLiterals).forEach(function(key2) {
      if (key2 === "default" || key2 === "__esModule") return;
      if (key2 in exports2 && exports2[key2] === _templateLiterals[key2]) return;
      Object.defineProperty(exports2, key2, {
        enumerable: true,
        get: function() {
          return _templateLiterals[key2];
        }
      });
    });
    var _expressions = require_expressions2();
    Object.keys(_expressions).forEach(function(key2) {
      if (key2 === "default" || key2 === "__esModule") return;
      if (key2 in exports2 && exports2[key2] === _expressions[key2]) return;
      Object.defineProperty(exports2, key2, {
        enumerable: true,
        get: function() {
          return _expressions[key2];
        }
      });
    });
    var _statements = require_statements2();
    Object.keys(_statements).forEach(function(key2) {
      if (key2 === "default" || key2 === "__esModule") return;
      if (key2 in exports2 && exports2[key2] === _statements[key2]) return;
      Object.defineProperty(exports2, key2, {
        enumerable: true,
        get: function() {
          return _statements[key2];
        }
      });
    });
    var _classes = require_classes2();
    Object.keys(_classes).forEach(function(key2) {
      if (key2 === "default" || key2 === "__esModule") return;
      if (key2 in exports2 && exports2[key2] === _classes[key2]) return;
      Object.defineProperty(exports2, key2, {
        enumerable: true,
        get: function() {
          return _classes[key2];
        }
      });
    });
    var _methods = require_methods2();
    Object.keys(_methods).forEach(function(key2) {
      if (key2 === "default" || key2 === "__esModule") return;
      if (key2 in exports2 && exports2[key2] === _methods[key2]) return;
      Object.defineProperty(exports2, key2, {
        enumerable: true,
        get: function() {
          return _methods[key2];
        }
      });
    });
    var _modules = require_modules2();
    Object.keys(_modules).forEach(function(key2) {
      if (key2 === "default" || key2 === "__esModule") return;
      if (key2 in exports2 && exports2[key2] === _modules[key2]) return;
      Object.defineProperty(exports2, key2, {
        enumerable: true,
        get: function() {
          return _modules[key2];
        }
      });
    });
    var _types2 = require_types2();
    Object.keys(_types2).forEach(function(key2) {
      if (key2 === "default" || key2 === "__esModule") return;
      if (key2 in exports2 && exports2[key2] === _types2[key2]) return;
      Object.defineProperty(exports2, key2, {
        enumerable: true,
        get: function() {
          return _types2[key2];
        }
      });
    });
    var _flow = require_flow2();
    Object.keys(_flow).forEach(function(key2) {
      if (key2 === "default" || key2 === "__esModule") return;
      if (key2 in exports2 && exports2[key2] === _flow[key2]) return;
      Object.defineProperty(exports2, key2, {
        enumerable: true,
        get: function() {
          return _flow[key2];
        }
      });
    });
    var _base = require_base2();
    Object.keys(_base).forEach(function(key2) {
      if (key2 === "default" || key2 === "__esModule") return;
      if (key2 in exports2 && exports2[key2] === _base[key2]) return;
      Object.defineProperty(exports2, key2, {
        enumerable: true,
        get: function() {
          return _base[key2];
        }
      });
    });
    var _jsx = require_jsx2();
    Object.keys(_jsx).forEach(function(key2) {
      if (key2 === "default" || key2 === "__esModule") return;
      if (key2 in exports2 && exports2[key2] === _jsx[key2]) return;
      Object.defineProperty(exports2, key2, {
        enumerable: true,
        get: function() {
          return _jsx[key2];
        }
      });
    });
    var _typescript = require_typescript2();
    Object.keys(_typescript).forEach(function(key2) {
      if (key2 === "default" || key2 === "__esModule") return;
      if (key2 in exports2 && exports2[key2] === _typescript[key2]) return;
      Object.defineProperty(exports2, key2, {
        enumerable: true,
        get: function() {
          return _typescript[key2];
        }
      });
    });
  }
});

// node_modules/@babel/core/node_modules/@babel/generator/lib/generators/deprecated.js
var require_deprecated2 = __commonJS({
  "node_modules/@babel/core/node_modules/@babel/generator/lib/generators/deprecated.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.addDeprecatedGenerators = addDeprecatedGenerators;
    function addDeprecatedGenerators(PrinterClass) {
      {
        const deprecatedBabel7Generators = {
          Noop() {
          },
          TSExpressionWithTypeArguments(node) {
            this.print(node.expression);
            this.print(node.typeParameters);
          },
          DecimalLiteral(node) {
            const raw = this.getPossibleRaw(node);
            if (!this.format.minified && raw !== void 0) {
              this.word(raw);
              return;
            }
            this.word(node.value + "m");
          }
        };
        Object.assign(PrinterClass.prototype, deprecatedBabel7Generators);
      }
    }
  }
});

// node_modules/@babel/core/node_modules/@babel/generator/lib/printer.js
var require_printer2 = __commonJS({
  "node_modules/@babel/core/node_modules/@babel/generator/lib/printer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _buffer = require_buffer2();
    var n = require_node3();
    var _t = require("@babel/types");
    var _tokenMap = require_token_map2();
    var generatorFunctions = require_generators2();
    var _deprecated = require_deprecated2();
    var {
      isExpression: isExpression2,
      isFunction,
      isStatement: isStatement2,
      isClassBody,
      isTSInterfaceBody,
      isTSEnumMember
    } = _t;
    var SCIENTIFIC_NOTATION = /e/i;
    var ZERO_DECIMAL_INTEGER = /\.0+$/;
    var HAS_NEWLINE = /[\n\r\u2028\u2029]/;
    var HAS_NEWLINE_OR_BlOCK_COMMENT_END = /[\n\r\u2028\u2029]|\*\//;
    function commentIsNewline(c2) {
      return c2.type === "CommentLine" || HAS_NEWLINE.test(c2.value);
    }
    var {
      needsParens
    } = n;
    var Printer = class {
      constructor(format, map, tokens, originalCode) {
        this.inForStatementInit = false;
        this.tokenContext = 0;
        this._tokens = null;
        this._originalCode = null;
        this._currentNode = null;
        this._indent = 0;
        this._indentRepeat = 0;
        this._insideAux = false;
        this._noLineTerminator = false;
        this._noLineTerminatorAfterNode = null;
        this._printAuxAfterOnNextUserNode = false;
        this._printedComments = /* @__PURE__ */ new Set();
        this._endsWithInteger = false;
        this._endsWithWord = false;
        this._endsWithDiv = false;
        this._lastCommentLine = 0;
        this._endsWithInnerRaw = false;
        this._indentInnerComments = true;
        this.tokenMap = null;
        this._boundGetRawIdentifier = this._getRawIdentifier.bind(this);
        this._printSemicolonBeforeNextNode = -1;
        this._printSemicolonBeforeNextToken = -1;
        this.format = format;
        this._tokens = tokens;
        this._originalCode = originalCode;
        this._indentRepeat = format.indent.style.length;
        this._inputMap = map == null ? void 0 : map._inputMap;
        this._buf = new _buffer.default(map, format.indent.style[0]);
      }
      enterForStatementInit() {
        if (this.inForStatementInit) return () => {
        };
        this.inForStatementInit = true;
        return () => {
          this.inForStatementInit = false;
        };
      }
      enterDelimited() {
        const oldInForStatementInit = this.inForStatementInit;
        const oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;
        if (oldInForStatementInit === false && oldNoLineTerminatorAfterNode === null) {
          return () => {
          };
        }
        this.inForStatementInit = false;
        this._noLineTerminatorAfterNode = null;
        return () => {
          this.inForStatementInit = oldInForStatementInit;
          this._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode;
        };
      }
      generate(ast) {
        if (this.format.preserveFormat) {
          this.tokenMap = new _tokenMap.TokenMap(ast, this._tokens, this._originalCode);
        }
        this.print(ast);
        this._maybeAddAuxComment();
        return this._buf.get();
      }
      indent() {
        const {
          format
        } = this;
        if (format.preserveFormat || format.compact || format.concise) {
          return;
        }
        this._indent++;
      }
      dedent() {
        const {
          format
        } = this;
        if (format.preserveFormat || format.compact || format.concise) {
          return;
        }
        this._indent--;
      }
      semicolon(force = false) {
        this._maybeAddAuxComment();
        if (force) {
          this._appendChar(59);
          this._noLineTerminator = false;
          return;
        }
        if (this.tokenMap) {
          const node = this._currentNode;
          if (node.start != null && node.end != null) {
            if (!this.tokenMap.endMatches(node, ";")) {
              this._printSemicolonBeforeNextNode = this._buf.getCurrentLine();
              return;
            }
            const indexes = this.tokenMap.getIndexes(this._currentNode);
            this._catchUpTo(this._tokens[indexes[indexes.length - 1]].loc.start);
          }
        }
        this._queue(59);
        this._noLineTerminator = false;
      }
      rightBrace(node) {
        if (this.format.minified) {
          this._buf.removeLastSemicolon();
        }
        this.sourceWithOffset("end", node.loc, -1);
        this.tokenChar(125);
      }
      rightParens(node) {
        this.sourceWithOffset("end", node.loc, -1);
        this.tokenChar(41);
      }
      space(force = false) {
        const {
          format
        } = this;
        if (format.compact || format.preserveFormat) return;
        if (force) {
          this._space();
        } else if (this._buf.hasContent()) {
          const lastCp = this.getLastChar();
          if (lastCp !== 32 && lastCp !== 10) {
            this._space();
          }
        }
      }
      word(str, noLineTerminatorAfter = false) {
        this.tokenContext = 0;
        this._maybePrintInnerComments(str);
        this._maybeAddAuxComment();
        if (this.tokenMap) this._catchUpToCurrentToken(str);
        if (this._endsWithWord || this._endsWithDiv && str.charCodeAt(0) === 47) {
          this._space();
        }
        this._append(str, false);
        this._endsWithWord = true;
        this._noLineTerminator = noLineTerminatorAfter;
      }
      number(str, number) {
        function isNonDecimalLiteral(str2) {
          if (str2.length > 2 && str2.charCodeAt(0) === 48) {
            const secondChar = str2.charCodeAt(1);
            return secondChar === 98 || secondChar === 111 || secondChar === 120;
          }
          return false;
        }
        this.word(str);
        this._endsWithInteger = Number.isInteger(number) && !isNonDecimalLiteral(str) && !SCIENTIFIC_NOTATION.test(str) && !ZERO_DECIMAL_INTEGER.test(str) && str.charCodeAt(str.length - 1) !== 46;
      }
      token(str, maybeNewline = false, occurrenceCount = 0) {
        this.tokenContext = 0;
        this._maybePrintInnerComments(str, occurrenceCount);
        this._maybeAddAuxComment();
        if (this.tokenMap) this._catchUpToCurrentToken(str, occurrenceCount);
        const lastChar = this.getLastChar();
        const strFirst = str.charCodeAt(0);
        if (lastChar === 33 && (str === "--" || strFirst === 61) || strFirst === 43 && lastChar === 43 || strFirst === 45 && lastChar === 45 || strFirst === 46 && this._endsWithInteger) {
          this._space();
        }
        this._append(str, maybeNewline);
        this._noLineTerminator = false;
      }
      tokenChar(char) {
        this.tokenContext = 0;
        const str = String.fromCharCode(char);
        this._maybePrintInnerComments(str);
        this._maybeAddAuxComment();
        if (this.tokenMap) this._catchUpToCurrentToken(str);
        const lastChar = this.getLastChar();
        if (char === 43 && lastChar === 43 || char === 45 && lastChar === 45 || char === 46 && this._endsWithInteger) {
          this._space();
        }
        this._appendChar(char);
        this._noLineTerminator = false;
      }
      newline(i = 1, force) {
        if (i <= 0) return;
        if (!force) {
          if (this.format.retainLines || this.format.compact) return;
          if (this.format.concise) {
            this.space();
            return;
          }
        }
        if (i > 2) i = 2;
        i -= this._buf.getNewlineCount();
        for (let j = 0; j < i; j++) {
          this._newline();
        }
        return;
      }
      endsWith(char) {
        return this.getLastChar() === char;
      }
      getLastChar() {
        return this._buf.getLastChar();
      }
      endsWithCharAndNewline() {
        return this._buf.endsWithCharAndNewline();
      }
      removeTrailingNewline() {
        this._buf.removeTrailingNewline();
      }
      exactSource(loc, cb) {
        if (!loc) {
          cb();
          return;
        }
        this._catchUp("start", loc);
        this._buf.exactSource(loc, cb);
      }
      source(prop, loc) {
        if (!loc) return;
        this._catchUp(prop, loc);
        this._buf.source(prop, loc);
      }
      sourceWithOffset(prop, loc, columnOffset) {
        if (!loc || this.format.preserveFormat) return;
        this._catchUp(prop, loc);
        this._buf.sourceWithOffset(prop, loc, columnOffset);
      }
      sourceIdentifierName(identifierName, pos2) {
        if (!this._buf._canMarkIdName) return;
        const sourcePosition = this._buf._sourcePosition;
        sourcePosition.identifierNamePos = pos2;
        sourcePosition.identifierName = identifierName;
      }
      _space() {
        this._queue(32);
      }
      _newline() {
        this._queue(10);
      }
      _catchUpToCurrentToken(str, occurrenceCount = 0) {
        const token2 = this.tokenMap.findMatching(this._currentNode, str, occurrenceCount);
        if (token2) this._catchUpTo(token2.loc.start);
        if (this._printSemicolonBeforeNextToken !== -1 && this._printSemicolonBeforeNextToken === this._buf.getCurrentLine()) {
          this._buf.appendChar(59);
          this._endsWithWord = false;
          this._endsWithInteger = false;
          this._endsWithDiv = false;
        }
        this._printSemicolonBeforeNextToken = -1;
        this._printSemicolonBeforeNextNode = -1;
      }
      _append(str, maybeNewline) {
        this._maybeIndent(str.charCodeAt(0));
        this._buf.append(str, maybeNewline);
        this._endsWithWord = false;
        this._endsWithInteger = false;
        this._endsWithDiv = false;
      }
      _appendChar(char) {
        this._maybeIndent(char);
        this._buf.appendChar(char);
        this._endsWithWord = false;
        this._endsWithInteger = false;
        this._endsWithDiv = false;
      }
      _queue(char) {
        this._maybeIndent(char);
        this._buf.queue(char);
        this._endsWithWord = false;
        this._endsWithInteger = false;
      }
      _maybeIndent(firstChar) {
        if (this._indent && firstChar !== 10 && this.endsWith(10)) {
          this._buf.queueIndentation(this._getIndent());
        }
      }
      _shouldIndent(firstChar) {
        if (this._indent && firstChar !== 10 && this.endsWith(10)) {
          return true;
        }
      }
      catchUp(line2) {
        if (!this.format.retainLines) return;
        const count = line2 - this._buf.getCurrentLine();
        for (let i = 0; i < count; i++) {
          this._newline();
        }
      }
      _catchUp(prop, loc) {
        const {
          format
        } = this;
        if (!format.preserveFormat) {
          if (format.retainLines && loc != null && loc[prop]) {
            this.catchUp(loc[prop].line);
          }
          return;
        }
        const pos2 = loc == null ? void 0 : loc[prop];
        if (pos2 != null) this._catchUpTo(pos2);
      }
      _catchUpTo({
        line: line2,
        column: column2,
        index
      }) {
        const count = line2 - this._buf.getCurrentLine();
        if (count > 0 && this._noLineTerminator) {
          return;
        }
        for (let i = 0; i < count; i++) {
          this._newline();
        }
        const spacesCount = count > 0 ? column2 : column2 - this._buf.getCurrentColumn();
        if (spacesCount > 0) {
          const spaces = this._originalCode ? this._originalCode.slice(index - spacesCount, index).replace(/[^\t\x0B\f \xA0\u1680\u2000-\u200A\u202F\u205F\u3000\uFEFF]/gu, " ") : " ".repeat(spacesCount);
          this._append(spaces, false);
        }
      }
      _getIndent() {
        return this._indentRepeat * this._indent;
      }
      printTerminatorless(node) {
        this._noLineTerminator = true;
        this.print(node);
      }
      print(node, noLineTerminatorAfter, trailingCommentsLineOffset) {
        var _node$extra, _node$leadingComments, _node$leadingComments2;
        if (!node) return;
        this._endsWithInnerRaw = false;
        const nodeType = node.type;
        const format = this.format;
        const oldConcise = format.concise;
        if (node._compact) {
          format.concise = true;
        }
        const printMethod = this[nodeType];
        if (printMethod === void 0) {
          throw new ReferenceError(`unknown node of type ${JSON.stringify(nodeType)} with constructor ${JSON.stringify(node.constructor.name)}`);
        }
        const parent = this._currentNode;
        this._currentNode = node;
        if (this.tokenMap) {
          this._printSemicolonBeforeNextToken = this._printSemicolonBeforeNextNode;
        }
        const oldInAux = this._insideAux;
        this._insideAux = node.loc == null;
        this._maybeAddAuxComment(this._insideAux && !oldInAux);
        const parenthesized = (_node$extra = node.extra) == null ? void 0 : _node$extra.parenthesized;
        let shouldPrintParens = parenthesized && format.preserveFormat || parenthesized && format.retainFunctionParens && nodeType === "FunctionExpression" || needsParens(node, parent, this.tokenContext, this.inForStatementInit, format.preserveFormat ? this._boundGetRawIdentifier : void 0);
        if (!shouldPrintParens && parenthesized && (_node$leadingComments = node.leadingComments) != null && _node$leadingComments.length && node.leadingComments[0].type === "CommentBlock") {
          const parentType = parent == null ? void 0 : parent.type;
          switch (parentType) {
            case "ExpressionStatement":
            case "VariableDeclarator":
            case "AssignmentExpression":
            case "ReturnStatement":
              break;
            case "CallExpression":
            case "OptionalCallExpression":
            case "NewExpression":
              if (parent.callee !== node) break;
            default:
              shouldPrintParens = true;
          }
        }
        let indentParenthesized = false;
        if (!shouldPrintParens && this._noLineTerminator && ((_node$leadingComments2 = node.leadingComments) != null && _node$leadingComments2.some(commentIsNewline) || this.format.retainLines && node.loc && node.loc.start.line > this._buf.getCurrentLine())) {
          shouldPrintParens = true;
          indentParenthesized = true;
        }
        let oldNoLineTerminatorAfterNode;
        let oldInForStatementInitWasTrue;
        if (!shouldPrintParens) {
          noLineTerminatorAfter || (noLineTerminatorAfter = parent && this._noLineTerminatorAfterNode === parent && n.isLastChild(parent, node));
          if (noLineTerminatorAfter) {
            var _node$trailingComment;
            if ((_node$trailingComment = node.trailingComments) != null && _node$trailingComment.some(commentIsNewline)) {
              if (isExpression2(node)) shouldPrintParens = true;
            } else {
              oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;
              this._noLineTerminatorAfterNode = node;
            }
          }
        }
        if (shouldPrintParens) {
          this.tokenChar(40);
          if (indentParenthesized) this.indent();
          this._endsWithInnerRaw = false;
          if (this.inForStatementInit) {
            oldInForStatementInitWasTrue = true;
            this.inForStatementInit = false;
          }
          oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;
          this._noLineTerminatorAfterNode = null;
        }
        this._lastCommentLine = 0;
        this._printLeadingComments(node, parent);
        const loc = nodeType === "Program" || nodeType === "File" ? null : node.loc;
        this.exactSource(loc, printMethod.bind(this, node, parent));
        if (shouldPrintParens) {
          this._printTrailingComments(node, parent);
          if (indentParenthesized) {
            this.dedent();
            this.newline();
          }
          this.tokenChar(41);
          this._noLineTerminator = noLineTerminatorAfter;
          if (oldInForStatementInitWasTrue) this.inForStatementInit = true;
        } else if (noLineTerminatorAfter && !this._noLineTerminator) {
          this._noLineTerminator = true;
          this._printTrailingComments(node, parent);
        } else {
          this._printTrailingComments(node, parent, trailingCommentsLineOffset);
        }
        this._currentNode = parent;
        format.concise = oldConcise;
        this._insideAux = oldInAux;
        if (oldNoLineTerminatorAfterNode !== void 0) {
          this._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode;
        }
        this._endsWithInnerRaw = false;
      }
      _maybeAddAuxComment(enteredPositionlessNode) {
        if (enteredPositionlessNode) this._printAuxBeforeComment();
        if (!this._insideAux) this._printAuxAfterComment();
      }
      _printAuxBeforeComment() {
        if (this._printAuxAfterOnNextUserNode) return;
        this._printAuxAfterOnNextUserNode = true;
        const comment = this.format.auxiliaryCommentBefore;
        if (comment) {
          this._printComment({
            type: "CommentBlock",
            value: comment
          }, 0);
        }
      }
      _printAuxAfterComment() {
        if (!this._printAuxAfterOnNextUserNode) return;
        this._printAuxAfterOnNextUserNode = false;
        const comment = this.format.auxiliaryCommentAfter;
        if (comment) {
          this._printComment({
            type: "CommentBlock",
            value: comment
          }, 0);
        }
      }
      getPossibleRaw(node) {
        const extra = node.extra;
        if ((extra == null ? void 0 : extra.raw) != null && extra.rawValue != null && node.value === extra.rawValue) {
          return extra.raw;
        }
      }
      printJoin(nodes, statement, indent, separator, printTrailingSeparator, addNewlines, iterator, trailingCommentsLineOffset) {
        if (!(nodes != null && nodes.length)) return;
        if (indent == null && this.format.retainLines) {
          var _nodes$0$loc;
          const startLine = (_nodes$0$loc = nodes[0].loc) == null ? void 0 : _nodes$0$loc.start.line;
          if (startLine != null && startLine !== this._buf.getCurrentLine()) {
            indent = true;
          }
        }
        if (indent) this.indent();
        const newlineOpts = {
          addNewlines,
          nextNodeStartLine: 0
        };
        const boundSeparator = separator == null ? void 0 : separator.bind(this);
        const len = nodes.length;
        for (let i = 0; i < len; i++) {
          const node = nodes[i];
          if (!node) continue;
          if (statement) this._printNewline(i === 0, newlineOpts);
          this.print(node, void 0, trailingCommentsLineOffset || 0);
          iterator == null || iterator(node, i);
          if (boundSeparator != null) {
            if (i < len - 1) boundSeparator(i, false);
            else if (printTrailingSeparator) boundSeparator(i, true);
          }
          if (statement) {
            var _node$trailingComment2;
            if (!((_node$trailingComment2 = node.trailingComments) != null && _node$trailingComment2.length)) {
              this._lastCommentLine = 0;
            }
            if (i + 1 === len) {
              this.newline(1);
            } else {
              var _nextNode$loc;
              const nextNode = nodes[i + 1];
              newlineOpts.nextNodeStartLine = ((_nextNode$loc = nextNode.loc) == null ? void 0 : _nextNode$loc.start.line) || 0;
              this._printNewline(true, newlineOpts);
            }
          }
        }
        if (indent) this.dedent();
      }
      printAndIndentOnComments(node) {
        const indent = node.leadingComments && node.leadingComments.length > 0;
        if (indent) this.indent();
        this.print(node);
        if (indent) this.dedent();
      }
      printBlock(parent) {
        const node = parent.body;
        if (node.type !== "EmptyStatement") {
          this.space();
        }
        this.print(node);
      }
      _printTrailingComments(node, parent, lineOffset) {
        const {
          innerComments,
          trailingComments
        } = node;
        if (innerComments != null && innerComments.length) {
          this._printComments(2, innerComments, node, parent, lineOffset);
        }
        if (trailingComments != null && trailingComments.length) {
          this._printComments(2, trailingComments, node, parent, lineOffset);
        }
      }
      _printLeadingComments(node, parent) {
        const comments = node.leadingComments;
        if (!(comments != null && comments.length)) return;
        this._printComments(0, comments, node, parent);
      }
      _maybePrintInnerComments(nextTokenStr, nextTokenOccurrenceCount) {
        if (this._endsWithInnerRaw) {
          var _this$tokenMap;
          this.printInnerComments((_this$tokenMap = this.tokenMap) == null ? void 0 : _this$tokenMap.findMatching(this._currentNode, nextTokenStr, nextTokenOccurrenceCount));
        }
        this._endsWithInnerRaw = true;
        this._indentInnerComments = true;
      }
      printInnerComments(nextToken) {
        const node = this._currentNode;
        const comments = node.innerComments;
        if (!(comments != null && comments.length)) return;
        const hasSpace = this.endsWith(32);
        const indent = this._indentInnerComments;
        const printedCommentsCount = this._printedComments.size;
        if (indent) this.indent();
        this._printComments(1, comments, node, void 0, void 0, nextToken);
        if (hasSpace && printedCommentsCount !== this._printedComments.size) {
          this.space();
        }
        if (indent) this.dedent();
      }
      noIndentInnerCommentsHere() {
        this._indentInnerComments = false;
      }
      printSequence(nodes, indent, trailingCommentsLineOffset, addNewlines) {
        this.printJoin(nodes, true, indent != null ? indent : false, void 0, void 0, addNewlines, void 0, trailingCommentsLineOffset);
      }
      printList(items, printTrailingSeparator, statement, indent, separator, iterator) {
        this.printJoin(items, statement, indent, separator != null ? separator : commaSeparator, printTrailingSeparator, void 0, iterator);
      }
      shouldPrintTrailingComma(listEnd) {
        if (!this.tokenMap) return null;
        const listEndIndex = this.tokenMap.findLastIndex(this._currentNode, (token2) => this.tokenMap.matchesOriginal(token2, listEnd));
        if (listEndIndex <= 0) return null;
        return this.tokenMap.matchesOriginal(this._tokens[listEndIndex - 1], ",");
      }
      _printNewline(newLine, opts) {
        const format = this.format;
        if (format.retainLines || format.compact) return;
        if (format.concise) {
          this.space();
          return;
        }
        if (!newLine) {
          return;
        }
        const startLine = opts.nextNodeStartLine;
        const lastCommentLine = this._lastCommentLine;
        if (startLine > 0 && lastCommentLine > 0) {
          const offset = startLine - lastCommentLine;
          if (offset >= 0) {
            this.newline(offset || 1);
            return;
          }
        }
        if (this._buf.hasContent()) {
          this.newline(1);
        }
      }
      _shouldPrintComment(comment, nextToken) {
        if (comment.ignore) return 0;
        if (this._printedComments.has(comment)) return 0;
        if (this._noLineTerminator && HAS_NEWLINE_OR_BlOCK_COMMENT_END.test(comment.value)) {
          return 2;
        }
        if (nextToken && this.tokenMap) {
          const commentTok = this.tokenMap.find(this._currentNode, (token2) => token2.value === comment.value);
          if (commentTok && commentTok.start > nextToken.start) {
            return 2;
          }
        }
        this._printedComments.add(comment);
        if (!this.format.shouldPrintComment(comment.value)) {
          return 0;
        }
        return 1;
      }
      _printComment(comment, skipNewLines) {
        const noLineTerminator = this._noLineTerminator;
        const isBlockComment = comment.type === "CommentBlock";
        const printNewLines = isBlockComment && skipNewLines !== 1 && !this._noLineTerminator;
        if (printNewLines && this._buf.hasContent() && skipNewLines !== 2) {
          this.newline(1);
        }
        const lastCharCode = this.getLastChar();
        if (lastCharCode !== 91 && lastCharCode !== 123 && lastCharCode !== 40) {
          this.space();
        }
        let val;
        if (isBlockComment) {
          val = `/*${comment.value}*/`;
          if (this.format.indent.adjustMultilineComment) {
            var _comment$loc;
            const offset = (_comment$loc = comment.loc) == null ? void 0 : _comment$loc.start.column;
            if (offset) {
              const newlineRegex = new RegExp("\\n\\s{1," + offset + "}", "g");
              val = val.replace(newlineRegex, "\n");
            }
            if (this.format.concise) {
              val = val.replace(/\n(?!$)/g, `
`);
            } else {
              let indentSize = this.format.retainLines ? 0 : this._buf.getCurrentColumn();
              if (this._shouldIndent(47) || this.format.retainLines) {
                indentSize += this._getIndent();
              }
              val = val.replace(/\n(?!$)/g, `
${" ".repeat(indentSize)}`);
            }
          }
        } else if (!noLineTerminator) {
          val = `//${comment.value}`;
        } else {
          val = `/*${comment.value}*/`;
        }
        if (this._endsWithDiv) this._space();
        if (this.tokenMap) {
          const {
            _printSemicolonBeforeNextToken,
            _printSemicolonBeforeNextNode
          } = this;
          this._printSemicolonBeforeNextToken = -1;
          this._printSemicolonBeforeNextNode = -1;
          this.source("start", comment.loc);
          this._append(val, isBlockComment);
          this._printSemicolonBeforeNextNode = _printSemicolonBeforeNextNode;
          this._printSemicolonBeforeNextToken = _printSemicolonBeforeNextToken;
        } else {
          this.source("start", comment.loc);
          this._append(val, isBlockComment);
        }
        if (!isBlockComment && !noLineTerminator) {
          this.newline(1, true);
        }
        if (printNewLines && skipNewLines !== 3) {
          this.newline(1);
        }
      }
      _printComments(type, comments, node, parent, lineOffset = 0, nextToken) {
        const nodeLoc = node.loc;
        const len = comments.length;
        let hasLoc = !!nodeLoc;
        const nodeStartLine = hasLoc ? nodeLoc.start.line : 0;
        const nodeEndLine = hasLoc ? nodeLoc.end.line : 0;
        let lastLine = 0;
        let leadingCommentNewline = 0;
        const maybeNewline = this._noLineTerminator ? function() {
        } : this.newline.bind(this);
        for (let i = 0; i < len; i++) {
          const comment = comments[i];
          const shouldPrint = this._shouldPrintComment(comment, nextToken);
          if (shouldPrint === 2) {
            hasLoc = false;
            break;
          }
          if (hasLoc && comment.loc && shouldPrint === 1) {
            const commentStartLine = comment.loc.start.line;
            const commentEndLine = comment.loc.end.line;
            if (type === 0) {
              let offset = 0;
              if (i === 0) {
                if (this._buf.hasContent() && (comment.type === "CommentLine" || commentStartLine !== commentEndLine)) {
                  offset = leadingCommentNewline = 1;
                }
              } else {
                offset = commentStartLine - lastLine;
              }
              lastLine = commentEndLine;
              maybeNewline(offset);
              this._printComment(comment, 1);
              if (i + 1 === len) {
                maybeNewline(Math.max(nodeStartLine - lastLine, leadingCommentNewline));
                lastLine = nodeStartLine;
              }
            } else if (type === 1) {
              const offset = commentStartLine - (i === 0 ? nodeStartLine : lastLine);
              lastLine = commentEndLine;
              maybeNewline(offset);
              this._printComment(comment, 1);
              if (i + 1 === len) {
                maybeNewline(Math.min(1, nodeEndLine - lastLine));
                lastLine = nodeEndLine;
              }
            } else {
              const offset = commentStartLine - (i === 0 ? nodeEndLine - lineOffset : lastLine);
              lastLine = commentEndLine;
              maybeNewline(offset);
              this._printComment(comment, 1);
            }
          } else {
            hasLoc = false;
            if (shouldPrint !== 1) {
              continue;
            }
            if (len === 1) {
              const singleLine = comment.loc ? comment.loc.start.line === comment.loc.end.line : !HAS_NEWLINE.test(comment.value);
              const shouldSkipNewline = singleLine && !isStatement2(node) && !isClassBody(parent) && !isTSInterfaceBody(parent) && !isTSEnumMember(node);
              if (type === 0) {
                this._printComment(comment, shouldSkipNewline && node.type !== "ObjectExpression" || singleLine && isFunction(parent, {
                  body: node
                }) ? 1 : 0);
              } else if (shouldSkipNewline && type === 2) {
                this._printComment(comment, 1);
              } else {
                this._printComment(comment, 0);
              }
            } else if (type === 1 && !(node.type === "ObjectExpression" && node.properties.length > 1) && node.type !== "ClassBody" && node.type !== "TSInterfaceBody") {
              this._printComment(comment, i === 0 ? 2 : i === len - 1 ? 3 : 0);
            } else {
              this._printComment(comment, 0);
            }
          }
        }
        if (type === 2 && hasLoc && lastLine) {
          this._lastCommentLine = lastLine;
        }
      }
    };
    Object.assign(Printer.prototype, generatorFunctions);
    {
      (0, _deprecated.addDeprecatedGenerators)(Printer);
    }
    var _default = exports2.default = Printer;
    function commaSeparator(occurrenceCount, last) {
      this.token(",", false, occurrenceCount);
      if (!last) this.space();
    }
  }
});

// node_modules/@babel/core/node_modules/@babel/generator/lib/index.js
var require_lib8 = __commonJS({
  "node_modules/@babel/core/node_modules/@babel/generator/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    exports2.generate = generate2;
    var _sourceMap = require_source_map2();
    var _printer = require_printer2();
    function normalizeOptions(code, opts, ast) {
      if (opts.experimental_preserveFormat) {
        if (typeof code !== "string") {
          throw new Error("`experimental_preserveFormat` requires the original `code` to be passed to @babel/generator as a string");
        }
        if (!opts.retainLines) {
          throw new Error("`experimental_preserveFormat` requires `retainLines` to be set to `true`");
        }
        if (opts.compact && opts.compact !== "auto") {
          throw new Error("`experimental_preserveFormat` is not compatible with the `compact` option");
        }
        if (opts.minified) {
          throw new Error("`experimental_preserveFormat` is not compatible with the `minified` option");
        }
        if (opts.jsescOption) {
          throw new Error("`experimental_preserveFormat` is not compatible with the `jsescOption` option");
        }
        if (!Array.isArray(ast.tokens)) {
          throw new Error("`experimental_preserveFormat` requires the AST to have attatched the token of the input code. Make sure to enable the `tokens: true` parser option.");
        }
      }
      const format = {
        auxiliaryCommentBefore: opts.auxiliaryCommentBefore,
        auxiliaryCommentAfter: opts.auxiliaryCommentAfter,
        shouldPrintComment: opts.shouldPrintComment,
        preserveFormat: opts.experimental_preserveFormat,
        retainLines: opts.retainLines,
        retainFunctionParens: opts.retainFunctionParens,
        comments: opts.comments == null || opts.comments,
        compact: opts.compact,
        minified: opts.minified,
        concise: opts.concise,
        indent: {
          adjustMultilineComment: true,
          style: "  "
        },
        jsescOption: Object.assign({
          quotes: "double",
          wrap: true,
          minimal: false
        }, opts.jsescOption),
        topicToken: opts.topicToken,
        importAttributesKeyword: opts.importAttributesKeyword
      };
      {
        var _opts$recordAndTupleS;
        format.decoratorsBeforeExport = opts.decoratorsBeforeExport;
        format.jsescOption.json = opts.jsonCompatibleStrings;
        format.recordAndTupleSyntaxType = (_opts$recordAndTupleS = opts.recordAndTupleSyntaxType) != null ? _opts$recordAndTupleS : "hash";
      }
      if (format.minified) {
        format.compact = true;
        format.shouldPrintComment = format.shouldPrintComment || (() => format.comments);
      } else {
        format.shouldPrintComment = format.shouldPrintComment || ((value) => format.comments || value.includes("@license") || value.includes("@preserve"));
      }
      if (format.compact === "auto") {
        format.compact = typeof code === "string" && code.length > 5e5;
        if (format.compact) {
          console.error(`[BABEL] Note: The code generator has deoptimised the styling of ${opts.filename} as it exceeds the max of ${"500KB"}.`);
        }
      }
      if (format.compact || format.preserveFormat) {
        format.indent.adjustMultilineComment = false;
      }
      const {
        auxiliaryCommentBefore,
        auxiliaryCommentAfter,
        shouldPrintComment
      } = format;
      if (auxiliaryCommentBefore && !shouldPrintComment(auxiliaryCommentBefore)) {
        format.auxiliaryCommentBefore = void 0;
      }
      if (auxiliaryCommentAfter && !shouldPrintComment(auxiliaryCommentAfter)) {
        format.auxiliaryCommentAfter = void 0;
      }
      return format;
    }
    {
      exports2.CodeGenerator = class CodeGenerator {
        constructor(ast, opts = {}, code) {
          this._ast = void 0;
          this._format = void 0;
          this._map = void 0;
          this._ast = ast;
          this._format = normalizeOptions(code, opts, ast);
          this._map = opts.sourceMaps ? new _sourceMap.default(opts, code) : null;
        }
        generate() {
          const printer = new _printer.default(this._format, this._map);
          return printer.generate(this._ast);
        }
      };
    }
    function generate2(ast, opts = {}, code) {
      const format = normalizeOptions(code, opts, ast);
      const map = opts.sourceMaps ? new _sourceMap.default(opts, code) : null;
      const printer = new _printer.default(format, map, ast.tokens, typeof code === "string" ? code : null);
      return printer.generate(ast);
    }
    var _default = exports2.default = generate2;
  }
});

// node_modules/@babel/core/node_modules/@babel/traverse/lib/path/ancestry.js
var require_ancestry2 = __commonJS({
  "node_modules/@babel/core/node_modules/@babel/traverse/lib/path/ancestry.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.find = find;
    exports2.findParent = findParent;
    exports2.getAncestry = getAncestry;
    exports2.getDeepestCommonAncestorFrom = getDeepestCommonAncestorFrom;
    exports2.getEarliestCommonAncestorFrom = getEarliestCommonAncestorFrom;
    exports2.getFunctionParent = getFunctionParent;
    exports2.getStatementParent = getStatementParent;
    exports2.inType = inType;
    exports2.isAncestor = isAncestor;
    exports2.isDescendant = isDescendant;
    var _t = require("@babel/types");
    var {
      VISITOR_KEYS
    } = _t;
    function findParent(callback) {
      let path = this;
      while (path = path.parentPath) {
        if (callback(path)) return path;
      }
      return null;
    }
    function find(callback) {
      let path = this;
      do {
        if (callback(path)) return path;
      } while (path = path.parentPath);
      return null;
    }
    function getFunctionParent() {
      return this.findParent((p) => p.isFunction());
    }
    function getStatementParent() {
      let path = this;
      do {
        if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {
          break;
        } else {
          path = path.parentPath;
        }
      } while (path);
      if (path && (path.isProgram() || path.isFile())) {
        throw new Error("File/Program node, we can't possibly find a statement parent to this");
      }
      return path;
    }
    function getEarliestCommonAncestorFrom(paths) {
      return this.getDeepestCommonAncestorFrom(paths, function(deepest, i, ancestries) {
        let earliest;
        const keys = VISITOR_KEYS[deepest.type];
        for (const ancestry of ancestries) {
          const path = ancestry[i + 1];
          if (!earliest) {
            earliest = path;
            continue;
          }
          if (path.listKey && earliest.listKey === path.listKey) {
            if (path.key < earliest.key) {
              earliest = path;
              continue;
            }
          }
          const earliestKeyIndex = keys.indexOf(earliest.parentKey);
          const currentKeyIndex = keys.indexOf(path.parentKey);
          if (earliestKeyIndex > currentKeyIndex) {
            earliest = path;
          }
        }
        return earliest;
      });
    }
    function getDeepestCommonAncestorFrom(paths, filter) {
      if (!paths.length) {
        return this;
      }
      if (paths.length === 1) {
        return paths[0];
      }
      let minDepth = Infinity;
      let lastCommonIndex, lastCommon;
      const ancestries = paths.map((path) => {
        const ancestry = [];
        do {
          ancestry.unshift(path);
        } while ((path = path.parentPath) && path !== this);
        if (ancestry.length < minDepth) {
          minDepth = ancestry.length;
        }
        return ancestry;
      });
      const first = ancestries[0];
      depthLoop: for (let i = 0; i < minDepth; i++) {
        const shouldMatch = first[i];
        for (const ancestry of ancestries) {
          if (ancestry[i] !== shouldMatch) {
            break depthLoop;
          }
        }
        lastCommonIndex = i;
        lastCommon = shouldMatch;
      }
      if (lastCommon) {
        if (filter) {
          return filter(lastCommon, lastCommonIndex, ancestries);
        } else {
          return lastCommon;
        }
      } else {
        throw new Error("Couldn't find intersection");
      }
    }
    function getAncestry() {
      let path = this;
      const paths = [];
      do {
        paths.push(path);
      } while (path = path.parentPath);
      return paths;
    }
    function isAncestor(maybeDescendant) {
      return maybeDescendant.isDescendant(this);
    }
    function isDescendant(maybeAncestor) {
      return !!this.findParent((parent) => parent === maybeAncestor);
    }
    function inType(...candidateTypes) {
      let path = this;
      while (path) {
        if (candidateTypes.includes(path.node.type)) return true;
        path = path.parentPath;
      }
      return false;
    }
  }
});

// node_modules/@babel/core/node_modules/@babel/traverse/lib/path/inference/util.js
var require_util2 = __commonJS({
  "node_modules/@babel/core/node_modules/@babel/traverse/lib/path/inference/util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.createUnionType = createUnionType;
    var _t = require("@babel/types");
    var {
      createFlowUnionType,
      createTSUnionType,
      createUnionTypeAnnotation,
      isFlowType,
      isTSType: isTSType2
    } = _t;
    function createUnionType(types) {
      {
        if (types.every((v) => isFlowType(v))) {
          if (createFlowUnionType) {
            return createFlowUnionType(types);
          }
          return createUnionTypeAnnotation(types);
        } else if (types.every((v) => isTSType2(v))) {
          if (createTSUnionType) {
            return createTSUnionType(types);
          }
        }
      }
    }
  }
});

// node_modules/@babel/core/node_modules/@babel/traverse/lib/path/inference/inferer-reference.js
var require_inferer_reference2 = __commonJS({
  "node_modules/@babel/core/node_modules/@babel/traverse/lib/path/inference/inferer-reference.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = _default;
    var _t = require("@babel/types");
    var _util = require_util2();
    var {
      BOOLEAN_NUMBER_BINARY_OPERATORS,
      createTypeAnnotationBasedOnTypeof,
      numberTypeAnnotation,
      voidTypeAnnotation
    } = _t;
    function _default(node) {
      if (!this.isReferenced()) return;
      const binding = this.scope.getBinding(node.name);
      if (binding) {
        if (binding.identifier.typeAnnotation) {
          return binding.identifier.typeAnnotation;
        } else {
          return getTypeAnnotationBindingConstantViolations(binding, this, node.name);
        }
      }
      if (node.name === "undefined") {
        return voidTypeAnnotation();
      } else if (node.name === "NaN" || node.name === "Infinity") {
        return numberTypeAnnotation();
      } else if (node.name === "arguments") {
      }
    }
    function getTypeAnnotationBindingConstantViolations(binding, path, name) {
      const types = [];
      const functionConstantViolations = [];
      let constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);
      const testType = getConditionalAnnotation(binding, path, name);
      if (testType) {
        const testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);
        constantViolations = constantViolations.filter((path2) => !testConstantViolations.includes(path2));
        types.push(testType.typeAnnotation);
      }
      if (constantViolations.length) {
        constantViolations.push(...functionConstantViolations);
        for (const violation of constantViolations) {
          types.push(violation.getTypeAnnotation());
        }
      }
      if (!types.length) {
        return;
      }
      return (0, _util.createUnionType)(types);
    }
    function getConstantViolationsBefore(binding, path, functions) {
      const violations = binding.constantViolations.slice();
      violations.unshift(binding.path);
      return violations.filter((violation) => {
        violation = violation.resolve();
        const status = violation._guessExecutionStatusRelativeTo(path);
        if (functions && status === "unknown") functions.push(violation);
        return status === "before";
      });
    }
    function inferAnnotationFromBinaryExpression(name, path) {
      const operator = path.node.operator;
      const right = path.get("right").resolve();
      const left = path.get("left").resolve();
      let target;
      if (left.isIdentifier({
        name
      })) {
        target = right;
      } else if (right.isIdentifier({
        name
      })) {
        target = left;
      }
      if (target) {
        if (operator === "===") {
          return target.getTypeAnnotation();
        }
        if (BOOLEAN_NUMBER_BINARY_OPERATORS.includes(operator)) {
          return numberTypeAnnotation();
        }
        return;
      }
      if (operator !== "===" && operator !== "==") return;
      let typeofPath;
      let typePath;
      if (left.isUnaryExpression({
        operator: "typeof"
      })) {
        typeofPath = left;
        typePath = right;
      } else if (right.isUnaryExpression({
        operator: "typeof"
      })) {
        typeofPath = right;
        typePath = left;
      }
      if (!typeofPath) return;
      if (!typeofPath.get("argument").isIdentifier({
        name
      })) return;
      typePath = typePath.resolve();
      if (!typePath.isLiteral()) return;
      const typeValue = typePath.node.value;
      if (typeof typeValue !== "string") return;
      return createTypeAnnotationBasedOnTypeof(typeValue);
    }
    function getParentConditionalPath(binding, path, name) {
      let parentPath;
      while (parentPath = path.parentPath) {
        if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {
          if (path.key === "test") {
            return;
          }
          return parentPath;
        }
        if (parentPath.isFunction()) {
          if (parentPath.parentPath.scope.getBinding(name) !== binding) return;
        }
        path = parentPath;
      }
    }
    function getConditionalAnnotation(binding, path, name) {
      const ifStatement3 = getParentConditionalPath(binding, path, name);
      if (!ifStatement3) return;
      const test = ifStatement3.get("test");
      const paths = [test];
      const types = [];
      for (let i = 0; i < paths.length; i++) {
        const path2 = paths[i];
        if (path2.isLogicalExpression()) {
          if (path2.node.operator === "&&") {
            paths.push(path2.get("left"));
            paths.push(path2.get("right"));
          }
        } else if (path2.isBinaryExpression()) {
          const type = inferAnnotationFromBinaryExpression(name, path2);
          if (type) types.push(type);
        }
      }
      if (types.length) {
        return {
          typeAnnotation: (0, _util.createUnionType)(types),
          ifStatement: ifStatement3
        };
      }
      return getConditionalAnnotation(binding, ifStatement3, name);
    }
  }
});

// node_modules/@babel/core/node_modules/@babel/traverse/lib/path/inference/inferers.js
var require_inferers2 = __commonJS({
  "node_modules/@babel/core/node_modules/@babel/traverse/lib/path/inference/inferers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ArrayExpression = ArrayExpression6;
    exports2.AssignmentExpression = AssignmentExpression;
    exports2.BinaryExpression = BinaryExpression;
    exports2.BooleanLiteral = BooleanLiteral;
    exports2.CallExpression = CallExpression4;
    exports2.ConditionalExpression = ConditionalExpression;
    exports2.ClassDeclaration = exports2.ClassExpression = exports2.FunctionDeclaration = exports2.ArrowFunctionExpression = exports2.FunctionExpression = Func;
    Object.defineProperty(exports2, "Identifier", {
      enumerable: true,
      get: function() {
        return _infererReference.default;
      }
    });
    exports2.LogicalExpression = LogicalExpression;
    exports2.NewExpression = NewExpression;
    exports2.NullLiteral = NullLiteral;
    exports2.NumericLiteral = NumericLiteral;
    exports2.ObjectExpression = ObjectExpression;
    exports2.ParenthesizedExpression = ParenthesizedExpression;
    exports2.RegExpLiteral = RegExpLiteral;
    exports2.RestElement = RestElement;
    exports2.SequenceExpression = SequenceExpression;
    exports2.StringLiteral = StringLiteral;
    exports2.TSAsExpression = TSAsExpression;
    exports2.TSNonNullExpression = TSNonNullExpression;
    exports2.TaggedTemplateExpression = TaggedTemplateExpression;
    exports2.TemplateLiteral = TemplateLiteral;
    exports2.TypeCastExpression = TypeCastExpression;
    exports2.UnaryExpression = UnaryExpression;
    exports2.UpdateExpression = UpdateExpression;
    exports2.VariableDeclarator = VariableDeclarator;
    var _t = require("@babel/types");
    var _infererReference = require_inferer_reference2();
    var _util = require_util2();
    var {
      BOOLEAN_BINARY_OPERATORS,
      BOOLEAN_UNARY_OPERATORS,
      NUMBER_BINARY_OPERATORS,
      NUMBER_UNARY_OPERATORS,
      STRING_UNARY_OPERATORS,
      anyTypeAnnotation,
      arrayTypeAnnotation,
      booleanTypeAnnotation,
      buildMatchMemberExpression,
      genericTypeAnnotation,
      identifier: identifier4,
      nullLiteralTypeAnnotation,
      numberTypeAnnotation,
      stringTypeAnnotation,
      tupleTypeAnnotation,
      unionTypeAnnotation,
      voidTypeAnnotation,
      isIdentifier
    } = _t;
    function VariableDeclarator() {
      if (!this.get("id").isIdentifier()) return;
      return this.get("init").getTypeAnnotation();
    }
    function TypeCastExpression(node) {
      return node.typeAnnotation;
    }
    TypeCastExpression.validParent = true;
    function TSAsExpression(node) {
      return node.typeAnnotation;
    }
    TSAsExpression.validParent = true;
    function TSNonNullExpression() {
      return this.get("expression").getTypeAnnotation();
    }
    function NewExpression(node) {
      if (node.callee.type === "Identifier") {
        return genericTypeAnnotation(node.callee);
      }
    }
    function TemplateLiteral() {
      return stringTypeAnnotation();
    }
    function UnaryExpression(node) {
      const operator = node.operator;
      if (operator === "void") {
        return voidTypeAnnotation();
      } else if (NUMBER_UNARY_OPERATORS.includes(operator)) {
        return numberTypeAnnotation();
      } else if (STRING_UNARY_OPERATORS.includes(operator)) {
        return stringTypeAnnotation();
      } else if (BOOLEAN_UNARY_OPERATORS.includes(operator)) {
        return booleanTypeAnnotation();
      }
    }
    function BinaryExpression(node) {
      const operator = node.operator;
      if (NUMBER_BINARY_OPERATORS.includes(operator)) {
        return numberTypeAnnotation();
      } else if (BOOLEAN_BINARY_OPERATORS.includes(operator)) {
        return booleanTypeAnnotation();
      } else if (operator === "+") {
        const right = this.get("right");
        const left = this.get("left");
        if (left.isBaseType("number") && right.isBaseType("number")) {
          return numberTypeAnnotation();
        } else if (left.isBaseType("string") || right.isBaseType("string")) {
          return stringTypeAnnotation();
        }
        return unionTypeAnnotation([stringTypeAnnotation(), numberTypeAnnotation()]);
      }
    }
    function LogicalExpression() {
      const argumentTypes = [this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()];
      return (0, _util.createUnionType)(argumentTypes);
    }
    function ConditionalExpression() {
      const argumentTypes = [this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()];
      return (0, _util.createUnionType)(argumentTypes);
    }
    function SequenceExpression() {
      return this.get("expressions").pop().getTypeAnnotation();
    }
    function ParenthesizedExpression() {
      return this.get("expression").getTypeAnnotation();
    }
    function AssignmentExpression() {
      return this.get("right").getTypeAnnotation();
    }
    function UpdateExpression(node) {
      const operator = node.operator;
      if (operator === "++" || operator === "--") {
        return numberTypeAnnotation();
      }
    }
    function StringLiteral() {
      return stringTypeAnnotation();
    }
    function NumericLiteral() {
      return numberTypeAnnotation();
    }
    function BooleanLiteral() {
      return booleanTypeAnnotation();
    }
    function NullLiteral() {
      return nullLiteralTypeAnnotation();
    }
    function RegExpLiteral() {
      return genericTypeAnnotation(identifier4("RegExp"));
    }
    function ObjectExpression() {
      return genericTypeAnnotation(identifier4("Object"));
    }
    function ArrayExpression6() {
      return genericTypeAnnotation(identifier4("Array"));
    }
    function RestElement() {
      return ArrayExpression6();
    }
    RestElement.validParent = true;
    function Func() {
      return genericTypeAnnotation(identifier4("Function"));
    }
    var isArrayFrom = buildMatchMemberExpression("Array.from");
    var isObjectKeys = buildMatchMemberExpression("Object.keys");
    var isObjectValues = buildMatchMemberExpression("Object.values");
    var isObjectEntries = buildMatchMemberExpression("Object.entries");
    function CallExpression4() {
      const {
        callee
      } = this.node;
      if (isObjectKeys(callee)) {
        return arrayTypeAnnotation(stringTypeAnnotation());
      } else if (isArrayFrom(callee) || isObjectValues(callee) || isIdentifier(callee, {
        name: "Array"
      })) {
        return arrayTypeAnnotation(anyTypeAnnotation());
      } else if (isObjectEntries(callee)) {
        return arrayTypeAnnotation(tupleTypeAnnotation([stringTypeAnnotation(), anyTypeAnnotation()]));
      }
      return resolveCall(this.get("callee"));
    }
    function TaggedTemplateExpression() {
      return resolveCall(this.get("tag"));
    }
    function resolveCall(callee) {
      callee = callee.resolve();
      if (callee.isFunction()) {
        const {
          node
        } = callee;
        if (node.async) {
          if (node.generator) {
            return genericTypeAnnotation(identifier4("AsyncIterator"));
          } else {
            return genericTypeAnnotation(identifier4("Promise"));
          }
        } else {
          if (node.generator) {
            return genericTypeAnnotation(identifier4("Iterator"));
          } else if (callee.node.returnType) {
            return callee.node.returnType;
          } else {
          }
        }
      }
    }
  }
});

// node_modules/@babel/core/node_modules/@babel/traverse/lib/path/inference/index.js
var require_inference2 = __commonJS({
  "node_modules/@babel/core/node_modules/@babel/traverse/lib/path/inference/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2._getTypeAnnotation = _getTypeAnnotation;
    exports2.baseTypeStrictlyMatches = baseTypeStrictlyMatches;
    exports2.couldBeBaseType = couldBeBaseType;
    exports2.getTypeAnnotation = getTypeAnnotation;
    exports2.isBaseType = isBaseType;
    exports2.isGenericType = isGenericType;
    var inferers = require_inferers2();
    var _t = require("@babel/types");
    var {
      anyTypeAnnotation,
      isAnyTypeAnnotation,
      isArrayTypeAnnotation,
      isBooleanTypeAnnotation,
      isEmptyTypeAnnotation,
      isFlowBaseAnnotation,
      isGenericTypeAnnotation,
      isIdentifier,
      isMixedTypeAnnotation,
      isNumberTypeAnnotation,
      isStringTypeAnnotation,
      isTSArrayType,
      isTSTypeAnnotation,
      isTSTypeReference,
      isTupleTypeAnnotation,
      isTypeAnnotation,
      isUnionTypeAnnotation,
      isVoidTypeAnnotation,
      stringTypeAnnotation,
      voidTypeAnnotation
    } = _t;
    function getTypeAnnotation() {
      let type = this.getData("typeAnnotation");
      if (type != null) {
        return type;
      }
      type = _getTypeAnnotation.call(this) || anyTypeAnnotation();
      if (isTypeAnnotation(type) || isTSTypeAnnotation(type)) {
        type = type.typeAnnotation;
      }
      this.setData("typeAnnotation", type);
      return type;
    }
    var typeAnnotationInferringNodes = /* @__PURE__ */ new WeakSet();
    function _getTypeAnnotation() {
      const node = this.node;
      if (!node) {
        if (this.key === "init" && this.parentPath.isVariableDeclarator()) {
          const declar = this.parentPath.parentPath;
          const declarParent = declar.parentPath;
          if (declar.key === "left" && declarParent.isForInStatement()) {
            return stringTypeAnnotation();
          }
          if (declar.key === "left" && declarParent.isForOfStatement()) {
            return anyTypeAnnotation();
          }
          return voidTypeAnnotation();
        } else {
          return;
        }
      }
      if (node.typeAnnotation) {
        return node.typeAnnotation;
      }
      if (typeAnnotationInferringNodes.has(node)) {
        return;
      }
      typeAnnotationInferringNodes.add(node);
      try {
        var _inferer;
        let inferer = inferers[node.type];
        if (inferer) {
          return inferer.call(this, node);
        }
        inferer = inferers[this.parentPath.type];
        if ((_inferer = inferer) != null && _inferer.validParent) {
          return this.parentPath.getTypeAnnotation();
        }
      } finally {
        typeAnnotationInferringNodes.delete(node);
      }
    }
    function isBaseType(baseName, soft) {
      return _isBaseType(baseName, this.getTypeAnnotation(), soft);
    }
    function _isBaseType(baseName, type, soft) {
      if (baseName === "string") {
        return isStringTypeAnnotation(type);
      } else if (baseName === "number") {
        return isNumberTypeAnnotation(type);
      } else if (baseName === "boolean") {
        return isBooleanTypeAnnotation(type);
      } else if (baseName === "any") {
        return isAnyTypeAnnotation(type);
      } else if (baseName === "mixed") {
        return isMixedTypeAnnotation(type);
      } else if (baseName === "empty") {
        return isEmptyTypeAnnotation(type);
      } else if (baseName === "void") {
        return isVoidTypeAnnotation(type);
      } else {
        if (soft) {
          return false;
        } else {
          throw new Error(`Unknown base type ${baseName}`);
        }
      }
    }
    function couldBeBaseType(name) {
      const type = this.getTypeAnnotation();
      if (isAnyTypeAnnotation(type)) return true;
      if (isUnionTypeAnnotation(type)) {
        for (const type2 of type.types) {
          if (isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) {
            return true;
          }
        }
        return false;
      } else {
        return _isBaseType(name, type, true);
      }
    }
    function baseTypeStrictlyMatches(rightArg) {
      const left = this.getTypeAnnotation();
      const right = rightArg.getTypeAnnotation();
      if (!isAnyTypeAnnotation(left) && isFlowBaseAnnotation(left)) {
        return right.type === left.type;
      }
      return false;
    }
    function isGenericType(genericName) {
      const type = this.getTypeAnnotation();
      if (genericName === "Array") {
        if (isTSArrayType(type) || isArrayTypeAnnotation(type) || isTupleTypeAnnotation(type)) {
          return true;
        }
      }
      return isGenericTypeAnnotation(type) && isIdentifier(type.id, {
        name: genericName
      }) || isTSTypeReference(type) && isIdentifier(type.typeName, {
        name: genericName
      });
    }
  }
});

// node_modules/@babel/core/node_modules/@babel/traverse/lib/path/lib/removal-hooks.js
var require_removal_hooks2 = __commonJS({
  "node_modules/@babel/core/node_modules/@babel/traverse/lib/path/lib/removal-hooks.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.hooks = void 0;
    var hooks = exports2.hooks = [function(self2, parent) {
      const removeParent = self2.key === "test" && (parent.isWhile() || parent.isSwitchCase()) || self2.key === "declaration" && parent.isExportDeclaration() || self2.key === "body" && parent.isLabeledStatement() || self2.listKey === "declarations" && parent.isVariableDeclaration() && parent.node.declarations.length === 1 || self2.key === "expression" && parent.isExpressionStatement();
      if (removeParent) {
        parent.remove();
        return true;
      }
    }, function(self2, parent) {
      if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {
        parent.replaceWith(parent.node.expressions[0]);
        return true;
      }
    }, function(self2, parent) {
      if (parent.isBinary()) {
        if (self2.key === "left") {
          parent.replaceWith(parent.node.right);
        } else {
          parent.replaceWith(parent.node.left);
        }
        return true;
      }
    }, function(self2, parent) {
      if (parent.isIfStatement() && self2.key === "consequent" || self2.key === "body" && (parent.isLoop() || parent.isArrowFunctionExpression())) {
        self2.replaceWith({
          type: "BlockStatement",
          body: []
        });
        return true;
      }
    }];
  }
});

// node_modules/@babel/core/node_modules/@babel/traverse/lib/path/removal.js
var require_removal2 = __commonJS({
  "node_modules/@babel/core/node_modules/@babel/traverse/lib/path/removal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2._assertUnremoved = _assertUnremoved;
    exports2._callRemovalHooks = _callRemovalHooks;
    exports2._markRemoved = _markRemoved;
    exports2._remove = _remove;
    exports2._removeFromScope = _removeFromScope;
    exports2.remove = remove;
    var _removalHooks = require_removal_hooks2();
    var _cache = require_cache2();
    var _replacement = require_replacement2();
    var _index = require_path2();
    var _t = require("@babel/types");
    var _modification = require_modification2();
    var _context3 = require_context4();
    var {
      getBindingIdentifiers
    } = _t;
    function remove() {
      var _this$opts;
      _assertUnremoved.call(this);
      _context3.resync.call(this);
      if (_callRemovalHooks.call(this)) {
        _markRemoved.call(this);
        return;
      }
      if (!((_this$opts = this.opts) != null && _this$opts.noScope)) {
        _removeFromScope.call(this);
      }
      this.shareCommentsWithSiblings();
      _remove.call(this);
      _markRemoved.call(this);
    }
    function _removeFromScope() {
      const bindings = getBindingIdentifiers(this.node, false, false, true);
      Object.keys(bindings).forEach((name) => this.scope.removeBinding(name));
    }
    function _callRemovalHooks() {
      if (this.parentPath) {
        for (const fn of _removalHooks.hooks) {
          if (fn(this, this.parentPath)) return true;
        }
      }
    }
    function _remove() {
      if (Array.isArray(this.container)) {
        this.container.splice(this.key, 1);
        _modification.updateSiblingKeys.call(this, this.key, -1);
      } else {
        _replacement._replaceWith.call(this, null);
      }
    }
    function _markRemoved() {
      this._traverseFlags |= _index.SHOULD_SKIP | _index.REMOVED;
      if (this.parent) {
        (0, _cache.getCachedPaths)(this.hub, this.parent).delete(this.node);
      }
      this.node = null;
    }
    function _assertUnremoved() {
      if (this.removed) {
        throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
      }
    }
  }
});

// node_modules/@babel/core/node_modules/@babel/traverse/lib/path/lib/hoister.js
var require_hoister2 = __commonJS({
  "node_modules/@babel/core/node_modules/@babel/traverse/lib/path/lib/hoister.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _t = require("@babel/types");
    var _t2 = _t;
    var {
      react
    } = _t;
    var {
      cloneNode: cloneNode2,
      jsxExpressionContainer: jsxExpressionContainer2,
      variableDeclaration: variableDeclaration3,
      variableDeclarator: variableDeclarator3
    } = _t2;
    var referenceVisitor = {
      ReferencedIdentifier(path, state) {
        if (path.isJSXIdentifier() && react.isCompatTag(path.node.name) && !path.parentPath.isJSXMemberExpression()) {
          return;
        }
        if (path.node.name === "this") {
          let scope = path.scope;
          do {
            if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {
              break;
            }
          } while (scope = scope.parent);
          if (scope) state.breakOnScopePaths.push(scope.path);
        }
        const binding = path.scope.getBinding(path.node.name);
        if (!binding) return;
        for (const violation of binding.constantViolations) {
          if (violation.scope !== binding.path.scope) {
            state.mutableBinding = true;
            path.stop();
            return;
          }
        }
        if (binding !== state.scope.getBinding(path.node.name)) return;
        state.bindings[path.node.name] = binding;
      }
    };
    var PathHoister = class {
      constructor(path, scope) {
        this.breakOnScopePaths = void 0;
        this.bindings = void 0;
        this.mutableBinding = void 0;
        this.scopes = void 0;
        this.scope = void 0;
        this.path = void 0;
        this.attachAfter = void 0;
        this.breakOnScopePaths = [];
        this.bindings = {};
        this.mutableBinding = false;
        this.scopes = [];
        this.scope = scope;
        this.path = path;
        this.attachAfter = false;
      }
      isCompatibleScope(scope) {
        for (const key2 of Object.keys(this.bindings)) {
          const binding = this.bindings[key2];
          if (!scope.bindingIdentifierEquals(key2, binding.identifier)) {
            return false;
          }
        }
        return true;
      }
      getCompatibleScopes() {
        let scope = this.path.scope;
        do {
          if (this.isCompatibleScope(scope)) {
            this.scopes.push(scope);
          } else {
            break;
          }
          if (this.breakOnScopePaths.includes(scope.path)) {
            break;
          }
        } while (scope = scope.parent);
      }
      getAttachmentPath() {
        let path = this._getAttachmentPath();
        if (!path) return;
        let targetScope = path.scope;
        if (targetScope.path === path) {
          targetScope = path.scope.parent;
        }
        if (targetScope.path.isProgram() || targetScope.path.isFunction()) {
          for (const name of Object.keys(this.bindings)) {
            if (!targetScope.hasOwnBinding(name)) continue;
            const binding = this.bindings[name];
            if (binding.kind === "param" || binding.path.parentKey === "params") {
              continue;
            }
            const bindingParentPath = this.getAttachmentParentForPath(binding.path);
            if (bindingParentPath.key >= path.key) {
              this.attachAfter = true;
              path = binding.path;
              for (const violationPath of binding.constantViolations) {
                if (this.getAttachmentParentForPath(violationPath).key > path.key) {
                  path = violationPath;
                }
              }
            }
          }
        }
        return path;
      }
      _getAttachmentPath() {
        const scopes = this.scopes;
        const scope = scopes.pop();
        if (!scope) return;
        if (scope.path.isFunction()) {
          if (this.hasOwnParamBindings(scope)) {
            if (this.scope === scope) return;
            const bodies = scope.path.get("body").get("body");
            for (let i = 0; i < bodies.length; i++) {
              if (bodies[i].node._blockHoist) continue;
              return bodies[i];
            }
          } else {
            return this.getNextScopeAttachmentParent();
          }
        } else if (scope.path.isProgram()) {
          return this.getNextScopeAttachmentParent();
        }
      }
      getNextScopeAttachmentParent() {
        const scope = this.scopes.pop();
        if (scope) return this.getAttachmentParentForPath(scope.path);
      }
      getAttachmentParentForPath(path) {
        do {
          if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {
            return path;
          }
        } while (path = path.parentPath);
      }
      hasOwnParamBindings(scope) {
        for (const name of Object.keys(this.bindings)) {
          if (!scope.hasOwnBinding(name)) continue;
          const binding = this.bindings[name];
          if (binding.kind === "param" && binding.constant) return true;
        }
        return false;
      }
      run() {
        this.path.traverse(referenceVisitor, this);
        if (this.mutableBinding) return;
        this.getCompatibleScopes();
        const attachTo = this.getAttachmentPath();
        if (!attachTo) return;
        if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;
        let uid = attachTo.scope.generateUidIdentifier("ref");
        const declarator = variableDeclarator3(uid, this.path.node);
        const insertFn = this.attachAfter ? "insertAfter" : "insertBefore";
        const [attached] = attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : variableDeclaration3("var", [declarator])]);
        const parent = this.path.parentPath;
        if (parent.isJSXElement() && this.path.container === parent.node.children) {
          uid = jsxExpressionContainer2(uid);
        }
        this.path.replaceWith(cloneNode2(uid));
        return attachTo.isVariableDeclarator() ? attached.get("init") : attached.get("declarations.0.init");
      }
    };
    exports2.default = PathHoister;
  }
});

// node_modules/@babel/core/node_modules/@babel/traverse/lib/path/modification.js
var require_modification2 = __commonJS({
  "node_modules/@babel/core/node_modules/@babel/traverse/lib/path/modification.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2._containerInsert = _containerInsert;
    exports2._containerInsertAfter = _containerInsertAfter;
    exports2._containerInsertBefore = _containerInsertBefore;
    exports2._verifyNodeList = _verifyNodeList;
    exports2.insertAfter = insertAfter;
    exports2.insertBefore = insertBefore;
    exports2.pushContainer = pushContainer;
    exports2.unshiftContainer = unshiftContainer;
    exports2.updateSiblingKeys = updateSiblingKeys;
    var _cache = require_cache2();
    var _index = require_path2();
    var _context3 = require_context4();
    var _removal = require_removal2();
    var _t = require("@babel/types");
    var _hoister = require_hoister2();
    var {
      arrowFunctionExpression: arrowFunctionExpression2,
      assertExpression,
      assignmentExpression: assignmentExpression2,
      blockStatement: blockStatement3,
      callExpression: callExpression3,
      cloneNode: cloneNode2,
      expressionStatement: expressionStatement2,
      isAssignmentExpression,
      isCallExpression,
      isExportNamedDeclaration,
      isExpression: isExpression2,
      isIdentifier,
      isSequenceExpression,
      isSuper,
      thisExpression
    } = _t;
    function insertBefore(nodes_) {
      _removal._assertUnremoved.call(this);
      const nodes = _verifyNodeList.call(this, nodes_);
      const {
        parentPath,
        parent
      } = this;
      if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || isExportNamedDeclaration(parent) || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {
        return parentPath.insertBefore(nodes);
      } else if (this.isNodeType("Expression") && !this.isJSXElement() || parentPath.isForStatement() && this.key === "init") {
        if (this.node) nodes.push(this.node);
        return this.replaceExpressionWithStatements(nodes);
      } else if (Array.isArray(this.container)) {
        return _containerInsertBefore.call(this, nodes);
      } else if (this.isStatementOrBlock()) {
        const node = this.node;
        const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);
        this.replaceWith(blockStatement3(shouldInsertCurrentNode ? [node] : []));
        return this.unshiftContainer("body", nodes);
      } else {
        throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
      }
    }
    function _containerInsert(from, nodes) {
      updateSiblingKeys.call(this, from, nodes.length);
      const paths = [];
      this.container.splice(from, 0, ...nodes);
      for (let i = 0; i < nodes.length; i++) {
        var _this$context;
        const to = from + i;
        const path = this.getSibling(to);
        paths.push(path);
        if ((_this$context = this.context) != null && _this$context.queue) {
          _context3.pushContext.call(path, this.context);
        }
      }
      const contexts = _context3._getQueueContexts.call(this);
      for (const path of paths) {
        _context3.setScope.call(path);
        path.debug("Inserted.");
        for (const context of contexts) {
          context.maybeQueue(path, true);
        }
      }
      return paths;
    }
    function _containerInsertBefore(nodes) {
      return _containerInsert.call(this, this.key, nodes);
    }
    function _containerInsertAfter(nodes) {
      return _containerInsert.call(this, this.key + 1, nodes);
    }
    var last = (arr) => arr[arr.length - 1];
    function isHiddenInSequenceExpression(path) {
      return isSequenceExpression(path.parent) && (last(path.parent.expressions) !== path.node || isHiddenInSequenceExpression(path.parentPath));
    }
    function isAlmostConstantAssignment(node, scope) {
      if (!isAssignmentExpression(node) || !isIdentifier(node.left)) {
        return false;
      }
      const blockScope = scope.getBlockParent();
      return blockScope.hasOwnBinding(node.left.name) && blockScope.getOwnBinding(node.left.name).constantViolations.length <= 1;
    }
    function insertAfter(nodes_) {
      _removal._assertUnremoved.call(this);
      if (this.isSequenceExpression()) {
        return last(this.get("expressions")).insertAfter(nodes_);
      }
      const nodes = _verifyNodeList.call(this, nodes_);
      const {
        parentPath,
        parent
      } = this;
      if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || isExportNamedDeclaration(parent) || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {
        return parentPath.insertAfter(nodes.map((node) => {
          return isExpression2(node) ? expressionStatement2(node) : node;
        }));
      } else if (this.isNodeType("Expression") && !this.isJSXElement() && !parentPath.isJSXElement() || parentPath.isForStatement() && this.key === "init") {
        const self2 = this;
        if (self2.node) {
          const node = self2.node;
          let {
            scope
          } = this;
          if (scope.path.isPattern()) {
            assertExpression(node);
            self2.replaceWith(callExpression3(arrowFunctionExpression2([], node), []));
            self2.get("callee.body").insertAfter(nodes);
            return [self2];
          }
          if (isHiddenInSequenceExpression(self2)) {
            nodes.unshift(node);
          } else if (isCallExpression(node) && isSuper(node.callee)) {
            nodes.unshift(node);
            nodes.push(thisExpression());
          } else if (isAlmostConstantAssignment(node, scope)) {
            nodes.unshift(node);
            nodes.push(cloneNode2(node.left));
          } else if (scope.isPure(node, true)) {
            nodes.push(node);
          } else {
            if (parentPath.isMethod({
              computed: true,
              key: node
            })) {
              scope = scope.parent;
            }
            const temp = scope.generateDeclaredUidIdentifier();
            nodes.unshift(expressionStatement2(assignmentExpression2("=", cloneNode2(temp), node)));
            nodes.push(expressionStatement2(cloneNode2(temp)));
          }
        }
        return this.replaceExpressionWithStatements(nodes);
      } else if (Array.isArray(this.container)) {
        return _containerInsertAfter.call(this, nodes);
      } else if (this.isStatementOrBlock()) {
        const node = this.node;
        const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);
        this.replaceWith(blockStatement3(shouldInsertCurrentNode ? [node] : []));
        return this.pushContainer("body", nodes);
      } else {
        throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
      }
    }
    function updateSiblingKeys(fromIndex, incrementBy) {
      if (!this.parent) return;
      const paths = (0, _cache.getCachedPaths)(this.hub, this.parent) || [];
      for (const [, path] of paths) {
        if (typeof path.key === "number" && path.container === this.container && path.key >= fromIndex) {
          path.key += incrementBy;
        }
      }
    }
    function _verifyNodeList(nodes) {
      if (!nodes) {
        return [];
      }
      if (!Array.isArray(nodes)) {
        nodes = [nodes];
      }
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        let msg;
        if (!node) {
          msg = "has falsy node";
        } else if (typeof node !== "object") {
          msg = "contains a non-object node";
        } else if (!node.type) {
          msg = "without a type";
        } else if (node instanceof _index.default) {
          msg = "has a NodePath when it expected a raw object";
        }
        if (msg) {
          const type = Array.isArray(node) ? "array" : typeof node;
          throw new Error(`Node list ${msg} with the index of ${i} and type of ${type}`);
        }
      }
      return nodes;
    }
    function unshiftContainer(listKey, nodes) {
      _removal._assertUnremoved.call(this);
      nodes = _verifyNodeList.call(this, nodes);
      const path = _index.default.get({
        parentPath: this,
        parent: this.node,
        container: this.node[listKey],
        listKey,
        key: 0
      }).setContext(this.context);
      return _containerInsertBefore.call(path, nodes);
    }
    function pushContainer(listKey, nodes) {
      _removal._assertUnremoved.call(this);
      const verifiedNodes = _verifyNodeList.call(this, nodes);
      const container = this.node[listKey];
      const path = _index.default.get({
        parentPath: this,
        parent: this.node,
        container,
        listKey,
        key: container.length
      }).setContext(this.context);
      return path.replaceWithMultiple(verifiedNodes);
    }
    {
      exports2.hoist = function hoist(scope = this.scope) {
        const hoister = new _hoister.default(this, scope);
        return hoister.run();
      };
    }
  }
});

// node_modules/@babel/core/node_modules/@babel/traverse/lib/path/replacement.js
var require_replacement2 = __commonJS({
  "node_modules/@babel/core/node_modules/@babel/traverse/lib/path/replacement.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2._replaceWith = _replaceWith;
    exports2.replaceExpressionWithStatements = replaceExpressionWithStatements;
    exports2.replaceInline = replaceInline;
    exports2.replaceWith = replaceWith;
    exports2.replaceWithMultiple = replaceWithMultiple;
    exports2.replaceWithSourceString = replaceWithSourceString;
    var _codeFrame = require_lib3();
    var _index = require_lib9();
    var _index2 = require_path2();
    var _cache = require_cache2();
    var _modification = require_modification2();
    var _parser = require_lib4();
    var _t = require("@babel/types");
    var _context3 = require_context4();
    var {
      FUNCTION_TYPES,
      arrowFunctionExpression: arrowFunctionExpression2,
      assignmentExpression: assignmentExpression2,
      awaitExpression: awaitExpression2,
      blockStatement: blockStatement3,
      buildUndefinedNode,
      callExpression: callExpression3,
      cloneNode: cloneNode2,
      conditionalExpression: conditionalExpression3,
      expressionStatement: expressionStatement2,
      getBindingIdentifiers,
      identifier: identifier4,
      inheritLeadingComments,
      inheritTrailingComments,
      inheritsComments,
      isBlockStatement,
      isEmptyStatement,
      isExpression: isExpression2,
      isExpressionStatement,
      isIfStatement,
      isProgram,
      isStatement: isStatement2,
      isVariableDeclaration: isVariableDeclaration2,
      removeComments,
      returnStatement: returnStatement3,
      sequenceExpression: sequenceExpression2,
      validate: validate2,
      yieldExpression
    } = _t;
    function replaceWithMultiple(nodes) {
      var _getCachedPaths;
      _context3.resync.call(this);
      nodes = _modification._verifyNodeList.call(this, nodes);
      inheritLeadingComments(nodes[0], this.node);
      inheritTrailingComments(nodes[nodes.length - 1], this.node);
      (_getCachedPaths = (0, _cache.getCachedPaths)(this.hub, this.parent)) == null || _getCachedPaths.delete(this.node);
      this.node = this.container[this.key] = null;
      const paths = this.insertAfter(nodes);
      if (this.node) {
        this.requeue();
      } else {
        this.remove();
      }
      return paths;
    }
    function replaceWithSourceString(replacement) {
      _context3.resync.call(this);
      let ast;
      try {
        replacement = `(${replacement})`;
        ast = (0, _parser.parse)(replacement);
      } catch (err) {
        const loc = err.loc;
        if (loc) {
          err.message += " - make sure this is an expression.\n" + (0, _codeFrame.codeFrameColumns)(replacement, {
            start: {
              line: loc.line,
              column: loc.column + 1
            }
          });
          err.code = "BABEL_REPLACE_SOURCE_ERROR";
        }
        throw err;
      }
      const expressionAST = ast.program.body[0].expression;
      _index.default.removeProperties(expressionAST);
      return this.replaceWith(expressionAST);
    }
    function replaceWith(replacementPath) {
      _context3.resync.call(this);
      if (this.removed) {
        throw new Error("You can't replace this node, we've already removed it");
      }
      let replacement = replacementPath instanceof _index2.default ? replacementPath.node : replacementPath;
      if (!replacement) {
        throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
      }
      if (this.node === replacement) {
        return [this];
      }
      if (this.isProgram() && !isProgram(replacement)) {
        throw new Error("You can only replace a Program root node with another Program node");
      }
      if (Array.isArray(replacement)) {
        throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
      }
      if (typeof replacement === "string") {
        throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
      }
      let nodePath = "";
      if (this.isNodeType("Statement") && isExpression2(replacement)) {
        if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement) && !this.parentPath.isExportDefaultDeclaration()) {
          replacement = expressionStatement2(replacement);
          nodePath = "expression";
        }
      }
      if (this.isNodeType("Expression") && isStatement2(replacement)) {
        if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) {
          return this.replaceExpressionWithStatements([replacement]);
        }
      }
      const oldNode = this.node;
      if (oldNode) {
        inheritsComments(replacement, oldNode);
        removeComments(oldNode);
      }
      _replaceWith.call(this, replacement);
      this.type = replacement.type;
      _context3.setScope.call(this);
      this.requeue();
      return [nodePath ? this.get(nodePath) : this];
    }
    function _replaceWith(node) {
      var _getCachedPaths2;
      if (!this.container) {
        throw new ReferenceError("Container is falsy");
      }
      if (this.inList) {
        validate2(this.parent, this.key, [node]);
      } else {
        validate2(this.parent, this.key, node);
      }
      this.debug(`Replace with ${node == null ? void 0 : node.type}`);
      (_getCachedPaths2 = (0, _cache.getCachedPaths)(this.hub, this.parent)) == null || _getCachedPaths2.set(node, this).delete(this.node);
      this.node = this.container[this.key] = node;
    }
    function replaceExpressionWithStatements(nodes) {
      _context3.resync.call(this);
      const declars = [];
      const nodesAsSingleExpression = gatherSequenceExpressions(nodes, declars);
      if (nodesAsSingleExpression) {
        for (const id of declars) this.scope.push({
          id
        });
        return this.replaceWith(nodesAsSingleExpression)[0].get("expressions");
      }
      const functionParent = this.getFunctionParent();
      const isParentAsync = functionParent == null ? void 0 : functionParent.node.async;
      const isParentGenerator = functionParent == null ? void 0 : functionParent.node.generator;
      const container = arrowFunctionExpression2([], blockStatement3(nodes));
      this.replaceWith(callExpression3(container, []));
      const callee = this.get("callee");
      callee.get("body").scope.hoistVariables((id) => this.scope.push({
        id
      }));
      const completionRecords = callee.getCompletionRecords();
      for (const path of completionRecords) {
        if (!path.isExpressionStatement()) continue;
        const loop = path.findParent((path2) => path2.isLoop());
        if (loop) {
          let uid = loop.getData("expressionReplacementReturnUid");
          if (!uid) {
            uid = callee.scope.generateDeclaredUidIdentifier("ret");
            callee.get("body").pushContainer("body", returnStatement3(cloneNode2(uid)));
            loop.setData("expressionReplacementReturnUid", uid);
          } else {
            uid = identifier4(uid.name);
          }
          path.get("expression").replaceWith(assignmentExpression2("=", cloneNode2(uid), path.node.expression));
        } else {
          path.replaceWith(returnStatement3(path.node.expression));
        }
      }
      callee.arrowFunctionToExpression();
      const newCallee = callee;
      const needToAwaitFunction = isParentAsync && _index.default.hasType(this.get("callee.body").node, "AwaitExpression", FUNCTION_TYPES);
      const needToYieldFunction = isParentGenerator && _index.default.hasType(this.get("callee.body").node, "YieldExpression", FUNCTION_TYPES);
      if (needToAwaitFunction) {
        newCallee.set("async", true);
        if (!needToYieldFunction) {
          this.replaceWith(awaitExpression2(this.node));
        }
      }
      if (needToYieldFunction) {
        newCallee.set("generator", true);
        this.replaceWith(yieldExpression(this.node, true));
      }
      return newCallee.get("body.body");
    }
    function gatherSequenceExpressions(nodes, declars) {
      const exprs = [];
      let ensureLastUndefined = true;
      for (const node of nodes) {
        if (!isEmptyStatement(node)) {
          ensureLastUndefined = false;
        }
        if (isExpression2(node)) {
          exprs.push(node);
        } else if (isExpressionStatement(node)) {
          exprs.push(node.expression);
        } else if (isVariableDeclaration2(node)) {
          if (node.kind !== "var") return;
          for (const declar of node.declarations) {
            const bindings = getBindingIdentifiers(declar);
            for (const key2 of Object.keys(bindings)) {
              declars.push(cloneNode2(bindings[key2]));
            }
            if (declar.init) {
              exprs.push(assignmentExpression2("=", declar.id, declar.init));
            }
          }
          ensureLastUndefined = true;
        } else if (isIfStatement(node)) {
          const consequent = node.consequent ? gatherSequenceExpressions([node.consequent], declars) : buildUndefinedNode();
          const alternate = node.alternate ? gatherSequenceExpressions([node.alternate], declars) : buildUndefinedNode();
          if (!consequent || !alternate) return;
          exprs.push(conditionalExpression3(node.test, consequent, alternate));
        } else if (isBlockStatement(node)) {
          const body = gatherSequenceExpressions(node.body, declars);
          if (!body) return;
          exprs.push(body);
        } else if (isEmptyStatement(node)) {
          if (nodes.indexOf(node) === 0) {
            ensureLastUndefined = true;
          }
        } else {
          return;
        }
      }
      if (ensureLastUndefined) exprs.push(buildUndefinedNode());
      if (exprs.length === 1) {
        return exprs[0];
      } else {
        return sequenceExpression2(exprs);
      }
    }
    function replaceInline(nodes) {
      _context3.resync.call(this);
      if (Array.isArray(nodes)) {
        if (Array.isArray(this.container)) {
          nodes = _modification._verifyNodeList.call(this, nodes);
          const paths = _modification._containerInsertAfter.call(this, nodes);
          this.remove();
          return paths;
        } else {
          return this.replaceWithMultiple(nodes);
        }
      } else {
        return this.replaceWith(nodes);
      }
    }
  }
});

// node_modules/@babel/core/node_modules/@babel/traverse/lib/path/evaluation.js
var require_evaluation2 = __commonJS({
  "node_modules/@babel/core/node_modules/@babel/traverse/lib/path/evaluation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.evaluate = evaluate;
    exports2.evaluateTruthy = evaluateTruthy;
    var VALID_OBJECT_CALLEES = ["Number", "String", "Math"];
    var VALID_IDENTIFIER_CALLEES = ["isFinite", "isNaN", "parseFloat", "parseInt", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", null, null];
    var INVALID_METHODS = ["random"];
    function isValidObjectCallee(val) {
      return VALID_OBJECT_CALLEES.includes(val);
    }
    function isValidIdentifierCallee(val) {
      return VALID_IDENTIFIER_CALLEES.includes(val);
    }
    function isInvalidMethod(val) {
      return INVALID_METHODS.includes(val);
    }
    function evaluateTruthy() {
      const res = this.evaluate();
      if (res.confident) return !!res.value;
    }
    function deopt(path, state) {
      if (!state.confident) return;
      state.deoptPath = path;
      state.confident = false;
    }
    var Globals = /* @__PURE__ */ new Map([["undefined", void 0], ["Infinity", Infinity], ["NaN", NaN]]);
    function evaluateCached(path, state) {
      const {
        node
      } = path;
      const {
        seen
      } = state;
      if (seen.has(node)) {
        const existing = seen.get(node);
        if (existing.resolved) {
          return existing.value;
        } else {
          deopt(path, state);
          return;
        }
      } else {
        const item = {
          resolved: false
        };
        seen.set(node, item);
        const val = _evaluate(path, state);
        if (state.confident) {
          item.resolved = true;
          item.value = val;
        }
        return val;
      }
    }
    function _evaluate(path, state) {
      if (!state.confident) return;
      if (path.isSequenceExpression()) {
        const exprs = path.get("expressions");
        return evaluateCached(exprs[exprs.length - 1], state);
      }
      if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) {
        return path.node.value;
      }
      if (path.isNullLiteral()) {
        return null;
      }
      if (path.isTemplateLiteral()) {
        return evaluateQuasis(path, path.node.quasis, state);
      }
      if (path.isTaggedTemplateExpression() && path.get("tag").isMemberExpression()) {
        const object = path.get("tag.object");
        const {
          node: {
            name
          }
        } = object;
        const property = path.get("tag.property");
        if (object.isIdentifier() && name === "String" && !path.scope.getBinding(name) && property.isIdentifier() && property.node.name === "raw") {
          return evaluateQuasis(path, path.node.quasi.quasis, state, true);
        }
      }
      if (path.isConditionalExpression()) {
        const testResult = evaluateCached(path.get("test"), state);
        if (!state.confident) return;
        if (testResult) {
          return evaluateCached(path.get("consequent"), state);
        } else {
          return evaluateCached(path.get("alternate"), state);
        }
      }
      if (path.isExpressionWrapper()) {
        return evaluateCached(path.get("expression"), state);
      }
      if (path.isMemberExpression() && !path.parentPath.isCallExpression({
        callee: path.node
      })) {
        const property = path.get("property");
        const object = path.get("object");
        if (object.isLiteral()) {
          const value = object.node.value;
          const type = typeof value;
          let key2 = null;
          if (path.node.computed) {
            key2 = evaluateCached(property, state);
            if (!state.confident) return;
          } else if (property.isIdentifier()) {
            key2 = property.node.name;
          }
          if ((type === "number" || type === "string") && key2 != null && (typeof key2 === "number" || typeof key2 === "string")) {
            return value[key2];
          }
        }
      }
      if (path.isReferencedIdentifier()) {
        const binding = path.scope.getBinding(path.node.name);
        if (binding) {
          if (binding.constantViolations.length > 0 || path.node.start < binding.path.node.end) {
            deopt(binding.path, state);
            return;
          }
          const bindingPathScope = binding.path.scope;
          if (binding.kind === "var" && bindingPathScope !== binding.scope) {
            let hasUnsafeBlock = !bindingPathScope.path.parentPath.isBlockStatement();
            for (let scope = bindingPathScope.parent; scope; scope = scope.parent) {
              var _scope$path$parentPat;
              if (scope === path.scope) {
                if (hasUnsafeBlock) {
                  deopt(binding.path, state);
                  return;
                }
                break;
              }
              if ((_scope$path$parentPat = scope.path.parentPath) != null && _scope$path$parentPat.isBlockStatement()) {
                hasUnsafeBlock = true;
              }
            }
          }
          if (binding.hasValue) {
            return binding.value;
          }
        }
        const name = path.node.name;
        if (Globals.has(name)) {
          if (!binding) {
            return Globals.get(name);
          }
          deopt(binding.path, state);
          return;
        }
        const resolved = path.resolve();
        if (resolved === path) {
          deopt(path, state);
          return;
        } else {
          return evaluateCached(resolved, state);
        }
      }
      if (path.isUnaryExpression({
        prefix: true
      })) {
        if (path.node.operator === "void") {
          return void 0;
        }
        const argument = path.get("argument");
        if (path.node.operator === "typeof" && (argument.isFunction() || argument.isClass())) {
          return "function";
        }
        const arg = evaluateCached(argument, state);
        if (!state.confident) return;
        switch (path.node.operator) {
          case "!":
            return !arg;
          case "+":
            return +arg;
          case "-":
            return -arg;
          case "~":
            return ~arg;
          case "typeof":
            return typeof arg;
        }
      }
      if (path.isArrayExpression()) {
        const arr = [];
        const elems = path.get("elements");
        for (const elem of elems) {
          const elemValue = elem.evaluate();
          if (elemValue.confident) {
            arr.push(elemValue.value);
          } else {
            deopt(elemValue.deopt, state);
            return;
          }
        }
        return arr;
      }
      if (path.isObjectExpression()) {
        const obj = {};
        const props = path.get("properties");
        for (const prop of props) {
          if (prop.isObjectMethod() || prop.isSpreadElement()) {
            deopt(prop, state);
            return;
          }
          const keyPath = prop.get("key");
          let key2;
          if (prop.node.computed) {
            key2 = keyPath.evaluate();
            if (!key2.confident) {
              deopt(key2.deopt, state);
              return;
            }
            key2 = key2.value;
          } else if (keyPath.isIdentifier()) {
            key2 = keyPath.node.name;
          } else {
            key2 = keyPath.node.value;
          }
          const valuePath = prop.get("value");
          let value = valuePath.evaluate();
          if (!value.confident) {
            deopt(value.deopt, state);
            return;
          }
          value = value.value;
          obj[key2] = value;
        }
        return obj;
      }
      if (path.isLogicalExpression()) {
        const wasConfident = state.confident;
        const left = evaluateCached(path.get("left"), state);
        const leftConfident = state.confident;
        state.confident = wasConfident;
        const right = evaluateCached(path.get("right"), state);
        const rightConfident = state.confident;
        switch (path.node.operator) {
          case "||":
            state.confident = leftConfident && (!!left || rightConfident);
            if (!state.confident) return;
            return left || right;
          case "&&":
            state.confident = leftConfident && (!left || rightConfident);
            if (!state.confident) return;
            return left && right;
          case "??":
            state.confident = leftConfident && (left != null || rightConfident);
            if (!state.confident) return;
            return left != null ? left : right;
        }
      }
      if (path.isBinaryExpression()) {
        const left = evaluateCached(path.get("left"), state);
        if (!state.confident) return;
        const right = evaluateCached(path.get("right"), state);
        if (!state.confident) return;
        switch (path.node.operator) {
          case "-":
            return left - right;
          case "+":
            return left + right;
          case "/":
            return left / right;
          case "*":
            return left * right;
          case "%":
            return left % right;
          case "**":
            return Math.pow(left, right);
          case "<":
            return left < right;
          case ">":
            return left > right;
          case "<=":
            return left <= right;
          case ">=":
            return left >= right;
          case "==":
            return left == right;
          case "!=":
            return left != right;
          case "===":
            return left === right;
          case "!==":
            return left !== right;
          case "|":
            return left | right;
          case "&":
            return left & right;
          case "^":
            return left ^ right;
          case "<<":
            return left << right;
          case ">>":
            return left >> right;
          case ">>>":
            return left >>> right;
        }
      }
      if (path.isCallExpression()) {
        const callee = path.get("callee");
        let context;
        let func;
        if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name) && (isValidObjectCallee(callee.node.name) || isValidIdentifierCallee(callee.node.name))) {
          func = global[callee.node.name];
        }
        if (callee.isMemberExpression()) {
          const object = callee.get("object");
          const property = callee.get("property");
          if (object.isIdentifier() && property.isIdentifier() && isValidObjectCallee(object.node.name) && !isInvalidMethod(property.node.name)) {
            context = global[object.node.name];
            const key2 = property.node.name;
            if (hasOwnProperty.call(context, key2)) {
              func = context[key2];
            }
          }
          if (object.isLiteral() && property.isIdentifier()) {
            const type = typeof object.node.value;
            if (type === "string" || type === "number") {
              context = object.node.value;
              func = context[property.node.name];
            }
          }
        }
        if (func) {
          const args = path.get("arguments").map((arg) => evaluateCached(arg, state));
          if (!state.confident) return;
          return func.apply(context, args);
        }
      }
      deopt(path, state);
    }
    function evaluateQuasis(path, quasis, state, raw = false) {
      let str = "";
      let i = 0;
      const exprs = path.isTemplateLiteral() ? path.get("expressions") : path.get("quasi.expressions");
      for (const elem of quasis) {
        if (!state.confident) break;
        str += raw ? elem.value.raw : elem.value.cooked;
        const expr = exprs[i++];
        if (expr) str += String(evaluateCached(expr, state));
      }
      if (!state.confident) return;
      return str;
    }
    function evaluate() {
      const state = {
        confident: true,
        deoptPath: null,
        seen: /* @__PURE__ */ new Map()
      };
      let value = evaluateCached(this, state);
      if (!state.confident) value = void 0;
      return {
        confident: state.confident,
        deopt: state.deoptPath,
        value
      };
    }
  }
});

// node_modules/@babel/core/node_modules/@babel/traverse/lib/path/conversion.js
var require_conversion2 = __commonJS({
  "node_modules/@babel/core/node_modules/@babel/traverse/lib/path/conversion.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.arrowFunctionToExpression = arrowFunctionToExpression;
    exports2.ensureBlock = ensureBlock;
    exports2.ensureFunctionName = ensureFunctionName;
    exports2.splitExportDeclaration = splitExportDeclaration;
    exports2.toComputedKey = toComputedKey;
    exports2.unwrapFunctionEnvironment = unwrapFunctionEnvironment;
    var _t = require("@babel/types");
    var _template = require_lib5();
    var _visitors = require_visitors2();
    var _context3 = require_context4();
    var {
      arrowFunctionExpression: arrowFunctionExpression2,
      assignmentExpression: assignmentExpression2,
      binaryExpression: binaryExpression2,
      blockStatement: blockStatement3,
      callExpression: callExpression3,
      conditionalExpression: conditionalExpression3,
      expressionStatement: expressionStatement2,
      identifier: identifier4,
      isIdentifier,
      jsxIdentifier: jsxIdentifier2,
      logicalExpression: logicalExpression2,
      LOGICAL_OPERATORS,
      memberExpression: memberExpression2,
      metaProperty: metaProperty2,
      numericLiteral: numericLiteral2,
      objectExpression: objectExpression2,
      restElement: restElement3,
      returnStatement: returnStatement3,
      sequenceExpression: sequenceExpression2,
      spreadElement: spreadElement3,
      stringLiteral: stringLiteral3,
      super: _super,
      thisExpression,
      toExpression,
      unaryExpression: unaryExpression2,
      toBindingIdentifierName,
      isFunction,
      isAssignmentPattern,
      isRestElement,
      getFunctionName: getFunctionName3,
      cloneNode: cloneNode2,
      variableDeclaration: variableDeclaration3,
      variableDeclarator: variableDeclarator3,
      exportNamedDeclaration,
      exportSpecifier,
      inherits
    } = _t;
    function toComputedKey() {
      let key2;
      if (this.isMemberExpression()) {
        key2 = this.node.property;
      } else if (this.isProperty() || this.isMethod()) {
        key2 = this.node.key;
      } else {
        throw new ReferenceError("todo");
      }
      if (!this.node.computed) {
        if (isIdentifier(key2)) key2 = stringLiteral3(key2.name);
      }
      return key2;
    }
    function ensureBlock() {
      const body = this.get("body");
      const bodyNode = body.node;
      if (Array.isArray(body)) {
        throw new Error("Can't convert array path to a block statement");
      }
      if (!bodyNode) {
        throw new Error("Can't convert node without a body");
      }
      if (body.isBlockStatement()) {
        return bodyNode;
      }
      const statements = [];
      let stringPath = "body";
      let key2;
      let listKey;
      if (body.isStatement()) {
        listKey = "body";
        key2 = 0;
        statements.push(body.node);
      } else {
        stringPath += ".body.0";
        if (this.isFunction()) {
          key2 = "argument";
          statements.push(returnStatement3(body.node));
        } else {
          key2 = "expression";
          statements.push(expressionStatement2(body.node));
        }
      }
      this.node.body = blockStatement3(statements);
      const parentPath = this.get(stringPath);
      _context3.setup.call(body, parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key2);
      return this.node;
    }
    {
      exports2.arrowFunctionToShadowed = function() {
        if (!this.isArrowFunctionExpression()) return;
        this.arrowFunctionToExpression();
      };
    }
    function unwrapFunctionEnvironment() {
      if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {
        throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
      }
      hoistFunctionEnvironment(this);
    }
    function setType2(path, type) {
      path.node.type = type;
    }
    function arrowFunctionToExpression({
      allowInsertArrow = true,
      allowInsertArrowWithRest = allowInsertArrow,
      noNewArrows = !((_arguments$) => (_arguments$ = arguments[0]) == null ? void 0 : _arguments$.specCompliant)()
    } = {}) {
      if (!this.isArrowFunctionExpression()) {
        throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
      }
      let self2 = this;
      if (!noNewArrows) {
        var _self$ensureFunctionN;
        self2 = (_self$ensureFunctionN = self2.ensureFunctionName(false)) != null ? _self$ensureFunctionN : self2;
      }
      const {
        thisBinding,
        fnPath: fn
      } = hoistFunctionEnvironment(self2, noNewArrows, allowInsertArrow, allowInsertArrowWithRest);
      fn.ensureBlock();
      setType2(fn, "FunctionExpression");
      if (!noNewArrows) {
        const checkBinding = thisBinding ? null : fn.scope.generateUidIdentifier("arrowCheckId");
        if (checkBinding) {
          fn.parentPath.scope.push({
            id: checkBinding,
            init: objectExpression2([])
          });
        }
        fn.get("body").unshiftContainer("body", expressionStatement2(callExpression3(this.hub.addHelper("newArrowCheck"), [thisExpression(), checkBinding ? identifier4(checkBinding.name) : identifier4(thisBinding)])));
        fn.replaceWith(callExpression3(memberExpression2(fn.node, identifier4("bind")), [checkBinding ? identifier4(checkBinding.name) : thisExpression()]));
        return fn.get("callee.object");
      }
      return fn;
    }
    var getSuperCallsVisitor = (0, _visitors.environmentVisitor)({
      CallExpression(child, {
        allSuperCalls
      }) {
        if (!child.get("callee").isSuper()) return;
        allSuperCalls.push(child);
      }
    });
    function hoistFunctionEnvironment(fnPath, noNewArrows = true, allowInsertArrow = true, allowInsertArrowWithRest = true) {
      let arrowParent;
      let thisEnvFn = fnPath.findParent((p) => {
        if (p.isArrowFunctionExpression()) {
          arrowParent != null ? arrowParent : arrowParent = p;
          return false;
        }
        return p.isFunction() || p.isProgram() || p.isClassProperty({
          static: false
        }) || p.isClassPrivateProperty({
          static: false
        });
      });
      const inConstructor = thisEnvFn.isClassMethod({
        kind: "constructor"
      });
      if (thisEnvFn.isClassProperty() || thisEnvFn.isClassPrivateProperty()) {
        if (arrowParent) {
          thisEnvFn = arrowParent;
        } else if (allowInsertArrow) {
          fnPath.replaceWith(callExpression3(arrowFunctionExpression2([], toExpression(fnPath.node)), []));
          thisEnvFn = fnPath.get("callee");
          fnPath = thisEnvFn.get("body");
        } else {
          throw fnPath.buildCodeFrameError("Unable to transform arrow inside class property");
        }
      }
      const {
        thisPaths,
        argumentsPaths,
        newTargetPaths,
        superProps,
        superCalls
      } = getScopeInformation(fnPath);
      if (inConstructor && superCalls.length > 0) {
        if (!allowInsertArrow) {
          throw superCalls[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super()` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
        }
        if (!allowInsertArrowWithRest) {
          throw superCalls[0].buildCodeFrameError("When using '@babel/plugin-transform-parameters', it's not possible to compile `super()` in an arrow function with default or rest parameters without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
        }
        const allSuperCalls = [];
        thisEnvFn.traverse(getSuperCallsVisitor, {
          allSuperCalls
        });
        const superBinding = getSuperBinding(thisEnvFn);
        allSuperCalls.forEach((superCall) => {
          const callee = identifier4(superBinding);
          callee.loc = superCall.node.callee.loc;
          superCall.get("callee").replaceWith(callee);
        });
      }
      if (argumentsPaths.length > 0) {
        const argumentsBinding = getBinding(thisEnvFn, "arguments", () => {
          const args = () => identifier4("arguments");
          if (thisEnvFn.scope.path.isProgram()) {
            return conditionalExpression3(binaryExpression2("===", unaryExpression2("typeof", args()), stringLiteral3("undefined")), thisEnvFn.scope.buildUndefinedNode(), args());
          } else {
            return args();
          }
        });
        argumentsPaths.forEach((argumentsChild) => {
          const argsRef = identifier4(argumentsBinding);
          argsRef.loc = argumentsChild.node.loc;
          argumentsChild.replaceWith(argsRef);
        });
      }
      if (newTargetPaths.length > 0) {
        const newTargetBinding = getBinding(thisEnvFn, "newtarget", () => metaProperty2(identifier4("new"), identifier4("target")));
        newTargetPaths.forEach((targetChild) => {
          const targetRef = identifier4(newTargetBinding);
          targetRef.loc = targetChild.node.loc;
          targetChild.replaceWith(targetRef);
        });
      }
      if (superProps.length > 0) {
        if (!allowInsertArrow) {
          throw superProps[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super.prop` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
        }
        const flatSuperProps = superProps.reduce((acc, superProp) => acc.concat(standardizeSuperProperty(superProp)), []);
        flatSuperProps.forEach((superProp) => {
          const key2 = superProp.node.computed ? "" : superProp.get("property").node.name;
          const superParentPath = superProp.parentPath;
          const isAssignment = superParentPath.isAssignmentExpression({
            left: superProp.node
          });
          const isCall = superParentPath.isCallExpression({
            callee: superProp.node
          });
          const isTaggedTemplate = superParentPath.isTaggedTemplateExpression({
            tag: superProp.node
          });
          const superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key2);
          const args = [];
          if (superProp.node.computed) {
            args.push(superProp.get("property").node);
          }
          if (isAssignment) {
            const value = superParentPath.node.right;
            args.push(value);
          }
          const call = callExpression3(identifier4(superBinding), args);
          if (isCall) {
            superParentPath.unshiftContainer("arguments", thisExpression());
            superProp.replaceWith(memberExpression2(call, identifier4("call")));
            thisPaths.push(superParentPath.get("arguments.0"));
          } else if (isAssignment) {
            superParentPath.replaceWith(call);
          } else if (isTaggedTemplate) {
            superProp.replaceWith(callExpression3(memberExpression2(call, identifier4("bind"), false), [thisExpression()]));
            thisPaths.push(superProp.get("arguments.0"));
          } else {
            superProp.replaceWith(call);
          }
        });
      }
      let thisBinding;
      if (thisPaths.length > 0 || !noNewArrows) {
        thisBinding = getThisBinding(thisEnvFn, inConstructor);
        if (noNewArrows || inConstructor && hasSuperClass(thisEnvFn)) {
          thisPaths.forEach((thisChild) => {
            const thisRef = thisChild.isJSX() ? jsxIdentifier2(thisBinding) : identifier4(thisBinding);
            thisRef.loc = thisChild.node.loc;
            thisChild.replaceWith(thisRef);
          });
          if (!noNewArrows) thisBinding = null;
        }
      }
      return {
        thisBinding,
        fnPath
      };
    }
    function isLogicalOp(op) {
      return LOGICAL_OPERATORS.includes(op);
    }
    function standardizeSuperProperty(superProp) {
      if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== "=") {
        const assignmentPath = superProp.parentPath;
        const op = assignmentPath.node.operator.slice(0, -1);
        const value = assignmentPath.node.right;
        const isLogicalAssignment = isLogicalOp(op);
        if (superProp.node.computed) {
          const tmp = superProp.scope.generateDeclaredUidIdentifier("tmp");
          const object = superProp.node.object;
          const property = superProp.node.property;
          assignmentPath.get("left").replaceWith(memberExpression2(object, assignmentExpression2("=", tmp, property), true));
          assignmentPath.get("right").replaceWith(rightExpression(isLogicalAssignment ? "=" : op, memberExpression2(object, identifier4(tmp.name), true), value));
        } else {
          const object = superProp.node.object;
          const property = superProp.node.property;
          assignmentPath.get("left").replaceWith(memberExpression2(object, property));
          assignmentPath.get("right").replaceWith(rightExpression(isLogicalAssignment ? "=" : op, memberExpression2(object, identifier4(property.name)), value));
        }
        if (isLogicalAssignment) {
          assignmentPath.replaceWith(logicalExpression2(op, assignmentPath.node.left, assignmentPath.node.right));
        } else {
          assignmentPath.node.operator = "=";
        }
        return [assignmentPath.get("left"), assignmentPath.get("right").get("left")];
      } else if (superProp.parentPath.isUpdateExpression()) {
        const updateExpr = superProp.parentPath;
        const tmp = superProp.scope.generateDeclaredUidIdentifier("tmp");
        const computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier("prop") : null;
        const parts = [assignmentExpression2("=", tmp, memberExpression2(superProp.node.object, computedKey ? assignmentExpression2("=", computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)), assignmentExpression2("=", memberExpression2(superProp.node.object, computedKey ? identifier4(computedKey.name) : superProp.node.property, superProp.node.computed), binaryExpression2(superProp.parentPath.node.operator[0], identifier4(tmp.name), numericLiteral2(1)))];
        if (!superProp.parentPath.node.prefix) {
          parts.push(identifier4(tmp.name));
        }
        updateExpr.replaceWith(sequenceExpression2(parts));
        const left = updateExpr.get("expressions.0.right");
        const right = updateExpr.get("expressions.1.left");
        return [left, right];
      }
      return [superProp];
      function rightExpression(op, left, right) {
        if (op === "=") {
          return assignmentExpression2("=", left, right);
        } else {
          return binaryExpression2(op, left, right);
        }
      }
    }
    function hasSuperClass(thisEnvFn) {
      return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;
    }
    var assignSuperThisVisitor = (0, _visitors.environmentVisitor)({
      CallExpression(child, {
        supers,
        thisBinding
      }) {
        if (!child.get("callee").isSuper()) return;
        if (supers.has(child.node)) return;
        supers.add(child.node);
        child.replaceWithMultiple([child.node, assignmentExpression2("=", identifier4(thisBinding), identifier4("this"))]);
      }
    });
    function getThisBinding(thisEnvFn, inConstructor) {
      return getBinding(thisEnvFn, "this", (thisBinding) => {
        if (!inConstructor || !hasSuperClass(thisEnvFn)) return thisExpression();
        thisEnvFn.traverse(assignSuperThisVisitor, {
          supers: /* @__PURE__ */ new WeakSet(),
          thisBinding
        });
      });
    }
    function getSuperBinding(thisEnvFn) {
      return getBinding(thisEnvFn, "supercall", () => {
        const argsBinding = thisEnvFn.scope.generateUidIdentifier("args");
        return arrowFunctionExpression2([restElement3(argsBinding)], callExpression3(_super(), [spreadElement3(identifier4(argsBinding.name))]));
      });
    }
    function getSuperPropBinding(thisEnvFn, isAssignment, propName) {
      const op = isAssignment ? "set" : "get";
      return getBinding(thisEnvFn, `superprop_${op}:${propName || ""}`, () => {
        const argsList = [];
        let fnBody;
        if (propName) {
          fnBody = memberExpression2(_super(), identifier4(propName));
        } else {
          const method = thisEnvFn.scope.generateUidIdentifier("prop");
          argsList.unshift(method);
          fnBody = memberExpression2(_super(), identifier4(method.name), true);
        }
        if (isAssignment) {
          const valueIdent = thisEnvFn.scope.generateUidIdentifier("value");
          argsList.push(valueIdent);
          fnBody = assignmentExpression2("=", fnBody, identifier4(valueIdent.name));
        }
        return arrowFunctionExpression2(argsList, fnBody);
      });
    }
    function getBinding(thisEnvFn, key2, init) {
      const cacheKey = "binding:" + key2;
      let data = thisEnvFn.getData(cacheKey);
      if (!data) {
        const id = thisEnvFn.scope.generateUidIdentifier(key2);
        data = id.name;
        thisEnvFn.setData(cacheKey, data);
        thisEnvFn.scope.push({
          id,
          init: init(data)
        });
      }
      return data;
    }
    var getScopeInformationVisitor = (0, _visitors.environmentVisitor)({
      ThisExpression(child, {
        thisPaths
      }) {
        thisPaths.push(child);
      },
      JSXIdentifier(child, {
        thisPaths
      }) {
        if (child.node.name !== "this") return;
        if (!child.parentPath.isJSXMemberExpression({
          object: child.node
        }) && !child.parentPath.isJSXOpeningElement({
          name: child.node
        })) {
          return;
        }
        thisPaths.push(child);
      },
      CallExpression(child, {
        superCalls
      }) {
        if (child.get("callee").isSuper()) superCalls.push(child);
      },
      MemberExpression(child, {
        superProps
      }) {
        if (child.get("object").isSuper()) superProps.push(child);
      },
      Identifier(child, {
        argumentsPaths
      }) {
        if (!child.isReferencedIdentifier({
          name: "arguments"
        })) return;
        let curr = child.scope;
        do {
          if (curr.hasOwnBinding("arguments")) {
            curr.rename("arguments");
            return;
          }
          if (curr.path.isFunction() && !curr.path.isArrowFunctionExpression()) {
            break;
          }
        } while (curr = curr.parent);
        argumentsPaths.push(child);
      },
      MetaProperty(child, {
        newTargetPaths
      }) {
        if (!child.get("meta").isIdentifier({
          name: "new"
        })) return;
        if (!child.get("property").isIdentifier({
          name: "target"
        })) return;
        newTargetPaths.push(child);
      }
    });
    function getScopeInformation(fnPath) {
      const thisPaths = [];
      const argumentsPaths = [];
      const newTargetPaths = [];
      const superProps = [];
      const superCalls = [];
      fnPath.traverse(getScopeInformationVisitor, {
        thisPaths,
        argumentsPaths,
        newTargetPaths,
        superProps,
        superCalls
      });
      return {
        thisPaths,
        argumentsPaths,
        newTargetPaths,
        superProps,
        superCalls
      };
    }
    function splitExportDeclaration() {
      if (!this.isExportDeclaration() || this.isExportAllDeclaration()) {
        throw new Error("Only default and named export declarations can be split.");
      }
      if (this.isExportNamedDeclaration() && this.get("specifiers").length > 0) {
        throw new Error("It doesn't make sense to split exported specifiers.");
      }
      const declaration = this.get("declaration");
      if (this.isExportDefaultDeclaration()) {
        const standaloneDeclaration = declaration.isFunctionDeclaration() || declaration.isClassDeclaration();
        const exportExpr = declaration.isFunctionExpression() || declaration.isClassExpression();
        const scope = declaration.isScope() ? declaration.scope.parent : declaration.scope;
        let id = declaration.node.id;
        let needBindingRegistration = false;
        if (!id) {
          needBindingRegistration = true;
          id = scope.generateUidIdentifier("default");
          if (standaloneDeclaration || exportExpr) {
            declaration.node.id = cloneNode2(id);
          }
        } else if (exportExpr && scope.hasBinding(id.name)) {
          needBindingRegistration = true;
          id = scope.generateUidIdentifier(id.name);
        }
        const updatedDeclaration = standaloneDeclaration ? declaration.node : variableDeclaration3("var", [variableDeclarator3(cloneNode2(id), declaration.node)]);
        const updatedExportDeclaration = exportNamedDeclaration(null, [exportSpecifier(cloneNode2(id), identifier4("default"))]);
        this.insertAfter(updatedExportDeclaration);
        this.replaceWith(updatedDeclaration);
        if (needBindingRegistration) {
          scope.registerDeclaration(this);
        }
        return this;
      } else if (this.get("specifiers").length > 0) {
        throw new Error("It doesn't make sense to split exported specifiers.");
      }
      const bindingIdentifiers = declaration.getOuterBindingIdentifiers();
      const specifiers = Object.keys(bindingIdentifiers).map((name) => {
        return exportSpecifier(identifier4(name), identifier4(name));
      });
      const aliasDeclar = exportNamedDeclaration(null, specifiers);
      this.insertAfter(aliasDeclar);
      this.replaceWith(declaration.node);
      return this;
    }
    var refersOuterBindingVisitor = {
      "ReferencedIdentifier|BindingIdentifier"(path, state) {
        if (path.node.name !== state.name) return;
        state.needsRename = true;
        path.stop();
      },
      Scope(path, state) {
        if (path.scope.hasOwnBinding(state.name)) {
          path.skip();
        }
      }
    };
    function ensureFunctionName(supportUnicodeId) {
      if (this.node.id) return this;
      const res = getFunctionName3(this.node, this.parent);
      if (res == null) return this;
      let {
        name
      } = res;
      if (!supportUnicodeId && /[\uD800-\uDFFF]/.test(name)) {
        return null;
      }
      if (name.startsWith("get ") || name.startsWith("set ")) {
        return null;
      }
      name = toBindingIdentifierName(name.replace(/[/ ]/g, "_"));
      const id = identifier4(name);
      inherits(id, res.originalNode);
      const state = {
        needsRename: false,
        name
      };
      const {
        scope
      } = this;
      const binding = scope.getOwnBinding(name);
      if (binding) {
        if (binding.kind === "param") {
          state.needsRename = true;
        } else {
        }
      } else if (scope.parent.hasBinding(name) || scope.hasGlobal(name)) {
        this.traverse(refersOuterBindingVisitor, state);
      }
      if (!state.needsRename) {
        this.node.id = id;
        scope.getProgramParent().references[id.name] = true;
        return this;
      }
      if (scope.hasBinding(id.name) && !scope.hasGlobal(id.name)) {
        scope.rename(id.name);
        this.node.id = id;
        scope.getProgramParent().references[id.name] = true;
        return this;
      }
      if (!isFunction(this.node)) return null;
      const key2 = scope.generateUidIdentifier(id.name);
      const params = [];
      for (let i = 0, len = getFunctionArity(this.node); i < len; i++) {
        params.push(scope.generateUidIdentifier("x"));
      }
      const call = _template.default.expression.ast`
    (function (${key2}) {
      function ${id}(${params}) {
        return ${cloneNode2(key2)}.apply(this, arguments);
      }

      ${cloneNode2(id)}.toString = function () {
        return ${cloneNode2(key2)}.toString();
      }

      return ${cloneNode2(id)};
    })(${toExpression(this.node)})
  `;
      return this.replaceWith(call)[0].get("arguments.0");
    }
    function getFunctionArity(node) {
      const count = node.params.findIndex((param) => isAssignmentPattern(param) || isRestElement(param));
      return count === -1 ? node.params.length : count;
    }
  }
});

// node_modules/@babel/core/node_modules/@babel/traverse/lib/path/introspection.js
var require_introspection2 = __commonJS({
  "node_modules/@babel/core/node_modules/@babel/traverse/lib/path/introspection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2._guessExecutionStatusRelativeTo = _guessExecutionStatusRelativeTo;
    exports2._resolve = _resolve;
    exports2.canHaveVariableDeclarationOrExpression = canHaveVariableDeclarationOrExpression;
    exports2.canSwapBetweenExpressionAndStatement = canSwapBetweenExpressionAndStatement;
    exports2.getSource = getSource;
    exports2.isCompletionRecord = isCompletionRecord;
    exports2.isConstantExpression = isConstantExpression;
    exports2.isInStrictMode = isInStrictMode;
    exports2.isNodeType = isNodeType;
    exports2.isStatementOrBlock = isStatementOrBlock;
    exports2.isStatic = isStatic;
    exports2.matchesPattern = matchesPattern;
    exports2.referencesImport = referencesImport;
    exports2.resolve = resolve;
    exports2.willIMaybeExecuteBefore = willIMaybeExecuteBefore;
    var _t = require("@babel/types");
    var {
      STATEMENT_OR_BLOCK_KEYS,
      VISITOR_KEYS,
      isBlockStatement,
      isExpression: isExpression2,
      isIdentifier,
      isLiteral,
      isStringLiteral,
      isType,
      matchesPattern: _matchesPattern
    } = _t;
    function matchesPattern(pattern, allowPartial) {
      return _matchesPattern(this.node, pattern, allowPartial);
    }
    {
      exports2.has = function has(key2) {
        var _this$node;
        const val = (_this$node = this.node) == null ? void 0 : _this$node[key2];
        if (val && Array.isArray(val)) {
          return !!val.length;
        } else {
          return !!val;
        }
      };
    }
    function isStatic() {
      return this.scope.isStatic(this.node);
    }
    {
      exports2.is = exports2.has;
      exports2.isnt = function isnt(key2) {
        return !this.has(key2);
      };
      exports2.equals = function equals(key2, value) {
        return this.node[key2] === value;
      };
    }
    function isNodeType(type) {
      return isType(this.type, type);
    }
    function canHaveVariableDeclarationOrExpression() {
      return (this.key === "init" || this.key === "left") && this.parentPath.isFor();
    }
    function canSwapBetweenExpressionAndStatement(replacement) {
      if (this.key !== "body" || !this.parentPath.isArrowFunctionExpression()) {
        return false;
      }
      if (this.isExpression()) {
        return isBlockStatement(replacement);
      } else if (this.isBlockStatement()) {
        return isExpression2(replacement);
      }
      return false;
    }
    function isCompletionRecord(allowInsideFunction) {
      let path = this;
      let first = true;
      do {
        const {
          type,
          container
        } = path;
        if (!first && (path.isFunction() || type === "StaticBlock")) {
          return !!allowInsideFunction;
        }
        first = false;
        if (Array.isArray(container) && path.key !== container.length - 1) {
          return false;
        }
      } while ((path = path.parentPath) && !path.isProgram() && !path.isDoExpression());
      return true;
    }
    function isStatementOrBlock() {
      if (this.parentPath.isLabeledStatement() || isBlockStatement(this.container)) {
        return false;
      } else {
        return STATEMENT_OR_BLOCK_KEYS.includes(this.key);
      }
    }
    function referencesImport(moduleSource, importName) {
      if (!this.isReferencedIdentifier()) {
        if (this.isJSXMemberExpression() && this.node.property.name === importName || (this.isMemberExpression() || this.isOptionalMemberExpression()) && (this.node.computed ? isStringLiteral(this.node.property, {
          value: importName
        }) : this.node.property.name === importName)) {
          const object = this.get("object");
          return object.isReferencedIdentifier() && object.referencesImport(moduleSource, "*");
        }
        return false;
      }
      const binding = this.scope.getBinding(this.node.name);
      if (!binding || binding.kind !== "module") return false;
      const path = binding.path;
      const parent = path.parentPath;
      if (!parent.isImportDeclaration()) return false;
      if (parent.node.source.value === moduleSource) {
        if (!importName) return true;
      } else {
        return false;
      }
      if (path.isImportDefaultSpecifier() && importName === "default") {
        return true;
      }
      if (path.isImportNamespaceSpecifier() && importName === "*") {
        return true;
      }
      if (path.isImportSpecifier() && isIdentifier(path.node.imported, {
        name: importName
      })) {
        return true;
      }
      return false;
    }
    function getSource() {
      const node = this.node;
      if (node.end) {
        const code = this.hub.getCode();
        if (code) return code.slice(node.start, node.end);
      }
      return "";
    }
    function willIMaybeExecuteBefore(target) {
      return this._guessExecutionStatusRelativeTo(target) !== "after";
    }
    function getOuterFunction(path) {
      return path.isProgram() ? path : (path.parentPath.scope.getFunctionParent() || path.parentPath.scope.getProgramParent()).path;
    }
    function isExecutionUncertain(type, key2) {
      switch (type) {
        case "LogicalExpression":
          return key2 === "right";
        case "ConditionalExpression":
        case "IfStatement":
          return key2 === "consequent" || key2 === "alternate";
        case "WhileStatement":
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForOfStatement":
          return key2 === "body";
        case "ForStatement":
          return key2 === "body" || key2 === "update";
        case "SwitchStatement":
          return key2 === "cases";
        case "TryStatement":
          return key2 === "handler";
        case "AssignmentPattern":
          return key2 === "right";
        case "OptionalMemberExpression":
          return key2 === "property";
        case "OptionalCallExpression":
          return key2 === "arguments";
        default:
          return false;
      }
    }
    function isExecutionUncertainInList(paths, maxIndex) {
      for (let i = 0; i < maxIndex; i++) {
        const path = paths[i];
        if (isExecutionUncertain(path.parent.type, path.parentKey)) {
          return true;
        }
      }
      return false;
    }
    var SYMBOL_CHECKING = Symbol();
    function _guessExecutionStatusRelativeTo(target) {
      return _guessExecutionStatusRelativeToCached(this, target, /* @__PURE__ */ new Map());
    }
    function _guessExecutionStatusRelativeToCached(base, target, cache) {
      const funcParent = {
        this: getOuterFunction(base),
        target: getOuterFunction(target)
      };
      if (funcParent.target.node !== funcParent.this.node) {
        return _guessExecutionStatusRelativeToDifferentFunctionsCached(base, funcParent.target, cache);
      }
      const paths = {
        target: target.getAncestry(),
        this: base.getAncestry()
      };
      if (paths.target.includes(base)) return "after";
      if (paths.this.includes(target)) return "before";
      let commonPath;
      const commonIndex = {
        target: 0,
        this: 0
      };
      while (!commonPath && commonIndex.this < paths.this.length) {
        const path = paths.this[commonIndex.this];
        commonIndex.target = paths.target.indexOf(path);
        if (commonIndex.target >= 0) {
          commonPath = path;
        } else {
          commonIndex.this++;
        }
      }
      if (!commonPath) {
        throw new Error("Internal Babel error - The two compared nodes don't appear to belong to the same program.");
      }
      if (isExecutionUncertainInList(paths.this, commonIndex.this - 1) || isExecutionUncertainInList(paths.target, commonIndex.target - 1)) {
        return "unknown";
      }
      const divergence = {
        this: paths.this[commonIndex.this - 1],
        target: paths.target[commonIndex.target - 1]
      };
      if (divergence.target.listKey && divergence.this.listKey && divergence.target.container === divergence.this.container) {
        return divergence.target.key > divergence.this.key ? "before" : "after";
      }
      const keys = VISITOR_KEYS[commonPath.type];
      const keyPosition = {
        this: keys.indexOf(divergence.this.parentKey),
        target: keys.indexOf(divergence.target.parentKey)
      };
      return keyPosition.target > keyPosition.this ? "before" : "after";
    }
    function _guessExecutionStatusRelativeToDifferentFunctionsInternal(base, target, cache) {
      if (!target.isFunctionDeclaration()) {
        if (_guessExecutionStatusRelativeToCached(base, target, cache) === "before") {
          return "before";
        }
        return "unknown";
      } else if (target.parentPath.isExportDeclaration()) {
        return "unknown";
      }
      const binding = target.scope.getBinding(target.node.id.name);
      if (!binding.references) return "before";
      const referencePaths = binding.referencePaths;
      let allStatus;
      for (const path of referencePaths) {
        const childOfFunction = !!path.find((path2) => path2.node === target.node);
        if (childOfFunction) continue;
        if (path.key !== "callee" || !path.parentPath.isCallExpression()) {
          return "unknown";
        }
        const status = _guessExecutionStatusRelativeToCached(base, path, cache);
        if (allStatus && allStatus !== status) {
          return "unknown";
        } else {
          allStatus = status;
        }
      }
      return allStatus;
    }
    function _guessExecutionStatusRelativeToDifferentFunctionsCached(base, target, cache) {
      let nodeMap = cache.get(base.node);
      let cached;
      if (!nodeMap) {
        cache.set(base.node, nodeMap = /* @__PURE__ */ new Map());
      } else if (cached = nodeMap.get(target.node)) {
        if (cached === SYMBOL_CHECKING) {
          return "unknown";
        }
        return cached;
      }
      nodeMap.set(target.node, SYMBOL_CHECKING);
      const result = _guessExecutionStatusRelativeToDifferentFunctionsInternal(base, target, cache);
      nodeMap.set(target.node, result);
      return result;
    }
    function resolve(dangerous, resolved) {
      return _resolve.call(this, dangerous, resolved) || this;
    }
    function _resolve(dangerous, resolved) {
      var _resolved;
      if ((_resolved = resolved) != null && _resolved.includes(this)) return;
      resolved = resolved || [];
      resolved.push(this);
      if (this.isVariableDeclarator()) {
        if (this.get("id").isIdentifier()) {
          return this.get("init").resolve(dangerous, resolved);
        } else {
        }
      } else if (this.isReferencedIdentifier()) {
        const binding = this.scope.getBinding(this.node.name);
        if (!binding) return;
        if (!binding.constant) return;
        if (binding.kind === "module") return;
        if (binding.path !== this) {
          const ret = binding.path.resolve(dangerous, resolved);
          if (this.find((parent) => parent.node === ret.node)) return;
          return ret;
        }
      } else if (this.isTypeCastExpression()) {
        return this.get("expression").resolve(dangerous, resolved);
      } else if (dangerous && this.isMemberExpression()) {
        const targetKey = this.toComputedKey();
        if (!isLiteral(targetKey)) return;
        const targetName = targetKey.value;
        const target = this.get("object").resolve(dangerous, resolved);
        if (target.isObjectExpression()) {
          const props = target.get("properties");
          for (const prop of props) {
            if (!prop.isProperty()) continue;
            const key2 = prop.get("key");
            let match = prop.isnt("computed") && key2.isIdentifier({
              name: targetName
            });
            match = match || key2.isLiteral({
              value: targetName
            });
            if (match) return prop.get("value").resolve(dangerous, resolved);
          }
        } else if (target.isArrayExpression() && !isNaN(+targetName)) {
          const elems = target.get("elements");
          const elem = elems[targetName];
          if (elem) return elem.resolve(dangerous, resolved);
        }
      }
    }
    function isConstantExpression() {
      if (this.isIdentifier()) {
        const binding = this.scope.getBinding(this.node.name);
        if (!binding) return false;
        return binding.constant;
      }
      if (this.isLiteral()) {
        if (this.isRegExpLiteral()) {
          return false;
        }
        if (this.isTemplateLiteral()) {
          return this.get("expressions").every((expression) => expression.isConstantExpression());
        }
        return true;
      }
      if (this.isUnaryExpression()) {
        if (this.node.operator !== "void") {
          return false;
        }
        return this.get("argument").isConstantExpression();
      }
      if (this.isBinaryExpression()) {
        const {
          operator
        } = this.node;
        return operator !== "in" && operator !== "instanceof" && this.get("left").isConstantExpression() && this.get("right").isConstantExpression();
      }
      if (this.isMemberExpression()) {
        return !this.node.computed && this.get("object").isIdentifier({
          name: "Symbol"
        }) && !this.scope.hasBinding("Symbol", {
          noGlobals: true
        });
      }
      if (this.isCallExpression()) {
        return this.node.arguments.length === 1 && this.get("callee").matchesPattern("Symbol.for") && !this.scope.hasBinding("Symbol", {
          noGlobals: true
        }) && this.get("arguments")[0].isStringLiteral();
      }
      return false;
    }
    function isInStrictMode() {
      const start = this.isProgram() ? this : this.parentPath;
      const strictParent = start.find((path) => {
        if (path.isProgram({
          sourceType: "module"
        })) return true;
        if (path.isClass()) return true;
        if (path.isArrowFunctionExpression() && !path.get("body").isBlockStatement()) {
          return false;
        }
        let body;
        if (path.isFunction()) {
          body = path.node.body;
        } else if (path.isProgram()) {
          body = path.node;
        } else {
          return false;
        }
        for (const directive2 of body.directives) {
          if (directive2.value.value === "use strict") {
            return true;
          }
        }
      });
      return !!strictParent;
    }
  }
});

// node_modules/@babel/core/node_modules/@babel/traverse/lib/path/family.js
var require_family2 = __commonJS({
  "node_modules/@babel/core/node_modules/@babel/traverse/lib/path/family.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2._getKey = _getKey;
    exports2._getPattern = _getPattern;
    exports2.get = get;
    exports2.getAllNextSiblings = getAllNextSiblings;
    exports2.getAllPrevSiblings = getAllPrevSiblings;
    exports2.getAssignmentIdentifiers = getAssignmentIdentifiers;
    exports2.getBindingIdentifierPaths = getBindingIdentifierPaths;
    exports2.getBindingIdentifiers = getBindingIdentifiers;
    exports2.getCompletionRecords = getCompletionRecords;
    exports2.getNextSibling = getNextSibling;
    exports2.getOpposite = getOpposite;
    exports2.getOuterBindingIdentifierPaths = getOuterBindingIdentifierPaths;
    exports2.getOuterBindingIdentifiers = getOuterBindingIdentifiers;
    exports2.getPrevSibling = getPrevSibling;
    exports2.getSibling = getSibling;
    var _index = require_path2();
    var _t = require("@babel/types");
    var {
      getAssignmentIdentifiers: _getAssignmentIdentifiers,
      getBindingIdentifiers: _getBindingIdentifiers,
      getOuterBindingIdentifiers: _getOuterBindingIdentifiers,
      numericLiteral: numericLiteral2,
      unaryExpression: unaryExpression2
    } = _t;
    var NORMAL_COMPLETION = 0;
    var BREAK_COMPLETION = 1;
    function NormalCompletion(path) {
      return {
        type: NORMAL_COMPLETION,
        path
      };
    }
    function BreakCompletion(path) {
      return {
        type: BREAK_COMPLETION,
        path
      };
    }
    function getOpposite() {
      if (this.key === "left") {
        return this.getSibling("right");
      } else if (this.key === "right") {
        return this.getSibling("left");
      }
      return null;
    }
    function addCompletionRecords(path, records, context) {
      if (path) {
        records.push(..._getCompletionRecords(path, context));
      }
      return records;
    }
    function completionRecordForSwitch(cases, records, context) {
      let lastNormalCompletions = [];
      for (let i = 0; i < cases.length; i++) {
        const casePath = cases[i];
        const caseCompletions = _getCompletionRecords(casePath, context);
        const normalCompletions = [];
        const breakCompletions = [];
        for (const c2 of caseCompletions) {
          if (c2.type === NORMAL_COMPLETION) {
            normalCompletions.push(c2);
          }
          if (c2.type === BREAK_COMPLETION) {
            breakCompletions.push(c2);
          }
        }
        if (normalCompletions.length) {
          lastNormalCompletions = normalCompletions;
        }
        records.push(...breakCompletions);
      }
      records.push(...lastNormalCompletions);
      return records;
    }
    function normalCompletionToBreak(completions) {
      completions.forEach((c2) => {
        c2.type = BREAK_COMPLETION;
      });
    }
    function replaceBreakStatementInBreakCompletion(completions, reachable) {
      completions.forEach((c2) => {
        if (c2.path.isBreakStatement({
          label: null
        })) {
          if (reachable) {
            c2.path.replaceWith(unaryExpression2("void", numericLiteral2(0)));
          } else {
            c2.path.remove();
          }
        }
      });
    }
    function getStatementListCompletion(paths, context) {
      const completions = [];
      if (context.canHaveBreak) {
        let lastNormalCompletions = [];
        for (let i = 0; i < paths.length; i++) {
          const path = paths[i];
          const newContext = Object.assign({}, context, {
            inCaseClause: false
          });
          if (path.isBlockStatement() && (context.inCaseClause || context.shouldPopulateBreak)) {
            newContext.shouldPopulateBreak = true;
          } else {
            newContext.shouldPopulateBreak = false;
          }
          const statementCompletions = _getCompletionRecords(path, newContext);
          if (statementCompletions.length > 0 && statementCompletions.every((c2) => c2.type === BREAK_COMPLETION)) {
            if (lastNormalCompletions.length > 0 && statementCompletions.every((c2) => c2.path.isBreakStatement({
              label: null
            }))) {
              normalCompletionToBreak(lastNormalCompletions);
              completions.push(...lastNormalCompletions);
              if (lastNormalCompletions.some((c2) => c2.path.isDeclaration())) {
                completions.push(...statementCompletions);
                replaceBreakStatementInBreakCompletion(statementCompletions, true);
              }
              replaceBreakStatementInBreakCompletion(statementCompletions, false);
            } else {
              completions.push(...statementCompletions);
              if (!context.shouldPopulateBreak) {
                replaceBreakStatementInBreakCompletion(statementCompletions, true);
              }
            }
            break;
          }
          if (i === paths.length - 1) {
            completions.push(...statementCompletions);
          } else {
            lastNormalCompletions = [];
            for (let i2 = 0; i2 < statementCompletions.length; i2++) {
              const c2 = statementCompletions[i2];
              if (c2.type === BREAK_COMPLETION) {
                completions.push(c2);
              }
              if (c2.type === NORMAL_COMPLETION) {
                lastNormalCompletions.push(c2);
              }
            }
          }
        }
      } else if (paths.length) {
        for (let i = paths.length - 1; i >= 0; i--) {
          const pathCompletions = _getCompletionRecords(paths[i], context);
          if (pathCompletions.length > 1 || pathCompletions.length === 1 && !pathCompletions[0].path.isVariableDeclaration()) {
            completions.push(...pathCompletions);
            break;
          }
        }
      }
      return completions;
    }
    function _getCompletionRecords(path, context) {
      let records = [];
      if (path.isIfStatement()) {
        records = addCompletionRecords(path.get("consequent"), records, context);
        records = addCompletionRecords(path.get("alternate"), records, context);
      } else if (path.isDoExpression() || path.isFor() || path.isWhile() || path.isLabeledStatement()) {
        return addCompletionRecords(path.get("body"), records, context);
      } else if (path.isProgram() || path.isBlockStatement()) {
        return getStatementListCompletion(path.get("body"), context);
      } else if (path.isFunction()) {
        return _getCompletionRecords(path.get("body"), context);
      } else if (path.isTryStatement()) {
        records = addCompletionRecords(path.get("block"), records, context);
        records = addCompletionRecords(path.get("handler"), records, context);
      } else if (path.isCatchClause()) {
        return addCompletionRecords(path.get("body"), records, context);
      } else if (path.isSwitchStatement()) {
        return completionRecordForSwitch(path.get("cases"), records, context);
      } else if (path.isSwitchCase()) {
        return getStatementListCompletion(path.get("consequent"), {
          canHaveBreak: true,
          shouldPopulateBreak: false,
          inCaseClause: true
        });
      } else if (path.isBreakStatement()) {
        records.push(BreakCompletion(path));
      } else {
        records.push(NormalCompletion(path));
      }
      return records;
    }
    function getCompletionRecords() {
      const records = _getCompletionRecords(this, {
        canHaveBreak: false,
        shouldPopulateBreak: false,
        inCaseClause: false
      });
      return records.map((r) => r.path);
    }
    function getSibling(key2) {
      return _index.default.get({
        parentPath: this.parentPath,
        parent: this.parent,
        container: this.container,
        listKey: this.listKey,
        key: key2
      }).setContext(this.context);
    }
    function getPrevSibling() {
      return this.getSibling(this.key - 1);
    }
    function getNextSibling() {
      return this.getSibling(this.key + 1);
    }
    function getAllNextSiblings() {
      let _key = this.key;
      let sibling = this.getSibling(++_key);
      const siblings = [];
      while (sibling.node) {
        siblings.push(sibling);
        sibling = this.getSibling(++_key);
      }
      return siblings;
    }
    function getAllPrevSiblings() {
      let _key = this.key;
      let sibling = this.getSibling(--_key);
      const siblings = [];
      while (sibling.node) {
        siblings.push(sibling);
        sibling = this.getSibling(--_key);
      }
      return siblings;
    }
    function get(key2, context = true) {
      if (context === true) context = this.context;
      const parts = key2.split(".");
      if (parts.length === 1) {
        return _getKey.call(this, key2, context);
      } else {
        return _getPattern.call(this, parts, context);
      }
    }
    function _getKey(key2, context) {
      const node = this.node;
      const container = node[key2];
      if (Array.isArray(container)) {
        return container.map((_, i) => {
          return _index.default.get({
            listKey: key2,
            parentPath: this,
            parent: node,
            container,
            key: i
          }).setContext(context);
        });
      } else {
        return _index.default.get({
          parentPath: this,
          parent: node,
          container: node,
          key: key2
        }).setContext(context);
      }
    }
    function _getPattern(parts, context) {
      let path = this;
      for (const part of parts) {
        if (part === ".") {
          path = path.parentPath;
        } else {
          if (Array.isArray(path)) {
            path = path[part];
          } else {
            path = path.get(part, context);
          }
        }
      }
      return path;
    }
    function getAssignmentIdentifiers() {
      return _getAssignmentIdentifiers(this.node);
    }
    function getBindingIdentifiers(duplicates) {
      return _getBindingIdentifiers(this.node, duplicates);
    }
    function getOuterBindingIdentifiers(duplicates) {
      return _getOuterBindingIdentifiers(this.node, duplicates);
    }
    function getBindingIdentifierPaths(duplicates = false, outerOnly = false) {
      const path = this;
      const search = [path];
      const ids = /* @__PURE__ */ Object.create(null);
      while (search.length) {
        const id = search.shift();
        if (!id) continue;
        if (!id.node) continue;
        const keys = _getBindingIdentifiers.keys[id.node.type];
        if (id.isIdentifier()) {
          if (duplicates) {
            const _ids = ids[id.node.name] = ids[id.node.name] || [];
            _ids.push(id);
          } else {
            ids[id.node.name] = id;
          }
          continue;
        }
        if (id.isExportDeclaration()) {
          const declaration = id.get("declaration");
          if (declaration.isDeclaration()) {
            search.push(declaration);
          }
          continue;
        }
        if (outerOnly) {
          if (id.isFunctionDeclaration()) {
            search.push(id.get("id"));
            continue;
          }
          if (id.isFunctionExpression()) {
            continue;
          }
        }
        if (keys) {
          for (let i = 0; i < keys.length; i++) {
            const key2 = keys[i];
            const child = id.get(key2);
            if (Array.isArray(child)) {
              search.push(...child);
            } else if (child.node) {
              search.push(child);
            }
          }
        }
      }
      return ids;
    }
    function getOuterBindingIdentifierPaths(duplicates = false) {
      return this.getBindingIdentifierPaths(duplicates, true);
    }
  }
});

// node_modules/@babel/core/node_modules/@babel/traverse/lib/path/comments.js
var require_comments2 = __commonJS({
  "node_modules/@babel/core/node_modules/@babel/traverse/lib/path/comments.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.addComment = addComment2;
    exports2.addComments = addComments;
    exports2.shareCommentsWithSiblings = shareCommentsWithSiblings;
    var _t = require("@babel/types");
    var {
      addComment: _addComment,
      addComments: _addComments
    } = _t;
    function shareCommentsWithSiblings() {
      if (typeof this.key === "string") return;
      const node = this.node;
      if (!node) return;
      const trailing = node.trailingComments;
      const leading = node.leadingComments;
      if (!trailing && !leading) return;
      const prev = this.getSibling(this.key - 1);
      const next = this.getSibling(this.key + 1);
      const hasPrev = Boolean(prev.node);
      const hasNext = Boolean(next.node);
      if (hasPrev) {
        if (leading) {
          prev.addComments("trailing", removeIfExisting(leading, prev.node.trailingComments));
        }
        if (trailing && !hasNext) prev.addComments("trailing", trailing);
      }
      if (hasNext) {
        if (trailing) {
          next.addComments("leading", removeIfExisting(trailing, next.node.leadingComments));
        }
        if (leading && !hasPrev) next.addComments("leading", leading);
      }
    }
    function removeIfExisting(list, toRemove) {
      if (!(toRemove != null && toRemove.length)) return list;
      const set = new Set(toRemove);
      return list.filter((el) => {
        return !set.has(el);
      });
    }
    function addComment2(type, content, line2) {
      _addComment(this.node, type, content, line2);
    }
    function addComments(type, comments) {
      _addComments(this.node, type, comments);
    }
  }
});

// node_modules/@babel/core/node_modules/@babel/traverse/lib/path/index.js
var require_path2 = __commonJS({
  "node_modules/@babel/core/node_modules/@babel/traverse/lib/path/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = exports2.SHOULD_STOP = exports2.SHOULD_SKIP = exports2.REMOVED = void 0;
    var virtualTypes = require_virtual_types2();
    var _debug = require_src();
    var _index = require_lib9();
    var _index2 = require_scope2();
    var _t = require("@babel/types");
    var t6 = _t;
    var cache = require_cache2();
    var _generator = require_lib8();
    var NodePath_ancestry = require_ancestry2();
    var NodePath_inference = require_inference2();
    var NodePath_replacement = require_replacement2();
    var NodePath_evaluation = require_evaluation2();
    var NodePath_conversion = require_conversion2();
    var NodePath_introspection = require_introspection2();
    var _context3 = require_context4();
    var NodePath_context = _context3;
    var NodePath_removal = require_removal2();
    var NodePath_modification = require_modification2();
    var NodePath_family = require_family2();
    var NodePath_comments = require_comments2();
    var NodePath_virtual_types_validator = require_virtual_types_validator2();
    var {
      validate: validate2
    } = _t;
    var debug = _debug("babel");
    var REMOVED = exports2.REMOVED = 1 << 0;
    var SHOULD_STOP = exports2.SHOULD_STOP = 1 << 1;
    var SHOULD_SKIP = exports2.SHOULD_SKIP = 1 << 2;
    var NodePath_Final = exports2.default = class NodePath {
      constructor(hub, parent) {
        this.contexts = [];
        this.state = null;
        this.opts = null;
        this._traverseFlags = 0;
        this.skipKeys = null;
        this.parentPath = null;
        this.container = null;
        this.listKey = null;
        this.key = null;
        this.node = null;
        this.type = null;
        this.parent = parent;
        this.hub = hub;
        this.data = null;
        this.context = null;
        this.scope = null;
      }
      get removed() {
        return (this._traverseFlags & 1) > 0;
      }
      set removed(v) {
        if (v) this._traverseFlags |= 1;
        else this._traverseFlags &= -2;
      }
      get shouldStop() {
        return (this._traverseFlags & 2) > 0;
      }
      set shouldStop(v) {
        if (v) this._traverseFlags |= 2;
        else this._traverseFlags &= -3;
      }
      get shouldSkip() {
        return (this._traverseFlags & 4) > 0;
      }
      set shouldSkip(v) {
        if (v) this._traverseFlags |= 4;
        else this._traverseFlags &= -5;
      }
      static get({
        hub,
        parentPath,
        parent,
        container,
        listKey,
        key: key2
      }) {
        if (!hub && parentPath) {
          hub = parentPath.hub;
        }
        if (!parent) {
          throw new Error("To get a node path the parent needs to exist");
        }
        const targetNode = container[key2];
        const paths = cache.getOrCreateCachedPaths(hub, parent);
        let path = paths.get(targetNode);
        if (!path) {
          path = new NodePath(hub, parent);
          if (targetNode) paths.set(targetNode, path);
        }
        _context3.setup.call(path, parentPath, container, listKey, key2);
        return path;
      }
      getScope(scope) {
        return this.isScope() ? new _index2.default(this) : scope;
      }
      setData(key2, val) {
        if (this.data == null) {
          this.data = /* @__PURE__ */ Object.create(null);
        }
        return this.data[key2] = val;
      }
      getData(key2, def) {
        if (this.data == null) {
          this.data = /* @__PURE__ */ Object.create(null);
        }
        let val = this.data[key2];
        if (val === void 0 && def !== void 0) val = this.data[key2] = def;
        return val;
      }
      hasNode() {
        return this.node != null;
      }
      buildCodeFrameError(msg, Error2 = SyntaxError) {
        return this.hub.buildError(this.node, msg, Error2);
      }
      traverse(visitor, state) {
        (0, _index.default)(this.node, visitor, this.scope, state, this);
      }
      set(key2, node) {
        validate2(this.node, key2, node);
        this.node[key2] = node;
      }
      getPathLocation() {
        const parts = [];
        let path = this;
        do {
          let key2 = path.key;
          if (path.inList) key2 = `${path.listKey}[${key2}]`;
          parts.unshift(key2);
        } while (path = path.parentPath);
        return parts.join(".");
      }
      debug(message) {
        if (!debug.enabled) return;
        debug(`${this.getPathLocation()} ${this.type}: ${message}`);
      }
      toString() {
        return (0, _generator.default)(this.node).code;
      }
      get inList() {
        return !!this.listKey;
      }
      set inList(inList) {
        if (!inList) {
          this.listKey = null;
        }
      }
      get parentKey() {
        return this.listKey || this.key;
      }
    };
    var methods = {
      findParent: NodePath_ancestry.findParent,
      find: NodePath_ancestry.find,
      getFunctionParent: NodePath_ancestry.getFunctionParent,
      getStatementParent: NodePath_ancestry.getStatementParent,
      getEarliestCommonAncestorFrom: NodePath_ancestry.getEarliestCommonAncestorFrom,
      getDeepestCommonAncestorFrom: NodePath_ancestry.getDeepestCommonAncestorFrom,
      getAncestry: NodePath_ancestry.getAncestry,
      isAncestor: NodePath_ancestry.isAncestor,
      isDescendant: NodePath_ancestry.isDescendant,
      inType: NodePath_ancestry.inType,
      getTypeAnnotation: NodePath_inference.getTypeAnnotation,
      isBaseType: NodePath_inference.isBaseType,
      couldBeBaseType: NodePath_inference.couldBeBaseType,
      baseTypeStrictlyMatches: NodePath_inference.baseTypeStrictlyMatches,
      isGenericType: NodePath_inference.isGenericType,
      replaceWithMultiple: NodePath_replacement.replaceWithMultiple,
      replaceWithSourceString: NodePath_replacement.replaceWithSourceString,
      replaceWith: NodePath_replacement.replaceWith,
      replaceExpressionWithStatements: NodePath_replacement.replaceExpressionWithStatements,
      replaceInline: NodePath_replacement.replaceInline,
      evaluateTruthy: NodePath_evaluation.evaluateTruthy,
      evaluate: NodePath_evaluation.evaluate,
      toComputedKey: NodePath_conversion.toComputedKey,
      ensureBlock: NodePath_conversion.ensureBlock,
      unwrapFunctionEnvironment: NodePath_conversion.unwrapFunctionEnvironment,
      arrowFunctionToExpression: NodePath_conversion.arrowFunctionToExpression,
      splitExportDeclaration: NodePath_conversion.splitExportDeclaration,
      ensureFunctionName: NodePath_conversion.ensureFunctionName,
      matchesPattern: NodePath_introspection.matchesPattern,
      isStatic: NodePath_introspection.isStatic,
      isNodeType: NodePath_introspection.isNodeType,
      canHaveVariableDeclarationOrExpression: NodePath_introspection.canHaveVariableDeclarationOrExpression,
      canSwapBetweenExpressionAndStatement: NodePath_introspection.canSwapBetweenExpressionAndStatement,
      isCompletionRecord: NodePath_introspection.isCompletionRecord,
      isStatementOrBlock: NodePath_introspection.isStatementOrBlock,
      referencesImport: NodePath_introspection.referencesImport,
      getSource: NodePath_introspection.getSource,
      willIMaybeExecuteBefore: NodePath_introspection.willIMaybeExecuteBefore,
      _guessExecutionStatusRelativeTo: NodePath_introspection._guessExecutionStatusRelativeTo,
      resolve: NodePath_introspection.resolve,
      isConstantExpression: NodePath_introspection.isConstantExpression,
      isInStrictMode: NodePath_introspection.isInStrictMode,
      isDenylisted: NodePath_context.isDenylisted,
      visit: NodePath_context.visit,
      skip: NodePath_context.skip,
      skipKey: NodePath_context.skipKey,
      stop: NodePath_context.stop,
      setContext: NodePath_context.setContext,
      requeue: NodePath_context.requeue,
      requeueComputedKeyAndDecorators: NodePath_context.requeueComputedKeyAndDecorators,
      remove: NodePath_removal.remove,
      insertBefore: NodePath_modification.insertBefore,
      insertAfter: NodePath_modification.insertAfter,
      unshiftContainer: NodePath_modification.unshiftContainer,
      pushContainer: NodePath_modification.pushContainer,
      getOpposite: NodePath_family.getOpposite,
      getCompletionRecords: NodePath_family.getCompletionRecords,
      getSibling: NodePath_family.getSibling,
      getPrevSibling: NodePath_family.getPrevSibling,
      getNextSibling: NodePath_family.getNextSibling,
      getAllNextSiblings: NodePath_family.getAllNextSiblings,
      getAllPrevSiblings: NodePath_family.getAllPrevSiblings,
      get: NodePath_family.get,
      getAssignmentIdentifiers: NodePath_family.getAssignmentIdentifiers,
      getBindingIdentifiers: NodePath_family.getBindingIdentifiers,
      getOuterBindingIdentifiers: NodePath_family.getOuterBindingIdentifiers,
      getBindingIdentifierPaths: NodePath_family.getBindingIdentifierPaths,
      getOuterBindingIdentifierPaths: NodePath_family.getOuterBindingIdentifierPaths,
      shareCommentsWithSiblings: NodePath_comments.shareCommentsWithSiblings,
      addComment: NodePath_comments.addComment,
      addComments: NodePath_comments.addComments
    };
    Object.assign(NodePath_Final.prototype, methods);
    {
      NodePath_Final.prototype.arrowFunctionToShadowed = NodePath_conversion[String("arrowFunctionToShadowed")];
      Object.assign(NodePath_Final.prototype, {
        has: NodePath_introspection[String("has")],
        is: NodePath_introspection[String("is")],
        isnt: NodePath_introspection[String("isnt")],
        equals: NodePath_introspection[String("equals")],
        hoist: NodePath_modification[String("hoist")],
        updateSiblingKeys: NodePath_modification.updateSiblingKeys,
        call: NodePath_context.call,
        isBlacklisted: NodePath_context[String("isBlacklisted")],
        setScope: NodePath_context.setScope,
        resync: NodePath_context.resync,
        popContext: NodePath_context.popContext,
        pushContext: NodePath_context.pushContext,
        setup: NodePath_context.setup,
        setKey: NodePath_context.setKey
      });
    }
    {
      NodePath_Final.prototype._guessExecutionStatusRelativeToDifferentFunctions = NodePath_introspection._guessExecutionStatusRelativeTo;
      NodePath_Final.prototype._guessExecutionStatusRelativeToDifferentFunctions = NodePath_introspection._guessExecutionStatusRelativeTo;
      Object.assign(NodePath_Final.prototype, {
        _getTypeAnnotation: NodePath_inference._getTypeAnnotation,
        _replaceWith: NodePath_replacement._replaceWith,
        _resolve: NodePath_introspection._resolve,
        _call: NodePath_context._call,
        _resyncParent: NodePath_context._resyncParent,
        _resyncKey: NodePath_context._resyncKey,
        _resyncList: NodePath_context._resyncList,
        _resyncRemoved: NodePath_context._resyncRemoved,
        _getQueueContexts: NodePath_context._getQueueContexts,
        _removeFromScope: NodePath_removal._removeFromScope,
        _callRemovalHooks: NodePath_removal._callRemovalHooks,
        _remove: NodePath_removal._remove,
        _markRemoved: NodePath_removal._markRemoved,
        _assertUnremoved: NodePath_removal._assertUnremoved,
        _containerInsert: NodePath_modification._containerInsert,
        _containerInsertBefore: NodePath_modification._containerInsertBefore,
        _containerInsertAfter: NodePath_modification._containerInsertAfter,
        _verifyNodeList: NodePath_modification._verifyNodeList,
        _getKey: NodePath_family._getKey,
        _getPattern: NodePath_family._getPattern
      });
    }
    for (const type of t6.TYPES) {
      const typeKey = `is${type}`;
      const fn = t6[typeKey];
      NodePath_Final.prototype[typeKey] = function(opts) {
        return fn(this.node, opts);
      };
      NodePath_Final.prototype[`assert${type}`] = function(opts) {
        if (!fn(this.node, opts)) {
          throw new TypeError(`Expected node path of type ${type}`);
        }
      };
    }
    Object.assign(NodePath_Final.prototype, NodePath_virtual_types_validator);
    for (const type of Object.keys(virtualTypes)) {
      if (type[0] === "_") continue;
      if (!t6.TYPES.includes(type)) t6.TYPES.push(type);
    }
  }
});

// node_modules/@babel/core/node_modules/@babel/traverse/lib/context.js
var require_context3 = __commonJS({
  "node_modules/@babel/core/node_modules/@babel/traverse/lib/context.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _index = require_path2();
    var _t = require("@babel/types");
    var _context3 = require_context4();
    var {
      VISITOR_KEYS
    } = _t;
    var TraversalContext = class {
      constructor(scope, opts, state, parentPath) {
        this.queue = null;
        this.priorityQueue = null;
        this.parentPath = parentPath;
        this.scope = scope;
        this.state = state;
        this.opts = opts;
      }
      shouldVisit(node) {
        const opts = this.opts;
        if (opts.enter || opts.exit) return true;
        if (opts[node.type]) return true;
        const keys = VISITOR_KEYS[node.type];
        if (!(keys != null && keys.length)) return false;
        for (const key2 of keys) {
          if (node[key2]) {
            return true;
          }
        }
        return false;
      }
      create(node, container, key2, listKey) {
        return _index.default.get({
          parentPath: this.parentPath,
          parent: node,
          container,
          key: key2,
          listKey
        });
      }
      maybeQueue(path, notPriority) {
        if (this.queue) {
          if (notPriority) {
            this.queue.push(path);
          } else {
            this.priorityQueue.push(path);
          }
        }
      }
      visitMultiple(container, parent, listKey) {
        if (container.length === 0) return false;
        const queue = [];
        for (let key2 = 0; key2 < container.length; key2++) {
          const node = container[key2];
          if (node && this.shouldVisit(node)) {
            queue.push(this.create(parent, container, key2, listKey));
          }
        }
        return this.visitQueue(queue);
      }
      visitSingle(node, key2) {
        if (this.shouldVisit(node[key2])) {
          return this.visitQueue([this.create(node, node, key2)]);
        } else {
          return false;
        }
      }
      visitQueue(queue) {
        this.queue = queue;
        this.priorityQueue = [];
        const visited = /* @__PURE__ */ new WeakSet();
        let stop = false;
        let visitIndex = 0;
        for (; visitIndex < queue.length; ) {
          const path = queue[visitIndex];
          visitIndex++;
          _context3.resync.call(path);
          if (path.contexts.length === 0 || path.contexts[path.contexts.length - 1] !== this) {
            _context3.pushContext.call(path, this);
          }
          if (path.key === null) continue;
          const {
            node
          } = path;
          if (visited.has(node)) continue;
          if (node) visited.add(node);
          if (path.visit()) {
            stop = true;
            break;
          }
          if (this.priorityQueue.length) {
            stop = this.visitQueue(this.priorityQueue);
            this.priorityQueue = [];
            this.queue = queue;
            if (stop) break;
          }
        }
        for (let i = 0; i < visitIndex; i++) {
          _context3.popContext.call(queue[i]);
        }
        this.queue = null;
        return stop;
      }
      visit(node, key2) {
        const nodes = node[key2];
        if (!nodes) return false;
        if (Array.isArray(nodes)) {
          return this.visitMultiple(nodes, node, key2);
        } else {
          return this.visitSingle(node, key2);
        }
      }
    };
    exports2.default = TraversalContext;
  }
});

// node_modules/@babel/core/node_modules/@babel/traverse/lib/traverse-node.js
var require_traverse_node2 = __commonJS({
  "node_modules/@babel/core/node_modules/@babel/traverse/lib/traverse-node.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.traverseNode = traverseNode;
    var _context3 = require_context3();
    var _t = require("@babel/types");
    var {
      VISITOR_KEYS
    } = _t;
    function traverseNode(node, opts, scope, state, path, skipKeys, visitSelf) {
      const keys = VISITOR_KEYS[node.type];
      if (!keys) return false;
      const context = new _context3.default(scope, opts, state, path);
      if (visitSelf) {
        if (skipKeys != null && skipKeys[path.parentKey]) return false;
        return context.visitQueue([path]);
      }
      for (const key2 of keys) {
        if (skipKeys != null && skipKeys[key2]) continue;
        if (context.visit(node, key2)) {
          return true;
        }
      }
      return false;
    }
  }
});

// node_modules/@babel/core/node_modules/@babel/traverse/lib/path/context.js
var require_context4 = __commonJS({
  "node_modules/@babel/core/node_modules/@babel/traverse/lib/path/context.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2._call = _call;
    exports2._getQueueContexts = _getQueueContexts;
    exports2._resyncKey = _resyncKey;
    exports2._resyncList = _resyncList;
    exports2._resyncParent = _resyncParent;
    exports2._resyncRemoved = _resyncRemoved;
    exports2.call = call;
    exports2.isDenylisted = isDenylisted;
    exports2.popContext = popContext;
    exports2.pushContext = pushContext;
    exports2.requeue = requeue;
    exports2.requeueComputedKeyAndDecorators = requeueComputedKeyAndDecorators;
    exports2.resync = resync;
    exports2.setContext = setContext;
    exports2.setKey = setKey;
    exports2.setScope = setScope;
    exports2.setup = setup;
    exports2.skip = skip;
    exports2.skipKey = skipKey;
    exports2.stop = stop;
    exports2.visit = visit4;
    var _traverseNode = require_traverse_node2();
    var _index = require_path2();
    var _removal = require_removal2();
    var t6 = require("@babel/types");
    function call(key2) {
      const opts = this.opts;
      this.debug(key2);
      if (this.node) {
        if (_call.call(this, opts[key2])) return true;
      }
      if (this.node) {
        var _opts$this$node$type;
        return _call.call(this, (_opts$this$node$type = opts[this.node.type]) == null ? void 0 : _opts$this$node$type[key2]);
      }
      return false;
    }
    function _call(fns) {
      if (!fns) return false;
      for (const fn of fns) {
        if (!fn) continue;
        const node = this.node;
        if (!node) return true;
        const ret = fn.call(this.state, this, this.state);
        if (ret && typeof ret === "object" && typeof ret.then === "function") {
          throw new Error(`You appear to be using a plugin with an async traversal visitor, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.`);
        }
        if (ret) {
          throw new Error(`Unexpected return value from visitor method ${fn}`);
        }
        if (this.node !== node) return true;
        if (this._traverseFlags > 0) return true;
      }
      return false;
    }
    function isDenylisted() {
      var _this$opts$denylist;
      const denylist = (_this$opts$denylist = this.opts.denylist) != null ? _this$opts$denylist : this.opts.blacklist;
      return denylist == null ? void 0 : denylist.includes(this.node.type);
    }
    {
      exports2.isBlacklisted = isDenylisted;
    }
    function restoreContext(path, context) {
      if (path.context !== context) {
        path.context = context;
        path.state = context.state;
        path.opts = context.opts;
      }
    }
    function visit4() {
      var _this$opts$shouldSkip, _this$opts;
      if (!this.node) {
        return false;
      }
      if (this.isDenylisted()) {
        return false;
      }
      if ((_this$opts$shouldSkip = (_this$opts = this.opts).shouldSkip) != null && _this$opts$shouldSkip.call(_this$opts, this)) {
        return false;
      }
      const currentContext = this.context;
      if (this.shouldSkip || call.call(this, "enter")) {
        this.debug("Skip...");
        return this.shouldStop;
      }
      restoreContext(this, currentContext);
      this.debug("Recursing into...");
      this.shouldStop = (0, _traverseNode.traverseNode)(this.node, this.opts, this.scope, this.state, this, this.skipKeys);
      restoreContext(this, currentContext);
      call.call(this, "exit");
      return this.shouldStop;
    }
    function skip() {
      this.shouldSkip = true;
    }
    function skipKey(key2) {
      if (this.skipKeys == null) {
        this.skipKeys = {};
      }
      this.skipKeys[key2] = true;
    }
    function stop() {
      this._traverseFlags |= _index.SHOULD_SKIP | _index.SHOULD_STOP;
    }
    function setScope() {
      var _this$opts2, _this$scope;
      if ((_this$opts2 = this.opts) != null && _this$opts2.noScope) return;
      let path = this.parentPath;
      if ((this.key === "key" || this.listKey === "decorators") && path.isMethod() || this.key === "discriminant" && path.isSwitchStatement()) {
        path = path.parentPath;
      }
      let target;
      while (path && !target) {
        var _path$opts;
        if ((_path$opts = path.opts) != null && _path$opts.noScope) return;
        target = path.scope;
        path = path.parentPath;
      }
      this.scope = this.getScope(target);
      (_this$scope = this.scope) == null || _this$scope.init();
    }
    function setContext(context) {
      if (this.skipKeys != null) {
        this.skipKeys = {};
      }
      this._traverseFlags = 0;
      if (context) {
        this.context = context;
        this.state = context.state;
        this.opts = context.opts;
      }
      setScope.call(this);
      return this;
    }
    function resync() {
      if (this.removed) return;
      _resyncParent.call(this);
      _resyncList.call(this);
      _resyncKey.call(this);
    }
    function _resyncParent() {
      if (this.parentPath) {
        this.parent = this.parentPath.node;
      }
    }
    function _resyncKey() {
      if (!this.container) return;
      if (this.node === this.container[this.key]) {
        return;
      }
      if (Array.isArray(this.container)) {
        for (let i = 0; i < this.container.length; i++) {
          if (this.container[i] === this.node) {
            setKey.call(this, i);
            return;
          }
        }
      } else {
        for (const key2 of Object.keys(this.container)) {
          if (this.container[key2] === this.node) {
            setKey.call(this, key2);
            return;
          }
        }
      }
      this.key = null;
    }
    function _resyncList() {
      if (!this.parent || !this.inList) return;
      const newContainer = this.parent[this.listKey];
      if (this.container === newContainer) return;
      this.container = newContainer || null;
    }
    function _resyncRemoved() {
      if (this.key == null || !this.container || this.container[this.key] !== this.node) {
        _removal._markRemoved.call(this);
      }
    }
    function popContext() {
      this.contexts.pop();
      if (this.contexts.length > 0) {
        this.setContext(this.contexts[this.contexts.length - 1]);
      } else {
        this.setContext(void 0);
      }
    }
    function pushContext(context) {
      this.contexts.push(context);
      this.setContext(context);
    }
    function setup(parentPath, container, listKey, key2) {
      this.listKey = listKey;
      this.container = container;
      this.parentPath = parentPath || this.parentPath;
      setKey.call(this, key2);
    }
    function setKey(key2) {
      var _this$node;
      this.key = key2;
      this.node = this.container[this.key];
      this.type = (_this$node = this.node) == null ? void 0 : _this$node.type;
    }
    function requeue(pathToQueue = this) {
      if (pathToQueue.removed) return;
      ;
      const contexts = this.contexts;
      for (const context of contexts) {
        context.maybeQueue(pathToQueue);
      }
    }
    function requeueComputedKeyAndDecorators() {
      const {
        context,
        node
      } = this;
      if (!t6.isPrivate(node) && node.computed) {
        context.maybeQueue(this.get("key"));
      }
      if (node.decorators) {
        for (const decorator of this.get("decorators")) {
          context.maybeQueue(decorator);
        }
      }
    }
    function _getQueueContexts() {
      let path = this;
      let contexts = this.contexts;
      while (!contexts.length) {
        path = path.parentPath;
        if (!path) break;
        contexts = path.contexts;
      }
      return contexts;
    }
  }
});

// node_modules/@babel/core/node_modules/@babel/traverse/lib/hub.js
var require_hub2 = __commonJS({
  "node_modules/@babel/core/node_modules/@babel/traverse/lib/hub.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var Hub = class {
      getCode() {
      }
      getScope() {
      }
      addHelper() {
        throw new Error("Helpers are not supported by the default hub.");
      }
      buildError(node, msg, Error2 = TypeError) {
        return new Error2(msg);
      }
    };
    exports2.default = Hub;
  }
});

// node_modules/@babel/core/node_modules/@babel/traverse/lib/index.js
var require_lib9 = __commonJS({
  "node_modules/@babel/core/node_modules/@babel/traverse/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "Hub", {
      enumerable: true,
      get: function() {
        return _hub.default;
      }
    });
    Object.defineProperty(exports2, "NodePath", {
      enumerable: true,
      get: function() {
        return _index.default;
      }
    });
    Object.defineProperty(exports2, "Scope", {
      enumerable: true,
      get: function() {
        return _index2.default;
      }
    });
    exports2.visitors = exports2.default = void 0;
    require_context4();
    var visitors = require_visitors2();
    exports2.visitors = visitors;
    var _t = require("@babel/types");
    var cache = require_cache2();
    var _traverseNode = require_traverse_node2();
    var _index = require_path2();
    var _index2 = require_scope2();
    var _hub = require_hub2();
    var {
      VISITOR_KEYS,
      removeProperties,
      traverseFast
    } = _t;
    function traverse(parent, opts = {}, scope, state, parentPath, visitSelf) {
      if (!parent) return;
      if (!opts.noScope && !scope) {
        if (parent.type !== "Program" && parent.type !== "File") {
          throw new Error(`You must pass a scope and parentPath unless traversing a Program/File. Instead of that you tried to traverse a ${parent.type} node without passing scope and parentPath.`);
        }
      }
      if (!parentPath && visitSelf) {
        throw new Error("visitSelf can only be used when providing a NodePath.");
      }
      if (!VISITOR_KEYS[parent.type]) {
        return;
      }
      visitors.explode(opts);
      (0, _traverseNode.traverseNode)(parent, opts, scope, state, parentPath, null, visitSelf);
    }
    var _default = exports2.default = traverse;
    traverse.visitors = visitors;
    traverse.verify = visitors.verify;
    traverse.explode = visitors.explode;
    traverse.cheap = function(node, enter) {
      traverseFast(node, enter);
      return;
    };
    traverse.node = function(node, opts, scope, state, path, skipKeys) {
      (0, _traverseNode.traverseNode)(node, opts, scope, state, path, skipKeys);
    };
    traverse.clearNode = function(node, opts) {
      removeProperties(node, opts);
    };
    traverse.removeProperties = function(tree, opts) {
      traverseFast(tree, traverse.clearNode, opts);
      return tree;
    };
    traverse.hasType = function(tree, type, denylistTypes) {
      if (denylistTypes != null && denylistTypes.includes(tree.type)) return false;
      if (tree.type === type) return true;
      return traverseFast(tree, function(node) {
        if (denylistTypes != null && denylistTypes.includes(node.type)) {
          return traverseFast.skip;
        }
        if (node.type === type) {
          return traverseFast.stop;
        }
      });
    };
    traverse.cache = cache;
  }
});

// node_modules/semver/semver.js
var require_semver = __commonJS({
  "node_modules/semver/semver.js"(exports2, module2) {
    "use strict";
    exports2 = module2.exports = SemVer;
    var debug;
    if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
      debug = function() {
        var args = Array.prototype.slice.call(arguments, 0);
        args.unshift("SEMVER");
        console.log.apply(console, args);
      };
    } else {
      debug = function() {
      };
    }
    exports2.SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var re = exports2.re = [];
    var src = exports2.src = [];
    var R = 0;
    var NUMERICIDENTIFIER = R++;
    src[NUMERICIDENTIFIER] = "0|[1-9]\\d*";
    var NUMERICIDENTIFIERLOOSE = R++;
    src[NUMERICIDENTIFIERLOOSE] = "[0-9]+";
    var NONNUMERICIDENTIFIER = R++;
    src[NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
    var MAINVERSION = R++;
    src[MAINVERSION] = "(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")";
    var MAINVERSIONLOOSE = R++;
    src[MAINVERSIONLOOSE] = "(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")";
    var PRERELEASEIDENTIFIER = R++;
    src[PRERELEASEIDENTIFIER] = "(?:" + src[NUMERICIDENTIFIER] + "|" + src[NONNUMERICIDENTIFIER] + ")";
    var PRERELEASEIDENTIFIERLOOSE = R++;
    src[PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[NUMERICIDENTIFIERLOOSE] + "|" + src[NONNUMERICIDENTIFIER] + ")";
    var PRERELEASE = R++;
    src[PRERELEASE] = "(?:-(" + src[PRERELEASEIDENTIFIER] + "(?:\\." + src[PRERELEASEIDENTIFIER] + ")*))";
    var PRERELEASELOOSE = R++;
    src[PRERELEASELOOSE] = "(?:-?(" + src[PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[PRERELEASEIDENTIFIERLOOSE] + ")*))";
    var BUILDIDENTIFIER = R++;
    src[BUILDIDENTIFIER] = "[0-9A-Za-z-]+";
    var BUILD = R++;
    src[BUILD] = "(?:\\+(" + src[BUILDIDENTIFIER] + "(?:\\." + src[BUILDIDENTIFIER] + ")*))";
    var FULL = R++;
    var FULLPLAIN = "v?" + src[MAINVERSION] + src[PRERELEASE] + "?" + src[BUILD] + "?";
    src[FULL] = "^" + FULLPLAIN + "$";
    var LOOSEPLAIN = "[v=\\s]*" + src[MAINVERSIONLOOSE] + src[PRERELEASELOOSE] + "?" + src[BUILD] + "?";
    var LOOSE = R++;
    src[LOOSE] = "^" + LOOSEPLAIN + "$";
    var GTLT = R++;
    src[GTLT] = "((?:<|>)?=?)";
    var XRANGEIDENTIFIERLOOSE = R++;
    src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
    var XRANGEIDENTIFIER = R++;
    src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + "|x|X|\\*";
    var XRANGEPLAIN = R++;
    src[XRANGEPLAIN] = "[v=\\s]*(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:" + src[PRERELEASE] + ")?" + src[BUILD] + "?)?)?";
    var XRANGEPLAINLOOSE = R++;
    src[XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:" + src[PRERELEASELOOSE] + ")?" + src[BUILD] + "?)?)?";
    var XRANGE = R++;
    src[XRANGE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAIN] + "$";
    var XRANGELOOSE = R++;
    src[XRANGELOOSE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAINLOOSE] + "$";
    var COERCE = R++;
    src[COERCE] = "(?:^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
    var LONETILDE = R++;
    src[LONETILDE] = "(?:~>?)";
    var TILDETRIM = R++;
    src[TILDETRIM] = "(\\s*)" + src[LONETILDE] + "\\s+";
    re[TILDETRIM] = new RegExp(src[TILDETRIM], "g");
    var tildeTrimReplace = "$1~";
    var TILDE = R++;
    src[TILDE] = "^" + src[LONETILDE] + src[XRANGEPLAIN] + "$";
    var TILDELOOSE = R++;
    src[TILDELOOSE] = "^" + src[LONETILDE] + src[XRANGEPLAINLOOSE] + "$";
    var LONECARET = R++;
    src[LONECARET] = "(?:\\^)";
    var CARETTRIM = R++;
    src[CARETTRIM] = "(\\s*)" + src[LONECARET] + "\\s+";
    re[CARETTRIM] = new RegExp(src[CARETTRIM], "g");
    var caretTrimReplace = "$1^";
    var CARET = R++;
    src[CARET] = "^" + src[LONECARET] + src[XRANGEPLAIN] + "$";
    var CARETLOOSE = R++;
    src[CARETLOOSE] = "^" + src[LONECARET] + src[XRANGEPLAINLOOSE] + "$";
    var COMPARATORLOOSE = R++;
    src[COMPARATORLOOSE] = "^" + src[GTLT] + "\\s*(" + LOOSEPLAIN + ")$|^$";
    var COMPARATOR = R++;
    src[COMPARATOR] = "^" + src[GTLT] + "\\s*(" + FULLPLAIN + ")$|^$";
    var COMPARATORTRIM = R++;
    src[COMPARATORTRIM] = "(\\s*)" + src[GTLT] + "\\s*(" + LOOSEPLAIN + "|" + src[XRANGEPLAIN] + ")";
    re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], "g");
    var comparatorTrimReplace = "$1$2$3";
    var HYPHENRANGE = R++;
    src[HYPHENRANGE] = "^\\s*(" + src[XRANGEPLAIN] + ")\\s+-\\s+(" + src[XRANGEPLAIN] + ")\\s*$";
    var HYPHENRANGELOOSE = R++;
    src[HYPHENRANGELOOSE] = "^\\s*(" + src[XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[XRANGEPLAINLOOSE] + ")\\s*$";
    var STAR = R++;
    src[STAR] = "(<|>)?=?\\s*\\*";
    for (i = 0; i < R; i++) {
      debug(i, src[i]);
      if (!re[i]) {
        re[i] = new RegExp(src[i]);
      }
    }
    var i;
    exports2.parse = parse4;
    function parse4(version, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version !== "string") {
        return null;
      }
      if (version.length > MAX_LENGTH) {
        return null;
      }
      var r = options.loose ? re[LOOSE] : re[FULL];
      if (!r.test(version)) {
        return null;
      }
      try {
        return new SemVer(version, options);
      } catch (er) {
        return null;
      }
    }
    exports2.valid = valid;
    function valid(version, options) {
      var v = parse4(version, options);
      return v ? v.version : null;
    }
    exports2.clean = clean;
    function clean(version, options) {
      var s = parse4(version.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    }
    exports2.SemVer = SemVer;
    function SemVer(version, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version instanceof SemVer) {
        if (version.loose === options.loose) {
          return version;
        } else {
          version = version.version;
        }
      } else if (typeof version !== "string") {
        throw new TypeError("Invalid Version: " + version);
      }
      if (version.length > MAX_LENGTH) {
        throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
      }
      if (!(this instanceof SemVer)) {
        return new SemVer(version, options);
      }
      debug("SemVer", version, options);
      this.options = options;
      this.loose = !!options.loose;
      var m = version.trim().match(options.loose ? re[LOOSE] : re[FULL]);
      if (!m) {
        throw new TypeError("Invalid Version: " + version);
      }
      this.raw = version;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split(".").map(function(id) {
          if (/^[0-9]+$/.test(id)) {
            var num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m[5] ? m[5].split(".") : [];
      this.format();
    }
    SemVer.prototype.format = function() {
      this.version = this.major + "." + this.minor + "." + this.patch;
      if (this.prerelease.length) {
        this.version += "-" + this.prerelease.join(".");
      }
      return this.version;
    };
    SemVer.prototype.toString = function() {
      return this.version;
    };
    SemVer.prototype.compare = function(other) {
      debug("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return this.compareMain(other) || this.comparePre(other);
    };
    SemVer.prototype.compareMain = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    };
    SemVer.prototype.comparePre = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      var i2 = 0;
      do {
        var a = this.prerelease[i2];
        var b = other.prerelease[i2];
        debug("prerelease compare", i2, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i2);
    };
    SemVer.prototype.inc = function(release, identifier4) {
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier4);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier4);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier4);
          this.inc("pre", identifier4);
          break;
        // If the input is a non-prerelease version, this acts the same as
        // prepatch.
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier4);
          }
          this.inc("pre", identifier4);
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        // This probably shouldn't be used publicly.
        // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
        case "pre":
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            var i2 = this.prerelease.length;
            while (--i2 >= 0) {
              if (typeof this.prerelease[i2] === "number") {
                this.prerelease[i2]++;
                i2 = -2;
              }
            }
            if (i2 === -1) {
              this.prerelease.push(0);
            }
          }
          if (identifier4) {
            if (this.prerelease[0] === identifier4) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier4, 0];
              }
            } else {
              this.prerelease = [identifier4, 0];
            }
          }
          break;
        default:
          throw new Error("invalid increment argument: " + release);
      }
      this.format();
      this.raw = this.version;
      return this;
    };
    exports2.inc = inc;
    function inc(version, release, loose, identifier4) {
      if (typeof loose === "string") {
        identifier4 = loose;
        loose = void 0;
      }
      try {
        return new SemVer(version, loose).inc(release, identifier4).version;
      } catch (er) {
        return null;
      }
    }
    exports2.diff = diff;
    function diff(version1, version2) {
      if (eq(version1, version2)) {
        return null;
      } else {
        var v1 = parse4(version1);
        var v2 = parse4(version2);
        var prefix = "";
        if (v1.prerelease.length || v2.prerelease.length) {
          prefix = "pre";
          var defaultResult = "prerelease";
        }
        for (var key2 in v1) {
          if (key2 === "major" || key2 === "minor" || key2 === "patch") {
            if (v1[key2] !== v2[key2]) {
              return prefix + key2;
            }
          }
        }
        return defaultResult;
      }
    }
    exports2.compareIdentifiers = compareIdentifiers;
    var numeric = /^[0-9]+$/;
    function compareIdentifiers(a, b) {
      var anum = numeric.test(a);
      var bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    }
    exports2.rcompareIdentifiers = rcompareIdentifiers;
    function rcompareIdentifiers(a, b) {
      return compareIdentifiers(b, a);
    }
    exports2.major = major;
    function major(a, loose) {
      return new SemVer(a, loose).major;
    }
    exports2.minor = minor;
    function minor(a, loose) {
      return new SemVer(a, loose).minor;
    }
    exports2.patch = patch;
    function patch(a, loose) {
      return new SemVer(a, loose).patch;
    }
    exports2.compare = compare;
    function compare(a, b, loose) {
      return new SemVer(a, loose).compare(new SemVer(b, loose));
    }
    exports2.compareLoose = compareLoose;
    function compareLoose(a, b) {
      return compare(a, b, true);
    }
    exports2.rcompare = rcompare;
    function rcompare(a, b, loose) {
      return compare(b, a, loose);
    }
    exports2.sort = sort;
    function sort(list, loose) {
      return list.sort(function(a, b) {
        return exports2.compare(a, b, loose);
      });
    }
    exports2.rsort = rsort;
    function rsort(list, loose) {
      return list.sort(function(a, b) {
        return exports2.rcompare(a, b, loose);
      });
    }
    exports2.gt = gt;
    function gt(a, b, loose) {
      return compare(a, b, loose) > 0;
    }
    exports2.lt = lt;
    function lt(a, b, loose) {
      return compare(a, b, loose) < 0;
    }
    exports2.eq = eq;
    function eq(a, b, loose) {
      return compare(a, b, loose) === 0;
    }
    exports2.neq = neq;
    function neq(a, b, loose) {
      return compare(a, b, loose) !== 0;
    }
    exports2.gte = gte;
    function gte(a, b, loose) {
      return compare(a, b, loose) >= 0;
    }
    exports2.lte = lte;
    function lte(a, b, loose) {
      return compare(a, b, loose) <= 0;
    }
    exports2.cmp = cmp;
    function cmp(a, op, b, loose) {
      switch (op) {
        case "===":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a === b;
        case "!==":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError("Invalid operator: " + op);
      }
    }
    exports2.Comparator = Comparator;
    function Comparator(comp, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      if (!(this instanceof Comparator)) {
        return new Comparator(comp, options);
      }
      debug("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug("comp", this);
    }
    var ANY = {};
    Comparator.prototype.parse = function(comp) {
      var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
      var m = comp.match(r);
      if (!m) {
        throw new TypeError("Invalid comparator: " + comp);
      }
      this.operator = m[1];
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    };
    Comparator.prototype.toString = function() {
      return this.value;
    };
    Comparator.prototype.test = function(version) {
      debug("Comparator.test", version, this.options.loose);
      if (this.semver === ANY) {
        return true;
      }
      if (typeof version === "string") {
        version = new SemVer(version, this.options);
      }
      return cmp(version, this.operator, this.semver, this.options);
    };
    Comparator.prototype.intersects = function(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      var rangeTmp;
      if (this.operator === "") {
        rangeTmp = new Range(comp.value, options);
        return satisfies(this.value, rangeTmp, options);
      } else if (comp.operator === "") {
        rangeTmp = new Range(this.value, options);
        return satisfies(comp.semver, rangeTmp, options);
      }
      var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
      var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
      var sameSemVer = this.semver.version === comp.semver.version;
      var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
      var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
      var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    };
    exports2.Range = Range;
    function Range(range, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (range instanceof Range) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options);
        }
      }
      if (range instanceof Comparator) {
        return new Range(range.value, options);
      }
      if (!(this instanceof Range)) {
        return new Range(range, options);
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range;
      this.set = range.split(/\s*\|\|\s*/).map(function(range2) {
        return this.parseRange(range2.trim());
      }, this).filter(function(c2) {
        return c2.length;
      });
      if (!this.set.length) {
        throw new TypeError("Invalid SemVer Range: " + range);
      }
      this.format();
    }
    Range.prototype.format = function() {
      this.range = this.set.map(function(comps) {
        return comps.join(" ").trim();
      }).join("||").trim();
      return this.range;
    };
    Range.prototype.toString = function() {
      return this.range;
    };
    Range.prototype.parseRange = function(range) {
      var loose = this.options.loose;
      range = range.trim();
      var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
      range = range.replace(hr, hyphenReplace);
      debug("hyphen replace", range);
      range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
      debug("comparator trim", range, re[COMPARATORTRIM]);
      range = range.replace(re[TILDETRIM], tildeTrimReplace);
      range = range.replace(re[CARETTRIM], caretTrimReplace);
      range = range.split(/\s+/).join(" ");
      var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
      var set = range.split(" ").map(function(comp) {
        return parseComparator(comp, this.options);
      }, this).join(" ").split(/\s+/);
      if (this.options.loose) {
        set = set.filter(function(comp) {
          return !!comp.match(compRe);
        });
      }
      set = set.map(function(comp) {
        return new Comparator(comp, this.options);
      }, this);
      return set;
    };
    Range.prototype.intersects = function(range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some(function(thisComparators) {
        return thisComparators.every(function(thisComparator) {
          return range.set.some(function(rangeComparators) {
            return rangeComparators.every(function(rangeComparator) {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    };
    exports2.toComparators = toComparators;
    function toComparators(range, options) {
      return new Range(range, options).set.map(function(comp) {
        return comp.map(function(c2) {
          return c2.value;
        }).join(" ").trim().split(" ");
      });
    }
    function parseComparator(comp, options) {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    }
    function isX(id) {
      return !id || id.toLowerCase() === "x" || id === "*";
    }
    function replaceTildes(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceTilde(comp2, options);
      }).join(" ");
    }
    function replaceTilde(comp, options) {
      var r = options.loose ? re[TILDELOOSE] : re[TILDE];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug("tilde", comp, _, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
        } else {
          ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
        }
        debug("tilde return", ret);
        return ret;
      });
    }
    function replaceCarets(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceCaret(comp2, options);
      }).join(" ");
    }
    function replaceCaret(comp, options) {
      debug("caret", comp, options);
      var r = options.loose ? re[CARETLOOSE] : re[CARET];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug("caret", comp, _, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          if (M === "0") {
            ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
          } else {
            ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
          }
        }
        debug("caret return", ret);
        return ret;
      });
    }
    function replaceXRanges(comp, options) {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map(function(comp2) {
        return replaceXRange(comp2, options);
      }).join(" ");
    }
    function replaceXRange(comp, options) {
      comp = comp.trim();
      var r = options.loose ? re[XRANGELOOSE] : re[XRANGE];
      return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        var xM = isX(M);
        var xm = xM || isX(m);
        var xp = xm || isX(p);
        var anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          ret = gtlt + M + "." + m + "." + p;
        } else if (xm) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (xp) {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        }
        debug("xRange return", ret);
        return ret;
      });
    }
    function replaceStars(comp, options) {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[STAR], "");
    }
    function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = ">=" + fM + ".0.0";
      } else if (isX(fp)) {
        from = ">=" + fM + "." + fm + ".0";
      } else {
        from = ">=" + from;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = "<" + (+tM + 1) + ".0.0";
      } else if (isX(tp)) {
        to = "<" + tM + "." + (+tm + 1) + ".0";
      } else if (tpr) {
        to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
      } else {
        to = "<=" + to;
      }
      return (from + " " + to).trim();
    }
    Range.prototype.test = function(version) {
      if (!version) {
        return false;
      }
      if (typeof version === "string") {
        version = new SemVer(version, this.options);
      }
      for (var i2 = 0; i2 < this.set.length; i2++) {
        if (testSet(this.set[i2], version, this.options)) {
          return true;
        }
      }
      return false;
    };
    function testSet(set, version, options) {
      for (var i2 = 0; i2 < set.length; i2++) {
        if (!set[i2].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (i2 = 0; i2 < set.length; i2++) {
          debug(set[i2].semver);
          if (set[i2].semver === ANY) {
            continue;
          }
          if (set[i2].semver.prerelease.length > 0) {
            var allowed = set[i2].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    }
    exports2.satisfies = satisfies;
    function satisfies(version, range, options) {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version);
    }
    exports2.maxSatisfying = maxSatisfying;
    function maxSatisfying(versions, range, options) {
      var max = null;
      var maxSV = null;
      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    }
    exports2.minSatisfying = minSatisfying;
    function minSatisfying(versions, range, options) {
      var min = null;
      var minSV = null;
      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    }
    exports2.minVersion = minVersion;
    function minVersion(range, loose) {
      range = new Range(range, loose);
      var minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        comparators.forEach(function(comparator) {
          var compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            /* fallthrough */
            case "":
            case ">=":
              if (!minver || gt(minver, compver)) {
                minver = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            /* istanbul ignore next */
            default:
              throw new Error("Unexpected operation: " + comparator.operator);
          }
        });
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    }
    exports2.validRange = validRange;
    function validRange(range, options) {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    }
    exports2.ltr = ltr;
    function ltr(version, range, options) {
      return outside(version, range, "<", options);
    }
    exports2.gtr = gtr;
    function gtr(version, range, options) {
      return outside(version, range, ">", options);
    }
    exports2.outside = outside;
    function outside(version, range, hilo, options) {
      version = new SemVer(version, options);
      range = new Range(range, options);
      var gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range, options)) {
        return false;
      }
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        var high = null;
        var low = null;
        comparators.forEach(function(comparator) {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    }
    exports2.prerelease = prerelease;
    function prerelease(version, options) {
      var parsed = parse4(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    }
    exports2.intersects = intersects;
    function intersects(r1, r2, options) {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2);
    }
    exports2.coerce = coerce2;
    function coerce2(version) {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version !== "string") {
        return null;
      }
      var match = version.match(re[COERCE]);
      if (match == null) {
        return null;
      }
      return parse4(match[1] + "." + (match[2] || "0") + "." + (match[3] || "0"));
    }
  }
});

// node_modules/@babel/core/lib/transformation/file/file.js
var require_file = __commonJS({
  "node_modules/@babel/core/lib/transformation/file/file.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    function helpers() {
      const data = _interopRequireWildcard(require_lib7());
      helpers = function() {
        return data;
      };
      return data;
    }
    function _traverse() {
      const data = _interopRequireWildcard(require_lib9());
      _traverse = function() {
        return data;
      };
      return data;
    }
    function _codeFrame() {
      const data = require_lib3();
      _codeFrame = function() {
        return data;
      };
      return data;
    }
    function t6() {
      const data = _interopRequireWildcard(require("@babel/types"));
      t6 = function() {
        return data;
      };
      return data;
    }
    function _semver() {
      const data = _interopRequireDefault(require_semver());
      _semver = function() {
        return data;
      };
      return data;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key2 in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key2)) {
              var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key2) : {};
              if (desc.get || desc.set) {
                Object.defineProperty(newObj, key2, desc);
              } else {
                newObj[key2] = obj[key2];
              }
            }
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    var errorVisitor = {
      enter(path, state) {
        const loc = path.node.loc;
        if (loc) {
          state.loc = loc;
          path.stop();
        }
      }
    };
    var File = class {
      constructor(options, {
        code,
        ast,
        inputMap
      }) {
        this._map = /* @__PURE__ */ new Map();
        this.declarations = {};
        this.path = null;
        this.ast = {};
        this.metadata = {};
        this.code = "";
        this.inputMap = null;
        this.hub = {
          file: this,
          getCode: () => this.code,
          getScope: () => this.scope,
          addHelper: this.addHelper.bind(this),
          buildError: this.buildCodeFrameError.bind(this)
        };
        this.opts = options;
        this.code = code;
        this.ast = ast;
        this.inputMap = inputMap;
        this.path = _traverse().NodePath.get({
          hub: this.hub,
          parentPath: null,
          parent: this.ast,
          container: this.ast,
          key: "program"
        }).setContext();
        this.scope = this.path.scope;
      }
      get shebang() {
        const {
          interpreter
        } = this.path.node;
        return interpreter ? interpreter.value : "";
      }
      set shebang(value) {
        if (value) {
          this.path.get("interpreter").replaceWith(t6().interpreterDirective(value));
        } else {
          this.path.get("interpreter").remove();
        }
      }
      set(key2, val) {
        if (key2 === "helpersNamespace") {
          throw new Error("Babel 7.0.0-beta.56 has dropped support for the 'helpersNamespace' utility.If you are using @babel/plugin-external-helpers you will need to use a newer version than the one you currently have installed. If you have your own implementation, you'll want to explore using 'helperGenerator' alongside 'file.availableHelper()'.");
        }
        this._map.set(key2, val);
      }
      get(key2) {
        return this._map.get(key2);
      }
      has(key2) {
        return this._map.has(key2);
      }
      getModuleName() {
        const {
          filename,
          filenameRelative = filename,
          moduleId,
          moduleIds = !!moduleId,
          getModuleId,
          sourceRoot: sourceRootTmp,
          moduleRoot = sourceRootTmp,
          sourceRoot = moduleRoot
        } = this.opts;
        if (!moduleIds) return null;
        if (moduleId != null && !getModuleId) {
          return moduleId;
        }
        let moduleName = moduleRoot != null ? moduleRoot + "/" : "";
        if (filenameRelative) {
          const sourceRootReplacer = sourceRoot != null ? new RegExp("^" + sourceRoot + "/?") : "";
          moduleName += filenameRelative.replace(sourceRootReplacer, "").replace(/\.(\w*?)$/, "");
        }
        moduleName = moduleName.replace(/\\/g, "/");
        if (getModuleId) {
          return getModuleId(moduleName) || moduleName;
        } else {
          return moduleName;
        }
      }
      addImport() {
        throw new Error("This API has been removed. If you're looking for this functionality in Babel 7, you should import the '@babel/helper-module-imports' module and use the functions exposed  from that module, such as 'addNamed' or 'addDefault'.");
      }
      availableHelper(name, versionRange) {
        let minVersion;
        try {
          minVersion = helpers().minVersion(name);
        } catch (err) {
          if (err.code !== "BABEL_HELPER_UNKNOWN") throw err;
          return false;
        }
        if (typeof versionRange !== "string") return true;
        if (_semver().default.valid(versionRange)) versionRange = `^${versionRange}`;
        return !_semver().default.intersects(`<${minVersion}`, versionRange) && !_semver().default.intersects(`>=8.0.0`, versionRange);
      }
      addHelper(name) {
        const declar = this.declarations[name];
        if (declar) return t6().cloneNode(declar);
        const generator = this.get("helperGenerator");
        if (generator) {
          const res = generator(name);
          if (res) return res;
        }
        const uid = this.declarations[name] = this.scope.generateUidIdentifier(name);
        const dependencies = {};
        for (const dep of helpers().getDependencies(name)) {
          dependencies[dep] = this.addHelper(dep);
        }
        const {
          nodes,
          globals
        } = helpers().get(name, (dep) => dependencies[dep], uid, Object.keys(this.scope.getAllBindings()));
        globals.forEach((name2) => {
          if (this.path.scope.hasBinding(name2, true)) {
            this.path.scope.rename(name2);
          }
        });
        nodes.forEach((node) => {
          node._compact = true;
        });
        this.path.unshiftContainer("body", nodes);
        this.path.get("body").forEach((path) => {
          if (nodes.indexOf(path.node) === -1) return;
          if (path.isVariableDeclaration()) this.scope.registerDeclaration(path);
        });
        return uid;
      }
      addTemplateObject() {
        throw new Error("This function has been moved into the template literal transform itself.");
      }
      buildCodeFrameError(node, msg, Error2 = SyntaxError) {
        let loc = node && (node.loc || node._loc);
        msg = `${this.opts.filename}: ${msg}`;
        if (!loc && node) {
          const state = {
            loc: null
          };
          (0, _traverse().default)(node, errorVisitor, this.scope, state);
          loc = state.loc;
          let txt = "This is an error on an internal node. Probably an internal error.";
          if (loc) txt += " Location has been estimated.";
          msg += ` (${txt})`;
        }
        if (loc) {
          const {
            highlightCode = true
          } = this.opts;
          msg += "\n" + (0, _codeFrame().codeFrameColumns)(this.code, {
            start: {
              line: loc.start.line,
              column: loc.start.column + 1
            }
          }, {
            highlightCode
          });
        }
        return new Error2(msg);
      }
    };
    exports2.default = File;
  }
});

// node_modules/@babel/core/lib/tools/build-external-helpers.js
var require_build_external_helpers = __commonJS({
  "node_modules/@babel/core/lib/tools/build-external-helpers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = _default;
    function helpers() {
      const data = _interopRequireWildcard(require_lib7());
      helpers = function() {
        return data;
      };
      return data;
    }
    function _generator() {
      const data = _interopRequireDefault(require_lib8());
      _generator = function() {
        return data;
      };
      return data;
    }
    function _template() {
      const data = _interopRequireDefault(require_lib5());
      _template = function() {
        return data;
      };
      return data;
    }
    function t6() {
      const data = _interopRequireWildcard(require("@babel/types"));
      t6 = function() {
        return data;
      };
      return data;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key2 in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key2)) {
              var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key2) : {};
              if (desc.get || desc.set) {
                Object.defineProperty(newObj, key2, desc);
              } else {
                newObj[key2] = obj[key2];
              }
            }
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    var buildUmdWrapper = (replacements) => _template().default`
    (function (root, factory) {
      if (typeof define === "function" && define.amd) {
        define(AMD_ARGUMENTS, factory);
      } else if (typeof exports === "object") {
        factory(COMMON_ARGUMENTS);
      } else {
        factory(BROWSER_ARGUMENTS);
      }
    })(UMD_ROOT, function (FACTORY_PARAMETERS) {
      FACTORY_BODY
    });
  `(replacements);
    function buildGlobal(whitelist) {
      const namespace = t6().identifier("babelHelpers");
      const body = [];
      const container = t6().functionExpression(null, [t6().identifier("global")], t6().blockStatement(body));
      const tree = t6().program([t6().expressionStatement(t6().callExpression(container, [t6().conditionalExpression(t6().binaryExpression("===", t6().unaryExpression("typeof", t6().identifier("global")), t6().stringLiteral("undefined")), t6().identifier("self"), t6().identifier("global"))]))]);
      body.push(t6().variableDeclaration("var", [t6().variableDeclarator(namespace, t6().assignmentExpression("=", t6().memberExpression(t6().identifier("global"), namespace), t6().objectExpression([])))]));
      buildHelpers(body, namespace, whitelist);
      return tree;
    }
    function buildModule(whitelist) {
      const body = [];
      const refs = buildHelpers(body, null, whitelist);
      body.unshift(t6().exportNamedDeclaration(null, Object.keys(refs).map((name) => {
        return t6().exportSpecifier(t6().cloneNode(refs[name]), t6().identifier(name));
      })));
      return t6().program(body, [], "module");
    }
    function buildUmd(whitelist) {
      const namespace = t6().identifier("babelHelpers");
      const body = [];
      body.push(t6().variableDeclaration("var", [t6().variableDeclarator(namespace, t6().identifier("global"))]));
      buildHelpers(body, namespace, whitelist);
      return t6().program([buildUmdWrapper({
        FACTORY_PARAMETERS: t6().identifier("global"),
        BROWSER_ARGUMENTS: t6().assignmentExpression("=", t6().memberExpression(t6().identifier("root"), namespace), t6().objectExpression([])),
        COMMON_ARGUMENTS: t6().identifier("exports"),
        AMD_ARGUMENTS: t6().arrayExpression([t6().stringLiteral("exports")]),
        FACTORY_BODY: body,
        UMD_ROOT: t6().identifier("this")
      })]);
    }
    function buildVar(whitelist) {
      const namespace = t6().identifier("babelHelpers");
      const body = [];
      body.push(t6().variableDeclaration("var", [t6().variableDeclarator(namespace, t6().objectExpression([]))]));
      const tree = t6().program(body);
      buildHelpers(body, namespace, whitelist);
      body.push(t6().expressionStatement(namespace));
      return tree;
    }
    function buildHelpers(body, namespace, whitelist) {
      const getHelperReference = (name) => {
        return namespace ? t6().memberExpression(namespace, t6().identifier(name)) : t6().identifier(`_${name}`);
      };
      const refs = {};
      helpers().list.forEach(function(name) {
        if (whitelist && whitelist.indexOf(name) < 0) return;
        const ref = refs[name] = getHelperReference(name);
        const {
          nodes
        } = helpers().get(name, getHelperReference, ref);
        body.push(...nodes);
      });
      return refs;
    }
    function _default(whitelist, outputType = "global") {
      let tree;
      const build = {
        global: buildGlobal,
        module: buildModule,
        umd: buildUmd,
        var: buildVar
      }[outputType];
      if (build) {
        tree = build(whitelist);
      } else {
        throw new Error(`Unsupported output type ${outputType}`);
      }
      return (0, _generator().default)(tree).code;
    }
  }
});

// node_modules/@babel/core/lib/config/caching.js
var require_caching = __commonJS({
  "node_modules/@babel/core/lib/config/caching.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.makeStrongCache = makeStrongCache;
    exports2.makeWeakCache = makeWeakCache;
    exports2.assertSimpleType = assertSimpleType;
    function makeStrongCache(handler) {
      return makeCachedFunction(/* @__PURE__ */ new Map(), handler);
    }
    function makeWeakCache(handler) {
      return makeCachedFunction(/* @__PURE__ */ new WeakMap(), handler);
    }
    function makeCachedFunction(callCache, handler) {
      return function cachedFunction(arg, data) {
        let cachedValue = callCache.get(arg);
        if (cachedValue) {
          for (const _ref of cachedValue) {
            const {
              value: value2,
              valid
            } = _ref;
            if (valid(data)) return value2;
          }
        }
        const cache = new CacheConfigurator(data);
        const value = handler(arg, cache);
        if (!cache.configured()) cache.forever();
        cache.deactivate();
        switch (cache.mode()) {
          case "forever":
            cachedValue = [{
              value,
              valid: () => true
            }];
            callCache.set(arg, cachedValue);
            break;
          case "invalidate":
            cachedValue = [{
              value,
              valid: cache.validator()
            }];
            callCache.set(arg, cachedValue);
            break;
          case "valid":
            if (cachedValue) {
              cachedValue.push({
                value,
                valid: cache.validator()
              });
            } else {
              cachedValue = [{
                value,
                valid: cache.validator()
              }];
              callCache.set(arg, cachedValue);
            }
        }
        return value;
      };
    }
    var CacheConfigurator = class {
      constructor(data) {
        this._active = true;
        this._never = false;
        this._forever = false;
        this._invalidate = false;
        this._configured = false;
        this._pairs = [];
        this._data = data;
      }
      simple() {
        return makeSimpleConfigurator(this);
      }
      mode() {
        if (this._never) return "never";
        if (this._forever) return "forever";
        if (this._invalidate) return "invalidate";
        return "valid";
      }
      forever() {
        if (!this._active) {
          throw new Error("Cannot change caching after evaluation has completed.");
        }
        if (this._never) {
          throw new Error("Caching has already been configured with .never()");
        }
        this._forever = true;
        this._configured = true;
      }
      never() {
        if (!this._active) {
          throw new Error("Cannot change caching after evaluation has completed.");
        }
        if (this._forever) {
          throw new Error("Caching has already been configured with .forever()");
        }
        this._never = true;
        this._configured = true;
      }
      using(handler) {
        if (!this._active) {
          throw new Error("Cannot change caching after evaluation has completed.");
        }
        if (this._never || this._forever) {
          throw new Error("Caching has already been configured with .never or .forever()");
        }
        this._configured = true;
        const key2 = handler(this._data);
        this._pairs.push([key2, handler]);
        return key2;
      }
      invalidate(handler) {
        if (!this._active) {
          throw new Error("Cannot change caching after evaluation has completed.");
        }
        if (this._never || this._forever) {
          throw new Error("Caching has already been configured with .never or .forever()");
        }
        this._invalidate = true;
        this._configured = true;
        const key2 = handler(this._data);
        this._pairs.push([key2, handler]);
        return key2;
      }
      validator() {
        const pairs = this._pairs;
        return (data) => pairs.every(([key2, fn]) => key2 === fn(data));
      }
      deactivate() {
        this._active = false;
      }
      configured() {
        return this._configured;
      }
    };
    function makeSimpleConfigurator(cache) {
      function cacheFn(val) {
        if (typeof val === "boolean") {
          if (val) cache.forever();
          else cache.never();
          return;
        }
        return cache.using(() => assertSimpleType(val()));
      }
      cacheFn.forever = () => cache.forever();
      cacheFn.never = () => cache.never();
      cacheFn.using = (cb) => cache.using(() => assertSimpleType(cb()));
      cacheFn.invalidate = (cb) => cache.invalidate(() => assertSimpleType(cb()));
      return cacheFn;
    }
    function assertSimpleType(value) {
      if (value != null && typeof value !== "string" && typeof value !== "boolean" && typeof value !== "number") {
        throw new Error("Cache keys must be either string, boolean, number, null, or undefined.");
      }
      return value;
    }
  }
});

// node_modules/@babel/core/lib/config/files/utils.js
var require_utils = __commonJS({
  "node_modules/@babel/core/lib/config/files/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.makeStaticFileCache = makeStaticFileCache;
    function _fs() {
      const data = _interopRequireDefault(require("fs"));
      _fs = function() {
        return data;
      };
      return data;
    }
    var _caching = require_caching();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function makeStaticFileCache(fn) {
      return (0, _caching.makeStrongCache)((filepath, cache) => {
        if (cache.invalidate(() => fileMtime(filepath)) === null) {
          cache.forever();
          return null;
        }
        return fn(filepath, _fs().default.readFileSync(filepath, "utf8"));
      });
    }
    function fileMtime(filepath) {
      try {
        return +_fs().default.statSync(filepath).mtime;
      } catch (e) {
        if (e.code !== "ENOENT" && e.code !== "ENOTDIR") throw e;
      }
      return null;
    }
  }
});

// node_modules/@babel/core/lib/config/files/package.js
var require_package = __commonJS({
  "node_modules/@babel/core/lib/config/files/package.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.findPackageData = findPackageData;
    function _path() {
      const data = _interopRequireDefault(require("path"));
      _path = function() {
        return data;
      };
      return data;
    }
    var _utils = require_utils();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var PACKAGE_FILENAME = "package.json";
    function findPackageData(filepath) {
      let pkg = null;
      const directories = [];
      let isPackage = true;
      let dirname = _path().default.dirname(filepath);
      while (!pkg && _path().default.basename(dirname) !== "node_modules") {
        directories.push(dirname);
        pkg = readConfigPackage(_path().default.join(dirname, PACKAGE_FILENAME));
        const nextLoc = _path().default.dirname(dirname);
        if (dirname === nextLoc) {
          isPackage = false;
          break;
        }
        dirname = nextLoc;
      }
      return {
        filepath,
        directories,
        pkg,
        isPackage
      };
    }
    var readConfigPackage = (0, _utils.makeStaticFileCache)((filepath, content) => {
      let options;
      try {
        options = JSON.parse(content);
      } catch (err) {
        err.message = `${filepath}: Error while parsing JSON - ${err.message}`;
        throw err;
      }
      if (typeof options !== "object") {
        throw new Error(`${filepath}: Config returned typeof ${typeof options}`);
      }
      if (Array.isArray(options)) {
        throw new Error(`${filepath}: Expected config object but found array`);
      }
      return {
        filepath,
        dirname: _path().default.dirname(filepath),
        options
      };
    });
  }
});

// ../../node_modules/json5/dist/index.mjs
var dist_exports = {};
__export(dist_exports, {
  default: () => dist_default
});
function internalize(holder, name, reviver) {
  const value = holder[name];
  if (value != null && typeof value === "object") {
    if (Array.isArray(value)) {
      for (let i = 0; i < value.length; i++) {
        const key2 = String(i);
        const replacement = internalize(value, key2, reviver);
        if (replacement === void 0) {
          delete value[key2];
        } else {
          Object.defineProperty(value, key2, {
            value: replacement,
            writable: true,
            enumerable: true,
            configurable: true
          });
        }
      }
    } else {
      for (const key2 in value) {
        const replacement = internalize(value, key2, reviver);
        if (replacement === void 0) {
          delete value[key2];
        } else {
          Object.defineProperty(value, key2, {
            value: replacement,
            writable: true,
            enumerable: true,
            configurable: true
          });
        }
      }
    }
  }
  return reviver.call(holder, name, value);
}
function lex() {
  lexState = "default";
  buffer = "";
  doubleQuote = false;
  sign = 1;
  for (; ; ) {
    c = peek();
    const token2 = lexStates[lexState]();
    if (token2) {
      return token2;
    }
  }
}
function peek() {
  if (source[pos]) {
    return String.fromCodePoint(source.codePointAt(pos));
  }
}
function read() {
  const c2 = peek();
  if (c2 === "\n") {
    line++;
    column = 0;
  } else if (c2) {
    column += c2.length;
  } else {
    column++;
  }
  if (c2) {
    pos += c2.length;
  }
  return c2;
}
function newToken(type, value) {
  return {
    type,
    value,
    line,
    column
  };
}
function literal(s) {
  for (const c2 of s) {
    const p = peek();
    if (p !== c2) {
      throw invalidChar(read());
    }
    read();
  }
}
function escape() {
  const c2 = peek();
  switch (c2) {
    case "b":
      read();
      return "\b";
    case "f":
      read();
      return "\f";
    case "n":
      read();
      return "\n";
    case "r":
      read();
      return "\r";
    case "t":
      read();
      return "	";
    case "v":
      read();
      return "\v";
    case "0":
      read();
      if (util.isDigit(peek())) {
        throw invalidChar(read());
      }
      return "\0";
    case "x":
      read();
      return hexEscape();
    case "u":
      read();
      return unicodeEscape();
    case "\n":
    case "\u2028":
    case "\u2029":
      read();
      return "";
    case "\r":
      read();
      if (peek() === "\n") {
        read();
      }
      return "";
    case "1":
    case "2":
    case "3":
    case "4":
    case "5":
    case "6":
    case "7":
    case "8":
    case "9":
      throw invalidChar(read());
    case void 0:
      throw invalidChar(read());
  }
  return read();
}
function hexEscape() {
  let buffer2 = "";
  let c2 = peek();
  if (!util.isHexDigit(c2)) {
    throw invalidChar(read());
  }
  buffer2 += read();
  c2 = peek();
  if (!util.isHexDigit(c2)) {
    throw invalidChar(read());
  }
  buffer2 += read();
  return String.fromCodePoint(parseInt(buffer2, 16));
}
function unicodeEscape() {
  let buffer2 = "";
  let count = 4;
  while (count-- > 0) {
    const c2 = peek();
    if (!util.isHexDigit(c2)) {
      throw invalidChar(read());
    }
    buffer2 += read();
  }
  return String.fromCodePoint(parseInt(buffer2, 16));
}
function push() {
  let value;
  switch (token.type) {
    case "punctuator":
      switch (token.value) {
        case "{":
          value = {};
          break;
        case "[":
          value = [];
          break;
      }
      break;
    case "null":
    case "boolean":
    case "numeric":
    case "string":
      value = token.value;
      break;
  }
  if (root === void 0) {
    root = value;
  } else {
    const parent = stack[stack.length - 1];
    if (Array.isArray(parent)) {
      parent.push(value);
    } else {
      Object.defineProperty(parent, key, {
        value,
        writable: true,
        enumerable: true,
        configurable: true
      });
    }
  }
  if (value !== null && typeof value === "object") {
    stack.push(value);
    if (Array.isArray(value)) {
      parseState = "beforeArrayValue";
    } else {
      parseState = "beforePropertyName";
    }
  } else {
    const current = stack[stack.length - 1];
    if (current == null) {
      parseState = "end";
    } else if (Array.isArray(current)) {
      parseState = "afterArrayValue";
    } else {
      parseState = "afterPropertyValue";
    }
  }
}
function pop() {
  stack.pop();
  const current = stack[stack.length - 1];
  if (current == null) {
    parseState = "end";
  } else if (Array.isArray(current)) {
    parseState = "afterArrayValue";
  } else {
    parseState = "afterPropertyValue";
  }
}
function invalidChar(c2) {
  if (c2 === void 0) {
    return syntaxError(`JSON5: invalid end of input at ${line}:${column}`);
  }
  return syntaxError(`JSON5: invalid character '${formatChar(c2)}' at ${line}:${column}`);
}
function invalidEOF() {
  return syntaxError(`JSON5: invalid end of input at ${line}:${column}`);
}
function invalidIdentifier() {
  column -= 5;
  return syntaxError(`JSON5: invalid identifier character at ${line}:${column}`);
}
function separatorChar(c2) {
  console.warn(`JSON5: '${formatChar(c2)}' in strings is not valid ECMAScript; consider escaping`);
}
function formatChar(c2) {
  const replacements = {
    "'": "\\'",
    '"': '\\"',
    "\\": "\\\\",
    "\b": "\\b",
    "\f": "\\f",
    "\n": "\\n",
    "\r": "\\r",
    "	": "\\t",
    "\v": "\\v",
    "\0": "\\0",
    "\u2028": "\\u2028",
    "\u2029": "\\u2029"
  };
  if (replacements[c2]) {
    return replacements[c2];
  }
  if (c2 < " ") {
    const hexString = c2.charCodeAt(0).toString(16);
    return "\\x" + ("00" + hexString).substring(hexString.length);
  }
  return c2;
}
function syntaxError(message) {
  const err = new SyntaxError(message);
  err.lineNumber = line;
  err.columnNumber = column;
  return err;
}
var Space_Separator, ID_Start, ID_Continue, unicode, util, source, parseState, stack, pos, line, column, token, key, root, parse, lexState, buffer, doubleQuote, sign, c, lexStates, parseStates, stringify, JSON5, lib, dist_default;
var init_dist = __esm({
  "../../node_modules/json5/dist/index.mjs"() {
    "use strict";
    Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/;
    ID_Start = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/;
    ID_Continue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/;
    unicode = {
      Space_Separator,
      ID_Start,
      ID_Continue
    };
    util = {
      isSpaceSeparator(c2) {
        return typeof c2 === "string" && unicode.Space_Separator.test(c2);
      },
      isIdStartChar(c2) {
        return typeof c2 === "string" && (c2 >= "a" && c2 <= "z" || c2 >= "A" && c2 <= "Z" || c2 === "$" || c2 === "_" || unicode.ID_Start.test(c2));
      },
      isIdContinueChar(c2) {
        return typeof c2 === "string" && (c2 >= "a" && c2 <= "z" || c2 >= "A" && c2 <= "Z" || c2 >= "0" && c2 <= "9" || c2 === "$" || c2 === "_" || c2 === "\u200C" || c2 === "\u200D" || unicode.ID_Continue.test(c2));
      },
      isDigit(c2) {
        return typeof c2 === "string" && /[0-9]/.test(c2);
      },
      isHexDigit(c2) {
        return typeof c2 === "string" && /[0-9A-Fa-f]/.test(c2);
      }
    };
    parse = function parse2(text, reviver) {
      source = String(text);
      parseState = "start";
      stack = [];
      pos = 0;
      line = 1;
      column = 0;
      token = void 0;
      key = void 0;
      root = void 0;
      do {
        token = lex();
        parseStates[parseState]();
      } while (token.type !== "eof");
      if (typeof reviver === "function") {
        return internalize({ "": root }, "", reviver);
      }
      return root;
    };
    lexStates = {
      default() {
        switch (c) {
          case "	":
          case "\v":
          case "\f":
          case " ":
          case "\xA0":
          case "\uFEFF":
          case "\n":
          case "\r":
          case "\u2028":
          case "\u2029":
            read();
            return;
          case "/":
            read();
            lexState = "comment";
            return;
          case void 0:
            read();
            return newToken("eof");
        }
        if (util.isSpaceSeparator(c)) {
          read();
          return;
        }
        return lexStates[parseState]();
      },
      comment() {
        switch (c) {
          case "*":
            read();
            lexState = "multiLineComment";
            return;
          case "/":
            read();
            lexState = "singleLineComment";
            return;
        }
        throw invalidChar(read());
      },
      multiLineComment() {
        switch (c) {
          case "*":
            read();
            lexState = "multiLineCommentAsterisk";
            return;
          case void 0:
            throw invalidChar(read());
        }
        read();
      },
      multiLineCommentAsterisk() {
        switch (c) {
          case "*":
            read();
            return;
          case "/":
            read();
            lexState = "default";
            return;
          case void 0:
            throw invalidChar(read());
        }
        read();
        lexState = "multiLineComment";
      },
      singleLineComment() {
        switch (c) {
          case "\n":
          case "\r":
          case "\u2028":
          case "\u2029":
            read();
            lexState = "default";
            return;
          case void 0:
            read();
            return newToken("eof");
        }
        read();
      },
      value() {
        switch (c) {
          case "{":
          case "[":
            return newToken("punctuator", read());
          case "n":
            read();
            literal("ull");
            return newToken("null", null);
          case "t":
            read();
            literal("rue");
            return newToken("boolean", true);
          case "f":
            read();
            literal("alse");
            return newToken("boolean", false);
          case "-":
          case "+":
            if (read() === "-") {
              sign = -1;
            }
            lexState = "sign";
            return;
          case ".":
            buffer = read();
            lexState = "decimalPointLeading";
            return;
          case "0":
            buffer = read();
            lexState = "zero";
            return;
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
            buffer = read();
            lexState = "decimalInteger";
            return;
          case "I":
            read();
            literal("nfinity");
            return newToken("numeric", Infinity);
          case "N":
            read();
            literal("aN");
            return newToken("numeric", NaN);
          case '"':
          case "'":
            doubleQuote = read() === '"';
            buffer = "";
            lexState = "string";
            return;
        }
        throw invalidChar(read());
      },
      identifierNameStartEscape() {
        if (c !== "u") {
          throw invalidChar(read());
        }
        read();
        const u = unicodeEscape();
        switch (u) {
          case "$":
          case "_":
            break;
          default:
            if (!util.isIdStartChar(u)) {
              throw invalidIdentifier();
            }
            break;
        }
        buffer += u;
        lexState = "identifierName";
      },
      identifierName() {
        switch (c) {
          case "$":
          case "_":
          case "\u200C":
          case "\u200D":
            buffer += read();
            return;
          case "\\":
            read();
            lexState = "identifierNameEscape";
            return;
        }
        if (util.isIdContinueChar(c)) {
          buffer += read();
          return;
        }
        return newToken("identifier", buffer);
      },
      identifierNameEscape() {
        if (c !== "u") {
          throw invalidChar(read());
        }
        read();
        const u = unicodeEscape();
        switch (u) {
          case "$":
          case "_":
          case "\u200C":
          case "\u200D":
            break;
          default:
            if (!util.isIdContinueChar(u)) {
              throw invalidIdentifier();
            }
            break;
        }
        buffer += u;
        lexState = "identifierName";
      },
      sign() {
        switch (c) {
          case ".":
            buffer = read();
            lexState = "decimalPointLeading";
            return;
          case "0":
            buffer = read();
            lexState = "zero";
            return;
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
            buffer = read();
            lexState = "decimalInteger";
            return;
          case "I":
            read();
            literal("nfinity");
            return newToken("numeric", sign * Infinity);
          case "N":
            read();
            literal("aN");
            return newToken("numeric", NaN);
        }
        throw invalidChar(read());
      },
      zero() {
        switch (c) {
          case ".":
            buffer += read();
            lexState = "decimalPoint";
            return;
          case "e":
          case "E":
            buffer += read();
            lexState = "decimalExponent";
            return;
          case "x":
          case "X":
            buffer += read();
            lexState = "hexadecimal";
            return;
        }
        return newToken("numeric", sign * 0);
      },
      decimalInteger() {
        switch (c) {
          case ".":
            buffer += read();
            lexState = "decimalPoint";
            return;
          case "e":
          case "E":
            buffer += read();
            lexState = "decimalExponent";
            return;
        }
        if (util.isDigit(c)) {
          buffer += read();
          return;
        }
        return newToken("numeric", sign * Number(buffer));
      },
      decimalPointLeading() {
        if (util.isDigit(c)) {
          buffer += read();
          lexState = "decimalFraction";
          return;
        }
        throw invalidChar(read());
      },
      decimalPoint() {
        switch (c) {
          case "e":
          case "E":
            buffer += read();
            lexState = "decimalExponent";
            return;
        }
        if (util.isDigit(c)) {
          buffer += read();
          lexState = "decimalFraction";
          return;
        }
        return newToken("numeric", sign * Number(buffer));
      },
      decimalFraction() {
        switch (c) {
          case "e":
          case "E":
            buffer += read();
            lexState = "decimalExponent";
            return;
        }
        if (util.isDigit(c)) {
          buffer += read();
          return;
        }
        return newToken("numeric", sign * Number(buffer));
      },
      decimalExponent() {
        switch (c) {
          case "+":
          case "-":
            buffer += read();
            lexState = "decimalExponentSign";
            return;
        }
        if (util.isDigit(c)) {
          buffer += read();
          lexState = "decimalExponentInteger";
          return;
        }
        throw invalidChar(read());
      },
      decimalExponentSign() {
        if (util.isDigit(c)) {
          buffer += read();
          lexState = "decimalExponentInteger";
          return;
        }
        throw invalidChar(read());
      },
      decimalExponentInteger() {
        if (util.isDigit(c)) {
          buffer += read();
          return;
        }
        return newToken("numeric", sign * Number(buffer));
      },
      hexadecimal() {
        if (util.isHexDigit(c)) {
          buffer += read();
          lexState = "hexadecimalInteger";
          return;
        }
        throw invalidChar(read());
      },
      hexadecimalInteger() {
        if (util.isHexDigit(c)) {
          buffer += read();
          return;
        }
        return newToken("numeric", sign * Number(buffer));
      },
      string() {
        switch (c) {
          case "\\":
            read();
            buffer += escape();
            return;
          case '"':
            if (doubleQuote) {
              read();
              return newToken("string", buffer);
            }
            buffer += read();
            return;
          case "'":
            if (!doubleQuote) {
              read();
              return newToken("string", buffer);
            }
            buffer += read();
            return;
          case "\n":
          case "\r":
            throw invalidChar(read());
          case "\u2028":
          case "\u2029":
            separatorChar(c);
            break;
          case void 0:
            throw invalidChar(read());
        }
        buffer += read();
      },
      start() {
        switch (c) {
          case "{":
          case "[":
            return newToken("punctuator", read());
        }
        lexState = "value";
      },
      beforePropertyName() {
        switch (c) {
          case "$":
          case "_":
            buffer = read();
            lexState = "identifierName";
            return;
          case "\\":
            read();
            lexState = "identifierNameStartEscape";
            return;
          case "}":
            return newToken("punctuator", read());
          case '"':
          case "'":
            doubleQuote = read() === '"';
            lexState = "string";
            return;
        }
        if (util.isIdStartChar(c)) {
          buffer += read();
          lexState = "identifierName";
          return;
        }
        throw invalidChar(read());
      },
      afterPropertyName() {
        if (c === ":") {
          return newToken("punctuator", read());
        }
        throw invalidChar(read());
      },
      beforePropertyValue() {
        lexState = "value";
      },
      afterPropertyValue() {
        switch (c) {
          case ",":
          case "}":
            return newToken("punctuator", read());
        }
        throw invalidChar(read());
      },
      beforeArrayValue() {
        if (c === "]") {
          return newToken("punctuator", read());
        }
        lexState = "value";
      },
      afterArrayValue() {
        switch (c) {
          case ",":
          case "]":
            return newToken("punctuator", read());
        }
        throw invalidChar(read());
      },
      end() {
        throw invalidChar(read());
      }
    };
    parseStates = {
      start() {
        if (token.type === "eof") {
          throw invalidEOF();
        }
        push();
      },
      beforePropertyName() {
        switch (token.type) {
          case "identifier":
          case "string":
            key = token.value;
            parseState = "afterPropertyName";
            return;
          case "punctuator":
            pop();
            return;
          case "eof":
            throw invalidEOF();
        }
      },
      afterPropertyName() {
        if (token.type === "eof") {
          throw invalidEOF();
        }
        parseState = "beforePropertyValue";
      },
      beforePropertyValue() {
        if (token.type === "eof") {
          throw invalidEOF();
        }
        push();
      },
      beforeArrayValue() {
        if (token.type === "eof") {
          throw invalidEOF();
        }
        if (token.type === "punctuator" && token.value === "]") {
          pop();
          return;
        }
        push();
      },
      afterPropertyValue() {
        if (token.type === "eof") {
          throw invalidEOF();
        }
        switch (token.value) {
          case ",":
            parseState = "beforePropertyName";
            return;
          case "}":
            pop();
        }
      },
      afterArrayValue() {
        if (token.type === "eof") {
          throw invalidEOF();
        }
        switch (token.value) {
          case ",":
            parseState = "beforeArrayValue";
            return;
          case "]":
            pop();
        }
      },
      end() {
      }
    };
    stringify = function stringify2(value, replacer, space) {
      const stack2 = [];
      let indent = "";
      let propertyList;
      let replacerFunc;
      let gap = "";
      let quote;
      if (replacer != null && typeof replacer === "object" && !Array.isArray(replacer)) {
        space = replacer.space;
        quote = replacer.quote;
        replacer = replacer.replacer;
      }
      if (typeof replacer === "function") {
        replacerFunc = replacer;
      } else if (Array.isArray(replacer)) {
        propertyList = [];
        for (const v of replacer) {
          let item;
          if (typeof v === "string") {
            item = v;
          } else if (typeof v === "number" || v instanceof String || v instanceof Number) {
            item = String(v);
          }
          if (item !== void 0 && propertyList.indexOf(item) < 0) {
            propertyList.push(item);
          }
        }
      }
      if (space instanceof Number) {
        space = Number(space);
      } else if (space instanceof String) {
        space = String(space);
      }
      if (typeof space === "number") {
        if (space > 0) {
          space = Math.min(10, Math.floor(space));
          gap = "          ".substr(0, space);
        }
      } else if (typeof space === "string") {
        gap = space.substr(0, 10);
      }
      return serializeProperty("", { "": value });
      function serializeProperty(key2, holder) {
        let value2 = holder[key2];
        if (value2 != null) {
          if (typeof value2.toJSON5 === "function") {
            value2 = value2.toJSON5(key2);
          } else if (typeof value2.toJSON === "function") {
            value2 = value2.toJSON(key2);
          }
        }
        if (replacerFunc) {
          value2 = replacerFunc.call(holder, key2, value2);
        }
        if (value2 instanceof Number) {
          value2 = Number(value2);
        } else if (value2 instanceof String) {
          value2 = String(value2);
        } else if (value2 instanceof Boolean) {
          value2 = value2.valueOf();
        }
        switch (value2) {
          case null:
            return "null";
          case true:
            return "true";
          case false:
            return "false";
        }
        if (typeof value2 === "string") {
          return quoteString(value2, false);
        }
        if (typeof value2 === "number") {
          return String(value2);
        }
        if (typeof value2 === "object") {
          return Array.isArray(value2) ? serializeArray(value2) : serializeObject(value2);
        }
        return void 0;
      }
      function quoteString(value2) {
        const quotes = {
          "'": 0.1,
          '"': 0.2
        };
        const replacements = {
          "'": "\\'",
          '"': '\\"',
          "\\": "\\\\",
          "\b": "\\b",
          "\f": "\\f",
          "\n": "\\n",
          "\r": "\\r",
          "	": "\\t",
          "\v": "\\v",
          "\0": "\\0",
          "\u2028": "\\u2028",
          "\u2029": "\\u2029"
        };
        let product = "";
        for (let i = 0; i < value2.length; i++) {
          const c2 = value2[i];
          switch (c2) {
            case "'":
            case '"':
              quotes[c2]++;
              product += c2;
              continue;
            case "\0":
              if (util.isDigit(value2[i + 1])) {
                product += "\\x00";
                continue;
              }
          }
          if (replacements[c2]) {
            product += replacements[c2];
            continue;
          }
          if (c2 < " ") {
            let hexString = c2.charCodeAt(0).toString(16);
            product += "\\x" + ("00" + hexString).substring(hexString.length);
            continue;
          }
          product += c2;
        }
        const quoteChar = quote || Object.keys(quotes).reduce((a, b) => quotes[a] < quotes[b] ? a : b);
        product = product.replace(new RegExp(quoteChar, "g"), replacements[quoteChar]);
        return quoteChar + product + quoteChar;
      }
      function serializeObject(value2) {
        if (stack2.indexOf(value2) >= 0) {
          throw TypeError("Converting circular structure to JSON5");
        }
        stack2.push(value2);
        let stepback = indent;
        indent = indent + gap;
        let keys = propertyList || Object.keys(value2);
        let partial = [];
        for (const key2 of keys) {
          const propertyString = serializeProperty(key2, value2);
          if (propertyString !== void 0) {
            let member = serializeKey(key2) + ":";
            if (gap !== "") {
              member += " ";
            }
            member += propertyString;
            partial.push(member);
          }
        }
        let final;
        if (partial.length === 0) {
          final = "{}";
        } else {
          let properties;
          if (gap === "") {
            properties = partial.join(",");
            final = "{" + properties + "}";
          } else {
            let separator = ",\n" + indent;
            properties = partial.join(separator);
            final = "{\n" + indent + properties + ",\n" + stepback + "}";
          }
        }
        stack2.pop();
        indent = stepback;
        return final;
      }
      function serializeKey(key2) {
        if (key2.length === 0) {
          return quoteString(key2, true);
        }
        const firstChar = String.fromCodePoint(key2.codePointAt(0));
        if (!util.isIdStartChar(firstChar)) {
          return quoteString(key2, true);
        }
        for (let i = firstChar.length; i < key2.length; i++) {
          if (!util.isIdContinueChar(String.fromCodePoint(key2.codePointAt(i)))) {
            return quoteString(key2, true);
          }
        }
        return key2;
      }
      function serializeArray(value2) {
        if (stack2.indexOf(value2) >= 0) {
          throw TypeError("Converting circular structure to JSON5");
        }
        stack2.push(value2);
        let stepback = indent;
        indent = indent + gap;
        let partial = [];
        for (let i = 0; i < value2.length; i++) {
          const propertyString = serializeProperty(String(i), value2);
          partial.push(propertyString !== void 0 ? propertyString : "null");
        }
        let final;
        if (partial.length === 0) {
          final = "[]";
        } else {
          if (gap === "") {
            let properties = partial.join(",");
            final = "[" + properties + "]";
          } else {
            let separator = ",\n" + indent;
            let properties = partial.join(separator);
            final = "[\n" + indent + properties + ",\n" + stepback + "]";
          }
        }
        stack2.pop();
        indent = stepback;
        return final;
      }
    };
    JSON5 = {
      parse,
      stringify
    };
    lib = JSON5;
    dist_default = lib;
  }
});

// ../../node_modules/resolve/lib/homedir.js
var require_homedir = __commonJS({
  "../../node_modules/resolve/lib/homedir.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    module2.exports = os.homedir || function homedir() {
      var home = process.env.HOME;
      var user = process.env.LOGNAME || process.env.USER || process.env.LNAME || process.env.USERNAME;
      if (process.platform === "win32") {
        return process.env.USERPROFILE || process.env.HOMEDRIVE + process.env.HOMEPATH || home || null;
      }
      if (process.platform === "darwin") {
        return home || (user ? "/Users/" + user : null);
      }
      if (process.platform === "linux") {
        return home || (process.getuid() === 0 ? "/root" : user ? "/home/" + user : null);
      }
      return home || null;
    };
  }
});

// ../../node_modules/resolve/lib/caller.js
var require_caller = __commonJS({
  "../../node_modules/resolve/lib/caller.js"(exports2, module2) {
    "use strict";
    module2.exports = function() {
      var origPrepareStackTrace = Error.prepareStackTrace;
      Error.prepareStackTrace = function(_, stack3) {
        return stack3;
      };
      var stack2 = new Error().stack;
      Error.prepareStackTrace = origPrepareStackTrace;
      return stack2[2].getFileName();
    };
  }
});

// ../../node_modules/path-parse/index.js
var require_path_parse = __commonJS({
  "../../node_modules/path-parse/index.js"(exports2, module2) {
    "use strict";
    var isWindows = process.platform === "win32";
    var splitWindowsRe = /^(((?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?[\\\/]?)(?:[^\\\/]*[\\\/])*)((\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))[\\\/]*$/;
    var win32 = {};
    function win32SplitPath(filename) {
      return splitWindowsRe.exec(filename).slice(1);
    }
    win32.parse = function(pathString) {
      if (typeof pathString !== "string") {
        throw new TypeError(
          "Parameter 'pathString' must be a string, not " + typeof pathString
        );
      }
      var allParts = win32SplitPath(pathString);
      if (!allParts || allParts.length !== 5) {
        throw new TypeError("Invalid path '" + pathString + "'");
      }
      return {
        root: allParts[1],
        dir: allParts[0] === allParts[1] ? allParts[0] : allParts[0].slice(0, -1),
        base: allParts[2],
        ext: allParts[4],
        name: allParts[3]
      };
    };
    var splitPathRe = /^((\/?)(?:[^\/]*\/)*)((\.{1,2}|[^\/]+?|)(\.[^.\/]*|))[\/]*$/;
    var posix = {};
    function posixSplitPath(filename) {
      return splitPathRe.exec(filename).slice(1);
    }
    posix.parse = function(pathString) {
      if (typeof pathString !== "string") {
        throw new TypeError(
          "Parameter 'pathString' must be a string, not " + typeof pathString
        );
      }
      var allParts = posixSplitPath(pathString);
      if (!allParts || allParts.length !== 5) {
        throw new TypeError("Invalid path '" + pathString + "'");
      }
      return {
        root: allParts[1],
        dir: allParts[0].slice(0, -1),
        base: allParts[2],
        ext: allParts[4],
        name: allParts[3]
      };
    };
    if (isWindows)
      module2.exports = win32.parse;
    else
      module2.exports = posix.parse;
    module2.exports.posix = posix.parse;
    module2.exports.win32 = win32.parse;
  }
});

// ../../node_modules/resolve/lib/node-modules-paths.js
var require_node_modules_paths = __commonJS({
  "../../node_modules/resolve/lib/node-modules-paths.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var parse4 = path.parse || require_path_parse();
    var getNodeModulesDirs = function getNodeModulesDirs2(absoluteStart, modules) {
      var prefix = "/";
      if (/^([A-Za-z]:)/.test(absoluteStart)) {
        prefix = "";
      } else if (/^\\\\/.test(absoluteStart)) {
        prefix = "\\\\";
      }
      var paths = [absoluteStart];
      var parsed = parse4(absoluteStart);
      while (parsed.dir !== paths[paths.length - 1]) {
        paths.push(parsed.dir);
        parsed = parse4(parsed.dir);
      }
      return paths.reduce(function(dirs, aPath) {
        return dirs.concat(modules.map(function(moduleDir) {
          return path.resolve(prefix, aPath, moduleDir);
        }));
      }, []);
    };
    module2.exports = function nodeModulesPaths(start, opts, request) {
      var modules = opts && opts.moduleDirectory ? [].concat(opts.moduleDirectory) : ["node_modules"];
      if (opts && typeof opts.paths === "function") {
        return opts.paths(
          request,
          start,
          function() {
            return getNodeModulesDirs(start, modules);
          },
          opts
        );
      }
      var dirs = getNodeModulesDirs(start, modules);
      return opts && opts.paths ? dirs.concat(opts.paths) : dirs;
    };
  }
});

// ../../node_modules/resolve/lib/normalize-options.js
var require_normalize_options = __commonJS({
  "../../node_modules/resolve/lib/normalize-options.js"(exports2, module2) {
    "use strict";
    module2.exports = function(x, opts) {
      return opts || {};
    };
  }
});

// ../../node_modules/has/node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "../../node_modules/has/node_modules/function-bind/implementation.js"(exports2, module2) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var slice = Array.prototype.slice;
    var toStr = Object.prototype.toString;
    var funcType = "[object Function]";
    module2.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slice.call(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            args.concat(slice.call(arguments))
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        } else {
          return target.apply(
            that,
            args.concat(slice.call(arguments))
          );
        }
      };
      var boundLength = Math.max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs.push("$" + i);
      }
      bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty2 = function Empty3() {
        };
        Empty2.prototype = target.prototype;
        bound.prototype = new Empty2();
        Empty2.prototype = null;
      }
      return bound;
    };
  }
});

// ../../node_modules/has/node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "../../node_modules/has/node_modules/function-bind/index.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation();
    module2.exports = Function.prototype.bind || implementation;
  }
});

// ../../node_modules/has/src/index.js
var require_src2 = __commonJS({
  "../../node_modules/has/src/index.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    module2.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
  }
});

// ../../node_modules/is-core-module/core.json
var require_core = __commonJS({
  "../../node_modules/is-core-module/core.json"(exports2, module2) {
    module2.exports = {
      assert: true,
      "node:assert": [">= 14.18 && < 15", ">= 16"],
      "assert/strict": ">= 15",
      "node:assert/strict": ">= 16",
      async_hooks: ">= 8",
      "node:async_hooks": [">= 14.18 && < 15", ">= 16"],
      buffer_ieee754: ">= 0.5 && < 0.9.7",
      buffer: true,
      "node:buffer": [">= 14.18 && < 15", ">= 16"],
      child_process: true,
      "node:child_process": [">= 14.18 && < 15", ">= 16"],
      cluster: ">= 0.5",
      "node:cluster": [">= 14.18 && < 15", ">= 16"],
      console: true,
      "node:console": [">= 14.18 && < 15", ">= 16"],
      constants: true,
      "node:constants": [">= 14.18 && < 15", ">= 16"],
      crypto: true,
      "node:crypto": [">= 14.18 && < 15", ">= 16"],
      _debug_agent: ">= 1 && < 8",
      _debugger: "< 8",
      dgram: true,
      "node:dgram": [">= 14.18 && < 15", ">= 16"],
      diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],
      "node:diagnostics_channel": [">= 14.18 && < 15", ">= 16"],
      dns: true,
      "node:dns": [">= 14.18 && < 15", ">= 16"],
      "dns/promises": ">= 15",
      "node:dns/promises": ">= 16",
      domain: ">= 0.7.12",
      "node:domain": [">= 14.18 && < 15", ">= 16"],
      events: true,
      "node:events": [">= 14.18 && < 15", ">= 16"],
      freelist: "< 6",
      fs: true,
      "node:fs": [">= 14.18 && < 15", ">= 16"],
      "fs/promises": [">= 10 && < 10.1", ">= 14"],
      "node:fs/promises": [">= 14.18 && < 15", ">= 16"],
      _http_agent: ">= 0.11.1",
      "node:_http_agent": [">= 14.18 && < 15", ">= 16"],
      _http_client: ">= 0.11.1",
      "node:_http_client": [">= 14.18 && < 15", ">= 16"],
      _http_common: ">= 0.11.1",
      "node:_http_common": [">= 14.18 && < 15", ">= 16"],
      _http_incoming: ">= 0.11.1",
      "node:_http_incoming": [">= 14.18 && < 15", ">= 16"],
      _http_outgoing: ">= 0.11.1",
      "node:_http_outgoing": [">= 14.18 && < 15", ">= 16"],
      _http_server: ">= 0.11.1",
      "node:_http_server": [">= 14.18 && < 15", ">= 16"],
      http: true,
      "node:http": [">= 14.18 && < 15", ">= 16"],
      http2: ">= 8.8",
      "node:http2": [">= 14.18 && < 15", ">= 16"],
      https: true,
      "node:https": [">= 14.18 && < 15", ">= 16"],
      inspector: ">= 8",
      "node:inspector": [">= 14.18 && < 15", ">= 16"],
      _linklist: "< 8",
      module: true,
      "node:module": [">= 14.18 && < 15", ">= 16"],
      net: true,
      "node:net": [">= 14.18 && < 15", ">= 16"],
      "node-inspect/lib/_inspect": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
      os: true,
      "node:os": [">= 14.18 && < 15", ">= 16"],
      path: true,
      "node:path": [">= 14.18 && < 15", ">= 16"],
      "path/posix": ">= 15.3",
      "node:path/posix": ">= 16",
      "path/win32": ">= 15.3",
      "node:path/win32": ">= 16",
      perf_hooks: ">= 8.5",
      "node:perf_hooks": [">= 14.18 && < 15", ">= 16"],
      process: ">= 1",
      "node:process": [">= 14.18 && < 15", ">= 16"],
      punycode: ">= 0.5",
      "node:punycode": [">= 14.18 && < 15", ">= 16"],
      querystring: true,
      "node:querystring": [">= 14.18 && < 15", ">= 16"],
      readline: true,
      "node:readline": [">= 14.18 && < 15", ">= 16"],
      "readline/promises": ">= 17",
      "node:readline/promises": ">= 17",
      repl: true,
      "node:repl": [">= 14.18 && < 15", ">= 16"],
      smalloc: ">= 0.11.5 && < 3",
      _stream_duplex: ">= 0.9.4",
      "node:_stream_duplex": [">= 14.18 && < 15", ">= 16"],
      _stream_transform: ">= 0.9.4",
      "node:_stream_transform": [">= 14.18 && < 15", ">= 16"],
      _stream_wrap: ">= 1.4.1",
      "node:_stream_wrap": [">= 14.18 && < 15", ">= 16"],
      _stream_passthrough: ">= 0.9.4",
      "node:_stream_passthrough": [">= 14.18 && < 15", ">= 16"],
      _stream_readable: ">= 0.9.4",
      "node:_stream_readable": [">= 14.18 && < 15", ">= 16"],
      _stream_writable: ">= 0.9.4",
      "node:_stream_writable": [">= 14.18 && < 15", ">= 16"],
      stream: true,
      "node:stream": [">= 14.18 && < 15", ">= 16"],
      "stream/consumers": ">= 16.7",
      "node:stream/consumers": ">= 16.7",
      "stream/promises": ">= 15",
      "node:stream/promises": ">= 16",
      "stream/web": ">= 16.5",
      "node:stream/web": ">= 16.5",
      string_decoder: true,
      "node:string_decoder": [">= 14.18 && < 15", ">= 16"],
      sys: [">= 0.4 && < 0.7", ">= 0.8"],
      "node:sys": [">= 14.18 && < 15", ">= 16"],
      "node:test": [">= 16.17 && < 17", ">= 18"],
      timers: true,
      "node:timers": [">= 14.18 && < 15", ">= 16"],
      "timers/promises": ">= 15",
      "node:timers/promises": ">= 16",
      _tls_common: ">= 0.11.13",
      "node:_tls_common": [">= 14.18 && < 15", ">= 16"],
      _tls_legacy: ">= 0.11.3 && < 10",
      _tls_wrap: ">= 0.11.3",
      "node:_tls_wrap": [">= 14.18 && < 15", ">= 16"],
      tls: true,
      "node:tls": [">= 14.18 && < 15", ">= 16"],
      trace_events: ">= 10",
      "node:trace_events": [">= 14.18 && < 15", ">= 16"],
      tty: true,
      "node:tty": [">= 14.18 && < 15", ">= 16"],
      url: true,
      "node:url": [">= 14.18 && < 15", ">= 16"],
      util: true,
      "node:util": [">= 14.18 && < 15", ">= 16"],
      "util/types": ">= 15.3",
      "node:util/types": ">= 16",
      "v8/tools/arguments": ">= 10 && < 12",
      "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      v8: ">= 1",
      "node:v8": [">= 14.18 && < 15", ">= 16"],
      vm: true,
      "node:vm": [">= 14.18 && < 15", ">= 16"],
      wasi: ">= 13.4 && < 13.5",
      worker_threads: ">= 11.7",
      "node:worker_threads": [">= 14.18 && < 15", ">= 16"],
      zlib: ">= 0.5",
      "node:zlib": [">= 14.18 && < 15", ">= 16"]
    };
  }
});

// ../../node_modules/is-core-module/index.js
var require_is_core_module = __commonJS({
  "../../node_modules/is-core-module/index.js"(exports2, module2) {
    "use strict";
    var has = require_src2();
    function specifierIncluded(current, specifier) {
      var nodeParts = current.split(".");
      var parts = specifier.split(" ");
      var op = parts.length > 1 ? parts[0] : "=";
      var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split(".");
      for (var i = 0; i < 3; ++i) {
        var cur = parseInt(nodeParts[i] || 0, 10);
        var ver = parseInt(versionParts[i] || 0, 10);
        if (cur === ver) {
          continue;
        }
        if (op === "<") {
          return cur < ver;
        }
        if (op === ">=") {
          return cur >= ver;
        }
        return false;
      }
      return op === ">=";
    }
    function matchesRange(current, range) {
      var specifiers = range.split(/ ?&& ?/);
      if (specifiers.length === 0) {
        return false;
      }
      for (var i = 0; i < specifiers.length; ++i) {
        if (!specifierIncluded(current, specifiers[i])) {
          return false;
        }
      }
      return true;
    }
    function versionIncluded(nodeVersion, specifierValue) {
      if (typeof specifierValue === "boolean") {
        return specifierValue;
      }
      var current = typeof nodeVersion === "undefined" ? process.versions && process.versions.node : nodeVersion;
      if (typeof current !== "string") {
        throw new TypeError(typeof nodeVersion === "undefined" ? "Unable to determine current node version" : "If provided, a valid node version is required");
      }
      if (specifierValue && typeof specifierValue === "object") {
        for (var i = 0; i < specifierValue.length; ++i) {
          if (matchesRange(current, specifierValue[i])) {
            return true;
          }
        }
        return false;
      }
      return matchesRange(current, specifierValue);
    }
    var data = require_core();
    module2.exports = function isCore(x, nodeVersion) {
      return has(data, x) && versionIncluded(nodeVersion, data[x]);
    };
  }
});

// ../../node_modules/resolve/lib/async.js
var require_async = __commonJS({
  "../../node_modules/resolve/lib/async.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var getHomedir = require_homedir();
    var path = require("path");
    var caller = require_caller();
    var nodeModulesPaths = require_node_modules_paths();
    var normalizeOptions = require_normalize_options();
    var isCore = require_is_core_module();
    var realpathFS = process.platform !== "win32" && fs.realpath && typeof fs.realpath.native === "function" ? fs.realpath.native : fs.realpath;
    var homedir = getHomedir();
    var defaultPaths = function() {
      return [
        path.join(homedir, ".node_modules"),
        path.join(homedir, ".node_libraries")
      ];
    };
    var defaultIsFile = function isFile(file, cb) {
      fs.stat(file, function(err, stat) {
        if (!err) {
          return cb(null, stat.isFile() || stat.isFIFO());
        }
        if (err.code === "ENOENT" || err.code === "ENOTDIR") return cb(null, false);
        return cb(err);
      });
    };
    var defaultIsDir = function isDirectory(dir, cb) {
      fs.stat(dir, function(err, stat) {
        if (!err) {
          return cb(null, stat.isDirectory());
        }
        if (err.code === "ENOENT" || err.code === "ENOTDIR") return cb(null, false);
        return cb(err);
      });
    };
    var defaultRealpath = function realpath(x, cb) {
      realpathFS(x, function(realpathErr, realPath) {
        if (realpathErr && realpathErr.code !== "ENOENT") cb(realpathErr);
        else cb(null, realpathErr ? x : realPath);
      });
    };
    var maybeRealpath = function maybeRealpath2(realpath, x, opts, cb) {
      if (opts && opts.preserveSymlinks === false) {
        realpath(x, cb);
      } else {
        cb(null, x);
      }
    };
    var defaultReadPackage = function defaultReadPackage2(readFile, pkgfile, cb) {
      readFile(pkgfile, function(readFileErr, body) {
        if (readFileErr) cb(readFileErr);
        else {
          try {
            var pkg = JSON.parse(body);
            cb(null, pkg);
          } catch (jsonErr) {
            cb(null);
          }
        }
      });
    };
    var getPackageCandidates = function getPackageCandidates2(x, start, opts) {
      var dirs = nodeModulesPaths(start, opts, x);
      for (var i = 0; i < dirs.length; i++) {
        dirs[i] = path.join(dirs[i], x);
      }
      return dirs;
    };
    module2.exports = function resolve(x, options, callback) {
      var cb = callback;
      var opts = options;
      if (typeof options === "function") {
        cb = opts;
        opts = {};
      }
      if (typeof x !== "string") {
        var err = new TypeError("Path must be a string.");
        return process.nextTick(function() {
          cb(err);
        });
      }
      opts = normalizeOptions(x, opts);
      var isFile = opts.isFile || defaultIsFile;
      var isDirectory = opts.isDirectory || defaultIsDir;
      var readFile = opts.readFile || fs.readFile;
      var realpath = opts.realpath || defaultRealpath;
      var readPackage = opts.readPackage || defaultReadPackage;
      if (opts.readFile && opts.readPackage) {
        var conflictErr = new TypeError("`readFile` and `readPackage` are mutually exclusive.");
        return process.nextTick(function() {
          cb(conflictErr);
        });
      }
      var packageIterator = opts.packageIterator;
      var extensions = opts.extensions || [".js"];
      var includeCoreModules = opts.includeCoreModules !== false;
      var basedir = opts.basedir || path.dirname(caller());
      var parent = opts.filename || basedir;
      opts.paths = opts.paths || defaultPaths();
      var absoluteStart = path.resolve(basedir);
      maybeRealpath(
        realpath,
        absoluteStart,
        opts,
        function(err2, realStart) {
          if (err2) cb(err2);
          else init(realStart);
        }
      );
      var res;
      function init(basedir2) {
        if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
          res = path.resolve(basedir2, x);
          if (x === "." || x === ".." || x.slice(-1) === "/") res += "/";
          if (/\/$/.test(x) && res === basedir2) {
            loadAsDirectory(res, opts.package, onfile);
          } else loadAsFile(res, opts.package, onfile);
        } else if (includeCoreModules && isCore(x)) {
          return cb(null, x);
        } else loadNodeModules(x, basedir2, function(err2, n, pkg) {
          if (err2) cb(err2);
          else if (n) {
            return maybeRealpath(realpath, n, opts, function(err3, realN) {
              if (err3) {
                cb(err3);
              } else {
                cb(null, realN, pkg);
              }
            });
          } else {
            var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
            moduleError.code = "MODULE_NOT_FOUND";
            cb(moduleError);
          }
        });
      }
      function onfile(err2, m, pkg) {
        if (err2) cb(err2);
        else if (m) cb(null, m, pkg);
        else loadAsDirectory(res, function(err3, d, pkg2) {
          if (err3) cb(err3);
          else if (d) {
            maybeRealpath(realpath, d, opts, function(err4, realD) {
              if (err4) {
                cb(err4);
              } else {
                cb(null, realD, pkg2);
              }
            });
          } else {
            var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
            moduleError.code = "MODULE_NOT_FOUND";
            cb(moduleError);
          }
        });
      }
      function loadAsFile(x2, thePackage, callback2) {
        var loadAsFilePackage = thePackage;
        var cb2 = callback2;
        if (typeof loadAsFilePackage === "function") {
          cb2 = loadAsFilePackage;
          loadAsFilePackage = void 0;
        }
        var exts = [""].concat(extensions);
        load(exts, x2, loadAsFilePackage);
        function load(exts2, x3, loadPackage) {
          if (exts2.length === 0) return cb2(null, void 0, loadPackage);
          var file = x3 + exts2[0];
          var pkg = loadPackage;
          if (pkg) onpkg(null, pkg);
          else loadpkg(path.dirname(file), onpkg);
          function onpkg(err2, pkg_, dir) {
            pkg = pkg_;
            if (err2) return cb2(err2);
            if (dir && pkg && opts.pathFilter) {
              var rfile = path.relative(dir, file);
              var rel = rfile.slice(0, rfile.length - exts2[0].length);
              var r = opts.pathFilter(pkg, x3, rel);
              if (r) return load(
                [""].concat(extensions.slice()),
                path.resolve(dir, r),
                pkg
              );
            }
            isFile(file, onex);
          }
          function onex(err2, ex) {
            if (err2) return cb2(err2);
            if (ex) return cb2(null, file, pkg);
            load(exts2.slice(1), x3, pkg);
          }
        }
      }
      function loadpkg(dir, cb2) {
        if (dir === "" || dir === "/") return cb2(null);
        if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
          return cb2(null);
        }
        if (/[/\\]node_modules[/\\]*$/.test(dir)) return cb2(null);
        maybeRealpath(realpath, dir, opts, function(unwrapErr, pkgdir) {
          if (unwrapErr) return loadpkg(path.dirname(dir), cb2);
          var pkgfile = path.join(pkgdir, "package.json");
          isFile(pkgfile, function(err2, ex) {
            if (!ex) return loadpkg(path.dirname(dir), cb2);
            readPackage(readFile, pkgfile, function(err3, pkgParam) {
              if (err3) cb2(err3);
              var pkg = pkgParam;
              if (pkg && opts.packageFilter) {
                pkg = opts.packageFilter(pkg, pkgfile);
              }
              cb2(null, pkg, dir);
            });
          });
        });
      }
      function loadAsDirectory(x2, loadAsDirectoryPackage, callback2) {
        var cb2 = callback2;
        var fpkg = loadAsDirectoryPackage;
        if (typeof fpkg === "function") {
          cb2 = fpkg;
          fpkg = opts.package;
        }
        maybeRealpath(realpath, x2, opts, function(unwrapErr, pkgdir) {
          if (unwrapErr) return cb2(unwrapErr);
          var pkgfile = path.join(pkgdir, "package.json");
          isFile(pkgfile, function(err2, ex) {
            if (err2) return cb2(err2);
            if (!ex) return loadAsFile(path.join(x2, "index"), fpkg, cb2);
            readPackage(readFile, pkgfile, function(err3, pkgParam) {
              if (err3) return cb2(err3);
              var pkg = pkgParam;
              if (pkg && opts.packageFilter) {
                pkg = opts.packageFilter(pkg, pkgfile);
              }
              if (pkg && pkg.main) {
                if (typeof pkg.main !== "string") {
                  var mainError = new TypeError("package \u201C" + pkg.name + "\u201D `main` must be a string");
                  mainError.code = "INVALID_PACKAGE_MAIN";
                  return cb2(mainError);
                }
                if (pkg.main === "." || pkg.main === "./") {
                  pkg.main = "index";
                }
                loadAsFile(path.resolve(x2, pkg.main), pkg, function(err4, m, pkg2) {
                  if (err4) return cb2(err4);
                  if (m) return cb2(null, m, pkg2);
                  if (!pkg2) return loadAsFile(path.join(x2, "index"), pkg2, cb2);
                  var dir = path.resolve(x2, pkg2.main);
                  loadAsDirectory(dir, pkg2, function(err5, n, pkg3) {
                    if (err5) return cb2(err5);
                    if (n) return cb2(null, n, pkg3);
                    loadAsFile(path.join(x2, "index"), pkg3, cb2);
                  });
                });
                return;
              }
              loadAsFile(path.join(x2, "/index"), pkg, cb2);
            });
          });
        });
      }
      function processDirs(cb2, dirs) {
        if (dirs.length === 0) return cb2(null, void 0);
        var dir = dirs[0];
        isDirectory(path.dirname(dir), isdir);
        function isdir(err2, isdir2) {
          if (err2) return cb2(err2);
          if (!isdir2) return processDirs(cb2, dirs.slice(1));
          loadAsFile(dir, opts.package, onfile2);
        }
        function onfile2(err2, m, pkg) {
          if (err2) return cb2(err2);
          if (m) return cb2(null, m, pkg);
          loadAsDirectory(dir, opts.package, ondir);
        }
        function ondir(err2, n, pkg) {
          if (err2) return cb2(err2);
          if (n) return cb2(null, n, pkg);
          processDirs(cb2, dirs.slice(1));
        }
      }
      function loadNodeModules(x2, start, cb2) {
        var thunk = function() {
          return getPackageCandidates(x2, start, opts);
        };
        processDirs(
          cb2,
          packageIterator ? packageIterator(x2, start, thunk, opts) : thunk()
        );
      }
    };
  }
});

// ../../node_modules/resolve/lib/core.json
var require_core2 = __commonJS({
  "../../node_modules/resolve/lib/core.json"(exports2, module2) {
    module2.exports = {
      assert: true,
      "node:assert": [">= 14.18 && < 15", ">= 16"],
      "assert/strict": ">= 15",
      "node:assert/strict": ">= 16",
      async_hooks: ">= 8",
      "node:async_hooks": [">= 14.18 && < 15", ">= 16"],
      buffer_ieee754: ">= 0.5 && < 0.9.7",
      buffer: true,
      "node:buffer": [">= 14.18 && < 15", ">= 16"],
      child_process: true,
      "node:child_process": [">= 14.18 && < 15", ">= 16"],
      cluster: ">= 0.5",
      "node:cluster": [">= 14.18 && < 15", ">= 16"],
      console: true,
      "node:console": [">= 14.18 && < 15", ">= 16"],
      constants: true,
      "node:constants": [">= 14.18 && < 15", ">= 16"],
      crypto: true,
      "node:crypto": [">= 14.18 && < 15", ">= 16"],
      _debug_agent: ">= 1 && < 8",
      _debugger: "< 8",
      dgram: true,
      "node:dgram": [">= 14.18 && < 15", ">= 16"],
      diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],
      "node:diagnostics_channel": [">= 14.18 && < 15", ">= 16"],
      dns: true,
      "node:dns": [">= 14.18 && < 15", ">= 16"],
      "dns/promises": ">= 15",
      "node:dns/promises": ">= 16",
      domain: ">= 0.7.12",
      "node:domain": [">= 14.18 && < 15", ">= 16"],
      events: true,
      "node:events": [">= 14.18 && < 15", ">= 16"],
      freelist: "< 6",
      fs: true,
      "node:fs": [">= 14.18 && < 15", ">= 16"],
      "fs/promises": [">= 10 && < 10.1", ">= 14"],
      "node:fs/promises": [">= 14.18 && < 15", ">= 16"],
      _http_agent: ">= 0.11.1",
      "node:_http_agent": [">= 14.18 && < 15", ">= 16"],
      _http_client: ">= 0.11.1",
      "node:_http_client": [">= 14.18 && < 15", ">= 16"],
      _http_common: ">= 0.11.1",
      "node:_http_common": [">= 14.18 && < 15", ">= 16"],
      _http_incoming: ">= 0.11.1",
      "node:_http_incoming": [">= 14.18 && < 15", ">= 16"],
      _http_outgoing: ">= 0.11.1",
      "node:_http_outgoing": [">= 14.18 && < 15", ">= 16"],
      _http_server: ">= 0.11.1",
      "node:_http_server": [">= 14.18 && < 15", ">= 16"],
      http: true,
      "node:http": [">= 14.18 && < 15", ">= 16"],
      http2: ">= 8.8",
      "node:http2": [">= 14.18 && < 15", ">= 16"],
      https: true,
      "node:https": [">= 14.18 && < 15", ">= 16"],
      inspector: ">= 8",
      "node:inspector": [">= 14.18 && < 15", ">= 16"],
      _linklist: "< 8",
      module: true,
      "node:module": [">= 14.18 && < 15", ">= 16"],
      net: true,
      "node:net": [">= 14.18 && < 15", ">= 16"],
      "node-inspect/lib/_inspect": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
      os: true,
      "node:os": [">= 14.18 && < 15", ">= 16"],
      path: true,
      "node:path": [">= 14.18 && < 15", ">= 16"],
      "path/posix": ">= 15.3",
      "node:path/posix": ">= 16",
      "path/win32": ">= 15.3",
      "node:path/win32": ">= 16",
      perf_hooks: ">= 8.5",
      "node:perf_hooks": [">= 14.18 && < 15", ">= 16"],
      process: ">= 1",
      "node:process": [">= 14.18 && < 15", ">= 16"],
      punycode: ">= 0.5",
      "node:punycode": [">= 14.18 && < 15", ">= 16"],
      querystring: true,
      "node:querystring": [">= 14.18 && < 15", ">= 16"],
      readline: true,
      "node:readline": [">= 14.18 && < 15", ">= 16"],
      "readline/promises": ">= 17",
      "node:readline/promises": ">= 17",
      repl: true,
      "node:repl": [">= 14.18 && < 15", ">= 16"],
      smalloc: ">= 0.11.5 && < 3",
      _stream_duplex: ">= 0.9.4",
      "node:_stream_duplex": [">= 14.18 && < 15", ">= 16"],
      _stream_transform: ">= 0.9.4",
      "node:_stream_transform": [">= 14.18 && < 15", ">= 16"],
      _stream_wrap: ">= 1.4.1",
      "node:_stream_wrap": [">= 14.18 && < 15", ">= 16"],
      _stream_passthrough: ">= 0.9.4",
      "node:_stream_passthrough": [">= 14.18 && < 15", ">= 16"],
      _stream_readable: ">= 0.9.4",
      "node:_stream_readable": [">= 14.18 && < 15", ">= 16"],
      _stream_writable: ">= 0.9.4",
      "node:_stream_writable": [">= 14.18 && < 15", ">= 16"],
      stream: true,
      "node:stream": [">= 14.18 && < 15", ">= 16"],
      "stream/consumers": ">= 16.7",
      "node:stream/consumers": ">= 16.7",
      "stream/promises": ">= 15",
      "node:stream/promises": ">= 16",
      "stream/web": ">= 16.5",
      "node:stream/web": ">= 16.5",
      string_decoder: true,
      "node:string_decoder": [">= 14.18 && < 15", ">= 16"],
      sys: [">= 0.4 && < 0.7", ">= 0.8"],
      "node:sys": [">= 14.18 && < 15", ">= 16"],
      "node:test": ">= 18",
      timers: true,
      "node:timers": [">= 14.18 && < 15", ">= 16"],
      "timers/promises": ">= 15",
      "node:timers/promises": ">= 16",
      _tls_common: ">= 0.11.13",
      "node:_tls_common": [">= 14.18 && < 15", ">= 16"],
      _tls_legacy: ">= 0.11.3 && < 10",
      _tls_wrap: ">= 0.11.3",
      "node:_tls_wrap": [">= 14.18 && < 15", ">= 16"],
      tls: true,
      "node:tls": [">= 14.18 && < 15", ">= 16"],
      trace_events: ">= 10",
      "node:trace_events": [">= 14.18 && < 15", ">= 16"],
      tty: true,
      "node:tty": [">= 14.18 && < 15", ">= 16"],
      url: true,
      "node:url": [">= 14.18 && < 15", ">= 16"],
      util: true,
      "node:util": [">= 14.18 && < 15", ">= 16"],
      "util/types": ">= 15.3",
      "node:util/types": ">= 16",
      "v8/tools/arguments": ">= 10 && < 12",
      "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      v8: ">= 1",
      "node:v8": [">= 14.18 && < 15", ">= 16"],
      vm: true,
      "node:vm": [">= 14.18 && < 15", ">= 16"],
      wasi: ">= 13.4 && < 13.5",
      worker_threads: ">= 11.7",
      "node:worker_threads": [">= 14.18 && < 15", ">= 16"],
      zlib: ">= 0.5",
      "node:zlib": [">= 14.18 && < 15", ">= 16"]
    };
  }
});

// ../../node_modules/resolve/lib/core.js
var require_core3 = __commonJS({
  "../../node_modules/resolve/lib/core.js"(exports2, module2) {
    "use strict";
    var current = process.versions && process.versions.node && process.versions.node.split(".") || [];
    function specifierIncluded(specifier) {
      var parts = specifier.split(" ");
      var op = parts.length > 1 ? parts[0] : "=";
      var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split(".");
      for (var i = 0; i < 3; ++i) {
        var cur = parseInt(current[i] || 0, 10);
        var ver = parseInt(versionParts[i] || 0, 10);
        if (cur === ver) {
          continue;
        }
        if (op === "<") {
          return cur < ver;
        } else if (op === ">=") {
          return cur >= ver;
        }
        return false;
      }
      return op === ">=";
    }
    function matchesRange(range) {
      var specifiers = range.split(/ ?&& ?/);
      if (specifiers.length === 0) {
        return false;
      }
      for (var i = 0; i < specifiers.length; ++i) {
        if (!specifierIncluded(specifiers[i])) {
          return false;
        }
      }
      return true;
    }
    function versionIncluded(specifierValue) {
      if (typeof specifierValue === "boolean") {
        return specifierValue;
      }
      if (specifierValue && typeof specifierValue === "object") {
        for (var i = 0; i < specifierValue.length; ++i) {
          if (matchesRange(specifierValue[i])) {
            return true;
          }
        }
        return false;
      }
      return matchesRange(specifierValue);
    }
    var data = require_core2();
    var core = {};
    for (mod in data) {
      if (Object.prototype.hasOwnProperty.call(data, mod)) {
        core[mod] = versionIncluded(data[mod]);
      }
    }
    var mod;
    module2.exports = core;
  }
});

// ../../node_modules/resolve/lib/is-core.js
var require_is_core = __commonJS({
  "../../node_modules/resolve/lib/is-core.js"(exports2, module2) {
    "use strict";
    var isCoreModule = require_is_core_module();
    module2.exports = function isCore(x) {
      return isCoreModule(x);
    };
  }
});

// ../../node_modules/resolve/lib/sync.js
var require_sync = __commonJS({
  "../../node_modules/resolve/lib/sync.js"(exports2, module2) {
    "use strict";
    var isCore = require_is_core_module();
    var fs = require("fs");
    var path = require("path");
    var getHomedir = require_homedir();
    var caller = require_caller();
    var nodeModulesPaths = require_node_modules_paths();
    var normalizeOptions = require_normalize_options();
    var realpathFS = process.platform !== "win32" && fs.realpathSync && typeof fs.realpathSync.native === "function" ? fs.realpathSync.native : fs.realpathSync;
    var homedir = getHomedir();
    var defaultPaths = function() {
      return [
        path.join(homedir, ".node_modules"),
        path.join(homedir, ".node_libraries")
      ];
    };
    var defaultIsFile = function isFile(file) {
      try {
        var stat = fs.statSync(file, { throwIfNoEntry: false });
      } catch (e) {
        if (e && (e.code === "ENOENT" || e.code === "ENOTDIR")) return false;
        throw e;
      }
      return !!stat && (stat.isFile() || stat.isFIFO());
    };
    var defaultIsDir = function isDirectory(dir) {
      try {
        var stat = fs.statSync(dir, { throwIfNoEntry: false });
      } catch (e) {
        if (e && (e.code === "ENOENT" || e.code === "ENOTDIR")) return false;
        throw e;
      }
      return !!stat && stat.isDirectory();
    };
    var defaultRealpathSync = function realpathSync(x) {
      try {
        return realpathFS(x);
      } catch (realpathErr) {
        if (realpathErr.code !== "ENOENT") {
          throw realpathErr;
        }
      }
      return x;
    };
    var maybeRealpathSync = function maybeRealpathSync2(realpathSync, x, opts) {
      if (opts && opts.preserveSymlinks === false) {
        return realpathSync(x);
      }
      return x;
    };
    var defaultReadPackageSync = function defaultReadPackageSync2(readFileSync, pkgfile) {
      var body = readFileSync(pkgfile);
      try {
        var pkg = JSON.parse(body);
        return pkg;
      } catch (jsonErr) {
      }
    };
    var getPackageCandidates = function getPackageCandidates2(x, start, opts) {
      var dirs = nodeModulesPaths(start, opts, x);
      for (var i = 0; i < dirs.length; i++) {
        dirs[i] = path.join(dirs[i], x);
      }
      return dirs;
    };
    module2.exports = function resolveSync(x, options) {
      if (typeof x !== "string") {
        throw new TypeError("Path must be a string.");
      }
      var opts = normalizeOptions(x, options);
      var isFile = opts.isFile || defaultIsFile;
      var readFileSync = opts.readFileSync || fs.readFileSync;
      var isDirectory = opts.isDirectory || defaultIsDir;
      var realpathSync = opts.realpathSync || defaultRealpathSync;
      var readPackageSync = opts.readPackageSync || defaultReadPackageSync;
      if (opts.readFileSync && opts.readPackageSync) {
        throw new TypeError("`readFileSync` and `readPackageSync` are mutually exclusive.");
      }
      var packageIterator = opts.packageIterator;
      var extensions = opts.extensions || [".js"];
      var includeCoreModules = opts.includeCoreModules !== false;
      var basedir = opts.basedir || path.dirname(caller());
      var parent = opts.filename || basedir;
      opts.paths = opts.paths || defaultPaths();
      var absoluteStart = maybeRealpathSync(realpathSync, path.resolve(basedir), opts);
      if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
        var res = path.resolve(absoluteStart, x);
        if (x === "." || x === ".." || x.slice(-1) === "/") res += "/";
        var m = loadAsFileSync(res) || loadAsDirectorySync(res);
        if (m) return maybeRealpathSync(realpathSync, m, opts);
      } else if (includeCoreModules && isCore(x)) {
        return x;
      } else {
        var n = loadNodeModulesSync(x, absoluteStart);
        if (n) return maybeRealpathSync(realpathSync, n, opts);
      }
      var err = new Error("Cannot find module '" + x + "' from '" + parent + "'");
      err.code = "MODULE_NOT_FOUND";
      throw err;
      function loadAsFileSync(x2) {
        var pkg = loadpkg(path.dirname(x2));
        if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {
          var rfile = path.relative(pkg.dir, x2);
          var r = opts.pathFilter(pkg.pkg, x2, rfile);
          if (r) {
            x2 = path.resolve(pkg.dir, r);
          }
        }
        if (isFile(x2)) {
          return x2;
        }
        for (var i = 0; i < extensions.length; i++) {
          var file = x2 + extensions[i];
          if (isFile(file)) {
            return file;
          }
        }
      }
      function loadpkg(dir) {
        if (dir === "" || dir === "/") return;
        if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
          return;
        }
        if (/[/\\]node_modules[/\\]*$/.test(dir)) return;
        var pkgfile = path.join(maybeRealpathSync(realpathSync, dir, opts), "package.json");
        if (!isFile(pkgfile)) {
          return loadpkg(path.dirname(dir));
        }
        var pkg = readPackageSync(readFileSync, pkgfile);
        if (pkg && opts.packageFilter) {
          pkg = opts.packageFilter(
            pkg,
            /*pkgfile,*/
            dir
          );
        }
        return { pkg, dir };
      }
      function loadAsDirectorySync(x2) {
        var pkgfile = path.join(maybeRealpathSync(realpathSync, x2, opts), "/package.json");
        if (isFile(pkgfile)) {
          try {
            var pkg = readPackageSync(readFileSync, pkgfile);
          } catch (e) {
          }
          if (pkg && opts.packageFilter) {
            pkg = opts.packageFilter(
              pkg,
              /*pkgfile,*/
              x2
            );
          }
          if (pkg && pkg.main) {
            if (typeof pkg.main !== "string") {
              var mainError = new TypeError("package \u201C" + pkg.name + "\u201D `main` must be a string");
              mainError.code = "INVALID_PACKAGE_MAIN";
              throw mainError;
            }
            if (pkg.main === "." || pkg.main === "./") {
              pkg.main = "index";
            }
            try {
              var m2 = loadAsFileSync(path.resolve(x2, pkg.main));
              if (m2) return m2;
              var n2 = loadAsDirectorySync(path.resolve(x2, pkg.main));
              if (n2) return n2;
            } catch (e) {
            }
          }
        }
        return loadAsFileSync(path.join(x2, "/index"));
      }
      function loadNodeModulesSync(x2, start) {
        var thunk = function() {
          return getPackageCandidates(x2, start, opts);
        };
        var dirs = packageIterator ? packageIterator(x2, start, thunk, opts) : thunk();
        for (var i = 0; i < dirs.length; i++) {
          var dir = dirs[i];
          if (isDirectory(path.dirname(dir))) {
            var m2 = loadAsFileSync(dir);
            if (m2) return m2;
            var n2 = loadAsDirectorySync(dir);
            if (n2) return n2;
          }
        }
      }
    };
  }
});

// ../../node_modules/resolve/index.js
var require_resolve = __commonJS({
  "../../node_modules/resolve/index.js"(exports2, module2) {
    "use strict";
    var async = require_async();
    async.core = require_core3();
    async.isCore = require_is_core();
    async.sync = require_sync();
    module2.exports = async;
  }
});

// node_modules/@babel/core/lib/config/helpers/config-api.js
var require_config_api = __commonJS({
  "node_modules/@babel/core/lib/config/helpers/config-api.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = makeAPI;
    function _semver() {
      const data = _interopRequireDefault(require_semver());
      _semver = function() {
        return data;
      };
      return data;
    }
    var _ = require_lib10();
    var _caching = require_caching();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function makeAPI(cache) {
      const env = (value) => cache.using((data) => {
        if (typeof value === "undefined") return data.envName;
        if (typeof value === "function") {
          return (0, _caching.assertSimpleType)(value(data.envName));
        }
        if (!Array.isArray(value)) value = [value];
        return value.some((entry) => {
          if (typeof entry !== "string") {
            throw new Error("Unexpected non-string value");
          }
          return entry === data.envName;
        });
      });
      const caller = (cb) => cache.using((data) => (0, _caching.assertSimpleType)(cb(data.caller)));
      return {
        version: _.version,
        cache: cache.simple(),
        env,
        async: () => false,
        caller,
        assertVersion,
        tokTypes: void 0
      };
    }
    function assertVersion(range) {
      if (typeof range === "number") {
        if (!Number.isInteger(range)) {
          throw new Error("Expected string or integer value.");
        }
        range = `^${range}.0.0-0`;
      }
      if (typeof range !== "string") {
        throw new Error("Expected string or integer value.");
      }
      if (_semver().default.satisfies(_.version, range)) return;
      const limit = Error.stackTraceLimit;
      if (typeof limit === "number" && limit < 25) {
        Error.stackTraceLimit = 25;
      }
      const err = new Error(`Requires Babel "${range}", but was loaded with "${_.version}". If you are sure you have a compatible version of @babel/core, it is likely that something in your build process is loading the wrong version. Inspect the stack trace of this error to look for the first entry that doesn't mention "@babel/core" or "babel-core" to see what is calling Babel.`);
      if (typeof limit === "number") {
        Error.stackTraceLimit = limit;
      }
      throw Object.assign(err, {
        code: "BABEL_VERSION_UNSUPPORTED",
        version: _.version,
        range
      });
    }
  }
});

// ../../node_modules/lodash/_freeGlobal.js
var require_freeGlobal = __commonJS({
  "../../node_modules/lodash/_freeGlobal.js"(exports2, module2) {
    "use strict";
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    module2.exports = freeGlobal;
  }
});

// ../../node_modules/lodash/_root.js
var require_root = __commonJS({
  "../../node_modules/lodash/_root.js"(exports2, module2) {
    "use strict";
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root2 = freeGlobal || freeSelf || Function("return this")();
    module2.exports = root2;
  }
});

// ../../node_modules/lodash/_Symbol.js
var require_Symbol = __commonJS({
  "../../node_modules/lodash/_Symbol.js"(exports2, module2) {
    "use strict";
    var root2 = require_root();
    var Symbol2 = root2.Symbol;
    module2.exports = Symbol2;
  }
});

// ../../node_modules/lodash/_arrayMap.js
var require_arrayMap = __commonJS({
  "../../node_modules/lodash/_arrayMap.js"(exports2, module2) {
    "use strict";
    function arrayMap(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    module2.exports = arrayMap;
  }
});

// ../../node_modules/lodash/isArray.js
var require_isArray = __commonJS({
  "../../node_modules/lodash/isArray.js"(exports2, module2) {
    "use strict";
    var isArray = Array.isArray;
    module2.exports = isArray;
  }
});

// ../../node_modules/lodash/_getRawTag.js
var require_getRawTag = __commonJS({
  "../../node_modules/lodash/_getRawTag.js"(exports2, module2) {
    "use strict";
    var Symbol2 = require_Symbol();
    var objectProto = Object.prototype;
    var hasOwnProperty3 = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty3.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    module2.exports = getRawTag;
  }
});

// ../../node_modules/lodash/_objectToString.js
var require_objectToString = __commonJS({
  "../../node_modules/lodash/_objectToString.js"(exports2, module2) {
    "use strict";
    var objectProto = Object.prototype;
    var nativeObjectToString = objectProto.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    module2.exports = objectToString;
  }
});

// ../../node_modules/lodash/_baseGetTag.js
var require_baseGetTag = __commonJS({
  "../../node_modules/lodash/_baseGetTag.js"(exports2, module2) {
    "use strict";
    var Symbol2 = require_Symbol();
    var getRawTag = require_getRawTag();
    var objectToString = require_objectToString();
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    module2.exports = baseGetTag;
  }
});

// ../../node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS({
  "../../node_modules/lodash/isObjectLike.js"(exports2, module2) {
    "use strict";
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    module2.exports = isObjectLike;
  }
});

// ../../node_modules/lodash/isSymbol.js
var require_isSymbol = __commonJS({
  "../../node_modules/lodash/isSymbol.js"(exports2, module2) {
    "use strict";
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var symbolTag = "[object Symbol]";
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
    }
    module2.exports = isSymbol;
  }
});

// ../../node_modules/lodash/_baseToString.js
var require_baseToString = __commonJS({
  "../../node_modules/lodash/_baseToString.js"(exports2, module2) {
    "use strict";
    var Symbol2 = require_Symbol();
    var arrayMap = require_arrayMap();
    var isArray = require_isArray();
    var isSymbol = require_isSymbol();
    var INFINITY = 1 / 0;
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isArray(value)) {
        return arrayMap(value, baseToString) + "";
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    module2.exports = baseToString;
  }
});

// ../../node_modules/lodash/toString.js
var require_toString = __commonJS({
  "../../node_modules/lodash/toString.js"(exports2, module2) {
    "use strict";
    var baseToString = require_baseToString();
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    module2.exports = toString;
  }
});

// ../../node_modules/lodash/escapeRegExp.js
var require_escapeRegExp = __commonJS({
  "../../node_modules/lodash/escapeRegExp.js"(exports2, module2) {
    "use strict";
    var toString = require_toString();
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reHasRegExpChar = RegExp(reRegExpChar.source);
    function escapeRegExp(string) {
      string = toString(string);
      return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
    }
    module2.exports = escapeRegExp;
  }
});

// node_modules/@babel/core/lib/config/pattern-to-regex.js
var require_pattern_to_regex = __commonJS({
  "node_modules/@babel/core/lib/config/pattern-to-regex.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = pathToPattern;
    function _path() {
      const data = _interopRequireDefault(require("path"));
      _path = function() {
        return data;
      };
      return data;
    }
    function _escapeRegExp() {
      const data = _interopRequireDefault(require_escapeRegExp());
      _escapeRegExp = function() {
        return data;
      };
      return data;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var sep = `\\${_path().default.sep}`;
    var endSep = `(?:${sep}|$)`;
    var substitution = `[^${sep}]+`;
    var starPat = `(?:${substitution}${sep})`;
    var starPatLast = `(?:${substitution}${endSep})`;
    var starStarPat = `${starPat}*?`;
    var starStarPatLast = `${starPat}*?${starPatLast}?`;
    function pathToPattern(pattern, dirname) {
      const parts = _path().default.resolve(dirname, pattern).split(_path().default.sep);
      return new RegExp(["^", ...parts.map((part, i) => {
        const last = i === parts.length - 1;
        if (part === "**") return last ? starStarPatLast : starStarPat;
        if (part === "*") return last ? starPatLast : starPat;
        if (part.indexOf("*.") === 0) {
          return substitution + (0, _escapeRegExp().default)(part.slice(1)) + (last ? endSep : sep);
        }
        return (0, _escapeRegExp().default)(part) + (last ? endSep : sep);
      })].join(""));
    }
  }
});

// node_modules/@babel/core/lib/config/files/configuration.js
var require_configuration = __commonJS({
  "node_modules/@babel/core/lib/config/files/configuration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.findConfigUpwards = findConfigUpwards;
    exports2.findRelativeConfig = findRelativeConfig;
    exports2.findRootConfig = findRootConfig;
    exports2.loadConfig = loadConfig;
    function _debug() {
      const data = _interopRequireDefault(require_src());
      _debug = function() {
        return data;
      };
      return data;
    }
    function _path() {
      const data = _interopRequireDefault(require("path"));
      _path = function() {
        return data;
      };
      return data;
    }
    function _fs() {
      const data = _interopRequireDefault(require("fs"));
      _fs = function() {
        return data;
      };
      return data;
    }
    function _json() {
      const data = _interopRequireDefault((init_dist(), __toCommonJS(dist_exports)));
      _json = function() {
        return data;
      };
      return data;
    }
    function _resolve() {
      const data = _interopRequireDefault(require_resolve());
      _resolve = function() {
        return data;
      };
      return data;
    }
    var _caching = require_caching();
    var _configApi = _interopRequireDefault(require_config_api());
    var _utils = require_utils();
    var _patternToRegex = _interopRequireDefault(require_pattern_to_regex());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var debug = (0, _debug().default)("babel:config:loading:files:configuration");
    var BABEL_CONFIG_JS_FILENAME = "babel.config.js";
    var BABELRC_FILENAME = ".babelrc";
    var BABELRC_JS_FILENAME = ".babelrc.js";
    var BABELIGNORE_FILENAME = ".babelignore";
    function findConfigUpwards(rootDir) {
      let dirname = rootDir;
      while (true) {
        if (_fs().default.existsSync(_path().default.join(dirname, BABEL_CONFIG_JS_FILENAME))) {
          return dirname;
        }
        const nextDir = _path().default.dirname(dirname);
        if (dirname === nextDir) break;
        dirname = nextDir;
      }
      return null;
    }
    function findRelativeConfig(packageData, envName, caller) {
      let config = null;
      let ignore = null;
      const dirname = _path().default.dirname(packageData.filepath);
      for (const loc of packageData.directories) {
        if (!config) {
          config = [BABELRC_FILENAME, BABELRC_JS_FILENAME].reduce((previousConfig, name) => {
            const filepath = _path().default.join(loc, name);
            const config2 = readConfig(filepath, envName, caller);
            if (config2 && previousConfig) {
              throw new Error(`Multiple configuration files found. Please remove one:
 - ${_path().default.basename(previousConfig.filepath)}
 - ${name}
from ${loc}`);
            }
            return config2 || previousConfig;
          }, null);
          const pkgConfig = packageData.pkg && packageData.pkg.dirname === loc ? packageToBabelConfig(packageData.pkg) : null;
          if (pkgConfig) {
            if (config) {
              throw new Error(`Multiple configuration files found. Please remove one:
 - ${_path().default.basename(pkgConfig.filepath)}#babel
 - ${_path().default.basename(config.filepath)}
from ${loc}`);
            }
            config = pkgConfig;
          }
          if (config) {
            debug("Found configuration %o from %o.", config.filepath, dirname);
          }
        }
        if (!ignore) {
          const ignoreLoc = _path().default.join(loc, BABELIGNORE_FILENAME);
          ignore = readIgnoreConfig(ignoreLoc);
          if (ignore) {
            debug("Found ignore %o from %o.", ignore.filepath, dirname);
          }
        }
      }
      return {
        config,
        ignore
      };
    }
    function findRootConfig(dirname, envName, caller) {
      const filepath = _path().default.resolve(dirname, BABEL_CONFIG_JS_FILENAME);
      const conf = readConfig(filepath, envName, caller);
      if (conf) {
        debug("Found root config %o in $o.", BABEL_CONFIG_JS_FILENAME, dirname);
      }
      return conf;
    }
    function loadConfig(name, dirname, envName, caller) {
      const filepath = _resolve().default.sync(name, {
        basedir: dirname
      });
      const conf = readConfig(filepath, envName, caller);
      if (!conf) {
        throw new Error(`Config file ${filepath} contains no configuration data`);
      }
      debug("Loaded config %o from $o.", name, dirname);
      return conf;
    }
    function readConfig(filepath, envName, caller) {
      return _path().default.extname(filepath) === ".js" ? readConfigJS(filepath, {
        envName,
        caller
      }) : readConfigJSON5(filepath);
    }
    var LOADING_CONFIGS = /* @__PURE__ */ new Set();
    var readConfigJS = (0, _caching.makeStrongCache)((filepath, cache) => {
      if (!_fs().default.existsSync(filepath)) {
        cache.forever();
        return null;
      }
      if (LOADING_CONFIGS.has(filepath)) {
        cache.never();
        debug("Auto-ignoring usage of config %o.", filepath);
        return {
          filepath,
          dirname: _path().default.dirname(filepath),
          options: {}
        };
      }
      let options;
      try {
        LOADING_CONFIGS.add(filepath);
        const configModule = require(filepath);
        options = configModule && configModule.__esModule ? configModule.default || void 0 : configModule;
      } catch (err) {
        err.message = `${filepath}: Error while loading config - ${err.message}`;
        throw err;
      } finally {
        LOADING_CONFIGS.delete(filepath);
      }
      if (typeof options === "function") {
        options = options((0, _configApi.default)(cache));
        if (!cache.configured()) throwConfigError();
      }
      if (!options || typeof options !== "object" || Array.isArray(options)) {
        throw new Error(`${filepath}: Configuration should be an exported JavaScript object.`);
      }
      if (typeof options.then === "function") {
        throw new Error(`You appear to be using an async configuration, which your current version of Babel does not support. We may add support for this in the future, but if you're on the most recent version of @babel/core and still seeing this error, then you'll need to synchronously return your config.`);
      }
      return {
        filepath,
        dirname: _path().default.dirname(filepath),
        options
      };
    });
    var packageToBabelConfig = (0, _caching.makeWeakCache)((file) => {
      const babel = file.options["babel"];
      if (typeof babel === "undefined") return null;
      if (typeof babel !== "object" || Array.isArray(babel) || babel === null) {
        throw new Error(`${file.filepath}: .babel property must be an object`);
      }
      return {
        filepath: file.filepath,
        dirname: file.dirname,
        options: babel
      };
    });
    var readConfigJSON5 = (0, _utils.makeStaticFileCache)((filepath, content) => {
      let options;
      try {
        options = _json().default.parse(content);
      } catch (err) {
        err.message = `${filepath}: Error while parsing config - ${err.message}`;
        throw err;
      }
      if (!options) throw new Error(`${filepath}: No config detected`);
      if (typeof options !== "object") {
        throw new Error(`${filepath}: Config returned typeof ${typeof options}`);
      }
      if (Array.isArray(options)) {
        throw new Error(`${filepath}: Expected config object but found array`);
      }
      return {
        filepath,
        dirname: _path().default.dirname(filepath),
        options
      };
    });
    var readIgnoreConfig = (0, _utils.makeStaticFileCache)((filepath, content) => {
      const ignoreDir = _path().default.dirname(filepath);
      const ignorePatterns = content.split("\n").map((line2) => line2.replace(/#(.*?)$/, "").trim()).filter((line2) => !!line2);
      for (const pattern of ignorePatterns) {
        if (pattern[0] === "!") {
          throw new Error(`Negation of file paths is not supported.`);
        }
      }
      return {
        filepath,
        dirname: _path().default.dirname(filepath),
        ignore: ignorePatterns.map((pattern) => (0, _patternToRegex.default)(pattern, ignoreDir))
      };
    });
    function throwConfigError() {
      throw new Error(`Caching was left unconfigured. Babel's plugins, presets, and .babelrc.js files can be configured
for various types of caching, using the first param of their handler functions:

module.exports = function(api) {
  // The API exposes the following:

  // Cache the returned value forever and don't call this function again.
  api.cache(true);

  // Don't cache at all. Not recommended because it will be very slow.
  api.cache(false);

  // Cached based on the value of some function. If this function returns a value different from
  // a previously-encountered value, the plugins will re-evaluate.
  var env = api.cache(() => process.env.NODE_ENV);

  // If testing for a specific env, we recommend specifics to avoid instantiating a plugin for
  // any possible NODE_ENV value that might come up during plugin execution.
  var isProd = api.cache(() => process.env.NODE_ENV === "production");

  // .cache(fn) will perform a linear search though instances to find the matching plugin based
  // based on previous instantiated plugins. If you want to recreate the plugin and discard the
  // previous instance whenever something changes, you may use:
  var isProd = api.cache.invalidate(() => process.env.NODE_ENV === "production");

  // Note, we also expose the following more-verbose versions of the above examples:
  api.cache.forever(); // api.cache(true)
  api.cache.never();   // api.cache(false)
  api.cache.using(fn); // api.cache(fn)

  // Return the value that will be cached.
  return { };
};`);
    }
  }
});

// node_modules/@babel/core/lib/config/files/plugins.js
var require_plugins = __commonJS({
  "node_modules/@babel/core/lib/config/files/plugins.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.resolvePlugin = resolvePlugin;
    exports2.resolvePreset = resolvePreset;
    exports2.loadPlugin = loadPlugin;
    exports2.loadPreset = loadPreset;
    function _debug() {
      const data = _interopRequireDefault(require_src());
      _debug = function() {
        return data;
      };
      return data;
    }
    function _resolve() {
      const data = _interopRequireDefault(require_resolve());
      _resolve = function() {
        return data;
      };
      return data;
    }
    function _path() {
      const data = _interopRequireDefault(require("path"));
      _path = function() {
        return data;
      };
      return data;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var debug = (0, _debug().default)("babel:config:loading:files:plugins");
    var EXACT_RE = /^module:/;
    var BABEL_PLUGIN_PREFIX_RE = /^(?!@|module:|[^/]+\/|babel-plugin-)/;
    var BABEL_PRESET_PREFIX_RE = /^(?!@|module:|[^/]+\/|babel-preset-)/;
    var BABEL_PLUGIN_ORG_RE = /^(@babel\/)(?!plugin-|[^/]+\/)/;
    var BABEL_PRESET_ORG_RE = /^(@babel\/)(?!preset-|[^/]+\/)/;
    var OTHER_PLUGIN_ORG_RE = /^(@(?!babel\/)[^/]+\/)(?![^/]*babel-plugin(?:-|\/|$)|[^/]+\/)/;
    var OTHER_PRESET_ORG_RE = /^(@(?!babel\/)[^/]+\/)(?![^/]*babel-preset(?:-|\/|$)|[^/]+\/)/;
    var OTHER_ORG_DEFAULT_RE = /^(@(?!babel$)[^/]+)$/;
    function resolvePlugin(name, dirname) {
      return resolveStandardizedName("plugin", name, dirname);
    }
    function resolvePreset(name, dirname) {
      return resolveStandardizedName("preset", name, dirname);
    }
    function loadPlugin(name, dirname) {
      const filepath = resolvePlugin(name, dirname);
      if (!filepath) {
        throw new Error(`Plugin ${name} not found relative to ${dirname}`);
      }
      const value = requireModule("plugin", filepath);
      debug("Loaded plugin %o from %o.", name, dirname);
      return {
        filepath,
        value
      };
    }
    function loadPreset(name, dirname) {
      const filepath = resolvePreset(name, dirname);
      if (!filepath) {
        throw new Error(`Preset ${name} not found relative to ${dirname}`);
      }
      const value = requireModule("preset", filepath);
      debug("Loaded preset %o from %o.", name, dirname);
      return {
        filepath,
        value
      };
    }
    function standardizeName(type, name) {
      if (_path().default.isAbsolute(name)) return name;
      const isPreset = type === "preset";
      return name.replace(isPreset ? BABEL_PRESET_PREFIX_RE : BABEL_PLUGIN_PREFIX_RE, `babel-${type}-`).replace(isPreset ? BABEL_PRESET_ORG_RE : BABEL_PLUGIN_ORG_RE, `$1${type}-`).replace(isPreset ? OTHER_PRESET_ORG_RE : OTHER_PLUGIN_ORG_RE, `$1babel-${type}-`).replace(OTHER_ORG_DEFAULT_RE, `$1/babel-${type}`).replace(EXACT_RE, "");
    }
    function resolveStandardizedName(type, name, dirname = process.cwd()) {
      const standardizedName = standardizeName(type, name);
      try {
        return _resolve().default.sync(standardizedName, {
          basedir: dirname
        });
      } catch (e) {
        if (e.code !== "MODULE_NOT_FOUND") throw e;
        if (standardizedName !== name) {
          let resolvedOriginal = false;
          try {
            _resolve().default.sync(name, {
              basedir: dirname
            });
            resolvedOriginal = true;
          } catch (e2) {
          }
          if (resolvedOriginal) {
            e.message += `
- If you want to resolve "${name}", use "module:${name}"`;
          }
        }
        let resolvedBabel = false;
        try {
          _resolve().default.sync(standardizeName(type, "@babel/" + name), {
            basedir: dirname
          });
          resolvedBabel = true;
        } catch (e2) {
        }
        if (resolvedBabel) {
          e.message += `
- Did you mean "@babel/${name}"?`;
        }
        let resolvedOppositeType = false;
        const oppositeType = type === "preset" ? "plugin" : "preset";
        try {
          _resolve().default.sync(standardizeName(oppositeType, name), {
            basedir: dirname
          });
          resolvedOppositeType = true;
        } catch (e2) {
        }
        if (resolvedOppositeType) {
          e.message += `
- Did you accidentally pass a ${oppositeType} as a ${type}?`;
        }
        throw e;
      }
    }
    var LOADING_MODULES = /* @__PURE__ */ new Set();
    function requireModule(type, name) {
      if (LOADING_MODULES.has(name)) {
        throw new Error(`Reentrant ${type} detected trying to load "${name}". This module is not ignored and is trying to load itself while compiling itself, leading to a dependency cycle. We recommend adding it to your "ignore" list in your babelrc, or to a .babelignore.`);
      }
      try {
        LOADING_MODULES.add(name);
        return require(name);
      } finally {
        LOADING_MODULES.delete(name);
      }
    }
  }
});

// node_modules/@babel/core/lib/config/files/index.js
var require_files = __commonJS({
  "node_modules/@babel/core/lib/config/files/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "findPackageData", {
      enumerable: true,
      get: function() {
        return _package.findPackageData;
      }
    });
    Object.defineProperty(exports2, "findConfigUpwards", {
      enumerable: true,
      get: function() {
        return _configuration.findConfigUpwards;
      }
    });
    Object.defineProperty(exports2, "findRelativeConfig", {
      enumerable: true,
      get: function() {
        return _configuration.findRelativeConfig;
      }
    });
    Object.defineProperty(exports2, "findRootConfig", {
      enumerable: true,
      get: function() {
        return _configuration.findRootConfig;
      }
    });
    Object.defineProperty(exports2, "loadConfig", {
      enumerable: true,
      get: function() {
        return _configuration.loadConfig;
      }
    });
    Object.defineProperty(exports2, "resolvePlugin", {
      enumerable: true,
      get: function() {
        return _plugins.resolvePlugin;
      }
    });
    Object.defineProperty(exports2, "resolvePreset", {
      enumerable: true,
      get: function() {
        return _plugins.resolvePreset;
      }
    });
    Object.defineProperty(exports2, "loadPlugin", {
      enumerable: true,
      get: function() {
        return _plugins.loadPlugin;
      }
    });
    Object.defineProperty(exports2, "loadPreset", {
      enumerable: true,
      get: function() {
        return _plugins.loadPreset;
      }
    });
    var _package = require_package();
    var _configuration = require_configuration();
    var _plugins = require_plugins();
  }
});

// node_modules/@babel/core/package.json
var require_package2 = __commonJS({
  "node_modules/@babel/core/package.json"(exports2, module2) {
    module2.exports = {
      name: "@babel/core",
      version: "7.2.0",
      description: "Babel compiler core.",
      main: "lib/index.js",
      author: "Sebastian McKenzie <sebmck@gmail.com>",
      homepage: "https://babeljs.io/",
      license: "MIT",
      publishConfig: {
        access: "public"
      },
      repository: "https://github.com/babel/babel/tree/master/packages/babel-core",
      keywords: [
        "6to5",
        "babel",
        "classes",
        "const",
        "es6",
        "harmony",
        "let",
        "modules",
        "transpile",
        "transpiler",
        "var",
        "babel-core",
        "compiler"
      ],
      engines: {
        node: ">=6.9.0"
      },
      browser: {
        "./lib/config/files/index.js": "./lib/config/files/index-browser.js",
        "./lib/transform-file.js": "./lib/transform-file-browser.js"
      },
      dependencies: {
        "@babel/code-frame": "^7.0.0",
        "@babel/generator": "^7.2.0",
        "@babel/helpers": "^7.2.0",
        "@babel/parser": "^7.2.0",
        "@babel/template": "^7.1.2",
        "@babel/traverse": "^7.1.6",
        "@babel/types": "^7.2.0",
        "convert-source-map": "^1.1.0",
        debug: "^4.1.0",
        json5: "^2.1.0",
        lodash: "^4.17.10",
        resolve: "^1.3.2",
        semver: "^5.4.1",
        "source-map": "^0.5.0"
      },
      devDependencies: {
        "@babel/helper-transform-fixture-test-runner": "^7.0.0",
        "@babel/register": "^7.0.0"
      }
    };
  }
});

// node_modules/@babel/core/lib/config/helpers/environment.js
var require_environment = __commonJS({
  "node_modules/@babel/core/lib/config/helpers/environment.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getEnv = getEnv;
    function getEnv(defaultValue = "development") {
      return process.env.BABEL_ENV || process.env.NODE_ENV || defaultValue;
    }
  }
});

// node_modules/@babel/core/lib/config/config-descriptors.js
var require_config_descriptors = __commonJS({
  "node_modules/@babel/core/lib/config/config-descriptors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.createCachedDescriptors = createCachedDescriptors;
    exports2.createUncachedDescriptors = createUncachedDescriptors;
    exports2.createDescriptor = createDescriptor;
    var _files = require_files();
    var _item = require_item();
    var _caching = require_caching();
    function isEqualDescriptor(a, b) {
      return a.name === b.name && a.value === b.value && a.options === b.options && a.dirname === b.dirname && a.alias === b.alias && a.ownPass === b.ownPass && (a.file && a.file.request) === (b.file && b.file.request) && (a.file && a.file.resolved) === (b.file && b.file.resolved);
    }
    function createCachedDescriptors(dirname, options, alias) {
      const {
        plugins,
        presets,
        passPerPreset
      } = options;
      return {
        options,
        plugins: plugins ? () => createCachedPluginDescriptors(plugins, dirname)(alias) : () => [],
        presets: presets ? () => createCachedPresetDescriptors(presets, dirname)(alias)(!!passPerPreset) : () => []
      };
    }
    function createUncachedDescriptors(dirname, options, alias) {
      let plugins;
      let presets;
      return {
        options,
        plugins: () => {
          if (!plugins) {
            plugins = createPluginDescriptors(options.plugins || [], dirname, alias);
          }
          return plugins;
        },
        presets: () => {
          if (!presets) {
            presets = createPresetDescriptors(options.presets || [], dirname, alias, !!options.passPerPreset);
          }
          return presets;
        }
      };
    }
    var PRESET_DESCRIPTOR_CACHE = /* @__PURE__ */ new WeakMap();
    var createCachedPresetDescriptors = (0, _caching.makeWeakCache)((items, cache) => {
      const dirname = cache.using((dir) => dir);
      return (0, _caching.makeStrongCache)((alias) => (0, _caching.makeStrongCache)((passPerPreset) => createPresetDescriptors(items, dirname, alias, passPerPreset).map((desc) => loadCachedDescriptor(PRESET_DESCRIPTOR_CACHE, desc))));
    });
    var PLUGIN_DESCRIPTOR_CACHE = /* @__PURE__ */ new WeakMap();
    var createCachedPluginDescriptors = (0, _caching.makeWeakCache)((items, cache) => {
      const dirname = cache.using((dir) => dir);
      return (0, _caching.makeStrongCache)((alias) => createPluginDescriptors(items, dirname, alias).map((desc) => loadCachedDescriptor(PLUGIN_DESCRIPTOR_CACHE, desc)));
    });
    var DEFAULT_OPTIONS = {};
    function loadCachedDescriptor(cache, desc) {
      const {
        value,
        options = DEFAULT_OPTIONS
      } = desc;
      if (options === false) return desc;
      let cacheByOptions = cache.get(value);
      if (!cacheByOptions) {
        cacheByOptions = /* @__PURE__ */ new WeakMap();
        cache.set(value, cacheByOptions);
      }
      let possibilities = cacheByOptions.get(options);
      if (!possibilities) {
        possibilities = [];
        cacheByOptions.set(options, possibilities);
      }
      if (possibilities.indexOf(desc) === -1) {
        const matches = possibilities.filter((possibility) => isEqualDescriptor(possibility, desc));
        if (matches.length > 0) {
          return matches[0];
        }
        possibilities.push(desc);
      }
      return desc;
    }
    function createPresetDescriptors(items, dirname, alias, passPerPreset) {
      return createDescriptors("preset", items, dirname, alias, passPerPreset);
    }
    function createPluginDescriptors(items, dirname, alias) {
      return createDescriptors("plugin", items, dirname, alias);
    }
    function createDescriptors(type, items, dirname, alias, ownPass) {
      const descriptors = items.map((item, index) => createDescriptor(item, dirname, {
        type,
        alias: `${alias}$${index}`,
        ownPass: !!ownPass
      }));
      assertNoDuplicates(descriptors);
      return descriptors;
    }
    function createDescriptor(pair, dirname, {
      type,
      alias,
      ownPass
    }) {
      const desc = (0, _item.getItemDescriptor)(pair);
      if (desc) {
        return desc;
      }
      let name;
      let options;
      let value = pair;
      if (Array.isArray(value)) {
        if (value.length === 3) {
          [value, options, name] = value;
        } else {
          [value, options] = value;
        }
      }
      let file = void 0;
      let filepath = null;
      if (typeof value === "string") {
        if (typeof type !== "string") {
          throw new Error("To resolve a string-based item, the type of item must be given");
        }
        const resolver = type === "plugin" ? _files.loadPlugin : _files.loadPreset;
        const request = value;
        ({
          filepath,
          value
        } = resolver(value, dirname));
        file = {
          request,
          resolved: filepath
        };
      }
      if (!value) {
        throw new Error(`Unexpected falsy value: ${String(value)}`);
      }
      if (typeof value === "object" && value.__esModule) {
        if (value.default) {
          value = value.default;
        } else {
          throw new Error("Must export a default export when using ES6 modules.");
        }
      }
      if (typeof value !== "object" && typeof value !== "function") {
        throw new Error(`Unsupported format: ${typeof value}. Expected an object or a function.`);
      }
      if (filepath !== null && typeof value === "object" && value) {
        throw new Error(`Plugin/Preset files are not allowed to export objects, only functions. In ${filepath}`);
      }
      return {
        name,
        alias: filepath || alias,
        value,
        options,
        dirname,
        ownPass,
        file
      };
    }
    function assertNoDuplicates(items) {
      const map = /* @__PURE__ */ new Map();
      for (const item of items) {
        if (typeof item.value !== "function") continue;
        let nameMap = map.get(item.value);
        if (!nameMap) {
          nameMap = /* @__PURE__ */ new Set();
          map.set(item.value, nameMap);
        }
        if (nameMap.has(item.name)) {
          throw new Error([`Duplicate plugin/preset detected.`, `If you'd like to use two separate instances of a plugin,`, `they need separate names, e.g.`, ``, `  plugins: [`, `    ['some-plugin', {}],`, `    ['some-plugin', {}, 'some unique name'],`, `  ]`].join("\n"));
        }
        nameMap.add(item.name);
      }
    }
  }
});

// node_modules/@babel/core/lib/config/item.js
var require_item = __commonJS({
  "node_modules/@babel/core/lib/config/item.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.createItemFromDescriptor = createItemFromDescriptor;
    exports2.createConfigItem = createConfigItem;
    exports2.getItemDescriptor = getItemDescriptor;
    function _path() {
      const data = _interopRequireDefault(require("path"));
      _path = function() {
        return data;
      };
      return data;
    }
    var _configDescriptors = require_config_descriptors();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function createItemFromDescriptor(desc) {
      return new ConfigItem(desc);
    }
    function createConfigItem(value, {
      dirname = ".",
      type
    } = {}) {
      const descriptor = (0, _configDescriptors.createDescriptor)(value, _path().default.resolve(dirname), {
        type,
        alias: "programmatic item"
      });
      return createItemFromDescriptor(descriptor);
    }
    function getItemDescriptor(item) {
      if (item instanceof ConfigItem) {
        return item._descriptor;
      }
      return void 0;
    }
    var ConfigItem = class {
      constructor(descriptor) {
        this._descriptor = descriptor;
        Object.defineProperty(this, "_descriptor", {
          enumerable: false
        });
        this.value = this._descriptor.value;
        this.options = this._descriptor.options;
        this.dirname = this._descriptor.dirname;
        this.name = this._descriptor.name;
        this.file = this._descriptor.file ? {
          request: this._descriptor.file.request,
          resolved: this._descriptor.file.resolved
        } : void 0;
        Object.freeze(this);
      }
    };
    Object.freeze(ConfigItem.prototype);
  }
});

// node_modules/@babel/core/lib/config/util.js
var require_util3 = __commonJS({
  "node_modules/@babel/core/lib/config/util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.mergeOptions = mergeOptions;
    function mergeOptions(target, source2) {
      for (const k of Object.keys(source2)) {
        if (k === "parserOpts" && source2.parserOpts) {
          const parserOpts = source2.parserOpts;
          const targetObj = target.parserOpts = target.parserOpts || {};
          mergeDefaultFields(targetObj, parserOpts);
        } else if (k === "generatorOpts" && source2.generatorOpts) {
          const generatorOpts = source2.generatorOpts;
          const targetObj = target.generatorOpts = target.generatorOpts || {};
          mergeDefaultFields(targetObj, generatorOpts);
        } else {
          const val = source2[k];
          if (val !== void 0) target[k] = val;
        }
      }
    }
    function mergeDefaultFields(target, source2) {
      for (const k of Object.keys(source2)) {
        const val = source2[k];
        if (val !== void 0) target[k] = val;
      }
    }
  }
});

// node_modules/@babel/core/lib/config/plugin.js
var require_plugin = __commonJS({
  "node_modules/@babel/core/lib/config/plugin.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var Plugin = class {
      constructor(plugin, options, key2) {
        this.key = plugin.name || key2;
        this.manipulateOptions = plugin.manipulateOptions;
        this.post = plugin.post;
        this.pre = plugin.pre;
        this.visitor = plugin.visitor || {};
        this.parserOverride = plugin.parserOverride;
        this.generatorOverride = plugin.generatorOverride;
        this.options = options;
      }
    };
    exports2.default = Plugin;
  }
});

// node_modules/@babel/core/lib/config/validation/removed.js
var require_removed = __commonJS({
  "node_modules/@babel/core/lib/config/validation/removed.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default = {
      auxiliaryComment: {
        message: "Use `auxiliaryCommentBefore` or `auxiliaryCommentAfter`"
      },
      blacklist: {
        message: "Put the specific transforms you want in the `plugins` option"
      },
      breakConfig: {
        message: "This is not a necessary option in Babel 6"
      },
      experimental: {
        message: "Put the specific transforms you want in the `plugins` option"
      },
      externalHelpers: {
        message: "Use the `external-helpers` plugin instead. Check out http://babeljs.io/docs/plugins/external-helpers/"
      },
      extra: {
        message: ""
      },
      jsxPragma: {
        message: "use the `pragma` option in the `react-jsx` plugin. Check out http://babeljs.io/docs/plugins/transform-react-jsx/"
      },
      loose: {
        message: "Specify the `loose` option for the relevant plugin you are using or use a preset that sets the option."
      },
      metadataUsedHelpers: {
        message: "Not required anymore as this is enabled by default"
      },
      modules: {
        message: "Use the corresponding module transform plugin in the `plugins` option. Check out http://babeljs.io/docs/plugins/#modules"
      },
      nonStandard: {
        message: "Use the `react-jsx` and `flow-strip-types` plugins to support JSX and Flow. Also check out the react preset http://babeljs.io/docs/plugins/preset-react/"
      },
      optional: {
        message: "Put the specific transforms you want in the `plugins` option"
      },
      sourceMapName: {
        message: "The `sourceMapName` option has been removed because it makes more sense for the tooling that calls Babel to assign `map.file` themselves."
      },
      stage: {
        message: "Check out the corresponding stage-x presets http://babeljs.io/docs/plugins/#presets"
      },
      whitelist: {
        message: "Put the specific transforms you want in the `plugins` option"
      },
      resolveModuleSource: {
        version: 6,
        message: "Use `babel-plugin-module-resolver@3`'s 'resolvePath' options"
      },
      metadata: {
        version: 6,
        message: "Generated plugin metadata is always included in the output result"
      },
      sourceMapTarget: {
        version: 6,
        message: "The `sourceMapTarget` option has been removed because it makes more sense for the tooling that calls Babel to assign `map.file` themselves."
      }
    };
    exports2.default = _default;
  }
});

// node_modules/@babel/core/lib/config/validation/option-assertions.js
var require_option_assertions = __commonJS({
  "node_modules/@babel/core/lib/config/validation/option-assertions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.msg = msg;
    exports2.access = access;
    exports2.assertRootMode = assertRootMode;
    exports2.assertSourceMaps = assertSourceMaps;
    exports2.assertCompact = assertCompact;
    exports2.assertSourceType = assertSourceType;
    exports2.assertCallerMetadata = assertCallerMetadata;
    exports2.assertInputSourceMap = assertInputSourceMap;
    exports2.assertString = assertString;
    exports2.assertFunction = assertFunction;
    exports2.assertBoolean = assertBoolean;
    exports2.assertObject = assertObject;
    exports2.assertArray = assertArray;
    exports2.assertIgnoreList = assertIgnoreList;
    exports2.assertConfigApplicableTest = assertConfigApplicableTest;
    exports2.assertConfigFileSearch = assertConfigFileSearch;
    exports2.assertBabelrcSearch = assertBabelrcSearch;
    exports2.assertPluginList = assertPluginList;
    function msg(loc) {
      switch (loc.type) {
        case "root":
          return ``;
        case "env":
          return `${msg(loc.parent)}.env["${loc.name}"]`;
        case "overrides":
          return `${msg(loc.parent)}.overrides[${loc.index}]`;
        case "option":
          return `${msg(loc.parent)}.${loc.name}`;
        case "access":
          return `${msg(loc.parent)}[${JSON.stringify(loc.name)}]`;
        default:
          throw new Error(`Assertion failure: Unknown type ${loc.type}`);
      }
    }
    function access(loc, name) {
      return {
        type: "access",
        name,
        parent: loc
      };
    }
    function assertRootMode(loc, value) {
      if (value !== void 0 && value !== "root" && value !== "upward" && value !== "upward-optional") {
        throw new Error(`${msg(loc)} must be a "root", "upward", "upward-optional" or undefined`);
      }
      return value;
    }
    function assertSourceMaps(loc, value) {
      if (value !== void 0 && typeof value !== "boolean" && value !== "inline" && value !== "both") {
        throw new Error(`${msg(loc)} must be a boolean, "inline", "both", or undefined`);
      }
      return value;
    }
    function assertCompact(loc, value) {
      if (value !== void 0 && typeof value !== "boolean" && value !== "auto") {
        throw new Error(`${msg(loc)} must be a boolean, "auto", or undefined`);
      }
      return value;
    }
    function assertSourceType(loc, value) {
      if (value !== void 0 && value !== "module" && value !== "script" && value !== "unambiguous") {
        throw new Error(`${msg(loc)} must be "module", "script", "unambiguous", or undefined`);
      }
      return value;
    }
    function assertCallerMetadata(loc, value) {
      const obj = assertObject(loc, value);
      if (obj) {
        if (typeof obj["name"] !== "string") {
          throw new Error(`${msg(loc)} set but does not contain "name" property string`);
        }
        for (const prop of Object.keys(obj)) {
          const propLoc = access(loc, prop);
          const value2 = obj[prop];
          if (value2 != null && typeof value2 !== "boolean" && typeof value2 !== "string" && typeof value2 !== "number") {
            throw new Error(`${msg(propLoc)} must be null, undefined, a boolean, a string, or a number.`);
          }
        }
      }
      return value;
    }
    function assertInputSourceMap(loc, value) {
      if (value !== void 0 && typeof value !== "boolean" && (typeof value !== "object" || !value)) {
        throw new Error(`${msg(loc)} must be a boolean, object, or undefined`);
      }
      return value;
    }
    function assertString(loc, value) {
      if (value !== void 0 && typeof value !== "string") {
        throw new Error(`${msg(loc)} must be a string, or undefined`);
      }
      return value;
    }
    function assertFunction(loc, value) {
      if (value !== void 0 && typeof value !== "function") {
        throw new Error(`${msg(loc)} must be a function, or undefined`);
      }
      return value;
    }
    function assertBoolean(loc, value) {
      if (value !== void 0 && typeof value !== "boolean") {
        throw new Error(`${msg(loc)} must be a boolean, or undefined`);
      }
      return value;
    }
    function assertObject(loc, value) {
      if (value !== void 0 && (typeof value !== "object" || Array.isArray(value) || !value)) {
        throw new Error(`${msg(loc)} must be an object, or undefined`);
      }
      return value;
    }
    function assertArray(loc, value) {
      if (value != null && !Array.isArray(value)) {
        throw new Error(`${msg(loc)} must be an array, or undefined`);
      }
      return value;
    }
    function assertIgnoreList(loc, value) {
      const arr = assertArray(loc, value);
      if (arr) {
        arr.forEach((item, i) => assertIgnoreItem(access(loc, i), item));
      }
      return arr;
    }
    function assertIgnoreItem(loc, value) {
      if (typeof value !== "string" && typeof value !== "function" && !(value instanceof RegExp)) {
        throw new Error(`${msg(loc)} must be an array of string/Funtion/RegExp values, or undefined`);
      }
      return value;
    }
    function assertConfigApplicableTest(loc, value) {
      if (value === void 0) return value;
      if (Array.isArray(value)) {
        value.forEach((item, i) => {
          if (!checkValidTest(item)) {
            throw new Error(`${msg(access(loc, i))} must be a string/Function/RegExp.`);
          }
        });
      } else if (!checkValidTest(value)) {
        throw new Error(`${msg(loc)} must be a string/Function/RegExp, or an array of those`);
      }
      return value;
    }
    function checkValidTest(value) {
      return typeof value === "string" || typeof value === "function" || value instanceof RegExp;
    }
    function assertConfigFileSearch(loc, value) {
      if (value !== void 0 && typeof value !== "boolean" && typeof value !== "string") {
        throw new Error(`${msg(loc)} must be a undefined, a boolean, a string, got ${JSON.stringify(value)}`);
      }
      return value;
    }
    function assertBabelrcSearch(loc, value) {
      if (value === void 0 || typeof value === "boolean") return value;
      if (Array.isArray(value)) {
        value.forEach((item, i) => {
          if (!checkValidTest(item)) {
            throw new Error(`${msg(access(loc, i))} must be a string/Function/RegExp.`);
          }
        });
      } else if (!checkValidTest(value)) {
        throw new Error(`${msg(loc)} must be a undefined, a boolean, a string/Function/RegExp or an array of those, got ${JSON.stringify(value)}`);
      }
      return value;
    }
    function assertPluginList(loc, value) {
      const arr = assertArray(loc, value);
      if (arr) {
        arr.forEach((item, i) => assertPluginItem(access(loc, i), item));
      }
      return arr;
    }
    function assertPluginItem(loc, value) {
      if (Array.isArray(value)) {
        if (value.length === 0) {
          throw new Error(`${msg(loc)} must include an object`);
        }
        if (value.length > 3) {
          throw new Error(`${msg(loc)} may only be a two-tuple or three-tuple`);
        }
        assertPluginTarget(access(loc, 0), value[0]);
        if (value.length > 1) {
          const opts = value[1];
          if (opts !== void 0 && opts !== false && (typeof opts !== "object" || Array.isArray(opts))) {
            throw new Error(`${msg(access(loc, 1))} must be an object, false, or undefined`);
          }
        }
        if (value.length === 3) {
          const name = value[2];
          if (name !== void 0 && typeof name !== "string") {
            throw new Error(`${msg(access(loc, 2))} must be a string, or undefined`);
          }
        }
      } else {
        assertPluginTarget(loc, value);
      }
      return value;
    }
    function assertPluginTarget(loc, value) {
      if ((typeof value !== "object" || !value) && typeof value !== "string" && typeof value !== "function") {
        throw new Error(`${msg(loc)} must be a string, object, function`);
      }
      return value;
    }
  }
});

// node_modules/@babel/core/lib/config/validation/options.js
var require_options2 = __commonJS({
  "node_modules/@babel/core/lib/config/validation/options.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.validate = validate2;
    var _plugin = _interopRequireDefault(require_plugin());
    var _removed = _interopRequireDefault(require_removed());
    var _optionAssertions = require_option_assertions();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var ROOT_VALIDATORS = {
      cwd: _optionAssertions.assertString,
      root: _optionAssertions.assertString,
      rootMode: _optionAssertions.assertRootMode,
      configFile: _optionAssertions.assertConfigFileSearch,
      caller: _optionAssertions.assertCallerMetadata,
      filename: _optionAssertions.assertString,
      filenameRelative: _optionAssertions.assertString,
      code: _optionAssertions.assertBoolean,
      ast: _optionAssertions.assertBoolean,
      envName: _optionAssertions.assertString
    };
    var BABELRC_VALIDATORS = {
      babelrc: _optionAssertions.assertBoolean,
      babelrcRoots: _optionAssertions.assertBabelrcSearch
    };
    var NONPRESET_VALIDATORS = {
      extends: _optionAssertions.assertString,
      ignore: _optionAssertions.assertIgnoreList,
      only: _optionAssertions.assertIgnoreList
    };
    var COMMON_VALIDATORS = {
      inputSourceMap: _optionAssertions.assertInputSourceMap,
      presets: _optionAssertions.assertPluginList,
      plugins: _optionAssertions.assertPluginList,
      passPerPreset: _optionAssertions.assertBoolean,
      env: assertEnvSet,
      overrides: assertOverridesList,
      test: _optionAssertions.assertConfigApplicableTest,
      include: _optionAssertions.assertConfigApplicableTest,
      exclude: _optionAssertions.assertConfigApplicableTest,
      retainLines: _optionAssertions.assertBoolean,
      comments: _optionAssertions.assertBoolean,
      shouldPrintComment: _optionAssertions.assertFunction,
      compact: _optionAssertions.assertCompact,
      minified: _optionAssertions.assertBoolean,
      auxiliaryCommentBefore: _optionAssertions.assertString,
      auxiliaryCommentAfter: _optionAssertions.assertString,
      sourceType: _optionAssertions.assertSourceType,
      wrapPluginVisitorMethod: _optionAssertions.assertFunction,
      highlightCode: _optionAssertions.assertBoolean,
      sourceMaps: _optionAssertions.assertSourceMaps,
      sourceMap: _optionAssertions.assertSourceMaps,
      sourceFileName: _optionAssertions.assertString,
      sourceRoot: _optionAssertions.assertString,
      getModuleId: _optionAssertions.assertFunction,
      moduleRoot: _optionAssertions.assertString,
      moduleIds: _optionAssertions.assertBoolean,
      moduleId: _optionAssertions.assertString,
      parserOpts: _optionAssertions.assertObject,
      generatorOpts: _optionAssertions.assertObject
    };
    function getSource(loc) {
      return loc.type === "root" ? loc.source : getSource(loc.parent);
    }
    function validate2(type, opts) {
      return validateNested({
        type: "root",
        source: type
      }, opts);
    }
    function validateNested(loc, opts) {
      const type = getSource(loc);
      assertNoDuplicateSourcemap(opts);
      Object.keys(opts).forEach((key2) => {
        const optLoc = {
          type: "option",
          name: key2,
          parent: loc
        };
        if (type === "preset" && NONPRESET_VALIDATORS[key2]) {
          throw new Error(`${(0, _optionAssertions.msg)(optLoc)} is not allowed in preset options`);
        }
        if (type !== "arguments" && ROOT_VALIDATORS[key2]) {
          throw new Error(`${(0, _optionAssertions.msg)(optLoc)} is only allowed in root programmatic options`);
        }
        if (type !== "arguments" && type !== "configfile" && BABELRC_VALIDATORS[key2]) {
          if (type === "babelrcfile" || type === "extendsfile") {
            throw new Error(`${(0, _optionAssertions.msg)(optLoc)} is not allowed in .babelrc or "extends"ed files, only in root programmatic options, or babel.config.js/config file options`);
          }
          throw new Error(`${(0, _optionAssertions.msg)(optLoc)} is only allowed in root programmatic options, or babel.config.js/config file options`);
        }
        const validator = COMMON_VALIDATORS[key2] || NONPRESET_VALIDATORS[key2] || BABELRC_VALIDATORS[key2] || ROOT_VALIDATORS[key2] || throwUnknownError;
        validator(optLoc, opts[key2]);
      });
      return opts;
    }
    function throwUnknownError(loc) {
      const key2 = loc.name;
      if (_removed.default[key2]) {
        const {
          message,
          version = 5
        } = _removed.default[key2];
        throw new ReferenceError(`Using removed Babel ${version} option: ${(0, _optionAssertions.msg)(loc)} - ${message}`);
      } else {
        const unknownOptErr = `Unknown option: ${(0, _optionAssertions.msg)(loc)}. Check out https://babeljs.io/docs/en/babel-core/#options for more information about options.`;
        throw new ReferenceError(unknownOptErr);
      }
    }
    function has(obj, key2) {
      return Object.prototype.hasOwnProperty.call(obj, key2);
    }
    function assertNoDuplicateSourcemap(opts) {
      if (has(opts, "sourceMap") && has(opts, "sourceMaps")) {
        throw new Error(".sourceMap is an alias for .sourceMaps, cannot use both");
      }
    }
    function assertEnvSet(loc, value) {
      if (loc.parent.type === "env") {
        throw new Error(`${(0, _optionAssertions.msg)(loc)} is not allowed inside of another .env block`);
      }
      const parent = loc.parent;
      const obj = (0, _optionAssertions.assertObject)(loc, value);
      if (obj) {
        for (const envName of Object.keys(obj)) {
          const env = (0, _optionAssertions.assertObject)((0, _optionAssertions.access)(loc, envName), obj[envName]);
          if (!env) continue;
          const envLoc = {
            type: "env",
            name: envName,
            parent
          };
          validateNested(envLoc, env);
        }
      }
      return obj;
    }
    function assertOverridesList(loc, value) {
      if (loc.parent.type === "env") {
        throw new Error(`${(0, _optionAssertions.msg)(loc)} is not allowed inside an .env block`);
      }
      if (loc.parent.type === "overrides") {
        throw new Error(`${(0, _optionAssertions.msg)(loc)} is not allowed inside an .overrides block`);
      }
      const parent = loc.parent;
      const arr = (0, _optionAssertions.assertArray)(loc, value);
      if (arr) {
        for (const [index, item] of arr.entries()) {
          const objLoc = (0, _optionAssertions.access)(loc, index);
          const env = (0, _optionAssertions.assertObject)(objLoc, item);
          if (!env) throw new Error(`${(0, _optionAssertions.msg)(objLoc)} must be an object`);
          const overridesLoc = {
            type: "overrides",
            index,
            parent
          };
          validateNested(overridesLoc, env);
        }
      }
      return arr;
    }
  }
});

// node_modules/@babel/core/lib/config/config-chain.js
var require_config_chain = __commonJS({
  "node_modules/@babel/core/lib/config/config-chain.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.buildPresetChain = buildPresetChain;
    exports2.buildRootChain = buildRootChain;
    exports2.buildPresetChainWalker = void 0;
    function _path() {
      const data = _interopRequireDefault(require("path"));
      _path = function() {
        return data;
      };
      return data;
    }
    function _debug() {
      const data = _interopRequireDefault(require_src());
      _debug = function() {
        return data;
      };
      return data;
    }
    var _options = require_options2();
    var _patternToRegex = _interopRequireDefault(require_pattern_to_regex());
    var _files = require_files();
    var _caching = require_caching();
    var _configDescriptors = require_config_descriptors();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var debug = (0, _debug().default)("babel:config:config-chain");
    function buildPresetChain(arg, context) {
      const chain = buildPresetChainWalker(arg, context);
      if (!chain) return null;
      return {
        plugins: dedupDescriptors(chain.plugins),
        presets: dedupDescriptors(chain.presets),
        options: chain.options.map((o) => normalizeOptions(o))
      };
    }
    var buildPresetChainWalker = makeChainWalker({
      init: (arg) => arg,
      root: (preset) => loadPresetDescriptors(preset),
      env: (preset, envName) => loadPresetEnvDescriptors(preset)(envName),
      overrides: (preset, index) => loadPresetOverridesDescriptors(preset)(index),
      overridesEnv: (preset, index, envName) => loadPresetOverridesEnvDescriptors(preset)(index)(envName)
    });
    exports2.buildPresetChainWalker = buildPresetChainWalker;
    var loadPresetDescriptors = (0, _caching.makeWeakCache)((preset) => buildRootDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors));
    var loadPresetEnvDescriptors = (0, _caching.makeWeakCache)((preset) => (0, _caching.makeStrongCache)((envName) => buildEnvDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors, envName)));
    var loadPresetOverridesDescriptors = (0, _caching.makeWeakCache)((preset) => (0, _caching.makeStrongCache)((index) => buildOverrideDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors, index)));
    var loadPresetOverridesEnvDescriptors = (0, _caching.makeWeakCache)((preset) => (0, _caching.makeStrongCache)((index) => (0, _caching.makeStrongCache)((envName) => buildOverrideEnvDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors, index, envName))));
    function buildRootChain(opts, context) {
      const programmaticChain = loadProgrammaticChain({
        options: opts,
        dirname: context.cwd
      }, context);
      if (!programmaticChain) return null;
      let configFile;
      if (typeof opts.configFile === "string") {
        configFile = (0, _files.loadConfig)(opts.configFile, context.cwd, context.envName, context.caller);
      } else if (opts.configFile !== false) {
        configFile = (0, _files.findRootConfig)(context.root, context.envName, context.caller);
      }
      let {
        babelrc,
        babelrcRoots
      } = opts;
      let babelrcRootsDirectory = context.cwd;
      const configFileChain = emptyChain();
      if (configFile) {
        const validatedFile = validateConfigFile(configFile);
        const result = loadFileChain(validatedFile, context);
        if (!result) return null;
        if (babelrc === void 0) {
          babelrc = validatedFile.options.babelrc;
        }
        if (babelrcRoots === void 0) {
          babelrcRootsDirectory = validatedFile.dirname;
          babelrcRoots = validatedFile.options.babelrcRoots;
        }
        mergeChain(configFileChain, result);
      }
      const pkgData = typeof context.filename === "string" ? (0, _files.findPackageData)(context.filename) : null;
      let ignoreFile, babelrcFile;
      const fileChain = emptyChain();
      if ((babelrc === true || babelrc === void 0) && pkgData && babelrcLoadEnabled(context, pkgData, babelrcRoots, babelrcRootsDirectory)) {
        ({
          ignore: ignoreFile,
          config: babelrcFile
        } = (0, _files.findRelativeConfig)(pkgData, context.envName, context.caller));
        if (ignoreFile && shouldIgnore(context, ignoreFile.ignore, null, ignoreFile.dirname)) {
          return null;
        }
        if (babelrcFile) {
          const result = loadFileChain(validateBabelrcFile(babelrcFile), context);
          if (!result) return null;
          mergeChain(fileChain, result);
        }
      }
      const chain = mergeChain(mergeChain(mergeChain(emptyChain(), configFileChain), fileChain), programmaticChain);
      return {
        plugins: dedupDescriptors(chain.plugins),
        presets: dedupDescriptors(chain.presets),
        options: chain.options.map((o) => normalizeOptions(o)),
        ignore: ignoreFile || void 0,
        babelrc: babelrcFile || void 0,
        config: configFile || void 0
      };
    }
    function babelrcLoadEnabled(context, pkgData, babelrcRoots, babelrcRootsDirectory) {
      if (typeof babelrcRoots === "boolean") return babelrcRoots;
      const absoluteRoot = context.root;
      if (babelrcRoots === void 0) {
        return pkgData.directories.indexOf(absoluteRoot) !== -1;
      }
      let babelrcPatterns = babelrcRoots;
      if (!Array.isArray(babelrcPatterns)) babelrcPatterns = [babelrcPatterns];
      babelrcPatterns = babelrcPatterns.map((pat) => {
        return typeof pat === "string" ? _path().default.resolve(babelrcRootsDirectory, pat) : pat;
      });
      if (babelrcPatterns.length === 1 && babelrcPatterns[0] === absoluteRoot) {
        return pkgData.directories.indexOf(absoluteRoot) !== -1;
      }
      return babelrcPatterns.some((pat) => {
        if (typeof pat === "string") {
          pat = (0, _patternToRegex.default)(pat, babelrcRootsDirectory);
        }
        return pkgData.directories.some((directory) => {
          return matchPattern(pat, babelrcRootsDirectory, directory, context);
        });
      });
    }
    var validateConfigFile = (0, _caching.makeWeakCache)((file) => ({
      filepath: file.filepath,
      dirname: file.dirname,
      options: (0, _options.validate)("configfile", file.options)
    }));
    var validateBabelrcFile = (0, _caching.makeWeakCache)((file) => ({
      filepath: file.filepath,
      dirname: file.dirname,
      options: (0, _options.validate)("babelrcfile", file.options)
    }));
    var validateExtendFile = (0, _caching.makeWeakCache)((file) => ({
      filepath: file.filepath,
      dirname: file.dirname,
      options: (0, _options.validate)("extendsfile", file.options)
    }));
    var loadProgrammaticChain = makeChainWalker({
      root: (input) => buildRootDescriptors(input, "base", _configDescriptors.createCachedDescriptors),
      env: (input, envName) => buildEnvDescriptors(input, "base", _configDescriptors.createCachedDescriptors, envName),
      overrides: (input, index) => buildOverrideDescriptors(input, "base", _configDescriptors.createCachedDescriptors, index),
      overridesEnv: (input, index, envName) => buildOverrideEnvDescriptors(input, "base", _configDescriptors.createCachedDescriptors, index, envName)
    });
    var loadFileChain = makeChainWalker({
      root: (file) => loadFileDescriptors(file),
      env: (file, envName) => loadFileEnvDescriptors(file)(envName),
      overrides: (file, index) => loadFileOverridesDescriptors(file)(index),
      overridesEnv: (file, index, envName) => loadFileOverridesEnvDescriptors(file)(index)(envName)
    });
    var loadFileDescriptors = (0, _caching.makeWeakCache)((file) => buildRootDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors));
    var loadFileEnvDescriptors = (0, _caching.makeWeakCache)((file) => (0, _caching.makeStrongCache)((envName) => buildEnvDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors, envName)));
    var loadFileOverridesDescriptors = (0, _caching.makeWeakCache)((file) => (0, _caching.makeStrongCache)((index) => buildOverrideDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors, index)));
    var loadFileOverridesEnvDescriptors = (0, _caching.makeWeakCache)((file) => (0, _caching.makeStrongCache)((index) => (0, _caching.makeStrongCache)((envName) => buildOverrideEnvDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors, index, envName))));
    function buildRootDescriptors({
      dirname,
      options
    }, alias, descriptors) {
      return descriptors(dirname, options, alias);
    }
    function buildEnvDescriptors({
      dirname,
      options
    }, alias, descriptors, envName) {
      const opts = options.env && options.env[envName];
      return opts ? descriptors(dirname, opts, `${alias}.env["${envName}"]`) : null;
    }
    function buildOverrideDescriptors({
      dirname,
      options
    }, alias, descriptors, index) {
      const opts = options.overrides && options.overrides[index];
      if (!opts) throw new Error("Assertion failure - missing override");
      return descriptors(dirname, opts, `${alias}.overrides[${index}]`);
    }
    function buildOverrideEnvDescriptors({
      dirname,
      options
    }, alias, descriptors, index, envName) {
      const override = options.overrides && options.overrides[index];
      if (!override) throw new Error("Assertion failure - missing override");
      const opts = override.env && override.env[envName];
      return opts ? descriptors(dirname, opts, `${alias}.overrides[${index}].env["${envName}"]`) : null;
    }
    function makeChainWalker({
      root: root2,
      env,
      overrides,
      overridesEnv
    }) {
      return (input, context, files = /* @__PURE__ */ new Set()) => {
        const {
          dirname
        } = input;
        const flattenedConfigs = [];
        const rootOpts = root2(input);
        if (configIsApplicable(rootOpts, dirname, context)) {
          flattenedConfigs.push(rootOpts);
          const envOpts = env(input, context.envName);
          if (envOpts && configIsApplicable(envOpts, dirname, context)) {
            flattenedConfigs.push(envOpts);
          }
          (rootOpts.options.overrides || []).forEach((_, index) => {
            const overrideOps = overrides(input, index);
            if (configIsApplicable(overrideOps, dirname, context)) {
              flattenedConfigs.push(overrideOps);
              const overrideEnvOpts = overridesEnv(input, index, context.envName);
              if (overrideEnvOpts && configIsApplicable(overrideEnvOpts, dirname, context)) {
                flattenedConfigs.push(overrideEnvOpts);
              }
            }
          });
        }
        if (flattenedConfigs.some(({
          options: {
            ignore,
            only
          }
        }) => shouldIgnore(context, ignore, only, dirname))) {
          return null;
        }
        const chain = emptyChain();
        for (const op of flattenedConfigs) {
          if (!mergeExtendsChain(chain, op.options, dirname, context, files)) {
            return null;
          }
          mergeChainOpts(chain, op);
        }
        return chain;
      };
    }
    function mergeExtendsChain(chain, opts, dirname, context, files) {
      if (opts.extends === void 0) return true;
      const file = (0, _files.loadConfig)(opts.extends, dirname, context.envName, context.caller);
      if (files.has(file)) {
        throw new Error(`Configuration cycle detected loading ${file.filepath}.
File already loaded following the config chain:
` + Array.from(files, (file2) => ` - ${file2.filepath}`).join("\n"));
      }
      files.add(file);
      const fileChain = loadFileChain(validateExtendFile(file), context, files);
      files.delete(file);
      if (!fileChain) return false;
      mergeChain(chain, fileChain);
      return true;
    }
    function mergeChain(target, source2) {
      target.options.push(...source2.options);
      target.plugins.push(...source2.plugins);
      target.presets.push(...source2.presets);
      return target;
    }
    function mergeChainOpts(target, {
      options,
      plugins,
      presets
    }) {
      target.options.push(options);
      target.plugins.push(...plugins());
      target.presets.push(...presets());
      return target;
    }
    function emptyChain() {
      return {
        options: [],
        presets: [],
        plugins: []
      };
    }
    function normalizeOptions(opts) {
      const options = Object.assign({}, opts);
      delete options.extends;
      delete options.env;
      delete options.overrides;
      delete options.plugins;
      delete options.presets;
      delete options.passPerPreset;
      delete options.ignore;
      delete options.only;
      delete options.test;
      delete options.include;
      delete options.exclude;
      if (options.hasOwnProperty("sourceMap")) {
        options.sourceMaps = options.sourceMap;
        delete options.sourceMap;
      }
      return options;
    }
    function dedupDescriptors(items) {
      const map = /* @__PURE__ */ new Map();
      const descriptors = [];
      for (const item of items) {
        if (typeof item.value === "function") {
          const fnKey = item.value;
          let nameMap = map.get(fnKey);
          if (!nameMap) {
            nameMap = /* @__PURE__ */ new Map();
            map.set(fnKey, nameMap);
          }
          let desc = nameMap.get(item.name);
          if (!desc) {
            desc = {
              value: item
            };
            descriptors.push(desc);
            if (!item.ownPass) nameMap.set(item.name, desc);
          } else {
            desc.value = item;
          }
        } else {
          descriptors.push({
            value: item
          });
        }
      }
      return descriptors.reduce((acc, desc) => {
        acc.push(desc.value);
        return acc;
      }, []);
    }
    function configIsApplicable({
      options
    }, dirname, context) {
      return (options.test === void 0 || configFieldIsApplicable(context, options.test, dirname)) && (options.include === void 0 || configFieldIsApplicable(context, options.include, dirname)) && (options.exclude === void 0 || !configFieldIsApplicable(context, options.exclude, dirname));
    }
    function configFieldIsApplicable(context, test, dirname) {
      const patterns = Array.isArray(test) ? test : [test];
      return matchesPatterns(context, patterns, dirname);
    }
    function shouldIgnore(context, ignore, only, dirname) {
      if (ignore && matchesPatterns(context, ignore, dirname)) {
        debug("Ignored %o because it matched one of %O from %o", context.filename, ignore, dirname);
        return true;
      }
      if (only && !matchesPatterns(context, only, dirname)) {
        debug("Ignored %o because it failed to match one of %O from %o", context.filename, only, dirname);
        return true;
      }
      return false;
    }
    function matchesPatterns(context, patterns, dirname) {
      return patterns.some((pattern) => matchPattern(pattern, dirname, context.filename, context));
    }
    function matchPattern(pattern, dirname, pathToTest, context) {
      if (typeof pattern === "function") {
        return !!pattern(pathToTest, {
          dirname,
          envName: context.envName,
          caller: context.caller
        });
      }
      if (typeof pathToTest !== "string") {
        throw new Error(`Configuration contains string/RegExp pattern, but no filename was passed to Babel`);
      }
      if (typeof pattern === "string") {
        pattern = (0, _patternToRegex.default)(pattern, dirname);
      }
      return pattern.test(pathToTest);
    }
  }
});

// node_modules/@babel/core/lib/config/validation/plugins.js
var require_plugins2 = __commonJS({
  "node_modules/@babel/core/lib/config/validation/plugins.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.validatePluginObject = validatePluginObject;
    var _optionAssertions = require_option_assertions();
    var VALIDATORS = {
      name: _optionAssertions.assertString,
      manipulateOptions: _optionAssertions.assertFunction,
      pre: _optionAssertions.assertFunction,
      post: _optionAssertions.assertFunction,
      inherits: _optionAssertions.assertFunction,
      visitor: assertVisitorMap,
      parserOverride: _optionAssertions.assertFunction,
      generatorOverride: _optionAssertions.assertFunction
    };
    function assertVisitorMap(key2, value) {
      const obj = (0, _optionAssertions.assertObject)(key2, value);
      if (obj) {
        Object.keys(obj).forEach((prop) => assertVisitorHandler(prop, obj[prop]));
        if (obj.enter || obj.exit) {
          throw new Error(`.${key2} cannot contain catch-all "enter" or "exit" handlers. Please target individual nodes.`);
        }
      }
      return obj;
    }
    function assertVisitorHandler(key2, value) {
      if (value && typeof value === "object") {
        Object.keys(value).forEach((handler) => {
          if (handler !== "enter" && handler !== "exit") {
            throw new Error(`.visitor["${key2}"] may only have .enter and/or .exit handlers.`);
          }
        });
      } else if (typeof value !== "function") {
        throw new Error(`.visitor["${key2}"] must be a function`);
      }
      return value;
    }
    function validatePluginObject(obj) {
      Object.keys(obj).forEach((key2) => {
        const validator = VALIDATORS[key2];
        if (validator) validator(key2, obj[key2]);
        else throw new Error(`.${key2} is not a valid Plugin property`);
      });
      return obj;
    }
  }
});

// node_modules/@babel/core/lib/config/partial.js
var require_partial = __commonJS({
  "node_modules/@babel/core/lib/config/partial.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = loadPrivatePartialConfig;
    exports2.loadPartialConfig = loadPartialConfig;
    function _path() {
      const data = _interopRequireDefault(require("path"));
      _path = function() {
        return data;
      };
      return data;
    }
    var _plugin = _interopRequireDefault(require_plugin());
    var _util = require_util3();
    var _item = require_item();
    var _configChain = require_config_chain();
    var _environment = require_environment();
    var _options = require_options2();
    var _files = require_files();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function resolveRootMode(rootDir, rootMode) {
      switch (rootMode) {
        case "root":
          return rootDir;
        case "upward-optional": {
          const upwardRootDir = (0, _files.findConfigUpwards)(rootDir);
          return upwardRootDir === null ? rootDir : upwardRootDir;
        }
        case "upward": {
          const upwardRootDir = (0, _files.findConfigUpwards)(rootDir);
          if (upwardRootDir !== null) return upwardRootDir;
          throw Object.assign(new Error(`Babel was run with rootMode:"upward" but a root could not be found when searching upward from "${rootDir}"`), {
            code: "BABEL_ROOT_NOT_FOUND",
            dirname: rootDir
          });
        }
        default:
          throw new Error(`Assertion failure - unknown rootMode value`);
      }
    }
    function loadPrivatePartialConfig(inputOpts) {
      if (inputOpts != null && (typeof inputOpts !== "object" || Array.isArray(inputOpts))) {
        throw new Error("Babel options must be an object, null, or undefined");
      }
      const args = inputOpts ? (0, _options.validate)("arguments", inputOpts) : {};
      const {
        envName = (0, _environment.getEnv)(),
        cwd = ".",
        root: rootDir = ".",
        rootMode = "root",
        caller
      } = args;
      const absoluteCwd = _path().default.resolve(cwd);
      const absoluteRootDir = resolveRootMode(_path().default.resolve(absoluteCwd, rootDir), rootMode);
      const context = {
        filename: typeof args.filename === "string" ? _path().default.resolve(cwd, args.filename) : void 0,
        cwd: absoluteCwd,
        root: absoluteRootDir,
        envName,
        caller
      };
      const configChain = (0, _configChain.buildRootChain)(args, context);
      if (!configChain) return null;
      const options = {};
      configChain.options.forEach((opts) => {
        (0, _util.mergeOptions)(options, opts);
      });
      options.babelrc = false;
      options.configFile = false;
      options.passPerPreset = false;
      options.envName = context.envName;
      options.cwd = context.cwd;
      options.root = context.root;
      options.filename = typeof context.filename === "string" ? context.filename : void 0;
      options.plugins = configChain.plugins.map((descriptor) => (0, _item.createItemFromDescriptor)(descriptor));
      options.presets = configChain.presets.map((descriptor) => (0, _item.createItemFromDescriptor)(descriptor));
      return {
        options,
        context,
        ignore: configChain.ignore,
        babelrc: configChain.babelrc,
        config: configChain.config
      };
    }
    function loadPartialConfig(inputOpts) {
      const result = loadPrivatePartialConfig(inputOpts);
      if (!result) return null;
      const {
        options,
        babelrc,
        ignore,
        config
      } = result;
      (options.plugins || []).forEach((item) => {
        if (item.value instanceof _plugin.default) {
          throw new Error("Passing cached plugin instances is not supported in babel.loadPartialConfig()");
        }
      });
      return new PartialConfig(options, babelrc ? babelrc.filepath : void 0, ignore ? ignore.filepath : void 0, config ? config.filepath : void 0);
    }
    var PartialConfig = class {
      constructor(options, babelrc, ignore, config) {
        this.options = options;
        this.babelignore = ignore;
        this.babelrc = babelrc;
        this.config = config;
        Object.freeze(this);
      }
      hasFilesystemConfig() {
        return this.babelrc !== void 0 || this.config !== void 0;
      }
    };
    Object.freeze(PartialConfig.prototype);
  }
});

// node_modules/@babel/core/lib/config/full.js
var require_full = __commonJS({
  "node_modules/@babel/core/lib/config/full.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = loadFullConfig;
    var _util = require_util3();
    var context = _interopRequireWildcard(require_lib10());
    var _plugin = _interopRequireDefault(require_plugin());
    var _item = require_item();
    var _configChain = require_config_chain();
    function _traverse() {
      const data = _interopRequireDefault(require_lib9());
      _traverse = function() {
        return data;
      };
      return data;
    }
    var _caching = require_caching();
    var _options = require_options2();
    var _plugins = require_plugins2();
    var _configApi = _interopRequireDefault(require_config_api());
    var _partial = _interopRequireDefault(require_partial());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key2 in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key2)) {
              var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key2) : {};
              if (desc.get || desc.set) {
                Object.defineProperty(newObj, key2, desc);
              } else {
                newObj[key2] = obj[key2];
              }
            }
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    function loadFullConfig(inputOpts) {
      const result = (0, _partial.default)(inputOpts);
      if (!result) {
        return null;
      }
      const {
        options,
        context: context2
      } = result;
      const optionDefaults = {};
      const passes = [[]];
      try {
        const {
          plugins,
          presets
        } = options;
        if (!plugins || !presets) {
          throw new Error("Assertion failure - plugins and presets exist");
        }
        const ignored = function recurseDescriptors(config, pass) {
          const plugins2 = config.plugins.reduce((acc, descriptor) => {
            if (descriptor.options !== false) {
              acc.push(loadPluginDescriptor(descriptor, context2));
            }
            return acc;
          }, []);
          const presets2 = config.presets.reduce((acc, descriptor) => {
            if (descriptor.options !== false) {
              acc.push({
                preset: loadPresetDescriptor(descriptor, context2),
                pass: descriptor.ownPass ? [] : pass
              });
            }
            return acc;
          }, []);
          if (presets2.length > 0) {
            passes.splice(1, 0, ...presets2.map((o) => o.pass).filter((p) => p !== pass));
            for (const _ref of presets2) {
              const {
                preset,
                pass: pass2
              } = _ref;
              if (!preset) return true;
              const ignored2 = recurseDescriptors({
                plugins: preset.plugins,
                presets: preset.presets
              }, pass2);
              if (ignored2) return true;
              preset.options.forEach((opts2) => {
                (0, _util.mergeOptions)(optionDefaults, opts2);
              });
            }
          }
          if (plugins2.length > 0) {
            pass.unshift(...plugins2);
          }
        }({
          plugins: plugins.map((item) => {
            const desc = (0, _item.getItemDescriptor)(item);
            if (!desc) {
              throw new Error("Assertion failure - must be config item");
            }
            return desc;
          }),
          presets: presets.map((item) => {
            const desc = (0, _item.getItemDescriptor)(item);
            if (!desc) {
              throw new Error("Assertion failure - must be config item");
            }
            return desc;
          })
        }, passes[0]);
        if (ignored) return null;
      } catch (e) {
        if (!/^\[BABEL\]/.test(e.message)) {
          e.message = `[BABEL] ${context2.filename || "unknown"}: ${e.message}`;
        }
        throw e;
      }
      const opts = optionDefaults;
      (0, _util.mergeOptions)(opts, options);
      opts.plugins = passes[0];
      opts.presets = passes.slice(1).filter((plugins) => plugins.length > 0).map((plugins) => ({
        plugins
      }));
      opts.passPerPreset = opts.presets.length > 0;
      return {
        options: opts,
        passes
      };
    }
    var loadDescriptor = (0, _caching.makeWeakCache)(({
      value,
      options,
      dirname,
      alias
    }, cache) => {
      if (options === false) throw new Error("Assertion failure");
      options = options || {};
      let item = value;
      if (typeof value === "function") {
        const api = Object.assign({}, context, (0, _configApi.default)(cache));
        try {
          item = value(api, options, dirname);
        } catch (e) {
          if (alias) {
            e.message += ` (While processing: ${JSON.stringify(alias)})`;
          }
          throw e;
        }
      }
      if (!item || typeof item !== "object") {
        throw new Error("Plugin/Preset did not return an object.");
      }
      if (typeof item.then === "function") {
        throw new Error(`You appear to be using an async plugin, which your current version of Babel does not support.If you're using a published plugin, you may need to upgrade your @babel/core version.`);
      }
      return {
        value: item,
        options,
        dirname,
        alias
      };
    });
    function loadPluginDescriptor(descriptor, context2) {
      if (descriptor.value instanceof _plugin.default) {
        if (descriptor.options) {
          throw new Error("Passed options to an existing Plugin instance will not work.");
        }
        return descriptor.value;
      }
      return instantiatePlugin(loadDescriptor(descriptor, context2), context2);
    }
    var instantiatePlugin = (0, _caching.makeWeakCache)(({
      value,
      options,
      dirname,
      alias
    }, cache) => {
      const pluginObj = (0, _plugins.validatePluginObject)(value);
      const plugin = Object.assign({}, pluginObj);
      if (plugin.visitor) {
        plugin.visitor = _traverse().default.explode(Object.assign({}, plugin.visitor));
      }
      if (plugin.inherits) {
        const inheritsDescriptor = {
          name: void 0,
          alias: `${alias}$inherits`,
          value: plugin.inherits,
          options,
          dirname
        };
        const inherits = cache.invalidate((data) => loadPluginDescriptor(inheritsDescriptor, data));
        plugin.pre = chain(inherits.pre, plugin.pre);
        plugin.post = chain(inherits.post, plugin.post);
        plugin.manipulateOptions = chain(inherits.manipulateOptions, plugin.manipulateOptions);
        plugin.visitor = _traverse().default.visitors.merge([inherits.visitor || {}, plugin.visitor || {}]);
      }
      return new _plugin.default(plugin, options, alias);
    });
    var loadPresetDescriptor = (descriptor, context2) => {
      return (0, _configChain.buildPresetChain)(instantiatePreset(loadDescriptor(descriptor, context2)), context2);
    };
    var instantiatePreset = (0, _caching.makeWeakCache)(({
      value,
      dirname,
      alias
    }) => {
      return {
        options: (0, _options.validate)("preset", value),
        alias,
        dirname
      };
    });
    function chain(a, b) {
      const fns = [a, b].filter(Boolean);
      if (fns.length <= 1) return fns[0];
      return function(...args) {
        for (const fn of fns) {
          fn.apply(this, args);
        }
      };
    }
  }
});

// node_modules/@babel/core/lib/config/index.js
var require_config = __commonJS({
  "node_modules/@babel/core/lib/config/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.loadOptions = loadOptions;
    Object.defineProperty(exports2, "default", {
      enumerable: true,
      get: function() {
        return _full.default;
      }
    });
    Object.defineProperty(exports2, "loadPartialConfig", {
      enumerable: true,
      get: function() {
        return _partial.loadPartialConfig;
      }
    });
    var _full = _interopRequireDefault(require_full());
    var _partial = require_partial();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function loadOptions(opts) {
      const config = (0, _full.default)(opts);
      return config ? config.options : null;
    }
  }
});

// node_modules/@babel/core/lib/transformation/plugin-pass.js
var require_plugin_pass = __commonJS({
  "node_modules/@babel/core/lib/transformation/plugin-pass.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var PluginPass = class {
      constructor(file, key2, options) {
        this._map = /* @__PURE__ */ new Map();
        this.key = key2;
        this.file = file;
        this.opts = options || {};
        this.cwd = file.opts.cwd;
        this.filename = file.opts.filename;
      }
      set(key2, val) {
        this._map.set(key2, val);
      }
      get(key2) {
        return this._map.get(key2);
      }
      availableHelper(name, versionRange) {
        return this.file.availableHelper(name, versionRange);
      }
      addHelper(name) {
        return this.file.addHelper(name);
      }
      addImport() {
        return this.file.addImport();
      }
      getModuleName() {
        return this.file.getModuleName();
      }
      buildCodeFrameError(node, msg, Error2) {
        return this.file.buildCodeFrameError(node, msg, Error2);
      }
    };
    exports2.default = PluginPass;
  }
});

// ../../node_modules/lodash/_arrayPush.js
var require_arrayPush = __commonJS({
  "../../node_modules/lodash/_arrayPush.js"(exports2, module2) {
    "use strict";
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    module2.exports = arrayPush;
  }
});

// ../../node_modules/lodash/_baseIsArguments.js
var require_baseIsArguments = __commonJS({
  "../../node_modules/lodash/_baseIsArguments.js"(exports2, module2) {
    "use strict";
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    module2.exports = baseIsArguments;
  }
});

// ../../node_modules/lodash/isArguments.js
var require_isArguments = __commonJS({
  "../../node_modules/lodash/isArguments.js"(exports2, module2) {
    "use strict";
    var baseIsArguments = require_baseIsArguments();
    var isObjectLike = require_isObjectLike();
    var objectProto = Object.prototype;
    var hasOwnProperty3 = objectProto.hasOwnProperty;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var isArguments = baseIsArguments(/* @__PURE__ */ function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty3.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    module2.exports = isArguments;
  }
});

// ../../node_modules/lodash/_isFlattenable.js
var require_isFlattenable = __commonJS({
  "../../node_modules/lodash/_isFlattenable.js"(exports2, module2) {
    "use strict";
    var Symbol2 = require_Symbol();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    module2.exports = isFlattenable;
  }
});

// ../../node_modules/lodash/_baseFlatten.js
var require_baseFlatten = __commonJS({
  "../../node_modules/lodash/_baseFlatten.js"(exports2, module2) {
    "use strict";
    var arrayPush = require_arrayPush();
    var isFlattenable = require_isFlattenable();
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1, length = array.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    module2.exports = baseFlatten;
  }
});

// ../../node_modules/lodash/_isKey.js
var require_isKey = __commonJS({
  "../../node_modules/lodash/_isKey.js"(exports2, module2) {
    "use strict";
    var isArray = require_isArray();
    var isSymbol = require_isSymbol();
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    module2.exports = isKey;
  }
});

// ../../node_modules/lodash/isObject.js
var require_isObject = __commonJS({
  "../../node_modules/lodash/isObject.js"(exports2, module2) {
    "use strict";
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    module2.exports = isObject;
  }
});

// ../../node_modules/lodash/isFunction.js
var require_isFunction = __commonJS({
  "../../node_modules/lodash/isFunction.js"(exports2, module2) {
    "use strict";
    var baseGetTag = require_baseGetTag();
    var isObject = require_isObject();
    var asyncTag = "[object AsyncFunction]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var proxyTag = "[object Proxy]";
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    module2.exports = isFunction;
  }
});

// ../../node_modules/lodash/_coreJsData.js
var require_coreJsData = __commonJS({
  "../../node_modules/lodash/_coreJsData.js"(exports2, module2) {
    "use strict";
    var root2 = require_root();
    var coreJsData = root2["__core-js_shared__"];
    module2.exports = coreJsData;
  }
});

// ../../node_modules/lodash/_isMasked.js
var require_isMasked = __commonJS({
  "../../node_modules/lodash/_isMasked.js"(exports2, module2) {
    "use strict";
    var coreJsData = require_coreJsData();
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    module2.exports = isMasked;
  }
});

// ../../node_modules/lodash/_toSource.js
var require_toSource = __commonJS({
  "../../node_modules/lodash/_toSource.js"(exports2, module2) {
    "use strict";
    var funcProto = Function.prototype;
    var funcToString = funcProto.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    module2.exports = toSource;
  }
});

// ../../node_modules/lodash/_baseIsNative.js
var require_baseIsNative = __commonJS({
  "../../node_modules/lodash/_baseIsNative.js"(exports2, module2) {
    "use strict";
    var isFunction = require_isFunction();
    var isMasked = require_isMasked();
    var isObject = require_isObject();
    var toSource = require_toSource();
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty3 = objectProto.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty3).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    module2.exports = baseIsNative;
  }
});

// ../../node_modules/lodash/_getValue.js
var require_getValue = __commonJS({
  "../../node_modules/lodash/_getValue.js"(exports2, module2) {
    "use strict";
    function getValue(object, key2) {
      return object == null ? void 0 : object[key2];
    }
    module2.exports = getValue;
  }
});

// ../../node_modules/lodash/_getNative.js
var require_getNative = __commonJS({
  "../../node_modules/lodash/_getNative.js"(exports2, module2) {
    "use strict";
    var baseIsNative = require_baseIsNative();
    var getValue = require_getValue();
    function getNative(object, key2) {
      var value = getValue(object, key2);
      return baseIsNative(value) ? value : void 0;
    }
    module2.exports = getNative;
  }
});

// ../../node_modules/lodash/_nativeCreate.js
var require_nativeCreate = __commonJS({
  "../../node_modules/lodash/_nativeCreate.js"(exports2, module2) {
    "use strict";
    var getNative = require_getNative();
    var nativeCreate = getNative(Object, "create");
    module2.exports = nativeCreate;
  }
});

// ../../node_modules/lodash/_hashClear.js
var require_hashClear = __commonJS({
  "../../node_modules/lodash/_hashClear.js"(exports2, module2) {
    "use strict";
    var nativeCreate = require_nativeCreate();
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    module2.exports = hashClear;
  }
});

// ../../node_modules/lodash/_hashDelete.js
var require_hashDelete = __commonJS({
  "../../node_modules/lodash/_hashDelete.js"(exports2, module2) {
    "use strict";
    function hashDelete(key2) {
      var result = this.has(key2) && delete this.__data__[key2];
      this.size -= result ? 1 : 0;
      return result;
    }
    module2.exports = hashDelete;
  }
});

// ../../node_modules/lodash/_hashGet.js
var require_hashGet = __commonJS({
  "../../node_modules/lodash/_hashGet.js"(exports2, module2) {
    "use strict";
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var objectProto = Object.prototype;
    var hasOwnProperty3 = objectProto.hasOwnProperty;
    function hashGet(key2) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key2];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty3.call(data, key2) ? data[key2] : void 0;
    }
    module2.exports = hashGet;
  }
});

// ../../node_modules/lodash/_hashHas.js
var require_hashHas = __commonJS({
  "../../node_modules/lodash/_hashHas.js"(exports2, module2) {
    "use strict";
    var nativeCreate = require_nativeCreate();
    var objectProto = Object.prototype;
    var hasOwnProperty3 = objectProto.hasOwnProperty;
    function hashHas(key2) {
      var data = this.__data__;
      return nativeCreate ? data[key2] !== void 0 : hasOwnProperty3.call(data, key2);
    }
    module2.exports = hashHas;
  }
});

// ../../node_modules/lodash/_hashSet.js
var require_hashSet = __commonJS({
  "../../node_modules/lodash/_hashSet.js"(exports2, module2) {
    "use strict";
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function hashSet(key2, value) {
      var data = this.__data__;
      this.size += this.has(key2) ? 0 : 1;
      data[key2] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    module2.exports = hashSet;
  }
});

// ../../node_modules/lodash/_Hash.js
var require_Hash = __commonJS({
  "../../node_modules/lodash/_Hash.js"(exports2, module2) {
    "use strict";
    var hashClear = require_hashClear();
    var hashDelete = require_hashDelete();
    var hashGet = require_hashGet();
    var hashHas = require_hashHas();
    var hashSet = require_hashSet();
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    module2.exports = Hash;
  }
});

// ../../node_modules/lodash/_listCacheClear.js
var require_listCacheClear = __commonJS({
  "../../node_modules/lodash/_listCacheClear.js"(exports2, module2) {
    "use strict";
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    module2.exports = listCacheClear;
  }
});

// ../../node_modules/lodash/eq.js
var require_eq = __commonJS({
  "../../node_modules/lodash/eq.js"(exports2, module2) {
    "use strict";
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    module2.exports = eq;
  }
});

// ../../node_modules/lodash/_assocIndexOf.js
var require_assocIndexOf = __commonJS({
  "../../node_modules/lodash/_assocIndexOf.js"(exports2, module2) {
    "use strict";
    var eq = require_eq();
    function assocIndexOf(array, key2) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key2)) {
          return length;
        }
      }
      return -1;
    }
    module2.exports = assocIndexOf;
  }
});

// ../../node_modules/lodash/_listCacheDelete.js
var require_listCacheDelete = __commonJS({
  "../../node_modules/lodash/_listCacheDelete.js"(exports2, module2) {
    "use strict";
    var assocIndexOf = require_assocIndexOf();
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key2) {
      var data = this.__data__, index = assocIndexOf(data, key2);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    module2.exports = listCacheDelete;
  }
});

// ../../node_modules/lodash/_listCacheGet.js
var require_listCacheGet = __commonJS({
  "../../node_modules/lodash/_listCacheGet.js"(exports2, module2) {
    "use strict";
    var assocIndexOf = require_assocIndexOf();
    function listCacheGet(key2) {
      var data = this.__data__, index = assocIndexOf(data, key2);
      return index < 0 ? void 0 : data[index][1];
    }
    module2.exports = listCacheGet;
  }
});

// ../../node_modules/lodash/_listCacheHas.js
var require_listCacheHas = __commonJS({
  "../../node_modules/lodash/_listCacheHas.js"(exports2, module2) {
    "use strict";
    var assocIndexOf = require_assocIndexOf();
    function listCacheHas(key2) {
      return assocIndexOf(this.__data__, key2) > -1;
    }
    module2.exports = listCacheHas;
  }
});

// ../../node_modules/lodash/_listCacheSet.js
var require_listCacheSet = __commonJS({
  "../../node_modules/lodash/_listCacheSet.js"(exports2, module2) {
    "use strict";
    var assocIndexOf = require_assocIndexOf();
    function listCacheSet(key2, value) {
      var data = this.__data__, index = assocIndexOf(data, key2);
      if (index < 0) {
        ++this.size;
        data.push([key2, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    module2.exports = listCacheSet;
  }
});

// ../../node_modules/lodash/_ListCache.js
var require_ListCache = __commonJS({
  "../../node_modules/lodash/_ListCache.js"(exports2, module2) {
    "use strict";
    var listCacheClear = require_listCacheClear();
    var listCacheDelete = require_listCacheDelete();
    var listCacheGet = require_listCacheGet();
    var listCacheHas = require_listCacheHas();
    var listCacheSet = require_listCacheSet();
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    module2.exports = ListCache;
  }
});

// ../../node_modules/lodash/_Map.js
var require_Map = __commonJS({
  "../../node_modules/lodash/_Map.js"(exports2, module2) {
    "use strict";
    var getNative = require_getNative();
    var root2 = require_root();
    var Map2 = getNative(root2, "Map");
    module2.exports = Map2;
  }
});

// ../../node_modules/lodash/_mapCacheClear.js
var require_mapCacheClear = __commonJS({
  "../../node_modules/lodash/_mapCacheClear.js"(exports2, module2) {
    "use strict";
    var Hash = require_Hash();
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    module2.exports = mapCacheClear;
  }
});

// ../../node_modules/lodash/_isKeyable.js
var require_isKeyable = __commonJS({
  "../../node_modules/lodash/_isKeyable.js"(exports2, module2) {
    "use strict";
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    module2.exports = isKeyable;
  }
});

// ../../node_modules/lodash/_getMapData.js
var require_getMapData = __commonJS({
  "../../node_modules/lodash/_getMapData.js"(exports2, module2) {
    "use strict";
    var isKeyable = require_isKeyable();
    function getMapData(map, key2) {
      var data = map.__data__;
      return isKeyable(key2) ? data[typeof key2 == "string" ? "string" : "hash"] : data.map;
    }
    module2.exports = getMapData;
  }
});

// ../../node_modules/lodash/_mapCacheDelete.js
var require_mapCacheDelete = __commonJS({
  "../../node_modules/lodash/_mapCacheDelete.js"(exports2, module2) {
    "use strict";
    var getMapData = require_getMapData();
    function mapCacheDelete(key2) {
      var result = getMapData(this, key2)["delete"](key2);
      this.size -= result ? 1 : 0;
      return result;
    }
    module2.exports = mapCacheDelete;
  }
});

// ../../node_modules/lodash/_mapCacheGet.js
var require_mapCacheGet = __commonJS({
  "../../node_modules/lodash/_mapCacheGet.js"(exports2, module2) {
    "use strict";
    var getMapData = require_getMapData();
    function mapCacheGet(key2) {
      return getMapData(this, key2).get(key2);
    }
    module2.exports = mapCacheGet;
  }
});

// ../../node_modules/lodash/_mapCacheHas.js
var require_mapCacheHas = __commonJS({
  "../../node_modules/lodash/_mapCacheHas.js"(exports2, module2) {
    "use strict";
    var getMapData = require_getMapData();
    function mapCacheHas(key2) {
      return getMapData(this, key2).has(key2);
    }
    module2.exports = mapCacheHas;
  }
});

// ../../node_modules/lodash/_mapCacheSet.js
var require_mapCacheSet = __commonJS({
  "../../node_modules/lodash/_mapCacheSet.js"(exports2, module2) {
    "use strict";
    var getMapData = require_getMapData();
    function mapCacheSet(key2, value) {
      var data = getMapData(this, key2), size = data.size;
      data.set(key2, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    module2.exports = mapCacheSet;
  }
});

// ../../node_modules/lodash/_MapCache.js
var require_MapCache = __commonJS({
  "../../node_modules/lodash/_MapCache.js"(exports2, module2) {
    "use strict";
    var mapCacheClear = require_mapCacheClear();
    var mapCacheDelete = require_mapCacheDelete();
    var mapCacheGet = require_mapCacheGet();
    var mapCacheHas = require_mapCacheHas();
    var mapCacheSet = require_mapCacheSet();
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    module2.exports = MapCache;
  }
});

// ../../node_modules/lodash/memoize.js
var require_memoize = __commonJS({
  "../../node_modules/lodash/memoize.js"(exports2, module2) {
    "use strict";
    var MapCache = require_MapCache();
    var FUNC_ERROR_TEXT = "Expected a function";
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver != null && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key2 = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key2)) {
          return cache.get(key2);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key2, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    module2.exports = memoize;
  }
});

// ../../node_modules/lodash/_memoizeCapped.js
var require_memoizeCapped = __commonJS({
  "../../node_modules/lodash/_memoizeCapped.js"(exports2, module2) {
    "use strict";
    var memoize = require_memoize();
    var MAX_MEMOIZE_SIZE = 500;
    function memoizeCapped(func) {
      var result = memoize(func, function(key2) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key2;
      });
      var cache = result.cache;
      return result;
    }
    module2.exports = memoizeCapped;
  }
});

// ../../node_modules/lodash/_stringToPath.js
var require_stringToPath = __commonJS({
  "../../node_modules/lodash/_stringToPath.js"(exports2, module2) {
    "use strict";
    var memoizeCapped = require_memoizeCapped();
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46) {
        result.push("");
      }
      string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    module2.exports = stringToPath;
  }
});

// ../../node_modules/lodash/_castPath.js
var require_castPath = __commonJS({
  "../../node_modules/lodash/_castPath.js"(exports2, module2) {
    "use strict";
    var isArray = require_isArray();
    var isKey = require_isKey();
    var stringToPath = require_stringToPath();
    var toString = require_toString();
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }
    module2.exports = castPath;
  }
});

// ../../node_modules/lodash/_toKey.js
var require_toKey = __commonJS({
  "../../node_modules/lodash/_toKey.js"(exports2, module2) {
    "use strict";
    var isSymbol = require_isSymbol();
    var INFINITY = 1 / 0;
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    module2.exports = toKey;
  }
});

// ../../node_modules/lodash/_baseGet.js
var require_baseGet = __commonJS({
  "../../node_modules/lodash/_baseGet.js"(exports2, module2) {
    "use strict";
    var castPath = require_castPath();
    var toKey = require_toKey();
    function baseGet(object, path) {
      path = castPath(path, object);
      var index = 0, length = path.length;
      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return index && index == length ? object : void 0;
    }
    module2.exports = baseGet;
  }
});

// ../../node_modules/lodash/_stackClear.js
var require_stackClear = __commonJS({
  "../../node_modules/lodash/_stackClear.js"(exports2, module2) {
    "use strict";
    var ListCache = require_ListCache();
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    module2.exports = stackClear;
  }
});

// ../../node_modules/lodash/_stackDelete.js
var require_stackDelete = __commonJS({
  "../../node_modules/lodash/_stackDelete.js"(exports2, module2) {
    "use strict";
    function stackDelete(key2) {
      var data = this.__data__, result = data["delete"](key2);
      this.size = data.size;
      return result;
    }
    module2.exports = stackDelete;
  }
});

// ../../node_modules/lodash/_stackGet.js
var require_stackGet = __commonJS({
  "../../node_modules/lodash/_stackGet.js"(exports2, module2) {
    "use strict";
    function stackGet(key2) {
      return this.__data__.get(key2);
    }
    module2.exports = stackGet;
  }
});

// ../../node_modules/lodash/_stackHas.js
var require_stackHas = __commonJS({
  "../../node_modules/lodash/_stackHas.js"(exports2, module2) {
    "use strict";
    function stackHas(key2) {
      return this.__data__.has(key2);
    }
    module2.exports = stackHas;
  }
});

// ../../node_modules/lodash/_stackSet.js
var require_stackSet = __commonJS({
  "../../node_modules/lodash/_stackSet.js"(exports2, module2) {
    "use strict";
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    var MapCache = require_MapCache();
    var LARGE_ARRAY_SIZE = 200;
    function stackSet(key2, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key2, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key2, value);
      this.size = data.size;
      return this;
    }
    module2.exports = stackSet;
  }
});

// ../../node_modules/lodash/_Stack.js
var require_Stack = __commonJS({
  "../../node_modules/lodash/_Stack.js"(exports2, module2) {
    "use strict";
    var ListCache = require_ListCache();
    var stackClear = require_stackClear();
    var stackDelete = require_stackDelete();
    var stackGet = require_stackGet();
    var stackHas = require_stackHas();
    var stackSet = require_stackSet();
    function Stack3(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    Stack3.prototype.clear = stackClear;
    Stack3.prototype["delete"] = stackDelete;
    Stack3.prototype.get = stackGet;
    Stack3.prototype.has = stackHas;
    Stack3.prototype.set = stackSet;
    module2.exports = Stack3;
  }
});

// ../../node_modules/lodash/_setCacheAdd.js
var require_setCacheAdd = __commonJS({
  "../../node_modules/lodash/_setCacheAdd.js"(exports2, module2) {
    "use strict";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    module2.exports = setCacheAdd;
  }
});

// ../../node_modules/lodash/_setCacheHas.js
var require_setCacheHas = __commonJS({
  "../../node_modules/lodash/_setCacheHas.js"(exports2, module2) {
    "use strict";
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    module2.exports = setCacheHas;
  }
});

// ../../node_modules/lodash/_SetCache.js
var require_SetCache = __commonJS({
  "../../node_modules/lodash/_SetCache.js"(exports2, module2) {
    "use strict";
    var MapCache = require_MapCache();
    var setCacheAdd = require_setCacheAdd();
    var setCacheHas = require_setCacheHas();
    function SetCache(values) {
      var index = -1, length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    module2.exports = SetCache;
  }
});

// ../../node_modules/lodash/_arraySome.js
var require_arraySome = __commonJS({
  "../../node_modules/lodash/_arraySome.js"(exports2, module2) {
    "use strict";
    function arraySome(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    module2.exports = arraySome;
  }
});

// ../../node_modules/lodash/_cacheHas.js
var require_cacheHas = __commonJS({
  "../../node_modules/lodash/_cacheHas.js"(exports2, module2) {
    "use strict";
    function cacheHas(cache, key2) {
      return cache.has(key2);
    }
    module2.exports = cacheHas;
  }
});

// ../../node_modules/lodash/_equalArrays.js
var require_equalArrays = __commonJS({
  "../../node_modules/lodash/_equalArrays.js"(exports2, module2) {
    "use strict";
    var SetCache = require_SetCache();
    var arraySome = require_arraySome();
    var cacheHas = require_cacheHas();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack2) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var arrStacked = stack2.get(array);
      var othStacked = stack2.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array;
      }
      var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
      stack2.set(array, other);
      stack2.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack2) : customizer(arrValue, othValue, index, array, other, stack2);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack2))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack2))) {
          result = false;
          break;
        }
      }
      stack2["delete"](array);
      stack2["delete"](other);
      return result;
    }
    module2.exports = equalArrays;
  }
});

// ../../node_modules/lodash/_Uint8Array.js
var require_Uint8Array = __commonJS({
  "../../node_modules/lodash/_Uint8Array.js"(exports2, module2) {
    "use strict";
    var root2 = require_root();
    var Uint8Array2 = root2.Uint8Array;
    module2.exports = Uint8Array2;
  }
});

// ../../node_modules/lodash/_mapToArray.js
var require_mapToArray = __commonJS({
  "../../node_modules/lodash/_mapToArray.js"(exports2, module2) {
    "use strict";
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key2) {
        result[++index] = [key2, value];
      });
      return result;
    }
    module2.exports = mapToArray;
  }
});

// ../../node_modules/lodash/_setToArray.js
var require_setToArray = __commonJS({
  "../../node_modules/lodash/_setToArray.js"(exports2, module2) {
    "use strict";
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    module2.exports = setToArray;
  }
});

// ../../node_modules/lodash/_equalByTag.js
var require_equalByTag = __commonJS({
  "../../node_modules/lodash/_equalByTag.js"(exports2, module2) {
    "use strict";
    var Symbol2 = require_Symbol();
    var Uint8Array2 = require_Uint8Array();
    var eq = require_eq();
    var equalArrays = require_equalArrays();
    var mapToArray = require_mapToArray();
    var setToArray = require_setToArray();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack2) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack2.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack2.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack2);
          stack2["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    module2.exports = equalByTag;
  }
});

// ../../node_modules/lodash/_baseGetAllKeys.js
var require_baseGetAllKeys = __commonJS({
  "../../node_modules/lodash/_baseGetAllKeys.js"(exports2, module2) {
    "use strict";
    var arrayPush = require_arrayPush();
    var isArray = require_isArray();
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    module2.exports = baseGetAllKeys;
  }
});

// ../../node_modules/lodash/_arrayFilter.js
var require_arrayFilter = __commonJS({
  "../../node_modules/lodash/_arrayFilter.js"(exports2, module2) {
    "use strict";
    function arrayFilter(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    module2.exports = arrayFilter;
  }
});

// ../../node_modules/lodash/stubArray.js
var require_stubArray = __commonJS({
  "../../node_modules/lodash/stubArray.js"(exports2, module2) {
    "use strict";
    function stubArray() {
      return [];
    }
    module2.exports = stubArray;
  }
});

// ../../node_modules/lodash/_getSymbols.js
var require_getSymbols = __commonJS({
  "../../node_modules/lodash/_getSymbols.js"(exports2, module2) {
    "use strict";
    var arrayFilter = require_arrayFilter();
    var stubArray = require_stubArray();
    var objectProto = Object.prototype;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };
    module2.exports = getSymbols;
  }
});

// ../../node_modules/lodash/_baseTimes.js
var require_baseTimes = __commonJS({
  "../../node_modules/lodash/_baseTimes.js"(exports2, module2) {
    "use strict";
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    module2.exports = baseTimes;
  }
});

// ../../node_modules/lodash/stubFalse.js
var require_stubFalse = __commonJS({
  "../../node_modules/lodash/stubFalse.js"(exports2, module2) {
    "use strict";
    function stubFalse() {
      return false;
    }
    module2.exports = stubFalse;
  }
});

// ../../node_modules/lodash/isBuffer.js
var require_isBuffer = __commonJS({
  "../../node_modules/lodash/isBuffer.js"(exports2, module2) {
    "use strict";
    var root2 = require_root();
    var stubFalse = require_stubFalse();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root2.Buffer : void 0;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var isBuffer = nativeIsBuffer || stubFalse;
    module2.exports = isBuffer;
  }
});

// ../../node_modules/lodash/_isIndex.js
var require_isIndex = __commonJS({
  "../../node_modules/lodash/_isIndex.js"(exports2, module2) {
    "use strict";
    var MAX_SAFE_INTEGER = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    module2.exports = isIndex;
  }
});

// ../../node_modules/lodash/isLength.js
var require_isLength = __commonJS({
  "../../node_modules/lodash/isLength.js"(exports2, module2) {
    "use strict";
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    module2.exports = isLength;
  }
});

// ../../node_modules/lodash/_baseIsTypedArray.js
var require_baseIsTypedArray = __commonJS({
  "../../node_modules/lodash/_baseIsTypedArray.js"(exports2, module2) {
    "use strict";
    var baseGetTag = require_baseGetTag();
    var isLength = require_isLength();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    module2.exports = baseIsTypedArray;
  }
});

// ../../node_modules/lodash/_baseUnary.js
var require_baseUnary = __commonJS({
  "../../node_modules/lodash/_baseUnary.js"(exports2, module2) {
    "use strict";
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    module2.exports = baseUnary;
  }
});

// ../../node_modules/lodash/_nodeUtil.js
var require_nodeUtil = __commonJS({
  "../../node_modules/lodash/_nodeUtil.js"(exports2, module2) {
    "use strict";
    var freeGlobal = require_freeGlobal();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    module2.exports = nodeUtil;
  }
});

// ../../node_modules/lodash/isTypedArray.js
var require_isTypedArray = __commonJS({
  "../../node_modules/lodash/isTypedArray.js"(exports2, module2) {
    "use strict";
    var baseIsTypedArray = require_baseIsTypedArray();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    module2.exports = isTypedArray;
  }
});

// ../../node_modules/lodash/_arrayLikeKeys.js
var require_arrayLikeKeys = __commonJS({
  "../../node_modules/lodash/_arrayLikeKeys.js"(exports2, module2) {
    "use strict";
    var baseTimes = require_baseTimes();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isIndex = require_isIndex();
    var isTypedArray = require_isTypedArray();
    var objectProto = Object.prototype;
    var hasOwnProperty3 = objectProto.hasOwnProperty;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key2 in value) {
        if ((inherited || hasOwnProperty3.call(value, key2)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key2 == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key2 == "offset" || key2 == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key2 == "buffer" || key2 == "byteLength" || key2 == "byteOffset") || // Skip index properties.
        isIndex(key2, length)))) {
          result.push(key2);
        }
      }
      return result;
    }
    module2.exports = arrayLikeKeys;
  }
});

// ../../node_modules/lodash/_isPrototype.js
var require_isPrototype = __commonJS({
  "../../node_modules/lodash/_isPrototype.js"(exports2, module2) {
    "use strict";
    var objectProto = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    module2.exports = isPrototype;
  }
});

// ../../node_modules/lodash/_overArg.js
var require_overArg = __commonJS({
  "../../node_modules/lodash/_overArg.js"(exports2, module2) {
    "use strict";
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    module2.exports = overArg;
  }
});

// ../../node_modules/lodash/_nativeKeys.js
var require_nativeKeys = __commonJS({
  "../../node_modules/lodash/_nativeKeys.js"(exports2, module2) {
    "use strict";
    var overArg = require_overArg();
    var nativeKeys = overArg(Object.keys, Object);
    module2.exports = nativeKeys;
  }
});

// ../../node_modules/lodash/_baseKeys.js
var require_baseKeys = __commonJS({
  "../../node_modules/lodash/_baseKeys.js"(exports2, module2) {
    "use strict";
    var isPrototype = require_isPrototype();
    var nativeKeys = require_nativeKeys();
    var objectProto = Object.prototype;
    var hasOwnProperty3 = objectProto.hasOwnProperty;
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key2 in Object(object)) {
        if (hasOwnProperty3.call(object, key2) && key2 != "constructor") {
          result.push(key2);
        }
      }
      return result;
    }
    module2.exports = baseKeys;
  }
});

// ../../node_modules/lodash/isArrayLike.js
var require_isArrayLike = __commonJS({
  "../../node_modules/lodash/isArrayLike.js"(exports2, module2) {
    "use strict";
    var isFunction = require_isFunction();
    var isLength = require_isLength();
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    module2.exports = isArrayLike;
  }
});

// ../../node_modules/lodash/keys.js
var require_keys = __commonJS({
  "../../node_modules/lodash/keys.js"(exports2, module2) {
    "use strict";
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeys = require_baseKeys();
    var isArrayLike = require_isArrayLike();
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    module2.exports = keys;
  }
});

// ../../node_modules/lodash/_getAllKeys.js
var require_getAllKeys = __commonJS({
  "../../node_modules/lodash/_getAllKeys.js"(exports2, module2) {
    "use strict";
    var baseGetAllKeys = require_baseGetAllKeys();
    var getSymbols = require_getSymbols();
    var keys = require_keys();
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    module2.exports = getAllKeys;
  }
});

// ../../node_modules/lodash/_equalObjects.js
var require_equalObjects = __commonJS({
  "../../node_modules/lodash/_equalObjects.js"(exports2, module2) {
    "use strict";
    var getAllKeys = require_getAllKeys();
    var COMPARE_PARTIAL_FLAG = 1;
    var objectProto = Object.prototype;
    var hasOwnProperty3 = objectProto.hasOwnProperty;
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack2) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key2 = objProps[index];
        if (!(isPartial ? key2 in other : hasOwnProperty3.call(other, key2))) {
          return false;
        }
      }
      var objStacked = stack2.get(object);
      var othStacked = stack2.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object;
      }
      var result = true;
      stack2.set(object, other);
      stack2.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key2 = objProps[index];
        var objValue = object[key2], othValue = other[key2];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key2, other, object, stack2) : customizer(objValue, othValue, key2, object, other, stack2);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack2) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key2 == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack2["delete"](object);
      stack2["delete"](other);
      return result;
    }
    module2.exports = equalObjects;
  }
});

// ../../node_modules/lodash/_DataView.js
var require_DataView = __commonJS({
  "../../node_modules/lodash/_DataView.js"(exports2, module2) {
    "use strict";
    var getNative = require_getNative();
    var root2 = require_root();
    var DataView = getNative(root2, "DataView");
    module2.exports = DataView;
  }
});

// ../../node_modules/lodash/_Promise.js
var require_Promise = __commonJS({
  "../../node_modules/lodash/_Promise.js"(exports2, module2) {
    "use strict";
    var getNative = require_getNative();
    var root2 = require_root();
    var Promise2 = getNative(root2, "Promise");
    module2.exports = Promise2;
  }
});

// ../../node_modules/lodash/_Set.js
var require_Set = __commonJS({
  "../../node_modules/lodash/_Set.js"(exports2, module2) {
    "use strict";
    var getNative = require_getNative();
    var root2 = require_root();
    var Set2 = getNative(root2, "Set");
    module2.exports = Set2;
  }
});

// ../../node_modules/lodash/_WeakMap.js
var require_WeakMap = __commonJS({
  "../../node_modules/lodash/_WeakMap.js"(exports2, module2) {
    "use strict";
    var getNative = require_getNative();
    var root2 = require_root();
    var WeakMap2 = getNative(root2, "WeakMap");
    module2.exports = WeakMap2;
  }
});

// ../../node_modules/lodash/_getTag.js
var require_getTag = __commonJS({
  "../../node_modules/lodash/_getTag.js"(exports2, module2) {
    "use strict";
    var DataView = require_DataView();
    var Map2 = require_Map();
    var Promise2 = require_Promise();
    var Set2 = require_Set();
    var WeakMap2 = require_WeakMap();
    var baseGetTag = require_baseGetTag();
    var toSource = require_toSource();
    var mapTag = "[object Map]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var setTag = "[object Set]";
    var weakMapTag = "[object WeakMap]";
    var dataViewTag = "[object DataView]";
    var dataViewCtorString = toSource(DataView);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap2);
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    module2.exports = getTag;
  }
});

// ../../node_modules/lodash/_baseIsEqualDeep.js
var require_baseIsEqualDeep = __commonJS({
  "../../node_modules/lodash/_baseIsEqualDeep.js"(exports2, module2) {
    "use strict";
    var Stack3 = require_Stack();
    var equalArrays = require_equalArrays();
    var equalByTag = require_equalByTag();
    var equalObjects = require_equalObjects();
    var getTag = require_getTag();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isTypedArray = require_isTypedArray();
    var COMPARE_PARTIAL_FLAG = 1;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var objectTag = "[object Object]";
    var objectProto = Object.prototype;
    var hasOwnProperty3 = objectProto.hasOwnProperty;
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack2) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack2 || (stack2 = new Stack3());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack2) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack2);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty3.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty3.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack2 || (stack2 = new Stack3());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack2);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack2 || (stack2 = new Stack3());
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack2);
    }
    module2.exports = baseIsEqualDeep;
  }
});

// ../../node_modules/lodash/_baseIsEqual.js
var require_baseIsEqual = __commonJS({
  "../../node_modules/lodash/_baseIsEqual.js"(exports2, module2) {
    "use strict";
    var baseIsEqualDeep = require_baseIsEqualDeep();
    var isObjectLike = require_isObjectLike();
    function baseIsEqual(value, other, bitmask, customizer, stack2) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack2);
    }
    module2.exports = baseIsEqual;
  }
});

// ../../node_modules/lodash/_baseIsMatch.js
var require_baseIsMatch = __commonJS({
  "../../node_modules/lodash/_baseIsMatch.js"(exports2, module2) {
    "use strict";
    var Stack3 = require_Stack();
    var baseIsEqual = require_baseIsEqual();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function baseIsMatch(object, source2, matchData, customizer) {
      var index = matchData.length, length = index, noCustomizer = !customizer;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key2 = data[0], objValue = object[key2], srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === void 0 && !(key2 in object)) {
            return false;
          }
        } else {
          var stack2 = new Stack3();
          if (customizer) {
            var result = customizer(objValue, srcValue, key2, object, source2, stack2);
          }
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack2) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    module2.exports = baseIsMatch;
  }
});

// ../../node_modules/lodash/_isStrictComparable.js
var require_isStrictComparable = __commonJS({
  "../../node_modules/lodash/_isStrictComparable.js"(exports2, module2) {
    "use strict";
    var isObject = require_isObject();
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }
    module2.exports = isStrictComparable;
  }
});

// ../../node_modules/lodash/_getMatchData.js
var require_getMatchData = __commonJS({
  "../../node_modules/lodash/_getMatchData.js"(exports2, module2) {
    "use strict";
    var isStrictComparable = require_isStrictComparable();
    var keys = require_keys();
    function getMatchData(object) {
      var result = keys(object), length = result.length;
      while (length--) {
        var key2 = result[length], value = object[key2];
        result[length] = [key2, value, isStrictComparable(value)];
      }
      return result;
    }
    module2.exports = getMatchData;
  }
});

// ../../node_modules/lodash/_matchesStrictComparable.js
var require_matchesStrictComparable = __commonJS({
  "../../node_modules/lodash/_matchesStrictComparable.js"(exports2, module2) {
    "use strict";
    function matchesStrictComparable(key2, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key2] === srcValue && (srcValue !== void 0 || key2 in Object(object));
      };
    }
    module2.exports = matchesStrictComparable;
  }
});

// ../../node_modules/lodash/_baseMatches.js
var require_baseMatches = __commonJS({
  "../../node_modules/lodash/_baseMatches.js"(exports2, module2) {
    "use strict";
    var baseIsMatch = require_baseIsMatch();
    var getMatchData = require_getMatchData();
    var matchesStrictComparable = require_matchesStrictComparable();
    function baseMatches(source2) {
      var matchData = getMatchData(source2);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source2 || baseIsMatch(object, source2, matchData);
      };
    }
    module2.exports = baseMatches;
  }
});

// ../../node_modules/lodash/get.js
var require_get = __commonJS({
  "../../node_modules/lodash/get.js"(exports2, module2) {
    "use strict";
    var baseGet = require_baseGet();
    function get(object, path, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path);
      return result === void 0 ? defaultValue : result;
    }
    module2.exports = get;
  }
});

// ../../node_modules/lodash/_baseHasIn.js
var require_baseHasIn = __commonJS({
  "../../node_modules/lodash/_baseHasIn.js"(exports2, module2) {
    "use strict";
    function baseHasIn(object, key2) {
      return object != null && key2 in Object(object);
    }
    module2.exports = baseHasIn;
  }
});

// ../../node_modules/lodash/_hasPath.js
var require_hasPath = __commonJS({
  "../../node_modules/lodash/_hasPath.js"(exports2, module2) {
    "use strict";
    var castPath = require_castPath();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isIndex = require_isIndex();
    var isLength = require_isLength();
    var toKey = require_toKey();
    function hasPath(object, path, hasFunc) {
      path = castPath(path, object);
      var index = -1, length = path.length, result = false;
      while (++index < length) {
        var key2 = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key2))) {
          break;
        }
        object = object[key2];
      }
      if (result || ++index != length) {
        return result;
      }
      length = object == null ? 0 : object.length;
      return !!length && isLength(length) && isIndex(key2, length) && (isArray(object) || isArguments(object));
    }
    module2.exports = hasPath;
  }
});

// ../../node_modules/lodash/hasIn.js
var require_hasIn = __commonJS({
  "../../node_modules/lodash/hasIn.js"(exports2, module2) {
    "use strict";
    var baseHasIn = require_baseHasIn();
    var hasPath = require_hasPath();
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }
    module2.exports = hasIn;
  }
});

// ../../node_modules/lodash/_baseMatchesProperty.js
var require_baseMatchesProperty = __commonJS({
  "../../node_modules/lodash/_baseMatchesProperty.js"(exports2, module2) {
    "use strict";
    var baseIsEqual = require_baseIsEqual();
    var get = require_get();
    var hasIn = require_hasIn();
    var isKey = require_isKey();
    var isStrictComparable = require_isStrictComparable();
    var matchesStrictComparable = require_matchesStrictComparable();
    var toKey = require_toKey();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }
    module2.exports = baseMatchesProperty;
  }
});

// ../../node_modules/lodash/identity.js
var require_identity = __commonJS({
  "../../node_modules/lodash/identity.js"(exports2, module2) {
    "use strict";
    function identity(value) {
      return value;
    }
    module2.exports = identity;
  }
});

// ../../node_modules/lodash/_baseProperty.js
var require_baseProperty = __commonJS({
  "../../node_modules/lodash/_baseProperty.js"(exports2, module2) {
    "use strict";
    function baseProperty(key2) {
      return function(object) {
        return object == null ? void 0 : object[key2];
      };
    }
    module2.exports = baseProperty;
  }
});

// ../../node_modules/lodash/_basePropertyDeep.js
var require_basePropertyDeep = __commonJS({
  "../../node_modules/lodash/_basePropertyDeep.js"(exports2, module2) {
    "use strict";
    var baseGet = require_baseGet();
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }
    module2.exports = basePropertyDeep;
  }
});

// ../../node_modules/lodash/property.js
var require_property = __commonJS({
  "../../node_modules/lodash/property.js"(exports2, module2) {
    "use strict";
    var baseProperty = require_baseProperty();
    var basePropertyDeep = require_basePropertyDeep();
    var isKey = require_isKey();
    var toKey = require_toKey();
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }
    module2.exports = property;
  }
});

// ../../node_modules/lodash/_baseIteratee.js
var require_baseIteratee = __commonJS({
  "../../node_modules/lodash/_baseIteratee.js"(exports2, module2) {
    "use strict";
    var baseMatches = require_baseMatches();
    var baseMatchesProperty = require_baseMatchesProperty();
    var identity = require_identity();
    var isArray = require_isArray();
    var property = require_property();
    function baseIteratee(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == "object") {
        return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    module2.exports = baseIteratee;
  }
});

// ../../node_modules/lodash/_createBaseFor.js
var require_createBaseFor = __commonJS({
  "../../node_modules/lodash/_createBaseFor.js"(exports2, module2) {
    "use strict";
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key2 = props[fromRight ? length : ++index];
          if (iteratee(iterable[key2], key2, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    module2.exports = createBaseFor;
  }
});

// ../../node_modules/lodash/_baseFor.js
var require_baseFor = __commonJS({
  "../../node_modules/lodash/_baseFor.js"(exports2, module2) {
    "use strict";
    var createBaseFor = require_createBaseFor();
    var baseFor = createBaseFor();
    module2.exports = baseFor;
  }
});

// ../../node_modules/lodash/_baseForOwn.js
var require_baseForOwn = __commonJS({
  "../../node_modules/lodash/_baseForOwn.js"(exports2, module2) {
    "use strict";
    var baseFor = require_baseFor();
    var keys = require_keys();
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }
    module2.exports = baseForOwn;
  }
});

// ../../node_modules/lodash/_createBaseEach.js
var require_createBaseEach = __commonJS({
  "../../node_modules/lodash/_createBaseEach.js"(exports2, module2) {
    "use strict";
    var isArrayLike = require_isArrayLike();
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
        while (fromRight ? index-- : ++index < length) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }
    module2.exports = createBaseEach;
  }
});

// ../../node_modules/lodash/_baseEach.js
var require_baseEach = __commonJS({
  "../../node_modules/lodash/_baseEach.js"(exports2, module2) {
    "use strict";
    var baseForOwn = require_baseForOwn();
    var createBaseEach = require_createBaseEach();
    var baseEach = createBaseEach(baseForOwn);
    module2.exports = baseEach;
  }
});

// ../../node_modules/lodash/_baseMap.js
var require_baseMap = __commonJS({
  "../../node_modules/lodash/_baseMap.js"(exports2, module2) {
    "use strict";
    var baseEach = require_baseEach();
    var isArrayLike = require_isArrayLike();
    function baseMap(collection, iteratee) {
      var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
      baseEach(collection, function(value, key2, collection2) {
        result[++index] = iteratee(value, key2, collection2);
      });
      return result;
    }
    module2.exports = baseMap;
  }
});

// ../../node_modules/lodash/_baseSortBy.js
var require_baseSortBy = __commonJS({
  "../../node_modules/lodash/_baseSortBy.js"(exports2, module2) {
    "use strict";
    function baseSortBy(array, comparer) {
      var length = array.length;
      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }
    module2.exports = baseSortBy;
  }
});

// ../../node_modules/lodash/_compareAscending.js
var require_compareAscending = __commonJS({
  "../../node_modules/lodash/_compareAscending.js"(exports2, module2) {
    "use strict";
    var isSymbol = require_isSymbol();
    function compareAscending(value, other) {
      if (value !== other) {
        var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
        var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
        if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
          return 1;
        }
        if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
          return -1;
        }
      }
      return 0;
    }
    module2.exports = compareAscending;
  }
});

// ../../node_modules/lodash/_compareMultiple.js
var require_compareMultiple = __commonJS({
  "../../node_modules/lodash/_compareMultiple.js"(exports2, module2) {
    "use strict";
    var compareAscending = require_compareAscending();
    function compareMultiple(object, other, orders) {
      var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
      while (++index < length) {
        var result = compareAscending(objCriteria[index], othCriteria[index]);
        if (result) {
          if (index >= ordersLength) {
            return result;
          }
          var order = orders[index];
          return result * (order == "desc" ? -1 : 1);
        }
      }
      return object.index - other.index;
    }
    module2.exports = compareMultiple;
  }
});

// ../../node_modules/lodash/_baseOrderBy.js
var require_baseOrderBy = __commonJS({
  "../../node_modules/lodash/_baseOrderBy.js"(exports2, module2) {
    "use strict";
    var arrayMap = require_arrayMap();
    var baseGet = require_baseGet();
    var baseIteratee = require_baseIteratee();
    var baseMap = require_baseMap();
    var baseSortBy = require_baseSortBy();
    var baseUnary = require_baseUnary();
    var compareMultiple = require_compareMultiple();
    var identity = require_identity();
    var isArray = require_isArray();
    function baseOrderBy(collection, iteratees, orders) {
      if (iteratees.length) {
        iteratees = arrayMap(iteratees, function(iteratee) {
          if (isArray(iteratee)) {
            return function(value) {
              return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
            };
          }
          return iteratee;
        });
      } else {
        iteratees = [identity];
      }
      var index = -1;
      iteratees = arrayMap(iteratees, baseUnary(baseIteratee));
      var result = baseMap(collection, function(value, key2, collection2) {
        var criteria = arrayMap(iteratees, function(iteratee) {
          return iteratee(value);
        });
        return { "criteria": criteria, "index": ++index, "value": value };
      });
      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }
    module2.exports = baseOrderBy;
  }
});

// ../../node_modules/lodash/_apply.js
var require_apply = __commonJS({
  "../../node_modules/lodash/_apply.js"(exports2, module2) {
    "use strict";
    function apply2(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    module2.exports = apply2;
  }
});

// ../../node_modules/lodash/_overRest.js
var require_overRest = __commonJS({
  "../../node_modules/lodash/_overRest.js"(exports2, module2) {
    "use strict";
    var apply2 = require_apply();
    var nativeMax = Math.max;
    function overRest(func, start, transform) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply2(func, this, otherArgs);
      };
    }
    module2.exports = overRest;
  }
});

// ../../node_modules/lodash/constant.js
var require_constant = __commonJS({
  "../../node_modules/lodash/constant.js"(exports2, module2) {
    "use strict";
    function constant(value) {
      return function() {
        return value;
      };
    }
    module2.exports = constant;
  }
});

// ../../node_modules/lodash/_defineProperty.js
var require_defineProperty = __commonJS({
  "../../node_modules/lodash/_defineProperty.js"(exports2, module2) {
    "use strict";
    var getNative = require_getNative();
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e) {
      }
    }();
    module2.exports = defineProperty;
  }
});

// ../../node_modules/lodash/_baseSetToString.js
var require_baseSetToString = __commonJS({
  "../../node_modules/lodash/_baseSetToString.js"(exports2, module2) {
    "use strict";
    var constant = require_constant();
    var defineProperty = require_defineProperty();
    var identity = require_identity();
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(string),
        "writable": true
      });
    };
    module2.exports = baseSetToString;
  }
});

// ../../node_modules/lodash/_shortOut.js
var require_shortOut = __commonJS({
  "../../node_modules/lodash/_shortOut.js"(exports2, module2) {
    "use strict";
    var HOT_COUNT = 800;
    var HOT_SPAN = 16;
    var nativeNow = Date.now;
    function shortOut(func) {
      var count = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    module2.exports = shortOut;
  }
});

// ../../node_modules/lodash/_setToString.js
var require_setToString = __commonJS({
  "../../node_modules/lodash/_setToString.js"(exports2, module2) {
    "use strict";
    var baseSetToString = require_baseSetToString();
    var shortOut = require_shortOut();
    var setToString = shortOut(baseSetToString);
    module2.exports = setToString;
  }
});

// ../../node_modules/lodash/_baseRest.js
var require_baseRest = __commonJS({
  "../../node_modules/lodash/_baseRest.js"(exports2, module2) {
    "use strict";
    var identity = require_identity();
    var overRest = require_overRest();
    var setToString = require_setToString();
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + "");
    }
    module2.exports = baseRest;
  }
});

// ../../node_modules/lodash/_isIterateeCall.js
var require_isIterateeCall = __commonJS({
  "../../node_modules/lodash/_isIterateeCall.js"(exports2, module2) {
    "use strict";
    var eq = require_eq();
    var isArrayLike = require_isArrayLike();
    var isIndex = require_isIndex();
    var isObject = require_isObject();
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    module2.exports = isIterateeCall;
  }
});

// ../../node_modules/lodash/sortBy.js
var require_sortBy = __commonJS({
  "../../node_modules/lodash/sortBy.js"(exports2, module2) {
    "use strict";
    var baseFlatten = require_baseFlatten();
    var baseOrderBy = require_baseOrderBy();
    var baseRest = require_baseRest();
    var isIterateeCall = require_isIterateeCall();
    var sortBy = baseRest(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var length = iteratees.length;
      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
        iteratees = [];
      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
        iteratees = [iteratees[0]];
      }
      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
    });
    module2.exports = sortBy;
  }
});

// node_modules/@babel/core/lib/transformation/block-hoist-plugin.js
var require_block_hoist_plugin = __commonJS({
  "node_modules/@babel/core/lib/transformation/block-hoist-plugin.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = loadBlockHoistPlugin;
    function _sortBy() {
      const data = _interopRequireDefault(require_sortBy());
      _sortBy = function() {
        return data;
      };
      return data;
    }
    var _config = _interopRequireDefault(require_config());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var LOADED_PLUGIN;
    function loadBlockHoistPlugin() {
      if (!LOADED_PLUGIN) {
        const config = (0, _config.default)({
          babelrc: false,
          configFile: false,
          plugins: [blockHoistPlugin]
        });
        LOADED_PLUGIN = config ? config.passes[0][0] : void 0;
        if (!LOADED_PLUGIN) throw new Error("Assertion failure");
      }
      return LOADED_PLUGIN;
    }
    var blockHoistPlugin = {
      name: "internal.blockHoist",
      visitor: {
        Block: {
          exit({
            node
          }) {
            let hasChange = false;
            for (let i = 0; i < node.body.length; i++) {
              const bodyNode = node.body[i];
              if (bodyNode && bodyNode._blockHoist != null) {
                hasChange = true;
                break;
              }
            }
            if (!hasChange) return;
            node.body = (0, _sortBy().default)(node.body, function(bodyNode) {
              let priority = bodyNode && bodyNode._blockHoist;
              if (priority == null) priority = 1;
              if (priority === true) priority = 2;
              return -1 * priority;
            });
          }
        }
      }
    };
  }
});

// node_modules/@babel/core/lib/transformation/normalize-opts.js
var require_normalize_opts = __commonJS({
  "node_modules/@babel/core/lib/transformation/normalize-opts.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = normalizeOptions;
    function _path() {
      const data = _interopRequireDefault(require("path"));
      _path = function() {
        return data;
      };
      return data;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function normalizeOptions(config) {
      const {
        filename,
        cwd,
        filenameRelative = typeof filename === "string" ? _path().default.relative(cwd, filename) : "unknown",
        sourceType = "module",
        inputSourceMap,
        sourceMaps = !!inputSourceMap,
        moduleRoot,
        sourceRoot = moduleRoot,
        sourceFileName = _path().default.basename(filenameRelative),
        comments = true,
        compact = "auto"
      } = config.options;
      const opts = config.options;
      const options = Object.assign({}, opts, {
        parserOpts: Object.assign({
          sourceType: _path().default.extname(filenameRelative) === ".mjs" ? "module" : sourceType,
          sourceFileName: filename,
          plugins: []
        }, opts.parserOpts),
        generatorOpts: Object.assign({
          filename,
          auxiliaryCommentBefore: opts.auxiliaryCommentBefore,
          auxiliaryCommentAfter: opts.auxiliaryCommentAfter,
          retainLines: opts.retainLines,
          comments,
          shouldPrintComment: opts.shouldPrintComment,
          compact,
          minified: opts.minified,
          sourceMaps,
          sourceRoot,
          sourceFileName
        }, opts.generatorOpts)
      });
      for (const plugins of config.passes) {
        for (const plugin of plugins) {
          if (plugin.manipulateOptions) {
            plugin.manipulateOptions(options, options.parserOpts);
          }
        }
      }
      return options;
    }
  }
});

// ../../node_modules/lodash/_arrayEach.js
var require_arrayEach = __commonJS({
  "../../node_modules/lodash/_arrayEach.js"(exports2, module2) {
    "use strict";
    function arrayEach(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    module2.exports = arrayEach;
  }
});

// ../../node_modules/lodash/_baseAssignValue.js
var require_baseAssignValue = __commonJS({
  "../../node_modules/lodash/_baseAssignValue.js"(exports2, module2) {
    "use strict";
    var defineProperty = require_defineProperty();
    function baseAssignValue(object, key2, value) {
      if (key2 == "__proto__" && defineProperty) {
        defineProperty(object, key2, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object[key2] = value;
      }
    }
    module2.exports = baseAssignValue;
  }
});

// ../../node_modules/lodash/_assignValue.js
var require_assignValue = __commonJS({
  "../../node_modules/lodash/_assignValue.js"(exports2, module2) {
    "use strict";
    var baseAssignValue = require_baseAssignValue();
    var eq = require_eq();
    var objectProto = Object.prototype;
    var hasOwnProperty3 = objectProto.hasOwnProperty;
    function assignValue(object, key2, value) {
      var objValue = object[key2];
      if (!(hasOwnProperty3.call(object, key2) && eq(objValue, value)) || value === void 0 && !(key2 in object)) {
        baseAssignValue(object, key2, value);
      }
    }
    module2.exports = assignValue;
  }
});

// ../../node_modules/lodash/_copyObject.js
var require_copyObject = __commonJS({
  "../../node_modules/lodash/_copyObject.js"(exports2, module2) {
    "use strict";
    var assignValue = require_assignValue();
    var baseAssignValue = require_baseAssignValue();
    function copyObject(source2, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key2 = props[index];
        var newValue = customizer ? customizer(object[key2], source2[key2], key2, object, source2) : void 0;
        if (newValue === void 0) {
          newValue = source2[key2];
        }
        if (isNew) {
          baseAssignValue(object, key2, newValue);
        } else {
          assignValue(object, key2, newValue);
        }
      }
      return object;
    }
    module2.exports = copyObject;
  }
});

// ../../node_modules/lodash/_baseAssign.js
var require_baseAssign = __commonJS({
  "../../node_modules/lodash/_baseAssign.js"(exports2, module2) {
    "use strict";
    var copyObject = require_copyObject();
    var keys = require_keys();
    function baseAssign(object, source2) {
      return object && copyObject(source2, keys(source2), object);
    }
    module2.exports = baseAssign;
  }
});

// ../../node_modules/lodash/_nativeKeysIn.js
var require_nativeKeysIn = __commonJS({
  "../../node_modules/lodash/_nativeKeysIn.js"(exports2, module2) {
    "use strict";
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key2 in Object(object)) {
          result.push(key2);
        }
      }
      return result;
    }
    module2.exports = nativeKeysIn;
  }
});

// ../../node_modules/lodash/_baseKeysIn.js
var require_baseKeysIn = __commonJS({
  "../../node_modules/lodash/_baseKeysIn.js"(exports2, module2) {
    "use strict";
    var isObject = require_isObject();
    var isPrototype = require_isPrototype();
    var nativeKeysIn = require_nativeKeysIn();
    var objectProto = Object.prototype;
    var hasOwnProperty3 = objectProto.hasOwnProperty;
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key2 in object) {
        if (!(key2 == "constructor" && (isProto || !hasOwnProperty3.call(object, key2)))) {
          result.push(key2);
        }
      }
      return result;
    }
    module2.exports = baseKeysIn;
  }
});

// ../../node_modules/lodash/keysIn.js
var require_keysIn = __commonJS({
  "../../node_modules/lodash/keysIn.js"(exports2, module2) {
    "use strict";
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeysIn = require_baseKeysIn();
    var isArrayLike = require_isArrayLike();
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    module2.exports = keysIn;
  }
});

// ../../node_modules/lodash/_baseAssignIn.js
var require_baseAssignIn = __commonJS({
  "../../node_modules/lodash/_baseAssignIn.js"(exports2, module2) {
    "use strict";
    var copyObject = require_copyObject();
    var keysIn = require_keysIn();
    function baseAssignIn(object, source2) {
      return object && copyObject(source2, keysIn(source2), object);
    }
    module2.exports = baseAssignIn;
  }
});

// ../../node_modules/lodash/_cloneBuffer.js
var require_cloneBuffer = __commonJS({
  "../../node_modules/lodash/_cloneBuffer.js"(exports2, module2) {
    "use strict";
    var root2 = require_root();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root2.Buffer : void 0;
    var allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
    function cloneBuffer(buffer2, isDeep) {
      if (isDeep) {
        return buffer2.slice();
      }
      var length = buffer2.length, result = allocUnsafe ? allocUnsafe(length) : new buffer2.constructor(length);
      buffer2.copy(result);
      return result;
    }
    module2.exports = cloneBuffer;
  }
});

// ../../node_modules/lodash/_copyArray.js
var require_copyArray = __commonJS({
  "../../node_modules/lodash/_copyArray.js"(exports2, module2) {
    "use strict";
    function copyArray(source2, array) {
      var index = -1, length = source2.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source2[index];
      }
      return array;
    }
    module2.exports = copyArray;
  }
});

// ../../node_modules/lodash/_copySymbols.js
var require_copySymbols = __commonJS({
  "../../node_modules/lodash/_copySymbols.js"(exports2, module2) {
    "use strict";
    var copyObject = require_copyObject();
    var getSymbols = require_getSymbols();
    function copySymbols(source2, object) {
      return copyObject(source2, getSymbols(source2), object);
    }
    module2.exports = copySymbols;
  }
});

// ../../node_modules/lodash/_getPrototype.js
var require_getPrototype = __commonJS({
  "../../node_modules/lodash/_getPrototype.js"(exports2, module2) {
    "use strict";
    var overArg = require_overArg();
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    module2.exports = getPrototype;
  }
});

// ../../node_modules/lodash/_getSymbolsIn.js
var require_getSymbolsIn = __commonJS({
  "../../node_modules/lodash/_getSymbolsIn.js"(exports2, module2) {
    "use strict";
    var arrayPush = require_arrayPush();
    var getPrototype = require_getPrototype();
    var getSymbols = require_getSymbols();
    var stubArray = require_stubArray();
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
      }
      return result;
    };
    module2.exports = getSymbolsIn;
  }
});

// ../../node_modules/lodash/_copySymbolsIn.js
var require_copySymbolsIn = __commonJS({
  "../../node_modules/lodash/_copySymbolsIn.js"(exports2, module2) {
    "use strict";
    var copyObject = require_copyObject();
    var getSymbolsIn = require_getSymbolsIn();
    function copySymbolsIn(source2, object) {
      return copyObject(source2, getSymbolsIn(source2), object);
    }
    module2.exports = copySymbolsIn;
  }
});

// ../../node_modules/lodash/_getAllKeysIn.js
var require_getAllKeysIn = __commonJS({
  "../../node_modules/lodash/_getAllKeysIn.js"(exports2, module2) {
    "use strict";
    var baseGetAllKeys = require_baseGetAllKeys();
    var getSymbolsIn = require_getSymbolsIn();
    var keysIn = require_keysIn();
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn);
    }
    module2.exports = getAllKeysIn;
  }
});

// ../../node_modules/lodash/_initCloneArray.js
var require_initCloneArray = __commonJS({
  "../../node_modules/lodash/_initCloneArray.js"(exports2, module2) {
    "use strict";
    var objectProto = Object.prototype;
    var hasOwnProperty3 = objectProto.hasOwnProperty;
    function initCloneArray(array) {
      var length = array.length, result = new array.constructor(length);
      if (length && typeof array[0] == "string" && hasOwnProperty3.call(array, "index")) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }
    module2.exports = initCloneArray;
  }
});

// ../../node_modules/lodash/_cloneArrayBuffer.js
var require_cloneArrayBuffer = __commonJS({
  "../../node_modules/lodash/_cloneArrayBuffer.js"(exports2, module2) {
    "use strict";
    var Uint8Array2 = require_Uint8Array();
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    module2.exports = cloneArrayBuffer;
  }
});

// ../../node_modules/lodash/_cloneDataView.js
var require_cloneDataView = __commonJS({
  "../../node_modules/lodash/_cloneDataView.js"(exports2, module2) {
    "use strict";
    var cloneArrayBuffer = require_cloneArrayBuffer();
    function cloneDataView(dataView, isDeep) {
      var buffer2 = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer2, dataView.byteOffset, dataView.byteLength);
    }
    module2.exports = cloneDataView;
  }
});

// ../../node_modules/lodash/_cloneRegExp.js
var require_cloneRegExp = __commonJS({
  "../../node_modules/lodash/_cloneRegExp.js"(exports2, module2) {
    "use strict";
    var reFlags = /\w*$/;
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    module2.exports = cloneRegExp;
  }
});

// ../../node_modules/lodash/_cloneSymbol.js
var require_cloneSymbol = __commonJS({
  "../../node_modules/lodash/_cloneSymbol.js"(exports2, module2) {
    "use strict";
    var Symbol2 = require_Symbol();
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    module2.exports = cloneSymbol;
  }
});

// ../../node_modules/lodash/_cloneTypedArray.js
var require_cloneTypedArray = __commonJS({
  "../../node_modules/lodash/_cloneTypedArray.js"(exports2, module2) {
    "use strict";
    var cloneArrayBuffer = require_cloneArrayBuffer();
    function cloneTypedArray(typedArray, isDeep) {
      var buffer2 = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
    }
    module2.exports = cloneTypedArray;
  }
});

// ../../node_modules/lodash/_initCloneByTag.js
var require_initCloneByTag = __commonJS({
  "../../node_modules/lodash/_initCloneByTag.js"(exports2, module2) {
    "use strict";
    var cloneArrayBuffer = require_cloneArrayBuffer();
    var cloneDataView = require_cloneDataView();
    var cloneRegExp = require_cloneRegExp();
    var cloneSymbol = require_cloneSymbol();
    var cloneTypedArray = require_cloneTypedArray();
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);
        case boolTag:
        case dateTag:
          return new Ctor(+object);
        case dataViewTag:
          return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
          return cloneTypedArray(object, isDeep);
        case mapTag:
          return new Ctor();
        case numberTag:
        case stringTag:
          return new Ctor(object);
        case regexpTag:
          return cloneRegExp(object);
        case setTag:
          return new Ctor();
        case symbolTag:
          return cloneSymbol(object);
      }
    }
    module2.exports = initCloneByTag;
  }
});

// ../../node_modules/lodash/_baseCreate.js
var require_baseCreate = __commonJS({
  "../../node_modules/lodash/_baseCreate.js"(exports2, module2) {
    "use strict";
    var isObject = require_isObject();
    var objectCreate = Object.create;
    var baseCreate = /* @__PURE__ */ function() {
      function object() {
      }
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object();
        object.prototype = void 0;
        return result;
      };
    }();
    module2.exports = baseCreate;
  }
});

// ../../node_modules/lodash/_initCloneObject.js
var require_initCloneObject = __commonJS({
  "../../node_modules/lodash/_initCloneObject.js"(exports2, module2) {
    "use strict";
    var baseCreate = require_baseCreate();
    var getPrototype = require_getPrototype();
    var isPrototype = require_isPrototype();
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    module2.exports = initCloneObject;
  }
});

// ../../node_modules/lodash/_baseIsMap.js
var require_baseIsMap = __commonJS({
  "../../node_modules/lodash/_baseIsMap.js"(exports2, module2) {
    "use strict";
    var getTag = require_getTag();
    var isObjectLike = require_isObjectLike();
    var mapTag = "[object Map]";
    function baseIsMap(value) {
      return isObjectLike(value) && getTag(value) == mapTag;
    }
    module2.exports = baseIsMap;
  }
});

// ../../node_modules/lodash/isMap.js
var require_isMap = __commonJS({
  "../../node_modules/lodash/isMap.js"(exports2, module2) {
    "use strict";
    var baseIsMap = require_baseIsMap();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsMap = nodeUtil && nodeUtil.isMap;
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
    module2.exports = isMap;
  }
});

// ../../node_modules/lodash/_baseIsSet.js
var require_baseIsSet = __commonJS({
  "../../node_modules/lodash/_baseIsSet.js"(exports2, module2) {
    "use strict";
    var getTag = require_getTag();
    var isObjectLike = require_isObjectLike();
    var setTag = "[object Set]";
    function baseIsSet(value) {
      return isObjectLike(value) && getTag(value) == setTag;
    }
    module2.exports = baseIsSet;
  }
});

// ../../node_modules/lodash/isSet.js
var require_isSet = __commonJS({
  "../../node_modules/lodash/isSet.js"(exports2, module2) {
    "use strict";
    var baseIsSet = require_baseIsSet();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsSet = nodeUtil && nodeUtil.isSet;
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
    module2.exports = isSet;
  }
});

// ../../node_modules/lodash/_baseClone.js
var require_baseClone = __commonJS({
  "../../node_modules/lodash/_baseClone.js"(exports2, module2) {
    "use strict";
    var Stack3 = require_Stack();
    var arrayEach = require_arrayEach();
    var assignValue = require_assignValue();
    var baseAssign = require_baseAssign();
    var baseAssignIn = require_baseAssignIn();
    var cloneBuffer = require_cloneBuffer();
    var copyArray = require_copyArray();
    var copySymbols = require_copySymbols();
    var copySymbolsIn = require_copySymbolsIn();
    var getAllKeys = require_getAllKeys();
    var getAllKeysIn = require_getAllKeysIn();
    var getTag = require_getTag();
    var initCloneArray = require_initCloneArray();
    var initCloneByTag = require_initCloneByTag();
    var initCloneObject = require_initCloneObject();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isMap = require_isMap();
    var isObject = require_isObject();
    var isSet = require_isSet();
    var keys = require_keys();
    var keysIn = require_keysIn();
    var CLONE_DEEP_FLAG = 1;
    var CLONE_FLAT_FLAG = 2;
    var CLONE_SYMBOLS_FLAG = 4;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    function baseClone(value, bitmask, customizer, key2, object, stack2) {
      var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
      if (customizer) {
        result = object ? customizer(value, key2, object, stack2) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object) {
          result = isFlat || isFunc ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      stack2 || (stack2 = new Stack3());
      var stacked = stack2.get(value);
      if (stacked) {
        return stacked;
      }
      stack2.set(value, result);
      if (isSet(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack2));
        });
      } else if (isMap(value)) {
        value.forEach(function(subValue, key3) {
          result.set(key3, baseClone(subValue, bitmask, customizer, key3, value, stack2));
        });
      }
      var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
      var props = isArr ? void 0 : keysFunc(value);
      arrayEach(props || value, function(subValue, key3) {
        if (props) {
          key3 = subValue;
          subValue = value[key3];
        }
        assignValue(result, key3, baseClone(subValue, bitmask, customizer, key3, value, stack2));
      });
      return result;
    }
    module2.exports = baseClone;
  }
});

// ../../node_modules/lodash/cloneDeep.js
var require_cloneDeep = __commonJS({
  "../../node_modules/lodash/cloneDeep.js"(exports2, module2) {
    "use strict";
    var baseClone = require_baseClone();
    var CLONE_DEEP_FLAG = 1;
    var CLONE_SYMBOLS_FLAG = 4;
    function cloneDeep(value) {
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
    }
    module2.exports = cloneDeep;
  }
});

// ../../node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "../../node_modules/safe-buffer/index.js"(exports2, module2) {
    "use strict";
    var buffer2 = require("buffer");
    var Buffer2 = buffer2.Buffer;
    function copyProps(src, dst) {
      for (var key2 in src) {
        dst[key2] = src[key2];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer2;
    } else {
      copyProps(buffer2, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer2.SlowBuffer(size);
    };
  }
});

// node_modules/convert-source-map/index.js
var require_convert_source_map = __commonJS({
  "node_modules/convert-source-map/index.js"(exports2) {
    "use strict";
    var fs = require("fs");
    var path = require("path");
    var SafeBuffer = require_safe_buffer();
    Object.defineProperty(exports2, "commentRegex", {
      get: function getCommentRegex() {
        return /^\s*\/(?:\/|\*)[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(?:.*)$/mg;
      }
    });
    Object.defineProperty(exports2, "mapFileCommentRegex", {
      get: function getMapFileCommentRegex() {
        return /(?:\/\/[@#][ \t]+sourceMappingURL=([^\s'"`]+?)[ \t]*$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^\*]+?)[ \t]*(?:\*\/){1}[ \t]*$)/mg;
      }
    });
    function decodeBase64(base64) {
      return (SafeBuffer.Buffer.from(base64, "base64") || "").toString();
    }
    function stripComment(sm) {
      return sm.split(",").pop();
    }
    function readFromFileMap(sm, dir) {
      var r = exports2.mapFileCommentRegex.exec(sm);
      var filename = r[1] || r[2];
      var filepath = path.resolve(dir, filename);
      try {
        return fs.readFileSync(filepath, "utf8");
      } catch (e) {
        throw new Error("An error occurred while trying to read the map file at " + filepath + "\n" + e);
      }
    }
    function Converter(sm, opts) {
      opts = opts || {};
      if (opts.isFileComment) sm = readFromFileMap(sm, opts.commentFileDir);
      if (opts.hasComment) sm = stripComment(sm);
      if (opts.isEncoded) sm = decodeBase64(sm);
      if (opts.isJSON || opts.isEncoded) sm = JSON.parse(sm);
      this.sourcemap = sm;
    }
    Converter.prototype.toJSON = function(space) {
      return JSON.stringify(this.sourcemap, null, space);
    };
    Converter.prototype.toBase64 = function() {
      var json = this.toJSON();
      return (SafeBuffer.Buffer.from(json, "utf8") || "").toString("base64");
    };
    Converter.prototype.toComment = function(options) {
      var base64 = this.toBase64();
      var data = "sourceMappingURL=data:application/json;charset=utf-8;base64," + base64;
      return options && options.multiline ? "/*# " + data + " */" : "//# " + data;
    };
    Converter.prototype.toObject = function() {
      return JSON.parse(this.toJSON());
    };
    Converter.prototype.addProperty = function(key2, value) {
      if (this.sourcemap.hasOwnProperty(key2)) throw new Error('property "' + key2 + '" already exists on the sourcemap, use set property instead');
      return this.setProperty(key2, value);
    };
    Converter.prototype.setProperty = function(key2, value) {
      this.sourcemap[key2] = value;
      return this;
    };
    Converter.prototype.getProperty = function(key2) {
      return this.sourcemap[key2];
    };
    exports2.fromObject = function(obj) {
      return new Converter(obj);
    };
    exports2.fromJSON = function(json) {
      return new Converter(json, { isJSON: true });
    };
    exports2.fromBase64 = function(base64) {
      return new Converter(base64, { isEncoded: true });
    };
    exports2.fromComment = function(comment) {
      comment = comment.replace(/^\/\*/g, "//").replace(/\*\/$/g, "");
      return new Converter(comment, { isEncoded: true, hasComment: true });
    };
    exports2.fromMapFileComment = function(comment, dir) {
      return new Converter(comment, { commentFileDir: dir, isFileComment: true, isJSON: true });
    };
    exports2.fromSource = function(content) {
      var m = content.match(exports2.commentRegex);
      return m ? exports2.fromComment(m.pop()) : null;
    };
    exports2.fromMapFileSource = function(content, dir) {
      var m = content.match(exports2.mapFileCommentRegex);
      return m ? exports2.fromMapFileComment(m.pop(), dir) : null;
    };
    exports2.removeComments = function(src) {
      return src.replace(exports2.commentRegex, "");
    };
    exports2.removeMapFileComments = function(src) {
      return src.replace(exports2.mapFileCommentRegex, "");
    };
    exports2.generateMapFileComment = function(file, options) {
      var data = "sourceMappingURL=" + file;
      return options && options.multiline ? "/*# " + data + " */" : "//# " + data;
    };
  }
});

// node_modules/@babel/core/lib/transformation/util/missing-plugin-helper.js
var require_missing_plugin_helper = __commonJS({
  "node_modules/@babel/core/lib/transformation/util/missing-plugin-helper.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = generateMissingPluginMessage;
    var pluginNameMap = {
      classProperties: {
        syntax: {
          name: "@babel/plugin-syntax-class-properties",
          url: "https://git.io/vb4yQ"
        },
        transform: {
          name: "@babel/plugin-proposal-class-properties",
          url: "https://git.io/vb4SL"
        }
      },
      decorators: {
        syntax: {
          name: "@babel/plugin-syntax-decorators",
          url: "https://git.io/vb4y9"
        },
        transform: {
          name: "@babel/plugin-proposal-decorators",
          url: "https://git.io/vb4ST"
        }
      },
      doExpressions: {
        syntax: {
          name: "@babel/plugin-syntax-do-expressions",
          url: "https://git.io/vb4yh"
        },
        transform: {
          name: "@babel/plugin-proposal-do-expressions",
          url: "https://git.io/vb4S3"
        }
      },
      dynamicImport: {
        syntax: {
          name: "@babel/plugin-syntax-dynamic-import",
          url: "https://git.io/vb4Sv"
        }
      },
      exportDefaultFrom: {
        syntax: {
          name: "@babel/plugin-syntax-export-default-from",
          url: "https://git.io/vb4SO"
        },
        transform: {
          name: "@babel/plugin-proposal-export-default-from",
          url: "https://git.io/vb4yH"
        }
      },
      exportNamespaceFrom: {
        syntax: {
          name: "@babel/plugin-syntax-export-namespace-from",
          url: "https://git.io/vb4Sf"
        },
        transform: {
          name: "@babel/plugin-proposal-export-namespace-from",
          url: "https://git.io/vb4SG"
        }
      },
      flow: {
        syntax: {
          name: "@babel/plugin-syntax-flow",
          url: "https://git.io/vb4yb"
        },
        transform: {
          name: "@babel/plugin-transform-flow-strip-types",
          url: "https://git.io/vb49g"
        }
      },
      functionBind: {
        syntax: {
          name: "@babel/plugin-syntax-function-bind",
          url: "https://git.io/vb4y7"
        },
        transform: {
          name: "@babel/plugin-proposal-function-bind",
          url: "https://git.io/vb4St"
        }
      },
      functionSent: {
        syntax: {
          name: "@babel/plugin-syntax-function-sent",
          url: "https://git.io/vb4yN"
        },
        transform: {
          name: "@babel/plugin-proposal-function-sent",
          url: "https://git.io/vb4SZ"
        }
      },
      importMeta: {
        syntax: {
          name: "@babel/plugin-syntax-import-meta",
          url: "https://git.io/vbKK6"
        }
      },
      jsx: {
        syntax: {
          name: "@babel/plugin-syntax-jsx",
          url: "https://git.io/vb4yA"
        },
        transform: {
          name: "@babel/plugin-transform-react-jsx",
          url: "https://git.io/vb4yd"
        }
      },
      logicalAssignment: {
        syntax: {
          name: "@babel/plugin-syntax-logical-assignment-operators",
          url: "https://git.io/vAlBp"
        },
        transform: {
          name: "@babel/plugin-proposal-logical-assignment-operators",
          url: "https://git.io/vAlRe"
        }
      },
      nullishCoalescingOperator: {
        syntax: {
          name: "@babel/plugin-syntax-nullish-coalescing-operator",
          url: "https://git.io/vb4yx"
        },
        transform: {
          name: "@babel/plugin-proposal-nullish-coalescing-operator",
          url: "https://git.io/vb4Se"
        }
      },
      numericSeparator: {
        syntax: {
          name: "@babel/plugin-syntax-numeric-separator",
          url: "https://git.io/vb4Sq"
        },
        transform: {
          name: "@babel/plugin-proposal-numeric-separator",
          url: "https://git.io/vb4yS"
        }
      },
      optionalChaining: {
        syntax: {
          name: "@babel/plugin-syntax-optional-chaining",
          url: "https://git.io/vb4Sc"
        },
        transform: {
          name: "@babel/plugin-proposal-optional-chaining",
          url: "https://git.io/vb4Sk"
        }
      },
      pipelineOperator: {
        syntax: {
          name: "@babel/plugin-syntax-pipeline-operator",
          url: "https://git.io/vb4yj"
        },
        transform: {
          name: "@babel/plugin-proposal-pipeline-operator",
          url: "https://git.io/vb4SU"
        }
      },
      throwExpressions: {
        syntax: {
          name: "@babel/plugin-syntax-throw-expressions",
          url: "https://git.io/vb4SJ"
        },
        transform: {
          name: "@babel/plugin-proposal-throw-expressions",
          url: "https://git.io/vb4yF"
        }
      },
      typescript: {
        syntax: {
          name: "@babel/plugin-syntax-typescript",
          url: "https://git.io/vb4SC"
        },
        transform: {
          name: "@babel/plugin-transform-typescript",
          url: "https://git.io/vb4Sm"
        }
      },
      asyncGenerators: {
        syntax: {
          name: "@babel/plugin-syntax-async-generators",
          url: "https://git.io/vb4SY"
        },
        transform: {
          name: "@babel/plugin-proposal-async-generator-functions",
          url: "https://git.io/vb4yp"
        }
      },
      objectRestSpread: {
        syntax: {
          name: "@babel/plugin-syntax-object-rest-spread",
          url: "https://git.io/vb4y5"
        },
        transform: {
          name: "@babel/plugin-proposal-object-rest-spread",
          url: "https://git.io/vb4Ss"
        }
      },
      optionalCatchBinding: {
        syntax: {
          name: "@babel/plugin-syntax-optional-catch-binding",
          url: "https://git.io/vb4Sn"
        },
        transform: {
          name: "@babel/plugin-proposal-optional-catch-binding",
          url: "https://git.io/vb4SI"
        }
      }
    };
    var getNameURLCombination = ({
      name,
      url
    }) => `${name} (${url})`;
    function generateMissingPluginMessage(missingPluginName, loc, codeFrame) {
      let helpMessage = `Support for the experimental syntax '${missingPluginName}' isn't currently enabled (${loc.line}:${loc.column + 1}):

` + codeFrame;
      const pluginInfo = pluginNameMap[missingPluginName];
      if (pluginInfo) {
        const {
          syntax: syntaxPlugin,
          transform: transformPlugin
        } = pluginInfo;
        if (syntaxPlugin) {
          if (transformPlugin) {
            const transformPluginInfo = getNameURLCombination(transformPlugin);
            helpMessage += `

Add ${transformPluginInfo} to the 'plugins' section of your Babel config to enable transformation.`;
          } else {
            const syntaxPluginInfo = getNameURLCombination(syntaxPlugin);
            helpMessage += `

Add ${syntaxPluginInfo} to the 'plugins' section of your Babel config to enable parsing.`;
          }
        }
      }
      return helpMessage;
    }
  }
});

// node_modules/@babel/core/lib/transformation/normalize-file.js
var require_normalize_file = __commonJS({
  "node_modules/@babel/core/lib/transformation/normalize-file.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = normalizeFile;
    function _path() {
      const data = _interopRequireDefault(require("path"));
      _path = function() {
        return data;
      };
      return data;
    }
    function _debug() {
      const data = _interopRequireDefault(require_src());
      _debug = function() {
        return data;
      };
      return data;
    }
    function _cloneDeep() {
      const data = _interopRequireDefault(require_cloneDeep());
      _cloneDeep = function() {
        return data;
      };
      return data;
    }
    function t6() {
      const data = _interopRequireWildcard(require("@babel/types"));
      t6 = function() {
        return data;
      };
      return data;
    }
    function _convertSourceMap() {
      const data = _interopRequireDefault(require_convert_source_map());
      _convertSourceMap = function() {
        return data;
      };
      return data;
    }
    function _parser() {
      const data = require_lib4();
      _parser = function() {
        return data;
      };
      return data;
    }
    function _codeFrame() {
      const data = require_lib3();
      _codeFrame = function() {
        return data;
      };
      return data;
    }
    var _file = _interopRequireDefault(require_file());
    var _missingPluginHelper = _interopRequireDefault(require_missing_plugin_helper());
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key2 in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key2)) {
              var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key2) : {};
              if (desc.get || desc.set) {
                Object.defineProperty(newObj, key2, desc);
              } else {
                newObj[key2] = obj[key2];
              }
            }
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var debug = (0, _debug().default)("babel:transform:file");
    function normalizeFile(pluginPasses, options, code, ast) {
      code = `${code || ""}`;
      let inputMap = null;
      if (options.inputSourceMap !== false) {
        if (typeof options.inputSourceMap === "object") {
          inputMap = _convertSourceMap().default.fromObject(options.inputSourceMap);
        }
        if (!inputMap) {
          try {
            inputMap = _convertSourceMap().default.fromSource(code);
            if (inputMap) {
              code = _convertSourceMap().default.removeComments(code);
            }
          } catch (err) {
            debug("discarding unknown inline input sourcemap", err);
            code = _convertSourceMap().default.removeComments(code);
          }
        }
        if (!inputMap) {
          if (typeof options.filename === "string") {
            try {
              inputMap = _convertSourceMap().default.fromMapFileSource(code, _path().default.dirname(options.filename));
              if (inputMap) {
                code = _convertSourceMap().default.removeMapFileComments(code);
              }
            } catch (err) {
              debug("discarding unknown file input sourcemap", err);
              code = _convertSourceMap().default.removeMapFileComments(code);
            }
          } else {
            debug("discarding un-loadable file input sourcemap");
            code = _convertSourceMap().default.removeMapFileComments(code);
          }
        }
      }
      if (ast) {
        if (ast.type === "Program") {
          ast = t6().file(ast, [], []);
        } else if (ast.type !== "File") {
          throw new Error("AST root must be a Program or File node");
        }
        ast = (0, _cloneDeep().default)(ast);
      } else {
        ast = parser(pluginPasses, options, code);
      }
      return new _file.default(options, {
        code,
        ast,
        inputMap
      });
    }
    function parser(pluginPasses, {
      parserOpts,
      highlightCode = true,
      filename = "unknown"
    }, code) {
      try {
        const results = [];
        for (const plugins of pluginPasses) {
          for (const plugin of plugins) {
            const {
              parserOverride
            } = plugin;
            if (parserOverride) {
              const ast = parserOverride(code, parserOpts, _parser().parse);
              if (ast !== void 0) results.push(ast);
            }
          }
        }
        if (results.length === 0) {
          return (0, _parser().parse)(code, parserOpts);
        } else if (results.length === 1) {
          if (typeof results[0].then === "function") {
            throw new Error(`You appear to be using an async codegen plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.`);
          }
          return results[0];
        }
        throw new Error("More than one plugin attempted to override parsing.");
      } catch (err) {
        if (err.code === "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED") {
          err.message += "\nConsider renaming the file to '.mjs', or setting sourceType:module or sourceType:unambiguous in your Babel config for this file.";
        }
        const {
          loc,
          missingPlugin
        } = err;
        if (loc) {
          const codeFrame = (0, _codeFrame().codeFrameColumns)(code, {
            start: {
              line: loc.line,
              column: loc.column + 1
            }
          }, {
            highlightCode
          });
          if (missingPlugin) {
            err.message = `${filename}: ` + (0, _missingPluginHelper.default)(missingPlugin[0], loc, codeFrame);
          } else {
            err.message = `${filename}: ${err.message}

` + codeFrame;
          }
          err.code = "BABEL_PARSE_ERROR";
        }
        throw err;
      }
    }
  }
});

// node_modules/source-map/lib/base64.js
var require_base64 = __commonJS({
  "node_modules/source-map/lib/base64.js"(exports2) {
    "use strict";
    var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
    exports2.encode = function(number) {
      if (0 <= number && number < intToCharMap.length) {
        return intToCharMap[number];
      }
      throw new TypeError("Must be between 0 and 63: " + number);
    };
    exports2.decode = function(charCode) {
      var bigA = 65;
      var bigZ = 90;
      var littleA = 97;
      var littleZ = 122;
      var zero = 48;
      var nine = 57;
      var plus = 43;
      var slash = 47;
      var littleOffset = 26;
      var numberOffset = 52;
      if (bigA <= charCode && charCode <= bigZ) {
        return charCode - bigA;
      }
      if (littleA <= charCode && charCode <= littleZ) {
        return charCode - littleA + littleOffset;
      }
      if (zero <= charCode && charCode <= nine) {
        return charCode - zero + numberOffset;
      }
      if (charCode == plus) {
        return 62;
      }
      if (charCode == slash) {
        return 63;
      }
      return -1;
    };
  }
});

// node_modules/source-map/lib/base64-vlq.js
var require_base64_vlq = __commonJS({
  "node_modules/source-map/lib/base64-vlq.js"(exports2) {
    "use strict";
    var base64 = require_base64();
    var VLQ_BASE_SHIFT = 5;
    var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
    var VLQ_BASE_MASK = VLQ_BASE - 1;
    var VLQ_CONTINUATION_BIT = VLQ_BASE;
    function toVLQSigned(aValue) {
      return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
    }
    function fromVLQSigned(aValue) {
      var isNegative = (aValue & 1) === 1;
      var shifted = aValue >> 1;
      return isNegative ? -shifted : shifted;
    }
    exports2.encode = function base64VLQ_encode(aValue) {
      var encoded = "";
      var digit;
      var vlq = toVLQSigned(aValue);
      do {
        digit = vlq & VLQ_BASE_MASK;
        vlq >>>= VLQ_BASE_SHIFT;
        if (vlq > 0) {
          digit |= VLQ_CONTINUATION_BIT;
        }
        encoded += base64.encode(digit);
      } while (vlq > 0);
      return encoded;
    };
    exports2.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
      var strLen = aStr.length;
      var result = 0;
      var shift = 0;
      var continuation, digit;
      do {
        if (aIndex >= strLen) {
          throw new Error("Expected more digits in base 64 VLQ value.");
        }
        digit = base64.decode(aStr.charCodeAt(aIndex++));
        if (digit === -1) {
          throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
        }
        continuation = !!(digit & VLQ_CONTINUATION_BIT);
        digit &= VLQ_BASE_MASK;
        result = result + (digit << shift);
        shift += VLQ_BASE_SHIFT;
      } while (continuation);
      aOutParam.value = fromVLQSigned(result);
      aOutParam.rest = aIndex;
    };
  }
});

// node_modules/source-map/lib/util.js
var require_util4 = __commonJS({
  "node_modules/source-map/lib/util.js"(exports2) {
    "use strict";
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs) {
        return aArgs[aName];
      } else if (arguments.length === 3) {
        return aDefaultValue;
      } else {
        throw new Error('"' + aName + '" is a required argument.');
      }
    }
    exports2.getArg = getArg;
    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
    var dataUrlRegexp = /^data:.+\,.+$/;
    function urlParse(aUrl) {
      var match = aUrl.match(urlRegexp);
      if (!match) {
        return null;
      }
      return {
        scheme: match[1],
        auth: match[2],
        host: match[3],
        port: match[4],
        path: match[5]
      };
    }
    exports2.urlParse = urlParse;
    function urlGenerate(aParsedUrl) {
      var url = "";
      if (aParsedUrl.scheme) {
        url += aParsedUrl.scheme + ":";
      }
      url += "//";
      if (aParsedUrl.auth) {
        url += aParsedUrl.auth + "@";
      }
      if (aParsedUrl.host) {
        url += aParsedUrl.host;
      }
      if (aParsedUrl.port) {
        url += ":" + aParsedUrl.port;
      }
      if (aParsedUrl.path) {
        url += aParsedUrl.path;
      }
      return url;
    }
    exports2.urlGenerate = urlGenerate;
    function normalize(aPath) {
      var path = aPath;
      var url = urlParse(aPath);
      if (url) {
        if (!url.path) {
          return aPath;
        }
        path = url.path;
      }
      var isAbsolute = exports2.isAbsolute(path);
      var parts = path.split(/\/+/);
      for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
        part = parts[i];
        if (part === ".") {
          parts.splice(i, 1);
        } else if (part === "..") {
          up++;
        } else if (up > 0) {
          if (part === "") {
            parts.splice(i + 1, up);
            up = 0;
          } else {
            parts.splice(i, 2);
            up--;
          }
        }
      }
      path = parts.join("/");
      if (path === "") {
        path = isAbsolute ? "/" : ".";
      }
      if (url) {
        url.path = path;
        return urlGenerate(url);
      }
      return path;
    }
    exports2.normalize = normalize;
    function join(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      if (aPath === "") {
        aPath = ".";
      }
      var aPathUrl = urlParse(aPath);
      var aRootUrl = urlParse(aRoot);
      if (aRootUrl) {
        aRoot = aRootUrl.path || "/";
      }
      if (aPathUrl && !aPathUrl.scheme) {
        if (aRootUrl) {
          aPathUrl.scheme = aRootUrl.scheme;
        }
        return urlGenerate(aPathUrl);
      }
      if (aPathUrl || aPath.match(dataUrlRegexp)) {
        return aPath;
      }
      if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
        aRootUrl.host = aPath;
        return urlGenerate(aRootUrl);
      }
      var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
      if (aRootUrl) {
        aRootUrl.path = joined;
        return urlGenerate(aRootUrl);
      }
      return joined;
    }
    exports2.join = join;
    exports2.isAbsolute = function(aPath) {
      return aPath.charAt(0) === "/" || !!aPath.match(urlRegexp);
    };
    function relative(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      aRoot = aRoot.replace(/\/$/, "");
      var level = 0;
      while (aPath.indexOf(aRoot + "/") !== 0) {
        var index = aRoot.lastIndexOf("/");
        if (index < 0) {
          return aPath;
        }
        aRoot = aRoot.slice(0, index);
        if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
          return aPath;
        }
        ++level;
      }
      return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    }
    exports2.relative = relative;
    var supportsNullProto = function() {
      var obj = /* @__PURE__ */ Object.create(null);
      return !("__proto__" in obj);
    }();
    function identity(s) {
      return s;
    }
    function toSetString(aStr) {
      if (isProtoString(aStr)) {
        return "$" + aStr;
      }
      return aStr;
    }
    exports2.toSetString = supportsNullProto ? identity : toSetString;
    function fromSetString(aStr) {
      if (isProtoString(aStr)) {
        return aStr.slice(1);
      }
      return aStr;
    }
    exports2.fromSetString = supportsNullProto ? identity : fromSetString;
    function isProtoString(s) {
      if (!s) {
        return false;
      }
      var length = s.length;
      if (length < 9) {
        return false;
      }
      if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
        return false;
      }
      for (var i = length - 10; i >= 0; i--) {
        if (s.charCodeAt(i) !== 36) {
          return false;
        }
      }
      return true;
    }
    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
      var cmp = mappingA.source - mappingB.source;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return mappingA.name - mappingB.name;
    }
    exports2.compareByOriginalPositions = compareByOriginalPositions;
    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = mappingA.source - mappingB.source;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return mappingA.name - mappingB.name;
    }
    exports2.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
    function strcmp(aStr1, aStr2) {
      if (aStr1 === aStr2) {
        return 0;
      }
      if (aStr1 > aStr2) {
        return 1;
      }
      return -1;
    }
    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
  }
});

// node_modules/source-map/lib/array-set.js
var require_array_set = __commonJS({
  "node_modules/source-map/lib/array-set.js"(exports2) {
    "use strict";
    var util3 = require_util4();
    var has = Object.prototype.hasOwnProperty;
    var hasNativeMap = typeof Map !== "undefined";
    function ArraySet() {
      this._array = [];
      this._set = hasNativeMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
    }
    ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
      var set = new ArraySet();
      for (var i = 0, len = aArray.length; i < len; i++) {
        set.add(aArray[i], aAllowDuplicates);
      }
      return set;
    };
    ArraySet.prototype.size = function ArraySet_size() {
      return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
    };
    ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
      var sStr = hasNativeMap ? aStr : util3.toSetString(aStr);
      var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
      var idx = this._array.length;
      if (!isDuplicate || aAllowDuplicates) {
        this._array.push(aStr);
      }
      if (!isDuplicate) {
        if (hasNativeMap) {
          this._set.set(aStr, idx);
        } else {
          this._set[sStr] = idx;
        }
      }
    };
    ArraySet.prototype.has = function ArraySet_has(aStr) {
      if (hasNativeMap) {
        return this._set.has(aStr);
      } else {
        var sStr = util3.toSetString(aStr);
        return has.call(this._set, sStr);
      }
    };
    ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
      if (hasNativeMap) {
        var idx = this._set.get(aStr);
        if (idx >= 0) {
          return idx;
        }
      } else {
        var sStr = util3.toSetString(aStr);
        if (has.call(this._set, sStr)) {
          return this._set[sStr];
        }
      }
      throw new Error('"' + aStr + '" is not in the set.');
    };
    ArraySet.prototype.at = function ArraySet_at(aIdx) {
      if (aIdx >= 0 && aIdx < this._array.length) {
        return this._array[aIdx];
      }
      throw new Error("No element indexed by " + aIdx);
    };
    ArraySet.prototype.toArray = function ArraySet_toArray() {
      return this._array.slice();
    };
    exports2.ArraySet = ArraySet;
  }
});

// node_modules/source-map/lib/mapping-list.js
var require_mapping_list = __commonJS({
  "node_modules/source-map/lib/mapping-list.js"(exports2) {
    "use strict";
    var util3 = require_util4();
    function generatedPositionAfter(mappingA, mappingB) {
      var lineA = mappingA.generatedLine;
      var lineB = mappingB.generatedLine;
      var columnA = mappingA.generatedColumn;
      var columnB = mappingB.generatedColumn;
      return lineB > lineA || lineB == lineA && columnB >= columnA || util3.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
    }
    function MappingList() {
      this._array = [];
      this._sorted = true;
      this._last = { generatedLine: -1, generatedColumn: 0 };
    }
    MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
      this._array.forEach(aCallback, aThisArg);
    };
    MappingList.prototype.add = function MappingList_add(aMapping) {
      if (generatedPositionAfter(this._last, aMapping)) {
        this._last = aMapping;
        this._array.push(aMapping);
      } else {
        this._sorted = false;
        this._array.push(aMapping);
      }
    };
    MappingList.prototype.toArray = function MappingList_toArray() {
      if (!this._sorted) {
        this._array.sort(util3.compareByGeneratedPositionsInflated);
        this._sorted = true;
      }
      return this._array;
    };
    exports2.MappingList = MappingList;
  }
});

// node_modules/source-map/lib/source-map-generator.js
var require_source_map_generator = __commonJS({
  "node_modules/source-map/lib/source-map-generator.js"(exports2) {
    "use strict";
    var base64VLQ = require_base64_vlq();
    var util3 = require_util4();
    var ArraySet = require_array_set().ArraySet;
    var MappingList = require_mapping_list().MappingList;
    function SourceMapGenerator(aArgs) {
      if (!aArgs) {
        aArgs = {};
      }
      this._file = util3.getArg(aArgs, "file", null);
      this._sourceRoot = util3.getArg(aArgs, "sourceRoot", null);
      this._skipValidation = util3.getArg(aArgs, "skipValidation", false);
      this._sources = new ArraySet();
      this._names = new ArraySet();
      this._mappings = new MappingList();
      this._sourcesContents = null;
    }
    SourceMapGenerator.prototype._version = 3;
    SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator({
        file: aSourceMapConsumer.file,
        sourceRoot
      });
      aSourceMapConsumer.eachMapping(function(mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };
        if (mapping.source != null) {
          newMapping.source = mapping.source;
          if (sourceRoot != null) {
            newMapping.source = util3.relative(sourceRoot, newMapping.source);
          }
          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };
          if (mapping.name != null) {
            newMapping.name = mapping.name;
          }
        }
        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          generator.setSourceContent(sourceFile, content);
        }
      });
      return generator;
    };
    SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
      var generated = util3.getArg(aArgs, "generated");
      var original = util3.getArg(aArgs, "original", null);
      var source2 = util3.getArg(aArgs, "source", null);
      var name = util3.getArg(aArgs, "name", null);
      if (!this._skipValidation) {
        this._validateMapping(generated, original, source2, name);
      }
      if (source2 != null) {
        source2 = String(source2);
        if (!this._sources.has(source2)) {
          this._sources.add(source2);
        }
      }
      if (name != null) {
        name = String(name);
        if (!this._names.has(name)) {
          this._names.add(name);
        }
      }
      this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source: source2,
        name
      });
    };
    SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source2 = aSourceFile;
      if (this._sourceRoot != null) {
        source2 = util3.relative(this._sourceRoot, source2);
      }
      if (aSourceContent != null) {
        if (!this._sourcesContents) {
          this._sourcesContents = /* @__PURE__ */ Object.create(null);
        }
        this._sourcesContents[util3.toSetString(source2)] = aSourceContent;
      } else if (this._sourcesContents) {
        delete this._sourcesContents[util3.toSetString(source2)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };
    SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      var sourceFile = aSourceFile;
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
          throw new Error(
            `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
          );
        }
        sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      if (sourceRoot != null) {
        sourceFile = util3.relative(sourceRoot, sourceFile);
      }
      var newSources = new ArraySet();
      var newNames = new ArraySet();
      this._mappings.unsortedForEach(function(mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source != null) {
            mapping.source = original.source;
            if (aSourceMapPath != null) {
              mapping.source = util3.join(aSourceMapPath, mapping.source);
            }
            if (sourceRoot != null) {
              mapping.source = util3.relative(sourceRoot, mapping.source);
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name != null) {
              mapping.name = original.name;
            }
          }
        }
        var source2 = mapping.source;
        if (source2 != null && !newSources.has(source2)) {
          newSources.add(source2);
        }
        var name = mapping.name;
        if (name != null && !newNames.has(name)) {
          newNames.add(name);
        }
      }, this);
      this._sources = newSources;
      this._names = newNames;
      aSourceMapConsumer.sources.forEach(function(sourceFile2) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
        if (content != null) {
          if (aSourceMapPath != null) {
            sourceFile2 = util3.join(aSourceMapPath, sourceFile2);
          }
          if (sourceRoot != null) {
            sourceFile2 = util3.relative(sourceRoot, sourceFile2);
          }
          this.setSourceContent(sourceFile2, content);
        }
      }, this);
    };
    SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
      if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
        throw new Error(
          "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values."
        );
      }
      if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
        return;
      } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
        return;
      } else {
        throw new Error("Invalid mapping: " + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        }));
      }
    };
    SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = "";
      var next;
      var mapping;
      var nameIdx;
      var sourceIdx;
      var mappings = this._mappings.toArray();
      for (var i = 0, len = mappings.length; i < len; i++) {
        mapping = mappings[i];
        next = "";
        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            next += ";";
            previousGeneratedLine++;
          }
        } else {
          if (i > 0) {
            if (!util3.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
              continue;
            }
            next += ",";
          }
        }
        next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;
        if (mapping.source != null) {
          sourceIdx = this._sources.indexOf(mapping.source);
          next += base64VLQ.encode(sourceIdx - previousSource);
          previousSource = sourceIdx;
          next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;
          next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;
          if (mapping.name != null) {
            nameIdx = this._names.indexOf(mapping.name);
            next += base64VLQ.encode(nameIdx - previousName);
            previousName = nameIdx;
          }
        }
        result += next;
      }
      return result;
    };
    SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function(source2) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot != null) {
          source2 = util3.relative(aSourceRoot, source2);
        }
        var key2 = util3.toSetString(source2);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key2) ? this._sourcesContents[key2] : null;
      }, this);
    };
    SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
      var map = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._file != null) {
        map.file = this._file;
      }
      if (this._sourceRoot != null) {
        map.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
      }
      return map;
    };
    SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
      return JSON.stringify(this.toJSON());
    };
    exports2.SourceMapGenerator = SourceMapGenerator;
  }
});

// node_modules/source-map/lib/binary-search.js
var require_binary_search = __commonJS({
  "node_modules/source-map/lib/binary-search.js"(exports2) {
    "use strict";
    exports2.GREATEST_LOWER_BOUND = 1;
    exports2.LEAST_UPPER_BOUND = 2;
    function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
      var mid = Math.floor((aHigh - aLow) / 2) + aLow;
      var cmp = aCompare(aNeedle, aHaystack[mid], true);
      if (cmp === 0) {
        return mid;
      } else if (cmp > 0) {
        if (aHigh - mid > 1) {
          return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports2.LEAST_UPPER_BOUND) {
          return aHigh < aHaystack.length ? aHigh : -1;
        } else {
          return mid;
        }
      } else {
        if (mid - aLow > 1) {
          return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports2.LEAST_UPPER_BOUND) {
          return mid;
        } else {
          return aLow < 0 ? -1 : aLow;
        }
      }
    }
    exports2.search = function search(aNeedle, aHaystack, aCompare, aBias) {
      if (aHaystack.length === 0) {
        return -1;
      }
      var index = recursiveSearch(
        -1,
        aHaystack.length,
        aNeedle,
        aHaystack,
        aCompare,
        aBias || exports2.GREATEST_LOWER_BOUND
      );
      if (index < 0) {
        return -1;
      }
      while (index - 1 >= 0) {
        if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
          break;
        }
        --index;
      }
      return index;
    };
  }
});

// node_modules/source-map/lib/quick-sort.js
var require_quick_sort = __commonJS({
  "node_modules/source-map/lib/quick-sort.js"(exports2) {
    "use strict";
    function swap(ary, x, y) {
      var temp = ary[x];
      ary[x] = ary[y];
      ary[y] = temp;
    }
    function randomIntInRange(low, high) {
      return Math.round(low + Math.random() * (high - low));
    }
    function doQuickSort(ary, comparator, p, r) {
      if (p < r) {
        var pivotIndex = randomIntInRange(p, r);
        var i = p - 1;
        swap(ary, pivotIndex, r);
        var pivot = ary[r];
        for (var j = p; j < r; j++) {
          if (comparator(ary[j], pivot) <= 0) {
            i += 1;
            swap(ary, i, j);
          }
        }
        swap(ary, i + 1, j);
        var q = i + 1;
        doQuickSort(ary, comparator, p, q - 1);
        doQuickSort(ary, comparator, q + 1, r);
      }
    }
    exports2.quickSort = function(ary, comparator) {
      doQuickSort(ary, comparator, 0, ary.length - 1);
    };
  }
});

// node_modules/source-map/lib/source-map-consumer.js
var require_source_map_consumer = __commonJS({
  "node_modules/source-map/lib/source-map-consumer.js"(exports2) {
    "use strict";
    var util3 = require_util4();
    var binarySearch = require_binary_search();
    var ArraySet = require_array_set().ArraySet;
    var base64VLQ = require_base64_vlq();
    var quickSort = require_quick_sort().quickSort;
    function SourceMapConsumer(aSourceMap) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ""));
      }
      return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap) : new BasicSourceMapConsumer(sourceMap);
    }
    SourceMapConsumer.fromSourceMap = function(aSourceMap) {
      return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
    };
    SourceMapConsumer.prototype._version = 3;
    SourceMapConsumer.prototype.__generatedMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
      get: function() {
        if (!this.__generatedMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__generatedMappings;
      }
    });
    SourceMapConsumer.prototype.__originalMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
      get: function() {
        if (!this.__originalMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__originalMappings;
      }
    });
    SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
      var c2 = aStr.charAt(index);
      return c2 === ";" || c2 === ",";
    };
    SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      throw new Error("Subclasses must implement _parseMappings");
    };
    SourceMapConsumer.GENERATED_ORDER = 1;
    SourceMapConsumer.ORIGINAL_ORDER = 2;
    SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
    SourceMapConsumer.LEAST_UPPER_BOUND = 2;
    SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context = aContext || null;
      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
      var mappings;
      switch (order) {
        case SourceMapConsumer.GENERATED_ORDER:
          mappings = this._generatedMappings;
          break;
        case SourceMapConsumer.ORIGINAL_ORDER:
          mappings = this._originalMappings;
          break;
        default:
          throw new Error("Unknown order of iteration.");
      }
      var sourceRoot = this.sourceRoot;
      mappings.map(function(mapping) {
        var source2 = mapping.source === null ? null : this._sources.at(mapping.source);
        if (source2 != null && sourceRoot != null) {
          source2 = util3.join(sourceRoot, source2);
        }
        return {
          source: source2,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name === null ? null : this._names.at(mapping.name)
        };
      }, this).forEach(aCallback, context);
    };
    SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
      var line2 = util3.getArg(aArgs, "line");
      var needle = {
        source: util3.getArg(aArgs, "source"),
        originalLine: line2,
        originalColumn: util3.getArg(aArgs, "column", 0)
      };
      if (this.sourceRoot != null) {
        needle.source = util3.relative(this.sourceRoot, needle.source);
      }
      if (!this._sources.has(needle.source)) {
        return [];
      }
      needle.source = this._sources.indexOf(needle.source);
      var mappings = [];
      var index = this._findMapping(
        needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util3.compareByOriginalPositions,
        binarySearch.LEAST_UPPER_BOUND
      );
      if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (aArgs.column === void 0) {
          var originalLine = mapping.originalLine;
          while (mapping && mapping.originalLine === originalLine) {
            mappings.push({
              line: util3.getArg(mapping, "generatedLine", null),
              column: util3.getArg(mapping, "generatedColumn", null),
              lastColumn: util3.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index];
          }
        } else {
          var originalColumn = mapping.originalColumn;
          while (mapping && mapping.originalLine === line2 && mapping.originalColumn == originalColumn) {
            mappings.push({
              line: util3.getArg(mapping, "generatedLine", null),
              column: util3.getArg(mapping, "generatedColumn", null),
              lastColumn: util3.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index];
          }
        }
      }
      return mappings;
    };
    exports2.SourceMapConsumer = SourceMapConsumer;
    function BasicSourceMapConsumer(aSourceMap) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ""));
      }
      var version = util3.getArg(sourceMap, "version");
      var sources = util3.getArg(sourceMap, "sources");
      var names = util3.getArg(sourceMap, "names", []);
      var sourceRoot = util3.getArg(sourceMap, "sourceRoot", null);
      var sourcesContent = util3.getArg(sourceMap, "sourcesContent", null);
      var mappings = util3.getArg(sourceMap, "mappings");
      var file = util3.getArg(sourceMap, "file", null);
      if (version != this._version) {
        throw new Error("Unsupported version: " + version);
      }
      sources = sources.map(String).map(util3.normalize).map(function(source2) {
        return sourceRoot && util3.isAbsolute(sourceRoot) && util3.isAbsolute(source2) ? util3.relative(sourceRoot, source2) : source2;
      });
      this._names = ArraySet.fromArray(names.map(String), true);
      this._sources = ArraySet.fromArray(sources, true);
      this.sourceRoot = sourceRoot;
      this.sourcesContent = sourcesContent;
      this._mappings = mappings;
      this.file = file;
    }
    BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
    BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap) {
      var smc = Object.create(BasicSourceMapConsumer.prototype);
      var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
      var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(
        smc._sources.toArray(),
        smc.sourceRoot
      );
      smc.file = aSourceMap._file;
      var generatedMappings = aSourceMap._mappings.toArray().slice();
      var destGeneratedMappings = smc.__generatedMappings = [];
      var destOriginalMappings = smc.__originalMappings = [];
      for (var i = 0, length = generatedMappings.length; i < length; i++) {
        var srcMapping = generatedMappings[i];
        var destMapping = new Mapping();
        destMapping.generatedLine = srcMapping.generatedLine;
        destMapping.generatedColumn = srcMapping.generatedColumn;
        if (srcMapping.source) {
          destMapping.source = sources.indexOf(srcMapping.source);
          destMapping.originalLine = srcMapping.originalLine;
          destMapping.originalColumn = srcMapping.originalColumn;
          if (srcMapping.name) {
            destMapping.name = names.indexOf(srcMapping.name);
          }
          destOriginalMappings.push(destMapping);
        }
        destGeneratedMappings.push(destMapping);
      }
      quickSort(smc.__originalMappings, util3.compareByOriginalPositions);
      return smc;
    };
    BasicSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
      get: function() {
        return this._sources.toArray().map(function(s) {
          return this.sourceRoot != null ? util3.join(this.sourceRoot, s) : s;
        }, this);
      }
    });
    function Mapping() {
      this.generatedLine = 0;
      this.generatedColumn = 0;
      this.source = null;
      this.originalLine = null;
      this.originalColumn = null;
      this.name = null;
    }
    BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var length = aStr.length;
      var index = 0;
      var cachedSegments = {};
      var temp = {};
      var originalMappings = [];
      var generatedMappings = [];
      var mapping, str, segment, end, value;
      while (index < length) {
        if (aStr.charAt(index) === ";") {
          generatedLine++;
          index++;
          previousGeneratedColumn = 0;
        } else if (aStr.charAt(index) === ",") {
          index++;
        } else {
          mapping = new Mapping();
          mapping.generatedLine = generatedLine;
          for (end = index; end < length; end++) {
            if (this._charIsMappingSeparator(aStr, end)) {
              break;
            }
          }
          str = aStr.slice(index, end);
          segment = cachedSegments[str];
          if (segment) {
            index += str.length;
          } else {
            segment = [];
            while (index < end) {
              base64VLQ.decode(aStr, index, temp);
              value = temp.value;
              index = temp.rest;
              segment.push(value);
            }
            if (segment.length === 2) {
              throw new Error("Found a source, but no line and column");
            }
            if (segment.length === 3) {
              throw new Error("Found a source and line, but no column");
            }
            cachedSegments[str] = segment;
          }
          mapping.generatedColumn = previousGeneratedColumn + segment[0];
          previousGeneratedColumn = mapping.generatedColumn;
          if (segment.length > 1) {
            mapping.source = previousSource + segment[1];
            previousSource += segment[1];
            mapping.originalLine = previousOriginalLine + segment[2];
            previousOriginalLine = mapping.originalLine;
            mapping.originalLine += 1;
            mapping.originalColumn = previousOriginalColumn + segment[3];
            previousOriginalColumn = mapping.originalColumn;
            if (segment.length > 4) {
              mapping.name = previousName + segment[4];
              previousName += segment[4];
            }
          }
          generatedMappings.push(mapping);
          if (typeof mapping.originalLine === "number") {
            originalMappings.push(mapping);
          }
        }
      }
      quickSort(generatedMappings, util3.compareByGeneratedPositionsDeflated);
      this.__generatedMappings = generatedMappings;
      quickSort(originalMappings, util3.compareByOriginalPositions);
      this.__originalMappings = originalMappings;
    };
    BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
      if (aNeedle[aLineName] <= 0) {
        throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
      }
      return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
    };
    BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
      for (var index = 0; index < this._generatedMappings.length; ++index) {
        var mapping = this._generatedMappings[index];
        if (index + 1 < this._generatedMappings.length) {
          var nextMapping = this._generatedMappings[index + 1];
          if (mapping.generatedLine === nextMapping.generatedLine) {
            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
            continue;
          }
        }
        mapping.lastGeneratedColumn = Infinity;
      }
    };
    BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util3.getArg(aArgs, "line"),
        generatedColumn: util3.getArg(aArgs, "column")
      };
      var index = this._findMapping(
        needle,
        this._generatedMappings,
        "generatedLine",
        "generatedColumn",
        util3.compareByGeneratedPositionsDeflated,
        util3.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
      );
      if (index >= 0) {
        var mapping = this._generatedMappings[index];
        if (mapping.generatedLine === needle.generatedLine) {
          var source2 = util3.getArg(mapping, "source", null);
          if (source2 !== null) {
            source2 = this._sources.at(source2);
            if (this.sourceRoot != null) {
              source2 = util3.join(this.sourceRoot, source2);
            }
          }
          var name = util3.getArg(mapping, "name", null);
          if (name !== null) {
            name = this._names.at(name);
          }
          return {
            source: source2,
            line: util3.getArg(mapping, "originalLine", null),
            column: util3.getArg(mapping, "originalColumn", null),
            name
          };
        }
      }
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };
    BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
      if (!this.sourcesContent) {
        return false;
      }
      return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
        return sc == null;
      });
    };
    BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      if (!this.sourcesContent) {
        return null;
      }
      if (this.sourceRoot != null) {
        aSource = util3.relative(this.sourceRoot, aSource);
      }
      if (this._sources.has(aSource)) {
        return this.sourcesContent[this._sources.indexOf(aSource)];
      }
      var url;
      if (this.sourceRoot != null && (url = util3.urlParse(this.sourceRoot))) {
        var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
        if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
        }
        if ((!url.path || url.path == "/") && this._sources.has("/" + aSource)) {
          return this.sourcesContent[this._sources.indexOf("/" + aSource)];
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
    };
    BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
      var source2 = util3.getArg(aArgs, "source");
      if (this.sourceRoot != null) {
        source2 = util3.relative(this.sourceRoot, source2);
      }
      if (!this._sources.has(source2)) {
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      }
      source2 = this._sources.indexOf(source2);
      var needle = {
        source: source2,
        originalLine: util3.getArg(aArgs, "line"),
        originalColumn: util3.getArg(aArgs, "column")
      };
      var index = this._findMapping(
        needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util3.compareByOriginalPositions,
        util3.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
      );
      if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (mapping.source === needle.source) {
          return {
            line: util3.getArg(mapping, "generatedLine", null),
            column: util3.getArg(mapping, "generatedColumn", null),
            lastColumn: util3.getArg(mapping, "lastGeneratedColumn", null)
          };
        }
      }
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    };
    exports2.BasicSourceMapConsumer = BasicSourceMapConsumer;
    function IndexedSourceMapConsumer(aSourceMap) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ""));
      }
      var version = util3.getArg(sourceMap, "version");
      var sections = util3.getArg(sourceMap, "sections");
      if (version != this._version) {
        throw new Error("Unsupported version: " + version);
      }
      this._sources = new ArraySet();
      this._names = new ArraySet();
      var lastOffset = {
        line: -1,
        column: 0
      };
      this._sections = sections.map(function(s) {
        if (s.url) {
          throw new Error("Support for url field in sections not implemented.");
        }
        var offset = util3.getArg(s, "offset");
        var offsetLine = util3.getArg(offset, "line");
        var offsetColumn = util3.getArg(offset, "column");
        if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
          throw new Error("Section offsets must be ordered and non-overlapping.");
        }
        lastOffset = offset;
        return {
          generatedOffset: {
            // The offset fields are 0-based, but we use 1-based indices when
            // encoding/decoding from VLQ.
            generatedLine: offsetLine + 1,
            generatedColumn: offsetColumn + 1
          },
          consumer: new SourceMapConsumer(util3.getArg(s, "map"))
        };
      });
    }
    IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
    IndexedSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
      get: function() {
        var sources = [];
        for (var i = 0; i < this._sections.length; i++) {
          for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
            sources.push(this._sections[i].consumer.sources[j]);
          }
        }
        return sources;
      }
    });
    IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util3.getArg(aArgs, "line"),
        generatedColumn: util3.getArg(aArgs, "column")
      };
      var sectionIndex = binarySearch.search(
        needle,
        this._sections,
        function(needle2, section2) {
          var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
          if (cmp) {
            return cmp;
          }
          return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
        }
      );
      var section = this._sections[sectionIndex];
      if (!section) {
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      }
      return section.consumer.originalPositionFor({
        line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
        column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
        bias: aArgs.bias
      });
    };
    IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
      return this._sections.every(function(s) {
        return s.consumer.hasContentsOfAllSources();
      });
    };
    IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var content = section.consumer.sourceContentFor(aSource, true);
        if (content) {
          return content;
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
    };
    IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        if (section.consumer.sources.indexOf(util3.getArg(aArgs, "source")) === -1) {
          continue;
        }
        var generatedPosition = section.consumer.generatedPositionFor(aArgs);
        if (generatedPosition) {
          var ret = {
            line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
            column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
          };
          return ret;
        }
      }
      return {
        line: null,
        column: null
      };
    };
    IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      this.__generatedMappings = [];
      this.__originalMappings = [];
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var sectionMappings = section.consumer._generatedMappings;
        for (var j = 0; j < sectionMappings.length; j++) {
          var mapping = sectionMappings[j];
          var source2 = section.consumer._sources.at(mapping.source);
          if (section.consumer.sourceRoot !== null) {
            source2 = util3.join(section.consumer.sourceRoot, source2);
          }
          this._sources.add(source2);
          source2 = this._sources.indexOf(source2);
          var name = section.consumer._names.at(mapping.name);
          this._names.add(name);
          name = this._names.indexOf(name);
          var adjustedMapping = {
            source: source2,
            generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
            generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name
          };
          this.__generatedMappings.push(adjustedMapping);
          if (typeof adjustedMapping.originalLine === "number") {
            this.__originalMappings.push(adjustedMapping);
          }
        }
      }
      quickSort(this.__generatedMappings, util3.compareByGeneratedPositionsDeflated);
      quickSort(this.__originalMappings, util3.compareByOriginalPositions);
    };
    exports2.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
  }
});

// node_modules/source-map/lib/source-node.js
var require_source_node = __commonJS({
  "node_modules/source-map/lib/source-node.js"(exports2) {
    "use strict";
    var SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    var util3 = require_util4();
    var REGEX_NEWLINE = /(\r?\n)/;
    var NEWLINE_CODE = 10;
    var isSourceNode = "$$$isSourceNode$$$";
    function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
      this.children = [];
      this.sourceContents = {};
      this.line = aLine == null ? null : aLine;
      this.column = aColumn == null ? null : aColumn;
      this.source = aSource == null ? null : aSource;
      this.name = aName == null ? null : aName;
      this[isSourceNode] = true;
      if (aChunks != null) this.add(aChunks);
    }
    SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
      var node = new SourceNode();
      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
      var remainingLinesIndex = 0;
      var shiftNextLine = function() {
        var lineContents = getNextLine();
        var newLine = getNextLine() || "";
        return lineContents + newLine;
        function getNextLine() {
          return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
        }
      };
      var lastGeneratedLine = 1, lastGeneratedColumn = 0;
      var lastMapping = null;
      aSourceMapConsumer.eachMapping(function(mapping) {
        if (lastMapping !== null) {
          if (lastGeneratedLine < mapping.generatedLine) {
            addMappingWithCode(lastMapping, shiftNextLine());
            lastGeneratedLine++;
            lastGeneratedColumn = 0;
          } else {
            var nextLine = remainingLines[remainingLinesIndex];
            var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
            addMappingWithCode(lastMapping, code);
            lastMapping = mapping;
            return;
          }
        }
        while (lastGeneratedLine < mapping.generatedLine) {
          node.add(shiftNextLine());
          lastGeneratedLine++;
        }
        if (lastGeneratedColumn < mapping.generatedColumn) {
          var nextLine = remainingLines[remainingLinesIndex];
          node.add(nextLine.substr(0, mapping.generatedColumn));
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
        }
        lastMapping = mapping;
      }, this);
      if (remainingLinesIndex < remainingLines.length) {
        if (lastMapping) {
          addMappingWithCode(lastMapping, shiftNextLine());
        }
        node.add(remainingLines.splice(remainingLinesIndex).join(""));
      }
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aRelativePath != null) {
            sourceFile = util3.join(aRelativePath, sourceFile);
          }
          node.setSourceContent(sourceFile, content);
        }
      });
      return node;
      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === void 0) {
          node.add(code);
        } else {
          var source2 = aRelativePath ? util3.join(aRelativePath, mapping.source) : mapping.source;
          node.add(new SourceNode(
            mapping.originalLine,
            mapping.originalColumn,
            source2,
            code,
            mapping.name
          ));
        }
      }
    };
    SourceNode.prototype.add = function SourceNode_add(aChunk) {
      if (Array.isArray(aChunk)) {
        aChunk.forEach(function(chunk) {
          this.add(chunk);
        }, this);
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        if (aChunk) {
          this.children.push(aChunk);
        }
      } else {
        throw new TypeError(
          "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
        );
      }
      return this;
    };
    SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
      if (Array.isArray(aChunk)) {
        for (var i = aChunk.length - 1; i >= 0; i--) {
          this.prepend(aChunk[i]);
        }
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        this.children.unshift(aChunk);
      } else {
        throw new TypeError(
          "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
        );
      }
      return this;
    };
    SourceNode.prototype.walk = function SourceNode_walk(aFn) {
      var chunk;
      for (var i = 0, len = this.children.length; i < len; i++) {
        chunk = this.children[i];
        if (chunk[isSourceNode]) {
          chunk.walk(aFn);
        } else {
          if (chunk !== "") {
            aFn(chunk, {
              source: this.source,
              line: this.line,
              column: this.column,
              name: this.name
            });
          }
        }
      }
    };
    SourceNode.prototype.join = function SourceNode_join(aSep) {
      var newChildren;
      var i;
      var len = this.children.length;
      if (len > 0) {
        newChildren = [];
        for (i = 0; i < len - 1; i++) {
          newChildren.push(this.children[i]);
          newChildren.push(aSep);
        }
        newChildren.push(this.children[i]);
        this.children = newChildren;
      }
      return this;
    };
    SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
      var lastChild = this.children[this.children.length - 1];
      if (lastChild[isSourceNode]) {
        lastChild.replaceRight(aPattern, aReplacement);
      } else if (typeof lastChild === "string") {
        this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
      } else {
        this.children.push("".replace(aPattern, aReplacement));
      }
      return this;
    };
    SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
      this.sourceContents[util3.toSetString(aSourceFile)] = aSourceContent;
    };
    SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
      for (var i = 0, len = this.children.length; i < len; i++) {
        if (this.children[i][isSourceNode]) {
          this.children[i].walkSourceContents(aFn);
        }
      }
      var sources = Object.keys(this.sourceContents);
      for (var i = 0, len = sources.length; i < len; i++) {
        aFn(util3.fromSetString(sources[i]), this.sourceContents[sources[i]]);
      }
    };
    SourceNode.prototype.toString = function SourceNode_toString() {
      var str = "";
      this.walk(function(chunk) {
        str += chunk;
      });
      return str;
    };
    SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
      var generated = {
        code: "",
        line: 1,
        column: 0
      };
      var map = new SourceMapGenerator(aArgs);
      var sourceMappingActive = false;
      var lastOriginalSource = null;
      var lastOriginalLine = null;
      var lastOriginalColumn = null;
      var lastOriginalName = null;
      this.walk(function(chunk, original) {
        generated.code += chunk;
        if (original.source !== null && original.line !== null && original.column !== null) {
          if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
          lastOriginalSource = original.source;
          lastOriginalLine = original.line;
          lastOriginalColumn = original.column;
          lastOriginalName = original.name;
          sourceMappingActive = true;
        } else if (sourceMappingActive) {
          map.addMapping({
            generated: {
              line: generated.line,
              column: generated.column
            }
          });
          lastOriginalSource = null;
          sourceMappingActive = false;
        }
        for (var idx = 0, length = chunk.length; idx < length; idx++) {
          if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
            generated.line++;
            generated.column = 0;
            if (idx + 1 === length) {
              lastOriginalSource = null;
              sourceMappingActive = false;
            } else if (sourceMappingActive) {
              map.addMapping({
                source: original.source,
                original: {
                  line: original.line,
                  column: original.column
                },
                generated: {
                  line: generated.line,
                  column: generated.column
                },
                name: original.name
              });
            }
          } else {
            generated.column++;
          }
        }
      });
      this.walkSourceContents(function(sourceFile, sourceContent) {
        map.setSourceContent(sourceFile, sourceContent);
      });
      return { code: generated.code, map };
    };
    exports2.SourceNode = SourceNode;
  }
});

// node_modules/source-map/source-map.js
var require_source_map3 = __commonJS({
  "node_modules/source-map/source-map.js"(exports2) {
    "use strict";
    exports2.SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    exports2.SourceMapConsumer = require_source_map_consumer().SourceMapConsumer;
    exports2.SourceNode = require_source_node().SourceNode;
  }
});

// node_modules/@babel/core/lib/transformation/file/merge-map.js
var require_merge_map = __commonJS({
  "node_modules/@babel/core/lib/transformation/file/merge-map.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = mergeSourceMap;
    function _sourceMap() {
      const data = _interopRequireDefault(require_source_map3());
      _sourceMap = function() {
        return data;
      };
      return data;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function mergeSourceMap(inputMap, map) {
      const input = buildMappingData(inputMap);
      const output = buildMappingData(map);
      const mergedGenerator = new (_sourceMap()).default.SourceMapGenerator();
      for (const _ref of input.sources) {
        const {
          source: source2
        } = _ref;
        if (typeof source2.content === "string") {
          mergedGenerator.setSourceContent(source2.path, source2.content);
        }
      }
      if (output.sources.length === 1) {
        const defaultSource = output.sources[0];
        const insertedMappings = /* @__PURE__ */ new Map();
        eachInputGeneratedRange(input, (generated, original, source2) => {
          eachOverlappingGeneratedOutputRange(defaultSource, generated, (item) => {
            const key2 = makeMappingKey(item);
            if (insertedMappings.has(key2)) return;
            insertedMappings.set(key2, item);
            mergedGenerator.addMapping({
              source: source2.path,
              original: {
                line: original.line,
                column: original.columnStart
              },
              generated: {
                line: item.line,
                column: item.columnStart
              },
              name: original.name
            });
          });
        });
        for (const item of insertedMappings.values()) {
          if (item.columnEnd === Infinity) {
            continue;
          }
          const clearItem = {
            line: item.line,
            columnStart: item.columnEnd
          };
          const key2 = makeMappingKey(clearItem);
          if (insertedMappings.has(key2)) {
            continue;
          }
          mergedGenerator.addMapping({
            generated: {
              line: clearItem.line,
              column: clearItem.columnStart
            }
          });
        }
      }
      const result = mergedGenerator.toJSON();
      if (typeof input.sourceRoot === "string") {
        result.sourceRoot = input.sourceRoot;
      }
      return result;
    }
    function makeMappingKey(item) {
      return `${item.line}/${item.columnStart}`;
    }
    function eachOverlappingGeneratedOutputRange(outputFile, inputGeneratedRange, callback) {
      const overlappingOriginal = filterApplicableOriginalRanges(outputFile, inputGeneratedRange);
      for (const _ref2 of overlappingOriginal) {
        const {
          generated
        } = _ref2;
        for (const item of generated) {
          callback(item);
        }
      }
    }
    function filterApplicableOriginalRanges({
      mappings
    }, {
      line: line2,
      columnStart,
      columnEnd
    }) {
      return filterSortedArray(mappings, ({
        original: outOriginal
      }) => {
        if (line2 > outOriginal.line) return -1;
        if (line2 < outOriginal.line) return 1;
        if (columnStart >= outOriginal.columnEnd) return -1;
        if (columnEnd <= outOriginal.columnStart) return 1;
        return 0;
      });
    }
    function eachInputGeneratedRange(map, callback) {
      for (const _ref3 of map.sources) {
        const {
          source: source2,
          mappings
        } = _ref3;
        for (const _ref4 of mappings) {
          const {
            original,
            generated
          } = _ref4;
          for (const item of generated) {
            callback(item, original, source2);
          }
        }
      }
    }
    function buildMappingData(map) {
      const consumer = new (_sourceMap()).default.SourceMapConsumer(Object.assign({}, map, {
        sourceRoot: null
      }));
      const sources = /* @__PURE__ */ new Map();
      const mappings = /* @__PURE__ */ new Map();
      let last = null;
      consumer.computeColumnSpans();
      consumer.eachMapping((m) => {
        if (m.originalLine === null) return;
        let source2 = sources.get(m.source);
        if (!source2) {
          source2 = {
            path: m.source,
            content: consumer.sourceContentFor(m.source, true)
          };
          sources.set(m.source, source2);
        }
        let sourceData = mappings.get(source2);
        if (!sourceData) {
          sourceData = {
            source: source2,
            mappings: []
          };
          mappings.set(source2, sourceData);
        }
        const obj = {
          line: m.originalLine,
          columnStart: m.originalColumn,
          columnEnd: Infinity,
          name: m.name
        };
        if (last && last.source === source2 && last.mapping.line === m.originalLine) {
          last.mapping.columnEnd = m.originalColumn;
        }
        last = {
          source: source2,
          mapping: obj
        };
        sourceData.mappings.push({
          original: obj,
          generated: consumer.allGeneratedPositionsFor({
            source: m.source,
            line: m.originalLine,
            column: m.originalColumn
          }).map((item) => ({
            line: item.line,
            columnStart: item.column,
            columnEnd: item.lastColumn + 1
          }))
        });
      }, null, _sourceMap().default.SourceMapConsumer.ORIGINAL_ORDER);
      return {
        file: map.file,
        sourceRoot: map.sourceRoot,
        sources: Array.from(mappings.values())
      };
    }
    function findInsertionLocation(array, callback) {
      let left = 0;
      let right = array.length;
      while (left < right) {
        const mid = Math.floor((left + right) / 2);
        const item = array[mid];
        const result = callback(item);
        if (result === 0) {
          left = mid;
          break;
        }
        if (result >= 0) {
          right = mid;
        } else {
          left = mid + 1;
        }
      }
      let i = left;
      if (i < array.length) {
        while (i >= 0 && callback(array[i]) >= 0) {
          i--;
        }
        return i + 1;
      }
      return i;
    }
    function filterSortedArray(array, callback) {
      const start = findInsertionLocation(array, callback);
      const results = [];
      for (let i = start; i < array.length && callback(array[i]) === 0; i++) {
        results.push(array[i]);
      }
      return results;
    }
  }
});

// node_modules/@babel/core/lib/transformation/file/generate.js
var require_generate = __commonJS({
  "node_modules/@babel/core/lib/transformation/file/generate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = generateCode;
    function _convertSourceMap() {
      const data = _interopRequireDefault(require_convert_source_map());
      _convertSourceMap = function() {
        return data;
      };
      return data;
    }
    function _generator() {
      const data = _interopRequireDefault(require_lib8());
      _generator = function() {
        return data;
      };
      return data;
    }
    var _mergeMap = _interopRequireDefault(require_merge_map());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function generateCode(pluginPasses, file) {
      const {
        opts,
        ast,
        code,
        inputMap
      } = file;
      const results = [];
      for (const plugins of pluginPasses) {
        for (const plugin of plugins) {
          const {
            generatorOverride
          } = plugin;
          if (generatorOverride) {
            const result2 = generatorOverride(ast, opts.generatorOpts, code, _generator().default);
            if (result2 !== void 0) results.push(result2);
          }
        }
      }
      let result;
      if (results.length === 0) {
        result = (0, _generator().default)(ast, opts.generatorOpts, code);
      } else if (results.length === 1) {
        result = results[0];
        if (typeof result.then === "function") {
          throw new Error(`You appear to be using an async parser plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.`);
        }
      } else {
        throw new Error("More than one plugin attempted to override codegen.");
      }
      let {
        code: outputCode,
        map: outputMap
      } = result;
      if (outputMap && inputMap) {
        outputMap = (0, _mergeMap.default)(inputMap.toObject(), outputMap);
      }
      if (opts.sourceMaps === "inline" || opts.sourceMaps === "both") {
        outputCode += "\n" + _convertSourceMap().default.fromObject(outputMap).toComment();
      }
      if (opts.sourceMaps === "inline") {
        outputMap = null;
      }
      return {
        outputCode,
        outputMap
      };
    }
  }
});

// node_modules/@babel/core/lib/transformation/index.js
var require_transformation = __commonJS({
  "node_modules/@babel/core/lib/transformation/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.runAsync = runAsync;
    exports2.runSync = runSync;
    function _traverse() {
      const data = _interopRequireDefault(require_lib9());
      _traverse = function() {
        return data;
      };
      return data;
    }
    var _pluginPass = _interopRequireDefault(require_plugin_pass());
    var _blockHoistPlugin = _interopRequireDefault(require_block_hoist_plugin());
    var _normalizeOpts = _interopRequireDefault(require_normalize_opts());
    var _normalizeFile = _interopRequireDefault(require_normalize_file());
    var _generate = _interopRequireDefault(require_generate());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function runAsync(config, code, ast, callback) {
      let result;
      try {
        result = runSync(config, code, ast);
      } catch (err) {
        return callback(err);
      }
      return callback(null, result);
    }
    function runSync(config, code, ast) {
      const file = (0, _normalizeFile.default)(config.passes, (0, _normalizeOpts.default)(config), code, ast);
      transformFile(file, config.passes);
      const opts = file.opts;
      const {
        outputCode,
        outputMap
      } = opts.code !== false ? (0, _generate.default)(config.passes, file) : {};
      return {
        metadata: file.metadata,
        options: opts,
        ast: opts.ast === true ? file.ast : null,
        code: outputCode === void 0 ? null : outputCode,
        map: outputMap === void 0 ? null : outputMap,
        sourceType: file.ast.program.sourceType
      };
    }
    function transformFile(file, pluginPasses) {
      for (const pluginPairs of pluginPasses) {
        const passPairs = [];
        const passes = [];
        const visitors = [];
        for (const plugin of pluginPairs.concat([(0, _blockHoistPlugin.default)()])) {
          const pass = new _pluginPass.default(file, plugin.key, plugin.options);
          passPairs.push([plugin, pass]);
          passes.push(pass);
          visitors.push(plugin.visitor);
        }
        for (const [plugin, pass] of passPairs) {
          const fn = plugin.pre;
          if (fn) {
            const result = fn.call(pass, file);
            if (isThenable(result)) {
              throw new Error(`You appear to be using an plugin with an async .pre, which your current version of Babel does not support.If you're using a published plugin, you may need to upgrade your @babel/core version.`);
            }
          }
        }
        const visitor = _traverse().default.visitors.merge(visitors, passes, file.opts.wrapPluginVisitorMethod);
        (0, _traverse().default)(file.ast, visitor, file.scope);
        for (const [plugin, pass] of passPairs) {
          const fn = plugin.post;
          if (fn) {
            const result = fn.call(pass, file);
            if (isThenable(result)) {
              throw new Error(`You appear to be using an plugin with an async .post, which your current version of Babel does not support.If you're using a published plugin, you may need to upgrade your @babel/core version.`);
            }
          }
        }
      }
    }
    function isThenable(val) {
      return !!val && (typeof val === "object" || typeof val === "function") && typeof val.then === "function";
    }
  }
});

// node_modules/@babel/core/lib/transform.js
var require_transform = __commonJS({
  "node_modules/@babel/core/lib/transform.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.transformSync = transformSync;
    exports2.transformAsync = transformAsync;
    exports2.transform = void 0;
    var _config = _interopRequireDefault(require_config());
    var _transformation = require_transformation();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var transform = function transform2(code, opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
        opts = void 0;
      }
      if (callback === void 0) return transformSync(code, opts);
      const cb = callback;
      process.nextTick(() => {
        let cfg;
        try {
          cfg = (0, _config.default)(opts);
          if (cfg === null) return cb(null, null);
        } catch (err) {
          return cb(err);
        }
        (0, _transformation.runAsync)(cfg, code, null, cb);
      });
    };
    exports2.transform = transform;
    function transformSync(code, opts) {
      const config = (0, _config.default)(opts);
      if (config === null) return null;
      return (0, _transformation.runSync)(config, code);
    }
    function transformAsync(code, opts) {
      return new Promise((res, rej) => {
        transform(code, opts, (err, result) => {
          if (err == null) res(result);
          else rej(err);
        });
      });
    }
  }
});

// node_modules/@babel/core/lib/transform-file.js
var require_transform_file = __commonJS({
  "node_modules/@babel/core/lib/transform-file.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.transformFileSync = transformFileSync;
    exports2.transformFileAsync = transformFileAsync;
    exports2.transformFile = void 0;
    function _fs() {
      const data = _interopRequireDefault(require("fs"));
      _fs = function() {
        return data;
      };
      return data;
    }
    var _config = _interopRequireDefault(require_config());
    var _transformation = require_transformation();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var transformFile = function transformFile2(filename, opts, callback) {
      let options;
      if (typeof opts === "function") {
        callback = opts;
        opts = void 0;
      }
      if (opts == null) {
        options = {
          filename
        };
      } else if (opts && typeof opts === "object") {
        options = Object.assign({}, opts, {
          filename
        });
      }
      process.nextTick(() => {
        let cfg;
        try {
          cfg = (0, _config.default)(options);
          if (cfg === null) return callback(null, null);
        } catch (err) {
          return callback(err);
        }
        const config = cfg;
        _fs().default.readFile(filename, "utf8", function(err, code) {
          if (err) return callback(err, null);
          (0, _transformation.runAsync)(config, code, null, callback);
        });
      });
    };
    exports2.transformFile = transformFile;
    function transformFileSync(filename, opts) {
      let options;
      if (opts == null) {
        options = {
          filename
        };
      } else if (opts && typeof opts === "object") {
        options = Object.assign({}, opts, {
          filename
        });
      }
      const config = (0, _config.default)(options);
      if (config === null) return null;
      return (0, _transformation.runSync)(config, _fs().default.readFileSync(filename, "utf8"));
    }
    function transformFileAsync(filename, opts) {
      return new Promise((res, rej) => {
        transformFile(filename, opts, (err, result) => {
          if (err == null) res(result);
          else rej(err);
        });
      });
    }
  }
});

// node_modules/@babel/core/lib/transform-ast.js
var require_transform_ast = __commonJS({
  "node_modules/@babel/core/lib/transform-ast.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.transformFromAstSync = transformFromAstSync2;
    exports2.transformFromAstAsync = transformFromAstAsync;
    exports2.transformFromAst = void 0;
    var _config = _interopRequireDefault(require_config());
    var _transformation = require_transformation();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var transformFromAst = function transformFromAst2(ast, code, opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
        opts = void 0;
      }
      if (callback === void 0) return transformFromAstSync2(ast, code, opts);
      const cb = callback;
      process.nextTick(() => {
        let cfg;
        try {
          cfg = (0, _config.default)(opts);
          if (cfg === null) return cb(null, null);
        } catch (err) {
          return cb(err);
        }
        if (!ast) return cb(new Error("No AST given"));
        (0, _transformation.runAsync)(cfg, code, ast, cb);
      });
    };
    exports2.transformFromAst = transformFromAst;
    function transformFromAstSync2(ast, code, opts) {
      const config = (0, _config.default)(opts);
      if (config === null) return null;
      if (!ast) throw new Error("No AST given");
      return (0, _transformation.runSync)(config, code, ast);
    }
    function transformFromAstAsync(ast, code, opts) {
      return new Promise((res, rej) => {
        transformFromAst(ast, code, opts, (err, result) => {
          if (err == null) res(result);
          else rej(err);
        });
      });
    }
  }
});

// node_modules/@babel/core/lib/parse.js
var require_parse2 = __commonJS({
  "node_modules/@babel/core/lib/parse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.parseSync = parseSync;
    exports2.parseAsync = parseAsync;
    exports2.parse = void 0;
    var _config = _interopRequireDefault(require_config());
    var _normalizeFile = _interopRequireDefault(require_normalize_file());
    var _normalizeOpts = _interopRequireDefault(require_normalize_opts());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var parse4 = function parse5(code, opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
        opts = void 0;
      }
      if (callback === void 0) return parseSync(code, opts);
      const config = (0, _config.default)(opts);
      if (config === null) {
        return null;
      }
      const cb = callback;
      process.nextTick(() => {
        let ast = null;
        try {
          const cfg = (0, _config.default)(opts);
          if (cfg === null) return cb(null, null);
          ast = (0, _normalizeFile.default)(cfg.passes, (0, _normalizeOpts.default)(cfg), code).ast;
        } catch (err) {
          return cb(err);
        }
        cb(null, ast);
      });
    };
    exports2.parse = parse4;
    function parseSync(code, opts) {
      const config = (0, _config.default)(opts);
      if (config === null) {
        return null;
      }
      return (0, _normalizeFile.default)(config.passes, (0, _normalizeOpts.default)(config), code).ast;
    }
    function parseAsync(code, opts) {
      return new Promise((res, rej) => {
        parse4(code, opts, (err, result) => {
          if (err == null) res(result);
          else rej(err);
        });
      });
    }
  }
});

// node_modules/@babel/core/lib/index.js
var require_lib10 = __commonJS({
  "node_modules/@babel/core/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Plugin = Plugin;
    Object.defineProperty(exports2, "File", {
      enumerable: true,
      get: function() {
        return _file.default;
      }
    });
    Object.defineProperty(exports2, "buildExternalHelpers", {
      enumerable: true,
      get: function() {
        return _buildExternalHelpers.default;
      }
    });
    Object.defineProperty(exports2, "resolvePlugin", {
      enumerable: true,
      get: function() {
        return _files.resolvePlugin;
      }
    });
    Object.defineProperty(exports2, "resolvePreset", {
      enumerable: true,
      get: function() {
        return _files.resolvePreset;
      }
    });
    Object.defineProperty(exports2, "version", {
      enumerable: true,
      get: function() {
        return _package.version;
      }
    });
    Object.defineProperty(exports2, "getEnv", {
      enumerable: true,
      get: function() {
        return _environment.getEnv;
      }
    });
    Object.defineProperty(exports2, "tokTypes", {
      enumerable: true,
      get: function() {
        return _parser().tokTypes;
      }
    });
    Object.defineProperty(exports2, "traverse", {
      enumerable: true,
      get: function() {
        return _traverse().default;
      }
    });
    Object.defineProperty(exports2, "template", {
      enumerable: true,
      get: function() {
        return _template().default;
      }
    });
    Object.defineProperty(exports2, "createConfigItem", {
      enumerable: true,
      get: function() {
        return _item.createConfigItem;
      }
    });
    Object.defineProperty(exports2, "loadPartialConfig", {
      enumerable: true,
      get: function() {
        return _config.loadPartialConfig;
      }
    });
    Object.defineProperty(exports2, "loadOptions", {
      enumerable: true,
      get: function() {
        return _config.loadOptions;
      }
    });
    Object.defineProperty(exports2, "transform", {
      enumerable: true,
      get: function() {
        return _transform.transform;
      }
    });
    Object.defineProperty(exports2, "transformSync", {
      enumerable: true,
      get: function() {
        return _transform.transformSync;
      }
    });
    Object.defineProperty(exports2, "transformAsync", {
      enumerable: true,
      get: function() {
        return _transform.transformAsync;
      }
    });
    Object.defineProperty(exports2, "transformFile", {
      enumerable: true,
      get: function() {
        return _transformFile.transformFile;
      }
    });
    Object.defineProperty(exports2, "transformFileSync", {
      enumerable: true,
      get: function() {
        return _transformFile.transformFileSync;
      }
    });
    Object.defineProperty(exports2, "transformFileAsync", {
      enumerable: true,
      get: function() {
        return _transformFile.transformFileAsync;
      }
    });
    Object.defineProperty(exports2, "transformFromAst", {
      enumerable: true,
      get: function() {
        return _transformAst.transformFromAst;
      }
    });
    Object.defineProperty(exports2, "transformFromAstSync", {
      enumerable: true,
      get: function() {
        return _transformAst.transformFromAstSync;
      }
    });
    Object.defineProperty(exports2, "transformFromAstAsync", {
      enumerable: true,
      get: function() {
        return _transformAst.transformFromAstAsync;
      }
    });
    Object.defineProperty(exports2, "parse", {
      enumerable: true,
      get: function() {
        return _parse.parse;
      }
    });
    Object.defineProperty(exports2, "parseSync", {
      enumerable: true,
      get: function() {
        return _parse.parseSync;
      }
    });
    Object.defineProperty(exports2, "parseAsync", {
      enumerable: true,
      get: function() {
        return _parse.parseAsync;
      }
    });
    exports2.types = exports2.OptionManager = exports2.DEFAULT_EXTENSIONS = void 0;
    var _file = _interopRequireDefault(require_file());
    var _buildExternalHelpers = _interopRequireDefault(require_build_external_helpers());
    var _files = require_files();
    var _package = require_package2();
    var _environment = require_environment();
    function _types2() {
      const data = _interopRequireWildcard(require("@babel/types"));
      _types2 = function() {
        return data;
      };
      return data;
    }
    Object.defineProperty(exports2, "types", {
      enumerable: true,
      get: function() {
        return _types2();
      }
    });
    function _parser() {
      const data = require_lib4();
      _parser = function() {
        return data;
      };
      return data;
    }
    function _traverse() {
      const data = _interopRequireDefault(require_lib9());
      _traverse = function() {
        return data;
      };
      return data;
    }
    function _template() {
      const data = _interopRequireDefault(require_lib5());
      _template = function() {
        return data;
      };
      return data;
    }
    var _item = require_item();
    var _config = require_config();
    var _transform = require_transform();
    var _transformFile = require_transform_file();
    var _transformAst = require_transform_ast();
    var _parse = require_parse2();
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key2 in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key2)) {
              var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key2) : {};
              if (desc.get || desc.set) {
                Object.defineProperty(newObj, key2, desc);
              } else {
                newObj[key2] = obj[key2];
              }
            }
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var DEFAULT_EXTENSIONS = Object.freeze([".js", ".jsx", ".es6", ".es", ".mjs"]);
    exports2.DEFAULT_EXTENSIONS = DEFAULT_EXTENSIONS;
    var OptionManager = class {
      init(opts) {
        return (0, _config.loadOptions)(opts);
      }
    };
    exports2.OptionManager = OptionManager;
    function Plugin(alias) {
      throw new Error(`The (${alias}) Babel 5 plugin is being run with an unsupported Babel version.`);
    }
  }
});

// ../../node_modules/invariant/invariant.js
var require_invariant = __commonJS({
  "../../node_modules/invariant/invariant.js"(exports2, module2) {
    "use strict";
    var NODE_ENV = process.env.NODE_ENV;
    var invariant5 = function(condition, format, a, b, c2, d, e, f) {
      if (NODE_ENV !== "production") {
        if (format === void 0) {
          throw new Error("invariant requires an error message argument");
        }
      }
      if (!condition) {
        var error;
        if (format === void 0) {
          error = new Error(
            "Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings."
          );
        } else {
          var args = [a, b, c2, d, e, f];
          var argIndex = 0;
          error = new Error(
            format.replace(/%s/g, function() {
              return args[argIndex++];
            })
          );
          error.name = "Invariant Violation";
        }
        error.framesToPop = 1;
        throw error;
      }
    };
    module2.exports = invariant5;
  }
});

// ../../node_modules/color-convert/node_modules/color-name/index.js
var require_color_name = __commonJS({
  "../../node_modules/color-convert/node_modules/color-name/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// ../../node_modules/color-convert/conversions.js
var require_conversions = __commonJS({
  "../../node_modules/color-convert/conversions.js"(exports2, module2) {
    "use strict";
    var cssKeywords = require_color_name();
    var reverseKeywords = {};
    for (key2 in cssKeywords) {
      if (cssKeywords.hasOwnProperty(key2)) {
        reverseKeywords[cssKeywords[key2]] = key2;
      }
    }
    var key2;
    var convert = module2.exports = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    for (model in convert) {
      if (convert.hasOwnProperty(model)) {
        if (!("channels" in convert[model])) {
          throw new Error("missing channels property: " + model);
        }
        if (!("labels" in convert[model])) {
          throw new Error("missing channel labels property: " + model);
        }
        if (convert[model].labels.length !== convert[model].channels) {
          throw new Error("channel and label counts mismatch: " + model);
        }
        channels = convert[model].channels;
        labels = convert[model].labels;
        delete convert[model].channels;
        delete convert[model].labels;
        Object.defineProperty(convert[model], "channels", { value: channels });
        Object.defineProperty(convert[model], "labels", { value: labels });
      }
    }
    var channels;
    var labels;
    var model;
    convert.rgb.hsl = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var min = Math.min(r, g, b);
      var max = Math.max(r, g, b);
      var delta = max - min;
      var h;
      var s;
      var l;
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
    convert.rgb.hsv = function(rgb) {
      var rdif;
      var gdif;
      var bdif;
      var h;
      var s;
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var v = Math.max(r, g, b);
      var diff = v - Math.min(r, g, b);
      var diffc = function(c2) {
        return (v - c2) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h = s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      var r = rgb[0];
      var g = rgb[1];
      var b = rgb[2];
      var h = convert.rgb.hsl(rgb)[0];
      var w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var c2;
      var m;
      var y;
      var k;
      k = Math.min(1 - r, 1 - g, 1 - b);
      c2 = (1 - r - k) / (1 - k) || 0;
      m = (1 - g - k) / (1 - k) || 0;
      y = (1 - b - k) / (1 - k) || 0;
      return [c2 * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
    }
    convert.rgb.keyword = function(rgb) {
      var reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      var currentClosestDistance = Infinity;
      var currentClosestKeyword;
      for (var keyword in cssKeywords) {
        if (cssKeywords.hasOwnProperty(keyword)) {
          var value = cssKeywords[keyword];
          var distance = comparativeDistance(rgb, value);
          if (distance < currentClosestDistance) {
            currentClosestDistance = distance;
            currentClosestKeyword = keyword;
          }
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
      g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
      b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
      var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      var z2 = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z2 * 100];
    };
    convert.rgb.lab = function(rgb) {
      var xyz = convert.rgb.xyz(rgb);
      var x = xyz[0];
      var y = xyz[1];
      var z2 = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z2 /= 108.883;
      x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z2 = z2 > 8856e-6 ? Math.pow(z2, 1 / 3) : 7.787 * z2 + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z2);
      return [l, a, b];
    };
    convert.hsl.rgb = function(hsl) {
      var h = hsl[0] / 360;
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var t1;
      var t22;
      var t32;
      var rgb;
      var val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t22 = l * (1 + s);
      } else {
        t22 = l + s - l * s;
      }
      t1 = 2 * l - t22;
      rgb = [0, 0, 0];
      for (var i = 0; i < 3; i++) {
        t32 = h + 1 / 3 * -(i - 1);
        if (t32 < 0) {
          t32++;
        }
        if (t32 > 1) {
          t32--;
        }
        if (6 * t32 < 1) {
          val = t1 + (t22 - t1) * 6 * t32;
        } else if (2 * t32 < 1) {
          val = t22;
        } else if (3 * t32 < 2) {
          val = t1 + (t22 - t1) * (2 / 3 - t32) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      var h = hsl[0];
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var smin = s;
      var lmin = Math.max(l, 0.01);
      var sv;
      var v;
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      v = (l + s) / 2;
      sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert.hsv.rgb = function(hsv) {
      var h = hsv[0] / 60;
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var hi = Math.floor(h) % 6;
      var f = h - Math.floor(h);
      var p = 255 * v * (1 - s);
      var q = 255 * v * (1 - s * f);
      var t6 = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t6, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t6];
        case 3:
          return [p, q, v];
        case 4:
          return [t6, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert.hsv.hsl = function(hsv) {
      var h = hsv[0];
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var vmin = Math.max(v, 0.01);
      var lmin;
      var sl;
      var l;
      l = (2 - s) * v;
      lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert.hwb.rgb = function(hwb) {
      var h = hwb[0] / 360;
      var wh = hwb[1] / 100;
      var bl = hwb[2] / 100;
      var ratio = wh + bl;
      var i;
      var v;
      var f;
      var n;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      i = Math.floor(6 * h);
      v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      n = wh + f * (v - wh);
      var r;
      var g;
      var b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      var c2 = cmyk[0] / 100;
      var m = cmyk[1] / 100;
      var y = cmyk[2] / 100;
      var k = cmyk[3] / 100;
      var r;
      var g;
      var b;
      r = 1 - Math.min(1, c2 * (1 - k) + k);
      g = 1 - Math.min(1, m * (1 - k) + k);
      b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      var x = xyz[0] / 100;
      var y = xyz[1] / 100;
      var z2 = xyz[2] / 100;
      var r;
      var g;
      var b;
      r = x * 3.2406 + y * -1.5372 + z2 * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z2 * 0.0415;
      b = x * 0.0557 + y * -0.204 + z2 * 1.057;
      r = r > 31308e-7 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      var x = xyz[0];
      var y = xyz[1];
      var z2 = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z2 /= 108.883;
      x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z2 = z2 > 8856e-6 ? Math.pow(z2, 1 / 3) : 7.787 * z2 + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z2);
      return [l, a, b];
    };
    convert.lab.xyz = function(lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var x;
      var y;
      var z2;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z2 = y - b / 200;
      var y2 = Math.pow(y, 3);
      var x2 = Math.pow(x, 3);
      var z22 = Math.pow(z2, 3);
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z2 = z22 > 8856e-6 ? z22 : (z2 - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z2 *= 108.883;
      return [x, y, z2];
    };
    convert.lab.lch = function(lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var hr;
      var h;
      var c2;
      hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      c2 = Math.sqrt(a * a + b * b);
      return [l, c2, h];
    };
    convert.lch.lab = function(lch) {
      var l = lch[0];
      var c2 = lch[1];
      var h = lch[2];
      var a;
      var b;
      var hr;
      hr = h / 360 * 2 * Math.PI;
      a = c2 * Math.cos(hr);
      b = c2 * Math.sin(hr);
      return [l, a, b];
    };
    convert.rgb.ansi16 = function(args) {
      var r = args[0];
      var g = args[1];
      var b = args[2];
      var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2];
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      var r = args[0];
      var g = args[1];
      var b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      var color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      var mult = (~~(args > 50) + 1) * 0.5;
      var r = (color & 1) * mult * 255;
      var g = (color >> 1 & 1) * mult * 255;
      var b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        var c2 = (args - 232) * 10 + 8;
        return [c2, c2, c2];
      }
      args -= 16;
      var rem;
      var r = Math.floor(args / 36) / 5 * 255;
      var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      var b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert.rgb.hex = function(args) {
      var integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      var string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      var colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map(function(char) {
          return char + char;
        }).join("");
      }
      var integer = parseInt(colorString, 16);
      var r = integer >> 16 & 255;
      var g = integer >> 8 & 255;
      var b = integer & 255;
      return [r, g, b];
    };
    convert.rgb.hcg = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var max = Math.max(Math.max(r, g), b);
      var min = Math.min(Math.min(r, g), b);
      var chroma = max - min;
      var grayscale;
      var hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma + 4;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var c2 = 1;
      var f = 0;
      if (l < 0.5) {
        c2 = 2 * s * l;
      } else {
        c2 = 2 * s * (1 - l);
      }
      if (c2 < 1) {
        f = (l - 0.5 * c2) / (1 - c2);
      }
      return [hsl[0], c2 * 100, f * 100];
    };
    convert.hsv.hcg = function(hsv) {
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var c2 = s * v;
      var f = 0;
      if (c2 < 1) {
        f = (v - c2) / (1 - c2);
      }
      return [hsv[0], c2 * 100, f * 100];
    };
    convert.hcg.rgb = function(hcg) {
      var h = hcg[0] / 360;
      var c2 = hcg[1] / 100;
      var g = hcg[2] / 100;
      if (c2 === 0) {
        return [g * 255, g * 255, g * 255];
      }
      var pure = [0, 0, 0];
      var hi = h % 1 * 6;
      var v = hi % 1;
      var w = 1 - v;
      var mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c2) * g;
      return [
        (c2 * pure[0] + mg) * 255,
        (c2 * pure[1] + mg) * 255,
        (c2 * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      var c2 = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c2 + g * (1 - c2);
      var f = 0;
      if (v > 0) {
        f = c2 / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert.hcg.hsl = function(hcg) {
      var c2 = hcg[1] / 100;
      var g = hcg[2] / 100;
      var l = g * (1 - c2) + 0.5 * c2;
      var s = 0;
      if (l > 0 && l < 0.5) {
        s = c2 / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c2 / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert.hcg.hwb = function(hcg) {
      var c2 = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c2 + g * (1 - c2);
      return [hcg[0], (v - c2) * 100, (1 - v) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      var w = hwb[1] / 100;
      var b = hwb[2] / 100;
      var v = 1 - b;
      var c2 = v - w;
      var g = 0;
      if (c2 < 1) {
        g = (v - c2) / (1 - c2);
      }
      return [hwb[0], c2 * 100, g * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = convert.gray.hsv = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      var val = Math.round(gray[0] / 100 * 255) & 255;
      var integer = (val << 16) + (val << 8) + val;
      var string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// ../../node_modules/color-convert/route.js
var require_route = __commonJS({
  "../../node_modules/color-convert/route.js"(exports2, module2) {
    "use strict";
    var conversions = require_conversions();
    function buildGraph() {
      var graph = {};
      var models = Object.keys(conversions);
      for (var len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      var graph = buildGraph();
      var queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        var current = queue.pop();
        var adjacents = Object.keys(conversions[current]);
        for (var len = adjacents.length, i = 0; i < len; i++) {
          var adjacent = adjacents[i];
          var node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      var path = [graph[toModel].parent, toModel];
      var fn = conversions[graph[toModel].parent][toModel];
      var cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path;
      return fn;
    }
    module2.exports = function(fromModel) {
      var graph = deriveBFS(fromModel);
      var conversion = {};
      var models = Object.keys(graph);
      for (var len = models.length, i = 0; i < len; i++) {
        var toModel = models[i];
        var node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// ../../node_modules/color-convert/index.js
var require_color_convert = __commonJS({
  "../../node_modules/color-convert/index.js"(exports2, module2) {
    "use strict";
    var conversions = require_conversions();
    var route = require_route();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      var wrappedFn = function(args) {
        if (args === void 0 || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      var wrappedFn = function(args) {
        if (args === void 0 || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        var result = fn(args);
        if (typeof result === "object") {
          for (var len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach(function(fromModel) {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      var routes = route(fromModel);
      var routeModels = Object.keys(routes);
      routeModels.forEach(function(toModel) {
        var fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module2.exports = convert;
  }
});

// node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS({
  "node_modules/ansi-styles/index.js"(exports2, module2) {
    "use strict";
    var colorConvert = require_color_convert();
    var wrapAnsi16 = (fn, offset) => function() {
      const code = fn.apply(colorConvert, arguments);
      return `\x1B[${code + offset}m`;
    };
    var wrapAnsi256 = (fn, offset) => function() {
      const code = fn.apply(colorConvert, arguments);
      return `\x1B[${38 + offset};5;${code}m`;
    };
    var wrapAnsi16m = (fn, offset) => function() {
      const rgb = fn.apply(colorConvert, arguments);
      return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
    function assembleStyles() {
      const codes = /* @__PURE__ */ new Map();
      const styles = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          gray: [90, 39],
          // Bright color
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles.color.grey = styles.color.gray;
      for (const groupName of Object.keys(styles)) {
        const group = styles[groupName];
        for (const styleName of Object.keys(group)) {
          const style = group[styleName];
          styles[styleName] = {
            open: `\x1B[${style[0]}m`,
            close: `\x1B[${style[1]}m`
          };
          group[styleName] = styles[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false
        });
        Object.defineProperty(styles, "codes", {
          value: codes,
          enumerable: false
        });
      }
      const ansi2ansi = (n) => n;
      const rgb2rgb = (r, g, b) => [r, g, b];
      styles.color.close = "\x1B[39m";
      styles.bgColor.close = "\x1B[49m";
      styles.color.ansi = {
        ansi: wrapAnsi16(ansi2ansi, 0)
      };
      styles.color.ansi256 = {
        ansi256: wrapAnsi256(ansi2ansi, 0)
      };
      styles.color.ansi16m = {
        rgb: wrapAnsi16m(rgb2rgb, 0)
      };
      styles.bgColor.ansi = {
        ansi: wrapAnsi16(ansi2ansi, 10)
      };
      styles.bgColor.ansi256 = {
        ansi256: wrapAnsi256(ansi2ansi, 10)
      };
      styles.bgColor.ansi16m = {
        rgb: wrapAnsi16m(rgb2rgb, 10)
      };
      for (let key2 of Object.keys(colorConvert)) {
        if (typeof colorConvert[key2] !== "object") {
          continue;
        }
        const suite = colorConvert[key2];
        if (key2 === "ansi16") {
          key2 = "ansi";
        }
        if ("ansi16" in suite) {
          styles.color.ansi[key2] = wrapAnsi16(suite.ansi16, 0);
          styles.bgColor.ansi[key2] = wrapAnsi16(suite.ansi16, 10);
        }
        if ("ansi256" in suite) {
          styles.color.ansi256[key2] = wrapAnsi256(suite.ansi256, 0);
          styles.bgColor.ansi256[key2] = wrapAnsi256(suite.ansi256, 10);
        }
        if ("rgb" in suite) {
          styles.color.ansi16m[key2] = wrapAnsi16m(suite.rgb, 0);
          styles.bgColor.ansi16m[key2] = wrapAnsi16m(suite.rgb, 10);
        }
      }
      return styles;
    }
    Object.defineProperty(module2, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// node_modules/pretty-format/build/collections.js
var require_collections = __commonJS({
  "node_modules/pretty-format/build/collections.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.printIteratorEntries = printIteratorEntries;
    exports2.printIteratorValues = printIteratorValues;
    exports2.printListItems = printListItems;
    exports2.printObjectProperties = printObjectProperties;
    var getKeysOfEnumerableProperties = (object) => {
      const keys = Object.keys(object).sort();
      if (Object.getOwnPropertySymbols) {
        Object.getOwnPropertySymbols(object).forEach((symbol) => {
          if (Object.getOwnPropertyDescriptor(object, symbol).enumerable) {
            keys.push(symbol);
          }
        });
      }
      return keys;
    };
    function printIteratorEntries(iterator, config, indentation, depth, refs, printer, separator = ": ") {
      let result = "";
      let current = iterator.next();
      if (!current.done) {
        result += config.spacingOuter;
        const indentationNext = indentation + config.indent;
        while (!current.done) {
          const name = printer(
            current.value[0],
            config,
            indentationNext,
            depth,
            refs
          );
          const value = printer(
            current.value[1],
            config,
            indentationNext,
            depth,
            refs
          );
          result += indentationNext + name + separator + value;
          current = iterator.next();
          if (!current.done) {
            result += "," + config.spacingInner;
          } else if (!config.min) {
            result += ",";
          }
        }
        result += config.spacingOuter + indentation;
      }
      return result;
    }
    function printIteratorValues(iterator, config, indentation, depth, refs, printer) {
      let result = "";
      let current = iterator.next();
      if (!current.done) {
        result += config.spacingOuter;
        const indentationNext = indentation + config.indent;
        while (!current.done) {
          result += indentationNext + printer(current.value, config, indentationNext, depth, refs);
          current = iterator.next();
          if (!current.done) {
            result += "," + config.spacingInner;
          } else if (!config.min) {
            result += ",";
          }
        }
        result += config.spacingOuter + indentation;
      }
      return result;
    }
    function printListItems(list, config, indentation, depth, refs, printer) {
      let result = "";
      if (list.length) {
        result += config.spacingOuter;
        const indentationNext = indentation + config.indent;
        for (let i = 0; i < list.length; i++) {
          result += indentationNext + printer(list[i], config, indentationNext, depth, refs);
          if (i < list.length - 1) {
            result += "," + config.spacingInner;
          } else if (!config.min) {
            result += ",";
          }
        }
        result += config.spacingOuter + indentation;
      }
      return result;
    }
    function printObjectProperties(val, config, indentation, depth, refs, printer) {
      let result = "";
      const keys = getKeysOfEnumerableProperties(val);
      if (keys.length) {
        result += config.spacingOuter;
        const indentationNext = indentation + config.indent;
        for (let i = 0; i < keys.length; i++) {
          const key2 = keys[i];
          const name = printer(key2, config, indentationNext, depth, refs);
          const value = printer(val[key2], config, indentationNext, depth, refs);
          result += indentationNext + name + ": " + value;
          if (i < keys.length - 1) {
            result += "," + config.spacingInner;
          } else if (!config.min) {
            result += ",";
          }
        }
        result += config.spacingOuter + indentation;
      }
      return result;
    }
  }
});

// node_modules/pretty-format/build/plugins/AsymmetricMatcher.js
var require_AsymmetricMatcher = __commonJS({
  "node_modules/pretty-format/build/plugins/AsymmetricMatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = exports2.test = exports2.serialize = void 0;
    var _collections = require_collections();
    var Symbol2 = global["jest-symbol-do-not-touch"] || global.Symbol;
    var asymmetricMatcher = Symbol2.for("jest.asymmetricMatcher");
    var SPACE = " ";
    var serialize = (val, config, indentation, depth, refs, printer) => {
      const stringedValue = val.toString();
      if (stringedValue === "ArrayContaining" || stringedValue === "ArrayNotContaining") {
        if (++depth > config.maxDepth) {
          return "[" + stringedValue + "]";
        }
        return stringedValue + SPACE + "[" + (0, _collections.printListItems)(
          val.sample,
          config,
          indentation,
          depth,
          refs,
          printer
        ) + "]";
      }
      if (stringedValue === "ObjectContaining" || stringedValue === "ObjectNotContaining") {
        if (++depth > config.maxDepth) {
          return "[" + stringedValue + "]";
        }
        return stringedValue + SPACE + "{" + (0, _collections.printObjectProperties)(
          val.sample,
          config,
          indentation,
          depth,
          refs,
          printer
        ) + "}";
      }
      if (stringedValue === "StringMatching" || stringedValue === "StringNotMatching") {
        return stringedValue + SPACE + printer(val.sample, config, indentation, depth, refs);
      }
      if (stringedValue === "StringContaining" || stringedValue === "StringNotContaining") {
        return stringedValue + SPACE + printer(val.sample, config, indentation, depth, refs);
      }
      return val.toAsymmetricMatcher();
    };
    exports2.serialize = serialize;
    var test = (val) => val && val.$$typeof === asymmetricMatcher;
    exports2.test = test;
    var plugin = {
      serialize,
      test
    };
    var _default = plugin;
    exports2.default = _default;
  }
});

// node_modules/ansi-regex/index.js
var require_ansi_regex = __commonJS({
  "node_modules/ansi-regex/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (options) => {
      options = Object.assign({
        onlyFirst: false
      }, options);
      const pattern = [
        "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
        "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
      ].join("|");
      return new RegExp(pattern, options.onlyFirst ? void 0 : "g");
    };
  }
});

// node_modules/pretty-format/build/plugins/ConvertAnsi.js
var require_ConvertAnsi = __commonJS({
  "node_modules/pretty-format/build/plugins/ConvertAnsi.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = exports2.serialize = exports2.test = void 0;
    var _ansiRegex = _interopRequireDefault(require_ansi_regex());
    var _ansiStyles = _interopRequireDefault(require_ansi_styles());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var toHumanReadableAnsi = (text) => text.replace((0, _ansiRegex.default)(), (match) => {
      switch (match) {
        case _ansiStyles.default.red.close:
        case _ansiStyles.default.green.close:
        case _ansiStyles.default.cyan.close:
        case _ansiStyles.default.gray.close:
        case _ansiStyles.default.white.close:
        case _ansiStyles.default.yellow.close:
        case _ansiStyles.default.bgRed.close:
        case _ansiStyles.default.bgGreen.close:
        case _ansiStyles.default.bgYellow.close:
        case _ansiStyles.default.inverse.close:
        case _ansiStyles.default.dim.close:
        case _ansiStyles.default.bold.close:
        case _ansiStyles.default.reset.open:
        case _ansiStyles.default.reset.close:
          return "</>";
        case _ansiStyles.default.red.open:
          return "<red>";
        case _ansiStyles.default.green.open:
          return "<green>";
        case _ansiStyles.default.cyan.open:
          return "<cyan>";
        case _ansiStyles.default.gray.open:
          return "<gray>";
        case _ansiStyles.default.white.open:
          return "<white>";
        case _ansiStyles.default.yellow.open:
          return "<yellow>";
        case _ansiStyles.default.bgRed.open:
          return "<bgRed>";
        case _ansiStyles.default.bgGreen.open:
          return "<bgGreen>";
        case _ansiStyles.default.bgYellow.open:
          return "<bgYellow>";
        case _ansiStyles.default.inverse.open:
          return "<inverse>";
        case _ansiStyles.default.dim.open:
          return "<dim>";
        case _ansiStyles.default.bold.open:
          return "<bold>";
        default:
          return "";
      }
    });
    var test = (val) => typeof val === "string" && !!val.match((0, _ansiRegex.default)());
    exports2.test = test;
    var serialize = (val, config, indentation, depth, refs, printer) => printer(toHumanReadableAnsi(val), config, indentation, depth, refs);
    exports2.serialize = serialize;
    var plugin = {
      serialize,
      test
    };
    var _default = plugin;
    exports2.default = _default;
  }
});

// node_modules/pretty-format/build/plugins/DOMCollection.js
var require_DOMCollection = __commonJS({
  "node_modules/pretty-format/build/plugins/DOMCollection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = exports2.serialize = exports2.test = void 0;
    var _collections = require_collections();
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source2 = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source2);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys = ownKeys.concat(
            Object.getOwnPropertySymbols(source2).filter(function(sym) {
              return Object.getOwnPropertyDescriptor(source2, sym).enumerable;
            })
          );
        }
        ownKeys.forEach(function(key2) {
          _defineProperty(target, key2, source2[key2]);
        });
      }
      return target;
    }
    function _defineProperty(obj, key2, value) {
      if (key2 in obj) {
        Object.defineProperty(obj, key2, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key2] = value;
      }
      return obj;
    }
    var SPACE = " ";
    var OBJECT_NAMES = ["DOMStringMap", "NamedNodeMap"];
    var ARRAY_REGEXP = /^(HTML\w*Collection|NodeList)$/;
    var testName = (name) => OBJECT_NAMES.indexOf(name) !== -1 || ARRAY_REGEXP.test(name);
    var test = (val) => val && val.constructor && val.constructor.name && testName(val.constructor.name);
    exports2.test = test;
    var propsReducer = (props, attribute) => {
      props[attribute.name] = attribute.value;
      return props;
    };
    var serialize = (collection, config, indentation, depth, refs, printer) => {
      const name = collection.constructor.name;
      if (++depth > config.maxDepth) {
        return "[" + name + "]";
      }
      return (config.min ? "" : name + SPACE) + (OBJECT_NAMES.indexOf(name) !== -1 ? "{" + (0, _collections.printObjectProperties)(
        name === "NamedNodeMap" ? Array.prototype.reduce.call(collection, propsReducer, {}) : _objectSpread({}, collection),
        config,
        indentation,
        depth,
        refs,
        printer
      ) + "}" : "[" + (0, _collections.printListItems)(
        Array.from(collection),
        config,
        indentation,
        depth,
        refs,
        printer
      ) + "]");
    };
    exports2.serialize = serialize;
    var plugin = {
      serialize,
      test
    };
    var _default = plugin;
    exports2.default = _default;
  }
});

// node_modules/pretty-format/build/plugins/lib/escapeHTML.js
var require_escapeHTML = __commonJS({
  "node_modules/pretty-format/build/plugins/lib/escapeHTML.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = escapeHTML;
    function escapeHTML(str) {
      return str.replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }
  }
});

// node_modules/pretty-format/build/plugins/lib/markup.js
var require_markup = __commonJS({
  "node_modules/pretty-format/build/plugins/lib/markup.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.printElementAsLeaf = exports2.printElement = exports2.printComment = exports2.printText = exports2.printChildren = exports2.printProps = void 0;
    var _escapeHTML = _interopRequireDefault(require_escapeHTML());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var printProps = (keys, props, config, indentation, depth, refs, printer) => {
      const indentationNext = indentation + config.indent;
      const colors = config.colors;
      return keys.map((key2) => {
        const value = props[key2];
        let printed = printer(value, config, indentationNext, depth, refs);
        if (typeof value !== "string") {
          if (printed.indexOf("\n") !== -1) {
            printed = config.spacingOuter + indentationNext + printed + config.spacingOuter + indentation;
          }
          printed = "{" + printed + "}";
        }
        return config.spacingInner + indentation + colors.prop.open + key2 + colors.prop.close + "=" + colors.value.open + printed + colors.value.close;
      }).join("");
    };
    exports2.printProps = printProps;
    var printChildren = (children, config, indentation, depth, refs, printer) => children.map(
      (child) => config.spacingOuter + indentation + (typeof child === "string" ? printText(child, config) : printer(child, config, indentation, depth, refs))
    ).join("");
    exports2.printChildren = printChildren;
    var printText = (text, config) => {
      const contentColor = config.colors.content;
      return contentColor.open + (0, _escapeHTML.default)(text) + contentColor.close;
    };
    exports2.printText = printText;
    var printComment = (comment, config) => {
      const commentColor = config.colors.comment;
      return commentColor.open + "<!--" + (0, _escapeHTML.default)(comment) + "-->" + commentColor.close;
    };
    exports2.printComment = printComment;
    var printElement = (type, printedProps, printedChildren, config, indentation) => {
      const tagColor = config.colors.tag;
      return tagColor.open + "<" + type + (printedProps && tagColor.close + printedProps + config.spacingOuter + indentation + tagColor.open) + (printedChildren ? ">" + tagColor.close + printedChildren + config.spacingOuter + indentation + tagColor.open + "</" + type : (printedProps && !config.min ? "" : " ") + "/") + ">" + tagColor.close;
    };
    exports2.printElement = printElement;
    var printElementAsLeaf = (type, config) => {
      const tagColor = config.colors.tag;
      return tagColor.open + "<" + type + tagColor.close + " \u2026" + tagColor.open + " />" + tagColor.close;
    };
    exports2.printElementAsLeaf = printElementAsLeaf;
  }
});

// node_modules/pretty-format/build/plugins/DOMElement.js
var require_DOMElement = __commonJS({
  "node_modules/pretty-format/build/plugins/DOMElement.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = exports2.serialize = exports2.test = void 0;
    var _markup = require_markup();
    var ELEMENT_NODE = 1;
    var TEXT_NODE = 3;
    var COMMENT_NODE = 8;
    var FRAGMENT_NODE = 11;
    var ELEMENT_REGEXP = /^((HTML|SVG)\w*)?Element$/;
    var testNode = (nodeType, name) => nodeType === ELEMENT_NODE && ELEMENT_REGEXP.test(name) || nodeType === TEXT_NODE && name === "Text" || nodeType === COMMENT_NODE && name === "Comment" || nodeType === FRAGMENT_NODE && name === "DocumentFragment";
    var test = (val) => val && val.constructor && val.constructor.name && testNode(val.nodeType, val.constructor.name);
    exports2.test = test;
    function nodeIsText(node) {
      return node.nodeType === TEXT_NODE;
    }
    function nodeIsComment(node) {
      return node.nodeType === COMMENT_NODE;
    }
    function nodeIsFragment(node) {
      return node.nodeType === FRAGMENT_NODE;
    }
    var serialize = (node, config, indentation, depth, refs, printer) => {
      if (nodeIsText(node)) {
        return (0, _markup.printText)(node.data, config);
      }
      if (nodeIsComment(node)) {
        return (0, _markup.printComment)(node.data, config);
      }
      const type = nodeIsFragment(node) ? `DocumentFragment` : node.tagName.toLowerCase();
      if (++depth > config.maxDepth) {
        return (0, _markup.printElementAsLeaf)(type, config);
      }
      return (0, _markup.printElement)(
        type,
        (0, _markup.printProps)(
          nodeIsFragment(node) ? [] : Array.from(node.attributes).map((attr) => attr.name).sort(),
          nodeIsFragment(node) ? [] : Array.from(node.attributes).reduce((props, attribute) => {
            props[attribute.name] = attribute.value;
            return props;
          }, {}),
          config,
          indentation + config.indent,
          depth,
          refs,
          printer
        ),
        (0, _markup.printChildren)(
          Array.prototype.slice.call(node.childNodes || node.children),
          config,
          indentation + config.indent,
          depth,
          refs,
          printer
        ),
        config,
        indentation
      );
    };
    exports2.serialize = serialize;
    var plugin = {
      serialize,
      test
    };
    var _default = plugin;
    exports2.default = _default;
  }
});

// node_modules/pretty-format/build/plugins/Immutable.js
var require_Immutable = __commonJS({
  "node_modules/pretty-format/build/plugins/Immutable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = exports2.test = exports2.serialize = void 0;
    var _collections = require_collections();
    var IS_ITERABLE_SENTINEL = "@@__IMMUTABLE_ITERABLE__@@";
    var IS_LIST_SENTINEL = "@@__IMMUTABLE_LIST__@@";
    var IS_KEYED_SENTINEL = "@@__IMMUTABLE_KEYED__@@";
    var IS_MAP_SENTINEL = "@@__IMMUTABLE_MAP__@@";
    var IS_ORDERED_SENTINEL = "@@__IMMUTABLE_ORDERED__@@";
    var IS_RECORD_SENTINEL = "@@__IMMUTABLE_RECORD__@@";
    var IS_SEQ_SENTINEL = "@@__IMMUTABLE_SEQ__@@";
    var IS_SET_SENTINEL = "@@__IMMUTABLE_SET__@@";
    var IS_STACK_SENTINEL = "@@__IMMUTABLE_STACK__@@";
    var getImmutableName = (name) => "Immutable." + name;
    var printAsLeaf = (name) => "[" + name + "]";
    var SPACE = " ";
    var LAZY = "\u2026";
    var printImmutableEntries = (val, config, indentation, depth, refs, printer, type) => ++depth > config.maxDepth ? printAsLeaf(getImmutableName(type)) : getImmutableName(type) + SPACE + "{" + (0, _collections.printIteratorEntries)(
      val.entries(),
      config,
      indentation,
      depth,
      refs,
      printer
    ) + "}";
    var getRecordEntries = (val) => {
      let i = 0;
      return {
        next() {
          if (i < val._keys.length) {
            const key2 = val._keys[i++];
            return {
              done: false,
              value: [key2, val.get(key2)]
            };
          }
          return {
            done: true
          };
        }
      };
    };
    var printImmutableRecord = (val, config, indentation, depth, refs, printer) => {
      const name = getImmutableName(val._name || "Record");
      return ++depth > config.maxDepth ? printAsLeaf(name) : name + SPACE + "{" + (0, _collections.printIteratorEntries)(
        getRecordEntries(val),
        config,
        indentation,
        depth,
        refs,
        printer
      ) + "}";
    };
    var printImmutableSeq = (val, config, indentation, depth, refs, printer) => {
      const name = getImmutableName("Seq");
      if (++depth > config.maxDepth) {
        return printAsLeaf(name);
      }
      if (val[IS_KEYED_SENTINEL]) {
        return name + SPACE + "{" + // from Immutable collection of entries or from ECMAScript object
        (val._iter || val._object ? (0, _collections.printIteratorEntries)(
          val.entries(),
          config,
          indentation,
          depth,
          refs,
          printer
        ) : LAZY) + "}";
      }
      return name + SPACE + "[" + (val._iter || // from Immutable collection of values
      val._array || // from ECMAScript array
      val._collection || // from ECMAScript collection in immutable v4
      val._iterable ? (0, _collections.printIteratorValues)(
        val.values(),
        config,
        indentation,
        depth,
        refs,
        printer
      ) : LAZY) + "]";
    };
    var printImmutableValues = (val, config, indentation, depth, refs, printer, type) => ++depth > config.maxDepth ? printAsLeaf(getImmutableName(type)) : getImmutableName(type) + SPACE + "[" + (0, _collections.printIteratorValues)(
      val.values(),
      config,
      indentation,
      depth,
      refs,
      printer
    ) + "]";
    var serialize = (val, config, indentation, depth, refs, printer) => {
      if (val[IS_MAP_SENTINEL]) {
        return printImmutableEntries(
          val,
          config,
          indentation,
          depth,
          refs,
          printer,
          val[IS_ORDERED_SENTINEL] ? "OrderedMap" : "Map"
        );
      }
      if (val[IS_LIST_SENTINEL]) {
        return printImmutableValues(
          val,
          config,
          indentation,
          depth,
          refs,
          printer,
          "List"
        );
      }
      if (val[IS_SET_SENTINEL]) {
        return printImmutableValues(
          val,
          config,
          indentation,
          depth,
          refs,
          printer,
          val[IS_ORDERED_SENTINEL] ? "OrderedSet" : "Set"
        );
      }
      if (val[IS_STACK_SENTINEL]) {
        return printImmutableValues(
          val,
          config,
          indentation,
          depth,
          refs,
          printer,
          "Stack"
        );
      }
      if (val[IS_SEQ_SENTINEL]) {
        return printImmutableSeq(val, config, indentation, depth, refs, printer);
      }
      return printImmutableRecord(val, config, indentation, depth, refs, printer);
    };
    exports2.serialize = serialize;
    var test = (val) => val && (val[IS_ITERABLE_SENTINEL] === true || val[IS_RECORD_SENTINEL] === true);
    exports2.test = test;
    var plugin = {
      serialize,
      test
    };
    var _default = plugin;
    exports2.default = _default;
  }
});

// node_modules/react-is/cjs/react-is.production.min.js
var require_react_is_production_min = __commonJS({
  "node_modules/react-is/cjs/react-is.production.min.js"(exports2) {
    "use strict";
    var b = "function" === typeof Symbol && Symbol.for;
    var c2 = b ? Symbol.for("react.element") : 60103;
    var d = b ? Symbol.for("react.portal") : 60106;
    var e = b ? Symbol.for("react.fragment") : 60107;
    var f = b ? Symbol.for("react.strict_mode") : 60108;
    var g = b ? Symbol.for("react.profiler") : 60114;
    var h = b ? Symbol.for("react.provider") : 60109;
    var k = b ? Symbol.for("react.context") : 60110;
    var l = b ? Symbol.for("react.async_mode") : 60111;
    var m = b ? Symbol.for("react.concurrent_mode") : 60111;
    var n = b ? Symbol.for("react.forward_ref") : 60112;
    var p = b ? Symbol.for("react.suspense") : 60113;
    var q = b ? Symbol.for("react.suspense_list") : 60120;
    var r = b ? Symbol.for("react.memo") : 60115;
    var t6 = b ? Symbol.for("react.lazy") : 60116;
    var v = b ? Symbol.for("react.block") : 60121;
    var w = b ? Symbol.for("react.fundamental") : 60117;
    var x = b ? Symbol.for("react.responder") : 60118;
    var y = b ? Symbol.for("react.scope") : 60119;
    function z2(a) {
      if ("object" === typeof a && null !== a) {
        var u = a.$$typeof;
        switch (u) {
          case c2:
            switch (a = a.type, a) {
              case l:
              case m:
              case e:
              case g:
              case f:
              case p:
                return a;
              default:
                switch (a = a && a.$$typeof, a) {
                  case k:
                  case n:
                  case t6:
                  case r:
                  case h:
                    return a;
                  default:
                    return u;
                }
            }
          case d:
            return u;
        }
      }
    }
    function A(a) {
      return z2(a) === m;
    }
    exports2.AsyncMode = l;
    exports2.ConcurrentMode = m;
    exports2.ContextConsumer = k;
    exports2.ContextProvider = h;
    exports2.Element = c2;
    exports2.ForwardRef = n;
    exports2.Fragment = e;
    exports2.Lazy = t6;
    exports2.Memo = r;
    exports2.Portal = d;
    exports2.Profiler = g;
    exports2.StrictMode = f;
    exports2.Suspense = p;
    exports2.isAsyncMode = function(a) {
      return A(a) || z2(a) === l;
    };
    exports2.isConcurrentMode = A;
    exports2.isContextConsumer = function(a) {
      return z2(a) === k;
    };
    exports2.isContextProvider = function(a) {
      return z2(a) === h;
    };
    exports2.isElement = function(a) {
      return "object" === typeof a && null !== a && a.$$typeof === c2;
    };
    exports2.isForwardRef = function(a) {
      return z2(a) === n;
    };
    exports2.isFragment = function(a) {
      return z2(a) === e;
    };
    exports2.isLazy = function(a) {
      return z2(a) === t6;
    };
    exports2.isMemo = function(a) {
      return z2(a) === r;
    };
    exports2.isPortal = function(a) {
      return z2(a) === d;
    };
    exports2.isProfiler = function(a) {
      return z2(a) === g;
    };
    exports2.isStrictMode = function(a) {
      return z2(a) === f;
    };
    exports2.isSuspense = function(a) {
      return z2(a) === p;
    };
    exports2.isValidElementType = function(a) {
      return "string" === typeof a || "function" === typeof a || a === e || a === m || a === g || a === f || a === p || a === q || "object" === typeof a && null !== a && (a.$$typeof === t6 || a.$$typeof === r || a.$$typeof === h || a.$$typeof === k || a.$$typeof === n || a.$$typeof === w || a.$$typeof === x || a.$$typeof === y || a.$$typeof === v);
    };
    exports2.typeOf = z2;
  }
});

// node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/react-is/cjs/react-is.development.js"(exports2) {
    "use strict";
    if (process.env.NODE_ENV !== "production") {
      (function() {
        "use strict";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType(type) {
          return typeof type === "string" || typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
          type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object) {
          return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        exports2.AsyncMode = AsyncMode;
        exports2.ConcurrentMode = ConcurrentMode;
        exports2.ContextConsumer = ContextConsumer;
        exports2.ContextProvider = ContextProvider;
        exports2.Element = Element;
        exports2.ForwardRef = ForwardRef;
        exports2.Fragment = Fragment;
        exports2.Lazy = Lazy;
        exports2.Memo = Memo;
        exports2.Portal = Portal;
        exports2.Profiler = Profiler;
        exports2.StrictMode = StrictMode;
        exports2.Suspense = Suspense;
        exports2.isAsyncMode = isAsyncMode;
        exports2.isConcurrentMode = isConcurrentMode;
        exports2.isContextConsumer = isContextConsumer;
        exports2.isContextProvider = isContextProvider;
        exports2.isElement = isElement;
        exports2.isForwardRef = isForwardRef;
        exports2.isFragment = isFragment;
        exports2.isLazy = isLazy;
        exports2.isMemo = isMemo;
        exports2.isPortal = isPortal;
        exports2.isProfiler = isProfiler;
        exports2.isStrictMode = isStrictMode;
        exports2.isSuspense = isSuspense;
        exports2.isValidElementType = isValidElementType;
        exports2.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/react-is/index.js"(exports2, module2) {
    "use strict";
    if (process.env.NODE_ENV === "production") {
      module2.exports = require_react_is_production_min();
    } else {
      module2.exports = require_react_is_development();
    }
  }
});

// node_modules/pretty-format/build/plugins/ReactElement.js
var require_ReactElement = __commonJS({
  "node_modules/pretty-format/build/plugins/ReactElement.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = exports2.test = exports2.serialize = void 0;
    var ReactIs = _interopRequireWildcard(require_react_is());
    var _markup = require_markup();
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key2 in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key2)) {
              var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key2) : {};
              if (desc.get || desc.set) {
                Object.defineProperty(newObj, key2, desc);
              } else {
                newObj[key2] = obj[key2];
              }
            }
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    var getChildren = (arg, children = []) => {
      if (Array.isArray(arg)) {
        arg.forEach((item) => {
          getChildren(item, children);
        });
      } else if (arg != null && arg !== false) {
        children.push(arg);
      }
      return children;
    };
    var getType = (element) => {
      const type = element.type;
      if (typeof type === "string") {
        return type;
      }
      if (typeof type === "function") {
        return type.displayName || type.name || "Unknown";
      }
      if (ReactIs.isFragment(element)) {
        return "React.Fragment";
      }
      if (ReactIs.isSuspense(element)) {
        return "React.Suspense";
      }
      if (typeof type === "object" && type !== null) {
        if (ReactIs.isContextProvider(element)) {
          return "Context.Provider";
        }
        if (ReactIs.isContextConsumer(element)) {
          return "Context.Consumer";
        }
        if (ReactIs.isForwardRef(element)) {
          const functionName = type.render.displayName || type.render.name || "";
          return functionName !== "" ? "ForwardRef(" + functionName + ")" : "ForwardRef";
        }
        if (ReactIs.isMemo(type)) {
          const functionName = type.displayName || type.type.displayName || type.type.name || "";
          return functionName !== "" ? "Memo(" + functionName + ")" : "Memo";
        }
      }
      return "UNDEFINED";
    };
    var getPropKeys = (element) => {
      const props = element.props;
      return Object.keys(props).filter((key2) => key2 !== "children" && props[key2] !== void 0).sort();
    };
    var serialize = (element, config, indentation, depth, refs, printer) => ++depth > config.maxDepth ? (0, _markup.printElementAsLeaf)(getType(element), config) : (0, _markup.printElement)(
      getType(element),
      (0, _markup.printProps)(
        getPropKeys(element),
        element.props,
        config,
        indentation + config.indent,
        depth,
        refs,
        printer
      ),
      (0, _markup.printChildren)(
        getChildren(element.props.children),
        config,
        indentation + config.indent,
        depth,
        refs,
        printer
      ),
      config,
      indentation
    );
    exports2.serialize = serialize;
    var test = (val) => val && ReactIs.isElement(val);
    exports2.test = test;
    var plugin = {
      serialize,
      test
    };
    var _default = plugin;
    exports2.default = _default;
  }
});

// node_modules/pretty-format/build/plugins/ReactTestComponent.js
var require_ReactTestComponent = __commonJS({
  "node_modules/pretty-format/build/plugins/ReactTestComponent.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = exports2.test = exports2.serialize = void 0;
    var _markup = require_markup();
    var Symbol2 = global["jest-symbol-do-not-touch"] || global.Symbol;
    var testSymbol = Symbol2.for("react.test.json");
    var getPropKeys = (object) => {
      const props = object.props;
      return props ? Object.keys(props).filter((key2) => props[key2] !== void 0).sort() : [];
    };
    var serialize = (object, config, indentation, depth, refs, printer) => ++depth > config.maxDepth ? (0, _markup.printElementAsLeaf)(object.type, config) : (0, _markup.printElement)(
      object.type,
      object.props ? (0, _markup.printProps)(
        getPropKeys(object),
        object.props,
        config,
        indentation + config.indent,
        depth,
        refs,
        printer
      ) : "",
      object.children ? (0, _markup.printChildren)(
        object.children,
        config,
        indentation + config.indent,
        depth,
        refs,
        printer
      ) : "",
      config,
      indentation
    );
    exports2.serialize = serialize;
    var test = (val) => val && val.$$typeof === testSymbol;
    exports2.test = test;
    var plugin = {
      serialize,
      test
    };
    var _default = plugin;
    exports2.default = _default;
  }
});

// node_modules/pretty-format/build/index.js
var require_build = __commonJS({
  "node_modules/pretty-format/build/index.js"(exports2, module2) {
    "use strict";
    var _ansiStyles = _interopRequireDefault(require_ansi_styles());
    var _collections = require_collections();
    var _AsymmetricMatcher = _interopRequireDefault(
      require_AsymmetricMatcher()
    );
    var _ConvertAnsi = _interopRequireDefault(require_ConvertAnsi());
    var _DOMCollection = _interopRequireDefault(require_DOMCollection());
    var _DOMElement = _interopRequireDefault(require_DOMElement());
    var _Immutable = _interopRequireDefault(require_Immutable());
    var _ReactElement = _interopRequireDefault(require_ReactElement());
    var _ReactTestComponent = _interopRequireDefault(
      require_ReactTestComponent()
    );
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Symbol2 = global["jest-symbol-do-not-touch"] || global.Symbol;
    var toString = Object.prototype.toString;
    var toISOString = Date.prototype.toISOString;
    var errorToString = Error.prototype.toString;
    var regExpToString = RegExp.prototype.toString;
    var symbolToString = Symbol2.prototype.toString;
    var getConstructorName = (val) => typeof val.constructor === "function" && val.constructor.name || "Object";
    var isWindow = (val) => typeof window !== "undefined" && val === window;
    var SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/;
    var NEWLINE_REGEXP = /\n/gi;
    var PrettyFormatPluginError = class extends Error {
      constructor(message, stack2) {
        super(message);
        this.stack = stack2;
        this.name = this.constructor.name;
      }
    };
    function isToStringedArrayType(toStringed) {
      return toStringed === "[object Array]" || toStringed === "[object ArrayBuffer]" || toStringed === "[object DataView]" || toStringed === "[object Float32Array]" || toStringed === "[object Float64Array]" || toStringed === "[object Int8Array]" || toStringed === "[object Int16Array]" || toStringed === "[object Int32Array]" || toStringed === "[object Uint8Array]" || toStringed === "[object Uint8ClampedArray]" || toStringed === "[object Uint16Array]" || toStringed === "[object Uint32Array]";
    }
    function printNumber(val) {
      return Object.is(val, -0) ? "-0" : String(val);
    }
    function printBigInt(val) {
      return String(`${val}n`);
    }
    function printFunction2(val, printFunctionName) {
      if (!printFunctionName) {
        return "[Function]";
      }
      return "[Function " + (val.name || "anonymous") + "]";
    }
    function printSymbol(val) {
      return symbolToString.call(val).replace(SYMBOL_REGEXP, "Symbol($1)");
    }
    function printError(val) {
      return "[" + errorToString.call(val) + "]";
    }
    function printBasicValue(val, printFunctionName, escapeRegex, escapeString) {
      if (val === true || val === false) {
        return "" + val;
      }
      if (val === void 0) {
        return "undefined";
      }
      if (val === null) {
        return "null";
      }
      const typeOf = typeof val;
      if (typeOf === "number") {
        return printNumber(val);
      }
      if (typeOf === "bigint") {
        return printBigInt(val);
      }
      if (typeOf === "string") {
        if (escapeString) {
          return '"' + val.replace(/"|\\/g, "\\$&") + '"';
        }
        return '"' + val + '"';
      }
      if (typeOf === "function") {
        return printFunction2(val, printFunctionName);
      }
      if (typeOf === "symbol") {
        return printSymbol(val);
      }
      const toStringed = toString.call(val);
      if (toStringed === "[object WeakMap]") {
        return "WeakMap {}";
      }
      if (toStringed === "[object WeakSet]") {
        return "WeakSet {}";
      }
      if (toStringed === "[object Function]" || toStringed === "[object GeneratorFunction]") {
        return printFunction2(val, printFunctionName);
      }
      if (toStringed === "[object Symbol]") {
        return printSymbol(val);
      }
      if (toStringed === "[object Date]") {
        return isNaN(+val) ? "Date { NaN }" : toISOString.call(val);
      }
      if (toStringed === "[object Error]") {
        return printError(val);
      }
      if (toStringed === "[object RegExp]") {
        if (escapeRegex) {
          return regExpToString.call(val).replace(/[\\^$*+?.()|[\]{}]/g, "\\$&");
        }
        return regExpToString.call(val);
      }
      if (val instanceof Error) {
        return printError(val);
      }
      return null;
    }
    function printComplexValue(val, config, indentation, depth, refs, hasCalledToJSON) {
      if (refs.indexOf(val) !== -1) {
        return "[Circular]";
      }
      refs = refs.slice();
      refs.push(val);
      const hitMaxDepth = ++depth > config.maxDepth;
      const min = config.min;
      if (config.callToJSON && !hitMaxDepth && val.toJSON && typeof val.toJSON === "function" && !hasCalledToJSON) {
        return printer(val.toJSON(), config, indentation, depth, refs, true);
      }
      const toStringed = toString.call(val);
      if (toStringed === "[object Arguments]") {
        return hitMaxDepth ? "[Arguments]" : (min ? "" : "Arguments ") + "[" + (0, _collections.printListItems)(
          val,
          config,
          indentation,
          depth,
          refs,
          printer
        ) + "]";
      }
      if (isToStringedArrayType(toStringed)) {
        return hitMaxDepth ? "[" + val.constructor.name + "]" : (min ? "" : val.constructor.name + " ") + "[" + (0, _collections.printListItems)(
          val,
          config,
          indentation,
          depth,
          refs,
          printer
        ) + "]";
      }
      if (toStringed === "[object Map]") {
        return hitMaxDepth ? "[Map]" : "Map {" + (0, _collections.printIteratorEntries)(
          val.entries(),
          config,
          indentation,
          depth,
          refs,
          printer,
          " => "
        ) + "}";
      }
      if (toStringed === "[object Set]") {
        return hitMaxDepth ? "[Set]" : "Set {" + (0, _collections.printIteratorValues)(
          val.values(),
          config,
          indentation,
          depth,
          refs,
          printer
        ) + "}";
      }
      return hitMaxDepth || isWindow(val) ? "[" + getConstructorName(val) + "]" : (min ? "" : getConstructorName(val) + " ") + "{" + (0, _collections.printObjectProperties)(
        val,
        config,
        indentation,
        depth,
        refs,
        printer
      ) + "}";
    }
    function isNewPlugin(plugin) {
      return plugin.serialize != null;
    }
    function printPlugin(plugin, val, config, indentation, depth, refs) {
      let printed;
      try {
        printed = isNewPlugin(plugin) ? plugin.serialize(val, config, indentation, depth, refs, printer) : plugin.print(
          val,
          (valChild) => printer(valChild, config, indentation, depth, refs),
          (str) => {
            const indentationNext = indentation + config.indent;
            return indentationNext + str.replace(NEWLINE_REGEXP, "\n" + indentationNext);
          },
          {
            edgeSpacing: config.spacingOuter,
            min: config.min,
            spacing: config.spacingInner
          },
          config.colors
        );
      } catch (error) {
        throw new PrettyFormatPluginError(error.message, error.stack);
      }
      if (typeof printed !== "string") {
        throw new Error(
          `pretty-format: Plugin must return type "string" but instead returned "${typeof printed}".`
        );
      }
      return printed;
    }
    function findPlugin(plugins, val) {
      for (let p = 0; p < plugins.length; p++) {
        try {
          if (plugins[p].test(val)) {
            return plugins[p];
          }
        } catch (error) {
          throw new PrettyFormatPluginError(error.message, error.stack);
        }
      }
      return null;
    }
    function printer(val, config, indentation, depth, refs, hasCalledToJSON) {
      const plugin = findPlugin(config.plugins, val);
      if (plugin !== null) {
        return printPlugin(plugin, val, config, indentation, depth, refs);
      }
      const basicResult = printBasicValue(
        val,
        config.printFunctionName,
        config.escapeRegex,
        config.escapeString
      );
      if (basicResult !== null) {
        return basicResult;
      }
      return printComplexValue(
        val,
        config,
        indentation,
        depth,
        refs,
        hasCalledToJSON
      );
    }
    var DEFAULT_THEME = {
      comment: "gray",
      content: "reset",
      prop: "yellow",
      tag: "cyan",
      value: "green"
    };
    var DEFAULT_THEME_KEYS = Object.keys(DEFAULT_THEME);
    var DEFAULT_OPTIONS = {
      callToJSON: true,
      escapeRegex: false,
      escapeString: true,
      highlight: false,
      indent: 2,
      maxDepth: Infinity,
      min: false,
      plugins: [],
      printFunctionName: true,
      theme: DEFAULT_THEME
    };
    function validateOptions(options) {
      Object.keys(options).forEach((key2) => {
        if (!DEFAULT_OPTIONS.hasOwnProperty(key2)) {
          throw new Error(`pretty-format: Unknown option "${key2}".`);
        }
      });
      if (options.min && options.indent !== void 0 && options.indent !== 0) {
        throw new Error(
          'pretty-format: Options "min" and "indent" cannot be used together.'
        );
      }
      if (options.theme !== void 0) {
        if (options.theme === null) {
          throw new Error(`pretty-format: Option "theme" must not be null.`);
        }
        if (typeof options.theme !== "object") {
          throw new Error(
            `pretty-format: Option "theme" must be of type "object" but instead received "${typeof options.theme}".`
          );
        }
      }
    }
    var getColorsHighlight = (options) => DEFAULT_THEME_KEYS.reduce((colors, key2) => {
      const value = options.theme && options.theme[key2] !== void 0 ? options.theme[key2] : DEFAULT_THEME[key2];
      const color = value && _ansiStyles.default[value];
      if (color && typeof color.close === "string" && typeof color.open === "string") {
        colors[key2] = color;
      } else {
        throw new Error(
          `pretty-format: Option "theme" has a key "${key2}" whose value "${value}" is undefined in ansi-styles.`
        );
      }
      return colors;
    }, /* @__PURE__ */ Object.create(null));
    var getColorsEmpty = () => DEFAULT_THEME_KEYS.reduce((colors, key2) => {
      colors[key2] = {
        close: "",
        open: ""
      };
      return colors;
    }, /* @__PURE__ */ Object.create(null));
    var getPrintFunctionName = (options) => options && options.printFunctionName !== void 0 ? options.printFunctionName : DEFAULT_OPTIONS.printFunctionName;
    var getEscapeRegex = (options) => options && options.escapeRegex !== void 0 ? options.escapeRegex : DEFAULT_OPTIONS.escapeRegex;
    var getEscapeString = (options) => options && options.escapeString !== void 0 ? options.escapeString : DEFAULT_OPTIONS.escapeString;
    var getConfig = (options) => ({
      callToJSON: options && options.callToJSON !== void 0 ? options.callToJSON : DEFAULT_OPTIONS.callToJSON,
      colors: options && options.highlight ? getColorsHighlight(options) : getColorsEmpty(),
      escapeRegex: getEscapeRegex(options),
      escapeString: getEscapeString(options),
      indent: options && options.min ? "" : createIndent(
        options && options.indent !== void 0 ? options.indent : DEFAULT_OPTIONS.indent
      ),
      maxDepth: options && options.maxDepth !== void 0 ? options.maxDepth : DEFAULT_OPTIONS.maxDepth,
      min: options && options.min !== void 0 ? options.min : DEFAULT_OPTIONS.min,
      plugins: options && options.plugins !== void 0 ? options.plugins : DEFAULT_OPTIONS.plugins,
      printFunctionName: getPrintFunctionName(options),
      spacingInner: options && options.min ? " " : "\n",
      spacingOuter: options && options.min ? "" : "\n"
    });
    function createIndent(indent) {
      return new Array(indent + 1).join(" ");
    }
    function prettyFormat4(val, options) {
      if (options) {
        validateOptions(options);
        if (options.plugins) {
          const plugin = findPlugin(options.plugins, val);
          if (plugin !== null) {
            return printPlugin(plugin, val, getConfig(options), "", 0, []);
          }
        }
      }
      const basicResult = printBasicValue(
        val,
        getPrintFunctionName(options),
        getEscapeRegex(options),
        getEscapeString(options)
      );
      if (basicResult !== null) {
        return basicResult;
      }
      return printComplexValue(val, getConfig(options), "", 0, []);
    }
    prettyFormat4.plugins = {
      AsymmetricMatcher: _AsymmetricMatcher.default,
      ConvertAnsi: _ConvertAnsi.default,
      DOMCollection: _DOMCollection.default,
      DOMElement: _DOMElement.default,
      Immutable: _Immutable.default,
      ReactElement: _ReactElement.default,
      ReactTestComponent: _ReactTestComponent.default
    };
    module2.exports = prettyFormat4;
  }
});

// src/index.ts
var index_exports = {};
__export(index_exports, {
  CompilerDiagnostic: () => CompilerDiagnostic,
  CompilerError: () => CompilerError,
  CompilerErrorDetail: () => CompilerErrorDetail,
  CompilerSuggestionOperation: () => CompilerSuggestionOperation,
  Effect: () => Effect,
  ErrorSeverity: () => ErrorSeverity,
  LintRules: () => LintRules,
  OPT_IN_DIRECTIVES: () => OPT_IN_DIRECTIVES,
  OPT_OUT_DIRECTIVES: () => OPT_OUT_DIRECTIVES,
  ProgramContext: () => ProgramContext,
  ValueKind: () => ValueKind,
  ValueReason: () => ValueReason,
  compile: () => compileFn,
  compileProgram: () => compileProgram,
  default: () => index_default,
  findDirectiveDisablingMemoization: () => findDirectiveDisablingMemoization,
  findDirectiveEnablingMemoization: () => tryFindDirectiveEnablingMemoization,
  parseConfigPragmaAsString: () => parseConfigPragmaAsString,
  parseConfigPragmaForTests: () => parseConfigPragmaForTests,
  parsePluginOptions: () => parsePluginOptions,
  printFunctionWithOutlined: () => printFunctionWithOutlined,
  printHIR: () => printHIR,
  printReactiveFunction: () => printReactiveFunction,
  printReactiveFunctionWithOutlined: () => printReactiveFunctionWithOutlined,
  runBabelPluginReactCompiler: () => runBabelPluginReactCompiler,
  validateEnvironmentConfig: () => validateEnvironmentConfig
});
module.exports = __toCommonJS(index_exports);

// src/Babel/RunReactCompilerBabelPlugin.ts
var import_core = __toESM(require_lib10());
var BabelParser = __toESM(require_lib4());
var import_invariant4 = __toESM(require_invariant());

// src/Entrypoint/Gating.ts
var t = __toESM(require("@babel/types"));

// src/CompilerError.ts
var import_code_frame = __toESM(require_lib3());

// src/Utils/Result.ts
function Ok(val) {
  return new OkImpl(val);
}
var _val;
var _OkImpl = class _OkImpl {
  constructor(val) {
    __privateAdd(this, _val);
    __privateSet(this, _val, val);
  }
  map(fn) {
    return new _OkImpl(fn(__privateGet(this, _val)));
  }
  mapErr(_fn) {
    return this;
  }
  mapOr(_fallback, fn) {
    return fn(__privateGet(this, _val));
  }
  mapOrElse(_fallback, fn) {
    return fn(__privateGet(this, _val));
  }
  andThen(fn) {
    return fn(__privateGet(this, _val));
  }
  and(res) {
    return res;
  }
  or(_res) {
    return this;
  }
  orElse(_fn) {
    return this;
  }
  isOk() {
    return true;
  }
  isErr() {
    return false;
  }
  expect(_msg) {
    return __privateGet(this, _val);
  }
  expectErr(msg) {
    throw new Error(`${msg}: ${__privateGet(this, _val)}`);
  }
  unwrap() {
    return __privateGet(this, _val);
  }
  unwrapOr(_fallback) {
    return __privateGet(this, _val);
  }
  unwrapOrElse(_fallback) {
    return __privateGet(this, _val);
  }
  unwrapErr() {
    if (__privateGet(this, _val) instanceof Error) {
      throw __privateGet(this, _val);
    }
    throw new Error(`Can't unwrap \`Ok\` to \`Err\`: ${__privateGet(this, _val)}`);
  }
};
_val = new WeakMap();
var OkImpl = _OkImpl;
function Err(val) {
  return new ErrImpl(val);
}
var _val2;
var _ErrImpl = class _ErrImpl {
  constructor(val) {
    __privateAdd(this, _val2);
    __privateSet(this, _val2, val);
  }
  map(_fn) {
    return this;
  }
  mapErr(fn) {
    return new _ErrImpl(fn(__privateGet(this, _val2)));
  }
  mapOr(fallback, _fn) {
    return fallback;
  }
  mapOrElse(fallback, _fn) {
    return fallback();
  }
  andThen(_fn) {
    return this;
  }
  and(_res) {
    return this;
  }
  or(res) {
    return res;
  }
  orElse(fn) {
    return fn(__privateGet(this, _val2));
  }
  isOk() {
    return false;
  }
  isErr() {
    return true;
  }
  expect(msg) {
    throw new Error(`${msg}: ${__privateGet(this, _val2)}`);
  }
  expectErr(_msg) {
    return __privateGet(this, _val2);
  }
  unwrap() {
    if (__privateGet(this, _val2) instanceof Error) {
      throw __privateGet(this, _val2);
    }
    throw new Error(`Can't unwrap \`Err\` to \`Ok\`: ${__privateGet(this, _val2)}`);
  }
  unwrapOr(fallback) {
    return fallback;
  }
  unwrapOrElse(fallback) {
    return fallback(__privateGet(this, _val2));
  }
  unwrapErr() {
    return __privateGet(this, _val2);
  }
};
_val2 = new WeakMap();
var ErrImpl = _ErrImpl;

// src/Utils/utils.ts
function assertExhaustive(_, errorMsg) {
  throw new Error(errorMsg);
}
function retainWhere(array, predicate) {
  let writeIndex = 0;
  for (let readIndex = 0; readIndex < array.length; readIndex++) {
    const item = array[readIndex];
    if (predicate(item, readIndex) === true) {
      array[writeIndex++] = item;
    }
  }
  array.length = writeIndex;
}
function retainWhere_Set(items, predicate) {
  for (const item of items) {
    if (!predicate(item)) {
      items.delete(item);
    }
  }
}
function getOrInsertWith(m, key2, makeDefault) {
  if (m.has(key2)) {
    return m.get(key2);
  } else {
    const defaultValue = makeDefault();
    m.set(key2, defaultValue);
    return defaultValue;
  }
}
function getOrInsertDefault(m, key2, defaultValue) {
  if (m.has(key2)) {
    return m.get(key2);
  } else {
    m.set(key2, defaultValue);
    return defaultValue;
  }
}
function Set_equal(a, b) {
  if (a.size !== b.size) {
    return false;
  }
  for (const item of a) {
    if (!b.has(item)) {
      return false;
    }
  }
  return true;
}
function Set_union(a, b) {
  const union = new Set(a);
  for (const item of b) {
    union.add(item);
  }
  return union;
}
function Set_intersect(sets) {
  if (sets.length === 0 || sets.some((s) => s.size === 0)) {
    return /* @__PURE__ */ new Set();
  } else if (sets.length === 1) {
    return new Set(sets[0]);
  }
  const result = /* @__PURE__ */ new Set();
  const first = sets[0];
  outer: for (const e of first) {
    for (let i = 1; i < sets.length; i++) {
      if (!sets[i].has(e)) {
        continue outer;
      }
    }
    result.add(e);
  }
  return result;
}
function Set_isSuperset(a, b) {
  for (const v of b) {
    if (!a.has(v)) {
      return false;
    }
  }
  return true;
}
function Iterable_some(iter, pred) {
  for (const item of iter) {
    if (pred(item)) {
      return true;
    }
  }
  return false;
}
function Set_filter(source2, fn) {
  const result = /* @__PURE__ */ new Set();
  for (const entry of source2) {
    if (fn(entry)) {
      result.add(entry);
    }
  }
  return result;
}
function hasNode(input) {
  return input.node != null;
}
function hasOwnProperty2(obj, key2) {
  return Object.prototype.hasOwnProperty.call(obj, key2);
}

// src/CompilerError.ts
var import_invariant = __toESM(require_invariant());
var ErrorSeverity = /* @__PURE__ */ ((ErrorSeverity2) => {
  ErrorSeverity2["InvalidJS"] = "InvalidJS";
  ErrorSeverity2["UnsupportedJS"] = "UnsupportedJS";
  ErrorSeverity2["InvalidReact"] = "InvalidReact";
  ErrorSeverity2["InvalidConfig"] = "InvalidConfig";
  ErrorSeverity2["CannotPreserveMemoization"] = "CannotPreserveMemoization";
  ErrorSeverity2["Todo"] = "Todo";
  ErrorSeverity2["Invariant"] = "Invariant";
  return ErrorSeverity2;
})(ErrorSeverity || {});
var CompilerSuggestionOperation = /* @__PURE__ */ ((CompilerSuggestionOperation2) => {
  CompilerSuggestionOperation2[CompilerSuggestionOperation2["InsertBefore"] = 0] = "InsertBefore";
  CompilerSuggestionOperation2[CompilerSuggestionOperation2["InsertAfter"] = 1] = "InsertAfter";
  CompilerSuggestionOperation2[CompilerSuggestionOperation2["Remove"] = 2] = "Remove";
  CompilerSuggestionOperation2[CompilerSuggestionOperation2["Replace"] = 3] = "Replace";
  return CompilerSuggestionOperation2;
})(CompilerSuggestionOperation || {});
var CompilerDiagnostic = class _CompilerDiagnostic {
  constructor(options) {
    this.options = options;
  }
  static create(options) {
    return new _CompilerDiagnostic(__spreadProps(__spreadValues({}, options), { details: [] }));
  }
  get reason() {
    return this.options.reason;
  }
  get description() {
    return this.options.description;
  }
  get severity() {
    return this.options.severity;
  }
  get suggestions() {
    return this.options.suggestions;
  }
  get category() {
    return this.options.category;
  }
  withDetail(detail) {
    this.options.details.push(detail);
    return this;
  }
  primaryLocation() {
    const firstErrorDetail = this.options.details.filter(
      (d) => d.kind === "error"
    )[0];
    return firstErrorDetail != null && firstErrorDetail.kind === "error" ? firstErrorDetail.loc : null;
  }
  printErrorMessage(source2, options) {
    const buffer2 = [
      printErrorSummary(this.severity, this.reason),
      "\n\n",
      this.description
    ];
    for (const detail of this.options.details) {
      switch (detail.kind) {
        case "error": {
          const loc = detail.loc;
          if (loc == null || typeof loc === "symbol") {
            continue;
          }
          let codeFrame;
          try {
            codeFrame = printCodeFrame(source2, loc, detail.message);
          } catch (e) {
            codeFrame = detail.message;
          }
          buffer2.push("\n\n");
          if (loc.filename != null) {
            const line2 = loc.start.line;
            const column2 = options.eslint ? loc.start.column + 1 : loc.start.column;
            buffer2.push(`${loc.filename}:${line2}:${column2}
`);
          }
          buffer2.push(codeFrame);
          break;
        }
        case "hint": {
          buffer2.push("\n\n");
          buffer2.push(detail.message);
          break;
        }
        default: {
          assertExhaustive(
            detail,
            `Unexpected detail kind ${detail.kind}`
          );
        }
      }
    }
    return buffer2.join("");
  }
  toString() {
    const buffer2 = [printErrorSummary(this.severity, this.reason)];
    if (this.description != null) {
      buffer2.push(`. ${this.description}.`);
    }
    const loc = this.primaryLocation();
    if (loc != null && typeof loc !== "symbol") {
      buffer2.push(` (${loc.start.line}:${loc.start.column})`);
    }
    return buffer2.join("");
  }
};
var CompilerErrorDetail = class {
  constructor(options) {
    this.options = options;
  }
  get reason() {
    return this.options.reason;
  }
  get description() {
    return this.options.description;
  }
  get severity() {
    return this.options.severity;
  }
  get loc() {
    return this.options.loc;
  }
  get suggestions() {
    return this.options.suggestions;
  }
  get category() {
    return this.options.category;
  }
  primaryLocation() {
    return this.loc;
  }
  printErrorMessage(source2, options) {
    const buffer2 = [printErrorSummary(this.severity, this.reason)];
    if (this.description != null) {
      buffer2.push(`

${this.description}.`);
    }
    const loc = this.loc;
    if (loc != null && typeof loc !== "symbol") {
      let codeFrame;
      try {
        codeFrame = printCodeFrame(source2, loc, this.reason);
      } catch (e) {
        codeFrame = "";
      }
      buffer2.push(`

`);
      if (loc.filename != null) {
        const line2 = loc.start.line;
        const column2 = options.eslint ? loc.start.column + 1 : loc.start.column;
        buffer2.push(`${loc.filename}:${line2}:${column2}
`);
      }
      buffer2.push(codeFrame);
      buffer2.push("\n\n");
    }
    return buffer2.join("");
  }
  toString() {
    const buffer2 = [printErrorSummary(this.severity, this.reason)];
    if (this.description != null) {
      buffer2.push(`. ${this.description}.`);
    }
    const loc = this.loc;
    if (loc != null && typeof loc !== "symbol") {
      buffer2.push(` (${loc.start.line}:${loc.start.column})`);
    }
    return buffer2.join("");
  }
};
var CompilerError = class _CompilerError extends Error {
  constructor(...args) {
    super(...args);
    this.details = [];
    this.printedMessage = null;
    this.name = "ReactCompilerError";
    this.details = [];
  }
  static invariant(condition, options) {
    if (!condition) {
      const errors = new _CompilerError();
      errors.pushErrorDetail(
        new CompilerErrorDetail(__spreadProps(__spreadValues({}, options), {
          category: "Invariant" /* Invariant */,
          severity: "Invariant" /* Invariant */
        }))
      );
      throw errors;
    }
  }
  static throwDiagnostic(options) {
    const errors = new _CompilerError();
    errors.pushDiagnostic(new CompilerDiagnostic(options));
    throw errors;
  }
  static throwTodo(options) {
    const errors = new _CompilerError();
    errors.pushErrorDetail(
      new CompilerErrorDetail(__spreadProps(__spreadValues({}, options), {
        severity: "Todo" /* Todo */,
        category: "Todo" /* Todo */
      }))
    );
    throw errors;
  }
  static throwInvalidJS(options) {
    const errors = new _CompilerError();
    errors.pushErrorDetail(
      new CompilerErrorDetail(__spreadProps(__spreadValues({}, options), {
        severity: "InvalidJS" /* InvalidJS */,
        category: "Syntax" /* Syntax */
      }))
    );
    throw errors;
  }
  static throwInvalidReact(options) {
    const errors = new _CompilerError();
    errors.pushErrorDetail(
      new CompilerErrorDetail(__spreadProps(__spreadValues({}, options), {
        severity: "InvalidReact" /* InvalidReact */
      }))
    );
    throw errors;
  }
  static throwInvalidConfig(options) {
    const errors = new _CompilerError();
    errors.pushErrorDetail(
      new CompilerErrorDetail(__spreadProps(__spreadValues({}, options), {
        severity: "InvalidConfig" /* InvalidConfig */,
        category: "Config" /* Config */
      }))
    );
    throw errors;
  }
  static throw(options) {
    const errors = new _CompilerError();
    errors.pushErrorDetail(new CompilerErrorDetail(options));
    throw errors;
  }
  get message() {
    var _a;
    return (_a = this.printedMessage) != null ? _a : this.toString();
  }
  set message(_message) {
  }
  toString() {
    if (this.printedMessage) {
      return this.printedMessage;
    }
    if (Array.isArray(this.details)) {
      return this.details.map((detail) => detail.toString()).join("\n\n");
    }
    return this.name;
  }
  withPrintedMessage(source2, options) {
    this.printedMessage = this.printErrorMessage(source2, options);
    return this;
  }
  printErrorMessage(source2, options) {
    if (options.eslint && this.details.length === 1) {
      return this.details[0].printErrorMessage(source2, options);
    }
    return `Found ${this.details.length} error${this.details.length === 1 ? "" : "s"}:

` + this.details.map((detail) => detail.printErrorMessage(source2, options).trim()).join("\n\n");
  }
  merge(other) {
    this.details.push(...other.details);
  }
  pushDiagnostic(diagnostic) {
    this.details.push(diagnostic);
  }
  push(options) {
    var _a;
    const detail = new CompilerErrorDetail({
      category: options.category,
      reason: options.reason,
      description: (_a = options.description) != null ? _a : null,
      severity: options.severity,
      suggestions: options.suggestions,
      loc: typeof options.loc === "symbol" ? null : options.loc
    });
    return this.pushErrorDetail(detail);
  }
  pushErrorDetail(detail) {
    this.details.push(detail);
    return detail;
  }
  hasErrors() {
    return this.details.length > 0;
  }
  asResult() {
    return this.hasErrors() ? Err(this) : Ok(void 0);
  }
  /*
   * An error is critical if it means the compiler has entered into a broken state and cannot
   * continue safely. Other expected errors such as Todos mean that we can skip over that component
   * but otherwise continue compiling the rest of the app.
   */
  isCritical() {
    return this.details.some((detail) => {
      switch (detail.severity) {
        case "Invariant" /* Invariant */:
        case "InvalidJS" /* InvalidJS */:
        case "InvalidReact" /* InvalidReact */:
        case "InvalidConfig" /* InvalidConfig */:
        case "UnsupportedJS" /* UnsupportedJS */: {
          return true;
        }
        case "CannotPreserveMemoization" /* CannotPreserveMemoization */:
        case "Todo" /* Todo */: {
          return false;
        }
        default: {
          assertExhaustive(detail.severity, "Unhandled error severity");
        }
      }
    });
  }
};
function printCodeFrame(source2, loc, message) {
  return (0, import_code_frame.codeFrameColumns)(
    source2,
    {
      start: {
        line: loc.start.line,
        column: loc.start.column + 1
      },
      end: {
        line: loc.end.line,
        column: loc.end.column + 1
      }
    },
    {
      message
    }
  );
}
function printErrorSummary(severity, message) {
  let severityCategory;
  switch (severity) {
    case "InvalidConfig" /* InvalidConfig */:
    case "InvalidJS" /* InvalidJS */:
    case "InvalidReact" /* InvalidReact */:
    case "UnsupportedJS" /* UnsupportedJS */: {
      severityCategory = "Error";
      break;
    }
    case "CannotPreserveMemoization" /* CannotPreserveMemoization */: {
      severityCategory = "Memoization";
      break;
    }
    case "Invariant" /* Invariant */: {
      severityCategory = "Invariant";
      break;
    }
    case "Todo" /* Todo */: {
      severityCategory = "Todo";
      break;
    }
    default: {
      assertExhaustive(severity, `Unexpected severity '${severity}'`);
    }
  }
  return `${severityCategory}: ${message}`;
}
var ErrorCategory = /* @__PURE__ */ ((ErrorCategory2) => {
  ErrorCategory2["Hooks"] = "Hooks";
  ErrorCategory2["CapitalizedCalls"] = "CapitalizedCalls";
  ErrorCategory2["StaticComponents"] = "StaticComponents";
  ErrorCategory2["UseMemo"] = "UseMemo";
  ErrorCategory2["Factories"] = "Factories";
  ErrorCategory2["PreserveManualMemo"] = "PreserveManualMemo";
  ErrorCategory2["Immutability"] = "Immutability";
  ErrorCategory2["Globals"] = "Globals";
  ErrorCategory2["Refs"] = "Refs";
  ErrorCategory2["EffectDependencies"] = "EffectDependencies";
  ErrorCategory2["EffectSetState"] = "EffectSetState";
  ErrorCategory2["EffectDerivationsOfState"] = "EffectDerivationsOfState";
  ErrorCategory2["ErrorBoundaries"] = "ErrorBoundaries";
  ErrorCategory2["Purity"] = "Purity";
  ErrorCategory2["RenderSetState"] = "RenderSetState";
  ErrorCategory2["Invariant"] = "Invariant";
  ErrorCategory2["Todo"] = "Todo";
  ErrorCategory2["Syntax"] = "Syntax";
  ErrorCategory2["UnsupportedSyntax"] = "UnsupportedSyntax";
  ErrorCategory2["Config"] = "Config";
  ErrorCategory2["Gating"] = "Gating";
  ErrorCategory2["Suppression"] = "Suppression";
  ErrorCategory2["AutomaticEffectDependencies"] = "AutomaticEffectDependencies";
  ErrorCategory2["Fire"] = "Fire";
  ErrorCategory2["FBT"] = "FBT";
  return ErrorCategory2;
})(ErrorCategory || {});
var RULE_NAME_PATTERN = /^[a-z]+(-[a-z]+)*$/;
function getRuleForCategory(category) {
  const rule = getRuleForCategoryImpl(category);
  (0, import_invariant.default)(
    RULE_NAME_PATTERN.test(rule.name),
    `Invalid rule name, got '${rule.name}' but rules must match ${RULE_NAME_PATTERN.toString()}`
  );
  return rule;
}
function getRuleForCategoryImpl(category) {
  switch (category) {
    case "AutomaticEffectDependencies" /* AutomaticEffectDependencies */: {
      return {
        category,
        name: "automatic-effect-dependencies",
        description: "Verifies that automatic effect dependencies are compiled if opted-in",
        recommended: false
      };
    }
    case "CapitalizedCalls" /* CapitalizedCalls */: {
      return {
        category,
        name: "capitalized-calls",
        description: "Validates against calling capitalized functions/methods instead of using JSX",
        recommended: false
      };
    }
    case "Config" /* Config */: {
      return {
        category,
        name: "config",
        description: "Validates the compiler configuration options",
        recommended: true
      };
    }
    case "EffectDependencies" /* EffectDependencies */: {
      return {
        category,
        name: "memoized-effect-dependencies",
        description: "Validates that effect dependencies are memoized",
        recommended: false
      };
    }
    case "EffectDerivationsOfState" /* EffectDerivationsOfState */: {
      return {
        category,
        name: "no-deriving-state-in-effects",
        description: "Validates against deriving values from state in an effect",
        recommended: false
      };
    }
    case "EffectSetState" /* EffectSetState */: {
      return {
        category,
        name: "set-state-in-effect",
        description: "Validates against calling setState synchronously in an effect, which can lead to re-renders that degrade performance",
        recommended: true
      };
    }
    case "ErrorBoundaries" /* ErrorBoundaries */: {
      return {
        category,
        name: "error-boundaries",
        description: "Validates usage of error boundaries instead of try/catch for errors in child components",
        recommended: true
      };
    }
    case "Factories" /* Factories */: {
      return {
        category,
        name: "component-hook-factories",
        description: "Validates against higher order functions defining nested components or hooks. Components and hooks should be defined at the module level",
        recommended: true
      };
    }
    case "FBT" /* FBT */: {
      return {
        category,
        name: "fbt",
        description: "Validates usage of fbt",
        recommended: false
      };
    }
    case "Fire" /* Fire */: {
      return {
        category,
        name: "fire",
        description: "Validates usage of `fire`",
        recommended: false
      };
    }
    case "Gating" /* Gating */: {
      return {
        category,
        name: "gating",
        description: "Validates configuration of [gating mode](https://react.dev/reference/react-compiler/gating)",
        recommended: true
      };
    }
    case "Globals" /* Globals */: {
      return {
        category,
        name: "globals",
        description: "Validates against assignment/mutation of globals during render, part of ensuring that [side effects must render outside of render](https://react.dev/reference/rules/components-and-hooks-must-be-pure#side-effects-must-run-outside-of-render)",
        recommended: true
      };
    }
    case "Hooks" /* Hooks */: {
      return {
        category,
        name: "hooks",
        description: "Validates the rules of hooks",
        /**
         * TODO: the "Hooks" rule largely reimplements the "rules-of-hooks" non-compiler rule.
         * We need to dedeupe these (moving the remaining bits into the compiler) and then enable
         * this rule.
         */
        recommended: false
      };
    }
    case "Immutability" /* Immutability */: {
      return {
        category,
        name: "immutability",
        description: "Validates against mutating props, state, and other values that [are immutable](https://react.dev/reference/rules/components-and-hooks-must-be-pure#props-and-state-are-immutable)",
        recommended: true
      };
    }
    case "Invariant" /* Invariant */: {
      return {
        category,
        name: "invariant",
        description: "Internal invariants",
        recommended: false
      };
    }
    case "PreserveManualMemo" /* PreserveManualMemo */: {
      return {
        category,
        name: "preserve-manual-memoization",
        description: "Validates that existing manual memoized is preserved by the compiler. React Compiler will only compile components and hooks if its inference [matches or exceeds the existing manual memoization](https://react.dev/learn/react-compiler/introduction#what-should-i-do-about-usememo-usecallback-and-reactmemo)",
        recommended: true
      };
    }
    case "Purity" /* Purity */: {
      return {
        category,
        name: "purity",
        description: "Validates that [components/hooks are pure](https://react.dev/reference/rules/components-and-hooks-must-be-pure) by checking that they do not call known-impure functions",
        recommended: true
      };
    }
    case "Refs" /* Refs */: {
      return {
        category,
        name: "refs",
        description: 'Validates correct usage of refs, not reading/writing during render. See the "pitfalls" section in [`useRef()` usage](https://react.dev/reference/react/useRef#usage)',
        recommended: true
      };
    }
    case "RenderSetState" /* RenderSetState */: {
      return {
        category,
        name: "set-state-in-render",
        description: "Validates against setting state during render, which can trigger additional renders and potential infinite render loops",
        recommended: true
      };
    }
    case "StaticComponents" /* StaticComponents */: {
      return {
        category,
        name: "static-components",
        description: "Validates that components are static, not recreated every render. Components that are recreated dynamically can reset state and trigger excessive re-rendering",
        recommended: true
      };
    }
    case "Suppression" /* Suppression */: {
      return {
        category,
        name: "rule-suppression",
        description: "Validates against suppression of other rules",
        recommended: false
      };
    }
    case "Syntax" /* Syntax */: {
      return {
        category,
        name: "syntax",
        description: "Validates against invalid syntax",
        recommended: false
      };
    }
    case "Todo" /* Todo */: {
      return {
        category,
        name: "todo",
        description: "Unimplemented features",
        recommended: false
      };
    }
    case "UnsupportedSyntax" /* UnsupportedSyntax */: {
      return {
        category,
        name: "unsupported-syntax",
        description: "Validates against syntax that we do not plan to support in React Compiler",
        recommended: true
      };
    }
    case "UseMemo" /* UseMemo */: {
      return {
        category,
        name: "use-memo",
        description: "Validates usage of the useMemo() hook against common mistakes. See [`useMemo()` docs](https://react.dev/reference/react/useMemo) for more information.",
        recommended: true
      };
    }
    default: {
      assertExhaustive(category, `Unsupported category ${category}`);
    }
  }
}
var LintRules = Object.keys(ErrorCategory).map(
  (category) => getRuleForCategory(category)
);

// src/Entrypoint/Gating.ts
function insertAdditionalFunctionDeclaration(fnPath, compiled, programContext, gatingFunctionIdentifierName) {
  var _a, _b;
  const originalFnName = fnPath.node.id;
  const originalFnParams = fnPath.node.params;
  const compiledParams = fnPath.node.params;
  CompilerError.invariant(originalFnName != null && compiled.id != null, {
    reason: "Expected function declarations that are referenced elsewhere to have a named identifier",
    loc: (_a = fnPath.node.loc) != null ? _a : null
  });
  CompilerError.invariant(originalFnParams.length === compiledParams.length, {
    reason: "Expected React Compiler optimized function declarations to have the same number of parameters as source",
    loc: (_b = fnPath.node.loc) != null ? _b : null
  });
  const gatingCondition = t.identifier(
    programContext.newUid(`${gatingFunctionIdentifierName}_result`)
  );
  const unoptimizedFnName = t.identifier(
    programContext.newUid(`${originalFnName.name}_unoptimized`)
  );
  const optimizedFnName = t.identifier(
    programContext.newUid(`${originalFnName.name}_optimized`)
  );
  compiled.id.name = optimizedFnName.name;
  fnPath.get("id").replaceInline(unoptimizedFnName);
  const newParams = [];
  const genNewArgs = [];
  for (let i = 0; i < originalFnParams.length; i++) {
    const argName = `arg${i}`;
    if (originalFnParams[i].type === "RestElement") {
      newParams.push(t.restElement(t.identifier(argName)));
      genNewArgs.push(() => t.spreadElement(t.identifier(argName)));
    } else {
      newParams.push(t.identifier(argName));
      genNewArgs.push(() => t.identifier(argName));
    }
  }
  fnPath.insertAfter(
    t.functionDeclaration(
      originalFnName,
      newParams,
      t.blockStatement([
        t.ifStatement(
          gatingCondition,
          t.returnStatement(
            t.callExpression(
              compiled.id,
              genNewArgs.map((fn) => fn())
            )
          ),
          t.returnStatement(
            t.callExpression(
              unoptimizedFnName,
              genNewArgs.map((fn) => fn())
            )
          )
        )
      ])
    )
  );
  fnPath.insertBefore(
    t.variableDeclaration("const", [
      t.variableDeclarator(
        gatingCondition,
        t.callExpression(t.identifier(gatingFunctionIdentifierName), [])
      )
    ])
  );
  fnPath.insertBefore(compiled);
}
function insertGatedFunctionDeclaration(fnPath, compiled, programContext, gating, referencedBeforeDeclaration) {
  var _a;
  const gatingImportedName = programContext.addImportSpecifier(gating).name;
  if (referencedBeforeDeclaration && fnPath.isFunctionDeclaration()) {
    CompilerError.invariant(compiled.type === "FunctionDeclaration", {
      reason: "Expected compiled node type to match input type",
      description: `Got ${compiled.type} but expected FunctionDeclaration`,
      loc: (_a = fnPath.node.loc) != null ? _a : null
    });
    insertAdditionalFunctionDeclaration(
      fnPath,
      compiled,
      programContext,
      gatingImportedName
    );
  } else {
    const gatingExpression = t.conditionalExpression(
      t.callExpression(t.identifier(gatingImportedName), []),
      buildFunctionExpression(compiled),
      buildFunctionExpression(fnPath.node)
    );
    if (fnPath.parentPath.node.type !== "ExportDefaultDeclaration" && fnPath.node.type === "FunctionDeclaration" && fnPath.node.id != null) {
      fnPath.replaceWith(
        t.variableDeclaration("const", [
          t.variableDeclarator(fnPath.node.id, gatingExpression)
        ])
      );
    } else if (fnPath.parentPath.node.type === "ExportDefaultDeclaration" && fnPath.node.type !== "ArrowFunctionExpression" && fnPath.node.id != null) {
      fnPath.insertAfter(
        t.exportDefaultDeclaration(t.identifier(fnPath.node.id.name))
      );
      fnPath.parentPath.replaceWith(
        t.variableDeclaration("const", [
          t.variableDeclarator(
            t.identifier(fnPath.node.id.name),
            gatingExpression
          )
        ])
      );
    } else {
      fnPath.replaceWith(gatingExpression);
    }
  }
}
function buildFunctionExpression(node) {
  var _a, _b;
  if (node.type === "ArrowFunctionExpression" || node.type === "FunctionExpression") {
    return node;
  } else {
    const fn = {
      type: "FunctionExpression",
      async: node.async,
      generator: node.generator,
      loc: (_a = node.loc) != null ? _a : null,
      id: (_b = node.id) != null ? _b : null,
      params: node.params,
      body: node.body
    };
    return fn;
  }
}

// src/Entrypoint/Imports.ts
var t5 = __toESM(require("@babel/types"));

// src/HIR/HIR.ts
var t2 = __toESM(require("@babel/types"));

// src/HIR/Types.ts
var opaqueTypeId = Symbol();
function makeTypeId(id) {
  CompilerError.invariant(id >= 0 && Number.isInteger(id), {
    reason: "Expected instruction id to be a non-negative integer",
    description: null,
    loc: null,
    suggestions: null
  });
  return id;
}
var typeCounter = 0;
function makeType() {
  return {
    kind: "Type",
    id: makeTypeId(typeCounter++)
  };
}
function typeEquals(tA, tB) {
  if (tA.kind !== tB.kind) return false;
  return typeVarEquals(tA, tB) || funcTypeEquals(tA, tB) || objectTypeEquals(tA, tB) || primitiveTypeEquals(tA, tB) || polyTypeEquals(tA, tB) || phiTypeEquals(tA, tB) || propTypeEquals(tA, tB) || objectMethodTypeEquals(tA, tB);
}
function typeVarEquals(tA, tB) {
  if (tA.kind === "Type" && tB.kind === "Type") {
    return tA.id === tB.id;
  }
  return false;
}
function typeKindCheck(tA, tb, type) {
  return tA.kind === type && tb.kind === type;
}
function objectMethodTypeEquals(tA, tB) {
  return typeKindCheck(tA, tB, "ObjectMethod");
}
function propTypeEquals(tA, tB) {
  if (tA.kind === "Property" && tB.kind === "Property") {
    if (!typeEquals(tA.objectType, tB.objectType)) {
      return false;
    }
    return tA.propertyName === tB.propertyName && tA.objectName === tB.objectName;
  }
  return false;
}
function primitiveTypeEquals(tA, tB) {
  return typeKindCheck(tA, tB, "Primitive");
}
function polyTypeEquals(tA, tB) {
  return typeKindCheck(tA, tB, "Poly");
}
function objectTypeEquals(tA, tB) {
  if (tA.kind === "Object" && tB.kind == "Object") {
    return tA.shapeId === tB.shapeId;
  }
  return false;
}
function funcTypeEquals(tA, tB) {
  if (tA.kind !== "Function" || tB.kind !== "Function") {
    return false;
  }
  return typeEquals(tA.return, tB.return);
}
function phiTypeEquals(tA, tB) {
  if (tA.kind === "Phi" && tB.kind === "Phi") {
    if (tA.operands.length !== tB.operands.length) {
      return false;
    }
    let operands = new Set(tA.operands);
    for (let i = 0; i < tB.operands.length; i++) {
      if (!operands.has(tB.operands[i])) {
        return false;
      }
    }
  }
  return false;
}

// ../../node_modules/zod/lib/index.mjs
var util2;
(function(util3) {
  util3.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util3.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util3.assertNever = assertNever;
  util3.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util3.getValidEnumValues = (obj) => {
    const validKeys = util3.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util3.objectValues(filtered);
  };
  util3.objectValues = (obj) => {
    return util3.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util3.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key2 in object) {
      if (Object.prototype.hasOwnProperty.call(object, key2)) {
        keys.push(key2);
      }
    }
    return keys;
  };
  util3.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util3.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util3.joinValues = joinValues;
  util3.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util2 || (util2 = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return __spreadValues(__spreadValues({}, first), second);
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util2.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t6 = typeof data;
  switch (t6) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
var ZodIssueCode = util2.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
var ZodError = class _ZodError extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof _ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util2.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util2.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util2.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util2.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util2.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util2.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util2.assertNever(issue);
  }
  return { message };
};
var overrideErrorMap = errorMap;
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = __spreadProps(__spreadValues({}, issueData), {
    path: fullPath
  });
  if (issueData.message !== void 0) {
    return __spreadProps(__spreadValues({}, issueData), {
      path: fullPath,
      message: issueData.message
    });
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return __spreadProps(__spreadValues({}, issueData), {
    path: fullPath,
    message: errorMessage
  });
};
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === errorMap ? void 0 : errorMap
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
var ParseStatus = class _ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static mergeObjectAsync(status, pairs) {
    return __async(this, null, function* () {
      const syncPairs = [];
      for (const pair of pairs) {
        const key2 = yield pair.key;
        const value = yield pair.value;
        syncPairs.push({
          key: key2,
          value
        });
      }
      return _ParseStatus.mergeObjectSync(status, syncPairs);
    });
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key: key2, value } = pair;
      if (key2.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key2.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key2.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key2.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x) => x.status === "aborted";
var isDirty = (x) => x.status === "dirty";
var isValid = (x) => x.status === "valid";
var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));
var _ZodEnum_cache;
var _ZodNativeEnum_cache;
var ParseInputLazyPath = class {
  constructor(parent, value, path, key2) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key2;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap3, invalid_type_error, required_error, description } = params;
  if (errorMap3 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap3)
    return { errorMap: errorMap3, description };
  const customMap = (iss, ctx) => {
    var _a, _b;
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message !== null && message !== void 0 ? message : ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: (_a = message !== null && message !== void 0 ? message : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
var ZodType = class {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    var _a, _b;
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if ((_b = (_a = err === null || err === void 0 ? void 0 : err.message) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  parseAsync(data, params) {
    return __async(this, null, function* () {
      const result = yield this.safeParseAsync(data, params);
      if (result.success)
        return result.data;
      throw result.error;
    });
  }
  safeParseAsync(data, params) {
    return __async(this, null, function* () {
      const ctx = {
        common: {
          issues: [],
          contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
          async: true
        },
        path: (params === null || params === void 0 ? void 0 : params.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: getParsedType(data)
      };
      const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
      const result = yield isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult);
      return handleResult(ctx, result);
    });
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue(__spreadValues({
        code: ZodIssueCode.custom
      }, getIssueProperties(val)));
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects(__spreadProps(__spreadValues({}, processCreateParams(this._def)), {
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    }));
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault(__spreadProps(__spreadValues({}, processCreateParams(this._def)), {
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    }));
  }
  brand() {
    return new ZodBranded(__spreadValues({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this
    }, processCreateParams(this._def)));
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch(__spreadProps(__spreadValues({}, processCreateParams(this._def)), {
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    }));
  }
  describe(description) {
    const This = this.constructor;
    return new This(__spreadProps(__spreadValues({}, this._def), {
      description
    }));
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[0-9a-z]+$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var nanoidRegex = /^[a-z0-9_-]{21}$/i;
var jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
var ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
var ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
var dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
  if (args.precision) {
    regex = `${regex}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    regex = `${regex}(\\.\\d+)?`;
  }
  return regex;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if (!decoded.typ || !decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch (_a) {
    return false;
  }
}
function isValidCidr(ip, version) {
  if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}
var ZodString = class _ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "jwt",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cidr",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util2.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), __spreadValues({
      validation,
      code: ZodIssueCode.invalid_string
    }, errorUtil.errToObj(message)));
  }
  _addCheck(check) {
    return new _ZodString(__spreadProps(__spreadValues({}, this._def), {
      checks: [...this._def.checks, check]
    }));
  }
  email(message) {
    return this._addCheck(__spreadValues({ kind: "email" }, errorUtil.errToObj(message)));
  }
  url(message) {
    return this._addCheck(__spreadValues({ kind: "url" }, errorUtil.errToObj(message)));
  }
  emoji(message) {
    return this._addCheck(__spreadValues({ kind: "emoji" }, errorUtil.errToObj(message)));
  }
  uuid(message) {
    return this._addCheck(__spreadValues({ kind: "uuid" }, errorUtil.errToObj(message)));
  }
  nanoid(message) {
    return this._addCheck(__spreadValues({ kind: "nanoid" }, errorUtil.errToObj(message)));
  }
  cuid(message) {
    return this._addCheck(__spreadValues({ kind: "cuid" }, errorUtil.errToObj(message)));
  }
  cuid2(message) {
    return this._addCheck(__spreadValues({ kind: "cuid2" }, errorUtil.errToObj(message)));
  }
  ulid(message) {
    return this._addCheck(__spreadValues({ kind: "ulid" }, errorUtil.errToObj(message)));
  }
  base64(message) {
    return this._addCheck(__spreadValues({ kind: "base64" }, errorUtil.errToObj(message)));
  }
  base64url(message) {
    return this._addCheck(__spreadValues({
      kind: "base64url"
    }, errorUtil.errToObj(message)));
  }
  jwt(options) {
    return this._addCheck(__spreadValues({ kind: "jwt" }, errorUtil.errToObj(options)));
  }
  ip(options) {
    return this._addCheck(__spreadValues({ kind: "ip" }, errorUtil.errToObj(options)));
  }
  cidr(options) {
    return this._addCheck(__spreadValues({ kind: "cidr" }, errorUtil.errToObj(options)));
  }
  datetime(options) {
    var _a, _b;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck(__spreadValues({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
      local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false
    }, errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)));
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck(__spreadValues({
      kind: "time",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision
    }, errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)));
  }
  duration(message) {
    return this._addCheck(__spreadValues({ kind: "duration" }, errorUtil.errToObj(message)));
  }
  regex(regex, message) {
    return this._addCheck(__spreadValues({
      kind: "regex",
      regex
    }, errorUtil.errToObj(message)));
  }
  includes(value, options) {
    return this._addCheck(__spreadValues({
      kind: "includes",
      value,
      position: options === null || options === void 0 ? void 0 : options.position
    }, errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)));
  }
  startsWith(value, message) {
    return this._addCheck(__spreadValues({
      kind: "startsWith",
      value
    }, errorUtil.errToObj(message)));
  }
  endsWith(value, message) {
    return this._addCheck(__spreadValues({
      kind: "endsWith",
      value
    }, errorUtil.errToObj(message)));
  }
  min(minLength, message) {
    return this._addCheck(__spreadValues({
      kind: "min",
      value: minLength
    }, errorUtil.errToObj(message)));
  }
  max(maxLength, message) {
    return this._addCheck(__spreadValues({
      kind: "max",
      value: maxLength
    }, errorUtil.errToObj(message)));
  }
  length(len, message) {
    return this._addCheck(__spreadValues({
      kind: "length",
      value: len
    }, errorUtil.errToObj(message)));
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new _ZodString(__spreadProps(__spreadValues({}, this._def), {
      checks: [...this._def.checks, { kind: "trim" }]
    }));
  }
  toLowerCase() {
    return new _ZodString(__spreadProps(__spreadValues({}, this._def), {
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    }));
  }
  toUpperCase() {
    return new _ZodString(__spreadProps(__spreadValues({}, this._def), {
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    }));
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString.create = (params) => {
  var _a;
  return new ZodString(__spreadValues({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false
  }, processCreateParams(params)));
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
var ZodNumber = class _ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util2.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util2.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodNumber(__spreadProps(__spreadValues({}, this._def), {
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    }));
  }
  _addCheck(check) {
    return new _ZodNumber(__spreadProps(__spreadValues({}, this._def), {
      checks: [...this._def.checks, check]
    }));
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util2.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber.create = (params) => {
  return new ZodNumber(__spreadValues({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false
  }, processCreateParams(params)));
};
var ZodBigInt = class _ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch (_a) {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util2.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    });
    return INVALID;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodBigInt(__spreadProps(__spreadValues({}, this._def), {
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    }));
  }
  _addCheck(check) {
    return new _ZodBigInt(__spreadProps(__spreadValues({}, this._def), {
      checks: [...this._def.checks, check]
    }));
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt.create = (params) => {
  var _a;
  return new ZodBigInt(__spreadValues({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false
  }, processCreateParams(params)));
};
var ZodBoolean = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodBoolean.create = (params) => {
  return new ZodBoolean(__spreadValues({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false
  }, processCreateParams(params)));
};
var ZodDate = class _ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util2.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new _ZodDate(__spreadProps(__spreadValues({}, this._def), {
      checks: [...this._def.checks, check]
    }));
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate.create = (params) => {
  return new ZodDate(__spreadValues({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate
  }, processCreateParams(params)));
};
var ZodSymbol = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodSymbol.create = (params) => {
  return new ZodSymbol(__spreadValues({
    typeName: ZodFirstPartyTypeKind.ZodSymbol
  }, processCreateParams(params)));
};
var ZodUndefined = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodUndefined.create = (params) => {
  return new ZodUndefined(__spreadValues({
    typeName: ZodFirstPartyTypeKind.ZodUndefined
  }, processCreateParams(params)));
};
var ZodNull = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodNull.create = (params) => {
  return new ZodNull(__spreadValues({
    typeName: ZodFirstPartyTypeKind.ZodNull
  }, processCreateParams(params)));
};
var ZodAny = class extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodAny.create = (params) => {
  return new ZodAny(__spreadValues({
    typeName: ZodFirstPartyTypeKind.ZodAny
  }, processCreateParams(params)));
};
var ZodUnknown = class extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodUnknown.create = (params) => {
  return new ZodUnknown(__spreadValues({
    typeName: ZodFirstPartyTypeKind.ZodUnknown
  }, processCreateParams(params)));
};
var ZodNever = class extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
};
ZodNever.create = (params) => {
  return new ZodNever(__spreadValues({
    typeName: ZodFirstPartyTypeKind.ZodNever
  }, processCreateParams(params)));
};
var ZodVoid = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodVoid.create = (params) => {
  return new ZodVoid(__spreadValues({
    typeName: ZodFirstPartyTypeKind.ZodVoid
  }, processCreateParams(params)));
};
var ZodArray = class _ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new _ZodArray(__spreadProps(__spreadValues({}, this._def), {
      minLength: { value: minLength, message: errorUtil.toString(message) }
    }));
  }
  max(maxLength, message) {
    return new _ZodArray(__spreadProps(__spreadValues({}, this._def), {
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    }));
  }
  length(len, message) {
    return new _ZodArray(__spreadProps(__spreadValues({}, this._def), {
      exactLength: { value: len, message: errorUtil.toString(message) }
    }));
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray.create = (schema, params) => {
  return new ZodArray(__spreadValues({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray
  }, processCreateParams(params)));
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key2 in schema.shape) {
      const fieldSchema = schema.shape[key2];
      newShape[key2] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject(__spreadProps(__spreadValues({}, schema._def), {
      shape: () => newShape
    }));
  } else if (schema instanceof ZodArray) {
    return new ZodArray(__spreadProps(__spreadValues({}, schema._def), {
      type: deepPartialify(schema.element)
    }));
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
var ZodObject = class _ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util2.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key2 in ctx.data) {
        if (!shapeKeys.includes(key2)) {
          extraKeys.push(key2);
        }
      }
    }
    const pairs = [];
    for (const key2 of shapeKeys) {
      const keyValidator = shape[key2];
      const value = ctx.data[key2];
      pairs.push({
        key: { status: "valid", value: key2 },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key2)),
        alwaysSet: key2 in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key2 of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key2 },
            value: { status: "valid", value: ctx.data[key2] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key2 of extraKeys) {
        const value = ctx.data[key2];
        pairs.push({
          key: { status: "valid", value: key2 },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key2)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key2 in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(() => __async(this, null, function* () {
        const syncPairs = [];
        for (const pair of pairs) {
          const key2 = yield pair.key;
          const value = yield pair.value;
          syncPairs.push({
            key: key2,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      })).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new _ZodObject(__spreadValues(__spreadProps(__spreadValues({}, this._def), {
      unknownKeys: "strict"
    }), message !== void 0 ? {
      errorMap: (issue, ctx) => {
        var _a, _b, _c, _d;
        const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
        if (issue.code === "unrecognized_keys")
          return {
            message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
          };
        return {
          message: defaultError
        };
      }
    } : {}));
  }
  strip() {
    return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
      unknownKeys: "strip"
    }));
  }
  passthrough() {
    return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
      unknownKeys: "passthrough"
    }));
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
      shape: () => __spreadValues(__spreadValues({}, this._def.shape()), augmentation)
    }));
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new _ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => __spreadValues(__spreadValues({}, this._def.shape()), merging._def.shape()),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key2, schema) {
    return this.augment({ [key2]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
      catchall: index
    }));
  }
  pick(mask) {
    const shape = {};
    util2.objectKeys(mask).forEach((key2) => {
      if (mask[key2] && this.shape[key2]) {
        shape[key2] = this.shape[key2];
      }
    });
    return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
      shape: () => shape
    }));
  }
  omit(mask) {
    const shape = {};
    util2.objectKeys(this.shape).forEach((key2) => {
      if (!mask[key2]) {
        shape[key2] = this.shape[key2];
      }
    });
    return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
      shape: () => shape
    }));
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util2.objectKeys(this.shape).forEach((key2) => {
      const fieldSchema = this.shape[key2];
      if (mask && !mask[key2]) {
        newShape[key2] = fieldSchema;
      } else {
        newShape[key2] = fieldSchema.optional();
      }
    });
    return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
      shape: () => newShape
    }));
  }
  required(mask) {
    const newShape = {};
    util2.objectKeys(this.shape).forEach((key2) => {
      if (mask && !mask[key2]) {
        newShape[key2] = this.shape[key2];
      } else {
        const fieldSchema = this.shape[key2];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key2] = newField;
      }
    });
    return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
      shape: () => newShape
    }));
  }
  keyof() {
    return createZodEnum(util2.objectKeys(this.shape));
  }
};
ZodObject.create = (shape, params) => {
  return new ZodObject(__spreadValues({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject
  }, processCreateParams(params)));
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject(__spreadValues({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject
  }, processCreateParams(params)));
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject(__spreadValues({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject
  }, processCreateParams(params)));
};
var ZodUnion = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map((option) => __async(this, null, function* () {
        const childCtx = __spreadProps(__spreadValues({}, ctx), {
          common: __spreadProps(__spreadValues({}, ctx.common), {
            issues: []
          }),
          parent: null
        });
        return {
          result: yield option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      }))).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = __spreadProps(__spreadValues({}, ctx), {
          common: __spreadProps(__spreadValues({}, ctx.common), {
            issues: []
          }),
          parent: null
        });
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion.create = (types, params) => {
  return new ZodUnion(__spreadValues({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion
  }, processCreateParams(params)));
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util2.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [void 0, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
};
var ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new _ZodDiscriminatedUnion(__spreadValues({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap
    }, processCreateParams(params)));
  }
};
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util2.objectKeys(b);
    const sharedKeys = util2.objectKeys(a).filter((key2) => bKeys.indexOf(key2) !== -1);
    const newObj = __spreadValues(__spreadValues({}, a), b);
    for (const key2 of sharedKeys) {
      const sharedValue = mergeValues(a[key2], b[key2]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key2] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
var ZodIntersection = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection(__spreadValues({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection
  }, processCreateParams(params)));
};
var ZodTuple = class _ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new _ZodTuple(__spreadProps(__spreadValues({}, this._def), {
      rest
    }));
  }
};
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple(__spreadValues({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null
  }, processCreateParams(params)));
};
var ZodRecord = class _ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key2 in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key2, ctx.path, key2)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key2], ctx.path, key2)),
        alwaysSet: key2 in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new _ZodRecord(__spreadValues({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord
      }, processCreateParams(third)));
    }
    return new _ZodRecord(__spreadValues({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord
    }, processCreateParams(second)));
  }
};
var ZodMap = class extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key2, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key2, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(() => __async(this, null, function* () {
        for (const pair of pairs) {
          const key2 = yield pair.key;
          const value = yield pair.value;
          if (key2.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key2.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key2.value, value.value);
        }
        return { status: status.value, value: finalMap };
      }));
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key2 = pair.key;
        const value = pair.value;
        if (key2.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key2.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key2.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap(__spreadValues({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap
  }, processCreateParams(params)));
};
var ZodSet = class _ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new _ZodSet(__spreadProps(__spreadValues({}, this._def), {
      minSize: { value: minSize, message: errorUtil.toString(message) }
    }));
  }
  max(maxSize, message) {
    return new _ZodSet(__spreadProps(__spreadValues({}, this._def), {
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    }));
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet.create = (valueType, params) => {
  return new ZodSet(__spreadValues({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet
  }, processCreateParams(params)));
};
var ZodFunction = class _ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(function(...args) {
        return __async(this, null, function* () {
          const error = new ZodError([]);
          const parsedArgs = yield me._def.args.parseAsync(args, params).catch((e) => {
            error.addIssue(makeArgsIssue(args, e));
            throw error;
          });
          const result = yield Reflect.apply(fn, this, parsedArgs);
          const parsedReturns = yield me._def.returns._def.type.parseAsync(result, params).catch((e) => {
            error.addIssue(makeReturnsIssue(result, e));
            throw error;
          });
          return parsedReturns;
        });
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new _ZodFunction(__spreadProps(__spreadValues({}, this._def), {
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    }));
  }
  returns(returnType) {
    return new _ZodFunction(__spreadProps(__spreadValues({}, this._def), {
      returns: returnType
    }));
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new _ZodFunction(__spreadValues({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction
    }, processCreateParams(params)));
  }
};
var ZodLazy = class extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy.create = (getter, params) => {
  return new ZodLazy(__spreadValues({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy
  }, processCreateParams(params)));
};
var ZodLiteral = class extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral.create = (value, params) => {
  return new ZodLiteral(__spreadValues({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral
  }, processCreateParams(params)));
};
function createZodEnum(values, params) {
  return new ZodEnum(__spreadValues({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum
  }, processCreateParams(params)));
}
var ZodEnum = class _ZodEnum extends ZodType {
  constructor() {
    super(...arguments);
    _ZodEnum_cache.set(this, void 0);
  }
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util2.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f")) {
      __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values), "f");
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f").has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return _ZodEnum.create(values, __spreadValues(__spreadValues({}, this._def), newDef));
  }
  exclude(values, newDef = this._def) {
    return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), __spreadValues(__spreadValues({}, this._def), newDef));
  }
};
_ZodEnum_cache = /* @__PURE__ */ new WeakMap();
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
  constructor() {
    super(...arguments);
    _ZodNativeEnum_cache.set(this, void 0);
  }
  _parse(input) {
    const nativeEnumValues = util2.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util2.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util2.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f")) {
      __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util2.getValidEnumValues(this._def.values)), "f");
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f").has(input.data)) {
      const expectedValues = util2.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
_ZodNativeEnum_cache = /* @__PURE__ */ new WeakMap();
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum(__spreadValues({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum
  }, processCreateParams(params)));
};
var ZodPromise = class extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise.create = (schema, params) => {
  return new ZodPromise(__spreadValues({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise
  }, processCreateParams(params)));
};
var ZodEffects = class extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then((processed2) => __async(this, null, function* () {
          if (status.value === "aborted")
            return INVALID;
          const result = yield this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        }));
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util2.assertNever(effect);
  }
};
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects(__spreadValues({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect
  }, processCreateParams(params)));
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects(__spreadValues({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects
  }, processCreateParams(params)));
};
var ZodOptional = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional.create = (type, params) => {
  return new ZodOptional(__spreadValues({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional
  }, processCreateParams(params)));
};
var ZodNullable = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable.create = (type, params) => {
  return new ZodNullable(__spreadValues({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable
  }, processCreateParams(params)));
};
var ZodDefault = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault.create = (type, params) => {
  return new ZodDefault(__spreadValues({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default
  }, processCreateParams(params)));
};
var ZodCatch = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = __spreadProps(__spreadValues({}, ctx), {
      common: __spreadProps(__spreadValues({}, ctx.common), {
        issues: []
      })
    });
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: __spreadValues({}, newCtx)
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch.create = (type, params) => {
  return new ZodCatch(__spreadValues({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch
  }, processCreateParams(params)));
};
var ZodNaN = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN.create = (params) => {
  return new ZodNaN(__spreadValues({
    typeName: ZodFirstPartyTypeKind.ZodNaN
  }, processCreateParams(params)));
};
var BRAND = Symbol("zod_brand");
var ZodBranded = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var ZodPipeline = class _ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = () => __async(this, null, function* () {
        const inResult = yield this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      });
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new _ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
};
var ZodReadonly = class extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly.create = (type, params) => {
  return new ZodReadonly(__spreadValues({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly
  }, processCreateParams(params)));
};
function cleanParams(params, data) {
  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
function custom(check, _params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a, _b;
      const r = check(data);
      if (r instanceof Promise) {
        return r.then((r2) => {
          var _a2, _b2;
          if (!r2) {
            const params = cleanParams(_params, data);
            const _fatal = (_b2 = (_a2 = params.fatal) !== null && _a2 !== void 0 ? _a2 : fatal) !== null && _b2 !== void 0 ? _b2 : true;
            ctx.addIssue(__spreadProps(__spreadValues({ code: "custom" }, params), { fatal: _fatal }));
          }
        });
      }
      if (!r) {
        const params = cleanParams(_params, data);
        const _fatal = (_b = (_a = params.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
        ctx.addIssue(__spreadProps(__spreadValues({ code: "custom" }, params), { fatal: _fatal }));
      }
      return;
    });
  return ZodAny.create();
}
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: (arg) => ZodString.create(__spreadProps(__spreadValues({}, arg), { coerce: true })),
  number: (arg) => ZodNumber.create(__spreadProps(__spreadValues({}, arg), { coerce: true })),
  boolean: (arg) => ZodBoolean.create(__spreadProps(__spreadValues({}, arg), {
    coerce: true
  })),
  bigint: (arg) => ZodBigInt.create(__spreadProps(__spreadValues({}, arg), { coerce: true })),
  date: (arg) => ZodDate.create(__spreadProps(__spreadValues({}, arg), { coerce: true }))
};
var NEVER = INVALID;
var z = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util2;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  datetimeRegex,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});

// src/Utils/Keyword.ts
var RESERVED_WORDS = /* @__PURE__ */ new Set([
  "break",
  "case",
  "catch",
  "class",
  "const",
  "continue",
  "debugger",
  "default",
  "delete",
  "do",
  "else",
  "enum",
  "export",
  "extends",
  "false",
  "finally",
  "for",
  "function",
  "if",
  "import",
  "in",
  "instanceof",
  "new",
  "null",
  "return",
  "super",
  "switch",
  "this",
  "throw",
  "true",
  "try",
  "typeof",
  "var",
  "void",
  "while",
  "with"
]);
var STRICT_MODE_RESERVED_WORDS = /* @__PURE__ */ new Set([
  "let",
  "static",
  "implements",
  "interface",
  "package",
  "private",
  "protected",
  "public"
]);
var STRICT_MODE_RESTRICTED_WORDS = /* @__PURE__ */ new Set(["eval", "arguments"]);
function isReservedWord(identifierName) {
  return RESERVED_WORDS.has(identifierName) || STRICT_MODE_RESERVED_WORDS.has(identifierName) || STRICT_MODE_RESTRICTED_WORDS.has(identifierName);
}

// src/HIR/HIR.ts
var GeneratedSource = Symbol();
function isStatementBlockKind(kind) {
  return kind === "block" || kind === "catch";
}
function isExpressionBlockKind(kind) {
  return !isStatementBlockKind(kind);
}
function convertHoistedLValueKind(kind) {
  switch (kind) {
    case "HoistedLet" /* HoistedLet */:
      return "Let" /* Let */;
    case "HoistedConst" /* HoistedConst */:
      return "Const" /* Const */;
    case "HoistedFunction" /* HoistedFunction */:
      return "Function" /* Function */;
    case "Let" /* Let */:
    case "Const" /* Const */:
    case "Function" /* Function */:
    case "Reassign" /* Reassign */:
    case "Catch" /* Catch */:
      return null;
    default:
      assertExhaustive(kind, "Unexpected lvalue kind");
  }
}
var opaqueValidIdentifierName = Symbol();
function makeTemporaryIdentifier(id, loc) {
  return {
    id,
    name: null,
    declarationId: makeDeclarationId(id),
    mutableRange: { start: makeInstructionId(0), end: makeInstructionId(0) },
    scope: null,
    type: makeType(),
    loc
  };
}
function forkTemporaryIdentifier(id, source2) {
  return __spreadProps(__spreadValues({}, source2), {
    mutableRange: { start: makeInstructionId(0), end: makeInstructionId(0) },
    id
  });
}
function makeIdentifierName(name) {
  if (isReservedWord(name)) {
    CompilerError.throwInvalidJS({
      reason: "Expected a non-reserved identifier name",
      loc: GeneratedSource,
      description: `\`${name}\` is a reserved word in JavaScript and cannot be used as an identifier name`,
      suggestions: null
    });
  } else {
    CompilerError.invariant(t2.isValidIdentifier(name), {
      reason: `Expected a valid identifier name`,
      loc: GeneratedSource,
      description: `\`${name}\` is not a valid JavaScript identifier`,
      suggestions: null
    });
  }
  return {
    kind: "named",
    value: name
  };
}
function promoteTemporary(identifier4) {
  CompilerError.invariant(identifier4.name === null, {
    reason: `Expected a temporary (unnamed) identifier`,
    loc: GeneratedSource,
    description: `Identifier already has a name, \`${identifier4.name}\``,
    suggestions: null
  });
  identifier4.name = {
    kind: "promoted",
    value: `#t${identifier4.declarationId}`
  };
}
function isPromotedTemporary(name) {
  return name.startsWith("#t");
}
function promoteTemporaryJsxTag(identifier4) {
  CompilerError.invariant(identifier4.name === null, {
    reason: `Expected a temporary (unnamed) identifier`,
    loc: GeneratedSource,
    description: `Identifier already has a name, \`${identifier4.name}\``,
    suggestions: null
  });
  identifier4.name = {
    kind: "promoted",
    value: `#T${identifier4.declarationId}`
  };
}
function isPromotedJsxTemporary(name) {
  return name.startsWith("#T");
}
var ValueReason = /* @__PURE__ */ ((ValueReason4) => {
  ValueReason4["Global"] = "global";
  ValueReason4["JsxCaptured"] = "jsx-captured";
  ValueReason4["HookCaptured"] = "hook-captured";
  ValueReason4["HookReturn"] = "hook-return";
  ValueReason4["Effect"] = "effect";
  ValueReason4["KnownReturnSignature"] = "known-return-signature";
  ValueReason4["Context"] = "context";
  ValueReason4["State"] = "state";
  ValueReason4["ReducerState"] = "reducer-state";
  ValueReason4["ReactiveFunctionArgument"] = "reactive-function-argument";
  ValueReason4["Other"] = "other";
  return ValueReason4;
})(ValueReason || {});
var ValueKind = /* @__PURE__ */ ((ValueKind3) => {
  ValueKind3["MaybeFrozen"] = "maybefrozen";
  ValueKind3["Frozen"] = "frozen";
  ValueKind3["Primitive"] = "primitive";
  ValueKind3["Global"] = "global";
  ValueKind3["Mutable"] = "mutable";
  ValueKind3["Context"] = "context";
  return ValueKind3;
})(ValueKind || {});
var ValueKindSchema = z.enum([
  "maybefrozen" /* MaybeFrozen */,
  "frozen" /* Frozen */,
  "primitive" /* Primitive */,
  "global" /* Global */,
  "mutable" /* Mutable */,
  "context" /* Context */
]);
var ValueReasonSchema = z.enum([
  "context" /* Context */,
  "effect" /* Effect */,
  "global" /* Global */,
  "hook-captured" /* HookCaptured */,
  "hook-return" /* HookReturn */,
  "jsx-captured" /* JsxCaptured */,
  "known-return-signature" /* KnownReturnSignature */,
  "other" /* Other */,
  "reactive-function-argument" /* ReactiveFunctionArgument */,
  "reducer-state" /* ReducerState */,
  "state" /* State */
]);
var Effect = /* @__PURE__ */ ((Effect2) => {
  Effect2["Unknown"] = "<unknown>";
  Effect2["Freeze"] = "freeze";
  Effect2["Read"] = "read";
  Effect2["Capture"] = "capture";
  Effect2["ConditionallyMutateIterator"] = "mutate-iterator?";
  Effect2["ConditionallyMutate"] = "mutate?";
  Effect2["Mutate"] = "mutate";
  Effect2["Store"] = "store";
  return Effect2;
})(Effect || {});
var EffectSchema = z.enum([
  "read" /* Read */,
  "mutate" /* Mutate */,
  "mutate?" /* ConditionallyMutate */,
  "mutate-iterator?" /* ConditionallyMutateIterator */,
  "capture" /* Capture */,
  "store" /* Store */,
  "freeze" /* Freeze */
]);
function isMutableEffect(effect, location) {
  switch (effect) {
    case "capture" /* Capture */:
    case "store" /* Store */:
    case "mutate?" /* ConditionallyMutate */:
    case "mutate-iterator?" /* ConditionallyMutateIterator */:
    case "mutate" /* Mutate */: {
      return true;
    }
    case "<unknown>" /* Unknown */: {
      CompilerError.invariant(false, {
        reason: "Unexpected unknown effect",
        description: null,
        loc: location,
        suggestions: null
      });
    }
    case "read" /* Read */:
    case "freeze" /* Freeze */: {
      return false;
    }
    default: {
      assertExhaustive(effect, `Unexpected effect \`${effect}\``);
    }
  }
}
var opaquePropertyLiteral = Symbol();
function makePropertyLiteral(value) {
  return value;
}
function areEqualPaths(a, b) {
  return a.length === b.length && a.every(
    (item, ix) => item.property === b[ix].property && item.optional === b[ix].optional
  );
}
function getPlaceScope(id, place) {
  const scope = place.identifier.scope;
  if (scope !== null && isScopeActive(scope, id)) {
    return scope;
  }
  return null;
}
function isScopeActive(scope, id) {
  return id >= scope.range.start && id < scope.range.end;
}
var opaqueBlockId = Symbol();
function makeBlockId(id) {
  CompilerError.invariant(id >= 0 && Number.isInteger(id), {
    reason: "Expected block id to be a non-negative integer",
    description: null,
    loc: null,
    suggestions: null
  });
  return id;
}
var opaqueScopeId = Symbol();
function makeScopeId(id) {
  CompilerError.invariant(id >= 0 && Number.isInteger(id), {
    reason: "Expected block id to be a non-negative integer",
    description: null,
    loc: null,
    suggestions: null
  });
  return id;
}
var opaqueIdentifierId = Symbol();
function makeIdentifierId(id) {
  CompilerError.invariant(id >= 0 && Number.isInteger(id), {
    reason: "Expected identifier id to be a non-negative integer",
    description: null,
    loc: null,
    suggestions: null
  });
  return id;
}
var opageDeclarationId = Symbol();
function makeDeclarationId(id) {
  CompilerError.invariant(id >= 0 && Number.isInteger(id), {
    reason: "Expected declaration id to be a non-negative integer",
    description: null,
    loc: null,
    suggestions: null
  });
  return id;
}
var opaqueInstructionId = Symbol();
function makeInstructionId(id) {
  CompilerError.invariant(id >= 0 && Number.isInteger(id), {
    reason: "Expected instruction id to be a non-negative integer",
    description: null,
    loc: null,
    suggestions: null
  });
  return id;
}
function isObjectMethodType(id) {
  return id.type.kind == "ObjectMethod";
}
function isPrimitiveType(id) {
  return id.type.kind === "Primitive";
}
function isArrayType(id) {
  return id.type.kind === "Object" && id.type.shapeId === "BuiltInArray";
}
function isMapType(id) {
  return id.type.kind === "Object" && id.type.shapeId === "BuiltInMap";
}
function isSetType(id) {
  return id.type.kind === "Object" && id.type.shapeId === "BuiltInSet";
}
function isPropsType(id) {
  return id.type.kind === "Object" && id.type.shapeId === "BuiltInProps";
}
function isRefValueType(id) {
  return id.type.kind === "Object" && id.type.shapeId === "BuiltInRefValue";
}
function isUseRefType(id) {
  return id.type.kind === "Object" && id.type.shapeId === "BuiltInUseRefId";
}
function isUseStateType(id) {
  return id.type.kind === "Object" && id.type.shapeId === "BuiltInUseState";
}
function isJsxType(type) {
  return type.kind === "Object" && type.shapeId === "BuiltInJsx";
}
function isRefOrRefValue(id) {
  return isUseRefType(id) || isRefValueType(id);
}
function isRefOrRefLikeMutableType(type) {
  return type.kind === "Object" && (type.shapeId === "BuiltInUseRefId" || type.shapeId == "ReanimatedSharedValueId");
}
function isSetStateType(id) {
  return id.type.kind === "Function" && id.type.shapeId === "BuiltInSetState";
}
function isStartTransitionType(id) {
  return id.type.kind === "Function" && id.type.shapeId === "BuiltInStartTransition";
}
function isSetActionStateType(id) {
  return id.type.kind === "Function" && id.type.shapeId === "BuiltInSetActionState";
}
function isUseReducerType(id) {
  return id.type.kind === "Function" && id.type.shapeId === "BuiltInUseReducer";
}
function isDispatcherType(id) {
  return id.type.kind === "Function" && id.type.shapeId === "BuiltInDispatch";
}
function isFireFunctionType(id) {
  return id.type.kind === "Function" && id.type.shapeId === "BuiltInFireFunction";
}
function isEffectEventFunctionType(id) {
  return id.type.kind === "Function" && id.type.shapeId === "BuiltInEffectEventFunction";
}
function isStableType(id) {
  return isSetStateType(id) || isSetActionStateType(id) || isDispatcherType(id) || isUseRefType(id) || isStartTransitionType(id);
}
function isStableTypeContainer(id) {
  const type_ = id.type;
  if (type_.kind !== "Object") {
    return false;
  }
  return isUseStateType(id) || // setState
  type_.shapeId === "BuiltInUseActionState" || // setActionState
  isUseReducerType(id) || // dispatcher
  type_.shapeId === "BuiltInUseTransition";
}
function evaluatesToStableTypeOrContainer(env, { value }) {
  if (value.kind === "CallExpression" || value.kind === "MethodCall") {
    const callee = value.kind === "CallExpression" ? value.callee : value.property;
    const calleeHookKind = getHookKind(env, callee.identifier);
    switch (calleeHookKind) {
      case "useState":
      case "useReducer":
      case "useActionState":
      case "useRef":
      case "useTransition":
        return true;
    }
  }
  return false;
}
function isUseEffectHookType(id) {
  return id.type.kind === "Function" && id.type.shapeId === "BuiltInUseEffectHook";
}
function isUseLayoutEffectHookType(id) {
  return id.type.kind === "Function" && id.type.shapeId === "BuiltInUseLayoutEffectHook";
}
function isUseInsertionEffectHookType(id) {
  return id.type.kind === "Function" && id.type.shapeId === "BuiltInUseInsertionEffectHook";
}
function isUseContextHookType(id) {
  return id.type.kind === "Function" && id.type.shapeId === "BuiltInUseContextHook";
}
function getHookKind(env, id) {
  return getHookKindForType(env, id.type);
}
function isUseOperator(id) {
  return id.type.kind === "Function" && id.type.shapeId === "BuiltInUseOperator";
}
function getHookKindForType(env, type) {
  var _a;
  if (type.kind === "Function") {
    const signature = env.getFunctionSignature(type);
    return (_a = signature == null ? void 0 : signature.hookKind) != null ? _a : null;
  }
  return null;
}

// src/ReactiveScopes/PrintReactiveFunction.ts
function printReactiveFunctionWithOutlined(fn) {
  const writer = new Writer();
  writeReactiveFunction(fn, writer);
  for (const outlined of fn.env.getOutlinedFunctions()) {
    writer.writeLine("\nfunction " + printFunction(outlined.fn));
  }
  return writer.complete();
}
function printReactiveFunction(fn) {
  const writer = new Writer();
  writeReactiveFunction(fn, writer);
  return writer.complete();
}
function writeReactiveFunction(fn, writer) {
  writer.writeLine(`function ${fn.id !== null ? fn.id : "<unknown>"}(`);
  writer.indented(() => {
    for (const param of fn.params) {
      if (param.kind === "Identifier") {
        writer.writeLine(`${printPlace(param)},`);
      } else {
        writer.writeLine(`...${printPlace(param.place)},`);
      }
    }
  });
  writer.writeLine(") {");
  writeReactiveInstructions(writer, fn.body);
  writer.writeLine("}");
}
function printReactiveScopeSummary(scope) {
  const items = [];
  items.push("scope");
  items.push(`@${scope.id}`);
  items.push(`[${scope.range.start}:${scope.range.end}]`);
  items.push(
    `dependencies=[${Array.from(scope.dependencies).map((dep) => printDependency(dep)).join(", ")}]`
  );
  items.push(
    `declarations=[${Array.from(scope.declarations).map(
      ([, decl]) => printIdentifier(__spreadProps(__spreadValues({}, decl.identifier), { scope: decl.scope }))
    ).join(", ")}]`
  );
  items.push(
    `reassignments=[${Array.from(scope.reassignments).map(
      (reassign) => printIdentifier(reassign)
    )}]`
  );
  if (scope.earlyReturnValue !== null) {
    items.push(
      `earlyReturn={id: ${printIdentifier(
        scope.earlyReturnValue.value
      )}, label: ${scope.earlyReturnValue.label}}}`
    );
  }
  return items.join(" ");
}
function writeReactiveBlock(writer, block) {
  writer.writeLine(`${printReactiveScopeSummary(block.scope)} {`);
  writeReactiveInstructions(writer, block.instructions);
  writer.writeLine("}");
}
function writePrunedScope(writer, block) {
  writer.writeLine(`<pruned> ${printReactiveScopeSummary(block.scope)} {`);
  writeReactiveInstructions(writer, block.instructions);
  writer.writeLine("}");
}
function printDependency(dependency) {
  const identifier4 = printIdentifier(dependency.identifier) + printType(dependency.identifier.type);
  return `${identifier4}${dependency.path.map((token2) => `${token2.optional ? "?." : "."}${token2.property}`).join("")}`;
}
function writeReactiveInstructions(writer, instructions) {
  writer.indented(() => {
    for (const instr of instructions) {
      writeReactiveInstruction(writer, instr);
    }
  });
}
function writeReactiveInstruction(writer, instr) {
  switch (instr.kind) {
    case "instruction": {
      const { instruction } = instr;
      const id = `[${instruction.id}]`;
      if (instruction.lvalue !== null) {
        writer.write(`${id} ${printPlace(instruction.lvalue)} = `);
        writeReactiveValue(writer, instruction.value);
        writer.newline();
      } else {
        writer.write(`${id} `);
        writeReactiveValue(writer, instruction.value);
        writer.newline();
      }
      break;
    }
    case "scope": {
      writeReactiveBlock(writer, instr);
      break;
    }
    case "pruned-scope": {
      writePrunedScope(writer, instr);
      break;
    }
    case "terminal": {
      if (instr.label !== null) {
        writer.write(`bb${instr.label.id}: `);
      }
      writeTerminal(writer, instr.terminal);
      break;
    }
    default: {
      assertExhaustive(
        instr,
        `Unexpected terminal kind \`${instr.kind}\``
      );
    }
  }
}
function writeReactiveValue(writer, value) {
  switch (value.kind) {
    case "ConditionalExpression": {
      writer.writeLine(`Ternary `);
      writer.indented(() => {
        writeReactiveValue(writer, value.test);
        writer.writeLine(`? `);
        writer.indented(() => {
          writeReactiveValue(writer, value.consequent);
        });
        writer.writeLine(`: `);
        writer.indented(() => {
          writeReactiveValue(writer, value.alternate);
        });
      });
      writer.newline();
      break;
    }
    case "LogicalExpression": {
      writer.writeLine(`Logical`);
      writer.indented(() => {
        writeReactiveValue(writer, value.left);
        writer.write(`${value.operator} `);
        writeReactiveValue(writer, value.right);
      });
      writer.newline();
      break;
    }
    case "SequenceExpression": {
      writer.writeLine(`Sequence`);
      writer.indented(() => {
        writer.indented(() => {
          value.instructions.forEach(
            (instr) => writeReactiveInstruction(writer, {
              kind: "instruction",
              instruction: instr
            })
          );
          writer.write(`[${value.id}] `);
          writeReactiveValue(writer, value.value);
        });
      });
      writer.newline();
      break;
    }
    case "OptionalExpression": {
      writer.append(`OptionalExpression optional=${value.optional}`);
      writer.newline();
      writer.indented(() => {
        writeReactiveValue(writer, value.value);
      });
      writer.newline();
      break;
    }
    default: {
      const printed = printInstructionValue(value);
      const lines = printed.split("\n");
      if (lines.length === 1) {
        writer.writeLine(printed);
      } else {
        writer.indented(() => {
          for (const line2 of lines) {
            writer.writeLine(line2);
          }
        });
      }
    }
  }
}
function writeTerminal(writer, terminal) {
  switch (terminal.kind) {
    case "break": {
      const id = terminal.id !== null ? `[${terminal.id}]` : [];
      writer.writeLine(
        `${id} break bb${terminal.target} (${terminal.targetKind})`
      );
      break;
    }
    case "continue": {
      const id = `[${terminal.id}]`;
      writer.writeLine(
        `${id} continue bb${terminal.target} (${terminal.targetKind})`
      );
      break;
    }
    case "do-while": {
      writer.writeLine(`[${terminal.id}] do-while {`);
      writeReactiveInstructions(writer, terminal.loop);
      writer.writeLine("} (");
      writer.indented(() => {
        writeReactiveValue(writer, terminal.test);
      });
      writer.writeLine(")");
      break;
    }
    case "while": {
      writer.writeLine(`[${terminal.id}] while (`);
      writer.indented(() => {
        writeReactiveValue(writer, terminal.test);
      });
      writer.writeLine(") {");
      writeReactiveInstructions(writer, terminal.loop);
      writer.writeLine("}");
      break;
    }
    case "if": {
      const { test, consequent, alternate } = terminal;
      writer.writeLine(`[${terminal.id}] if (${printPlace(test)}) {`);
      writeReactiveInstructions(writer, consequent);
      if (alternate !== null) {
        writer.writeLine("} else {");
        writeReactiveInstructions(writer, alternate);
      }
      writer.writeLine("}");
      break;
    }
    case "switch": {
      writer.writeLine(
        `[${terminal.id}] switch (${printPlace(terminal.test)}) {`
      );
      writer.indented(() => {
        for (const case_ of terminal.cases) {
          let prefix = case_.test !== null ? `case ${printPlace(case_.test)}` : "default";
          writer.writeLine(`${prefix}: {`);
          writer.indented(() => {
            var _a, _b;
            const block = case_.block;
            CompilerError.invariant(block != null, {
              reason: "Expected case to have a block",
              description: null,
              loc: (_b = (_a = case_.test) == null ? void 0 : _a.loc) != null ? _b : null,
              suggestions: null
            });
            writeReactiveInstructions(writer, block);
          });
          writer.writeLine("}");
        }
      });
      writer.writeLine("}");
      break;
    }
    case "for": {
      writer.writeLine(`[${terminal.id}] for (`);
      writer.indented(() => {
        writeReactiveValue(writer, terminal.init);
        writer.writeLine(";");
        writeReactiveValue(writer, terminal.test);
        writer.writeLine(";");
        if (terminal.update !== null) {
          writeReactiveValue(writer, terminal.update);
        }
      });
      writer.writeLine(") {");
      writeReactiveInstructions(writer, terminal.loop);
      writer.writeLine("}");
      break;
    }
    case "for-of": {
      writer.writeLine(`[${terminal.id}] for-of (`);
      writer.indented(() => {
        writeReactiveValue(writer, terminal.init);
        writer.writeLine(";");
        writeReactiveValue(writer, terminal.test);
      });
      writer.writeLine(") {");
      writeReactiveInstructions(writer, terminal.loop);
      writer.writeLine("}");
      break;
    }
    case "for-in": {
      writer.writeLine(`[${terminal.id}] for-in (`);
      writer.indented(() => {
        writeReactiveValue(writer, terminal.init);
      });
      writer.writeLine(") {");
      writeReactiveInstructions(writer, terminal.loop);
      writer.writeLine("}");
      break;
    }
    case "throw": {
      writer.writeLine(`[${terminal.id}] throw ${printPlace(terminal.value)}`);
      break;
    }
    case "return": {
      writer.writeLine(`[${terminal.id}] return ${printPlace(terminal.value)}`);
      break;
    }
    case "label": {
      writer.writeLine("{");
      writeReactiveInstructions(writer, terminal.block);
      writer.writeLine("}");
      break;
    }
    case "try": {
      writer.writeLine(`[${terminal.id}] try {`);
      writeReactiveInstructions(writer, terminal.block);
      writer.write(`} catch `);
      if (terminal.handlerBinding !== null) {
        writer.writeLine(`(${printPlace(terminal.handlerBinding)}) {`);
      } else {
        writer.writeLine(`{`);
      }
      writeReactiveInstructions(writer, terminal.handler);
      writer.writeLine("}");
      break;
    }
    default:
      assertExhaustive(
        terminal,
        `Unhandled terminal kind \`${terminal.kind}\``
      );
  }
}
var _out, _line, _depth;
var Writer = class {
  constructor({ depth } = { depth: 0 }) {
    __privateAdd(this, _out, []);
    __privateAdd(this, _line);
    __privateAdd(this, _depth);
    __privateSet(this, _depth, Math.max(depth, 0));
    __privateSet(this, _line, "");
  }
  complete() {
    const line2 = __privateGet(this, _line).trimEnd();
    if (line2.length > 0) {
      __privateGet(this, _out).push(line2);
    }
    return __privateGet(this, _out).join("\n");
  }
  append(s) {
    this.write(s);
  }
  newline() {
    const line2 = __privateGet(this, _line).trimEnd();
    if (line2.length > 0) {
      __privateGet(this, _out).push(line2);
    }
    __privateSet(this, _line, "");
  }
  write(s) {
    if (__privateGet(this, _line).length === 0 && __privateGet(this, _depth) > 0) {
      __privateSet(this, _line, "  ".repeat(__privateGet(this, _depth)));
    }
    __privateSet(this, _line, __privateGet(this, _line) + s);
  }
  writeLine(s) {
    this.write(s);
    this.newline();
  }
  indented(f) {
    __privateWrapper(this, _depth)._++;
    f();
    __privateWrapper(this, _depth)._--;
  }
};
_out = new WeakMap();
_line = new WeakMap();
_depth = new WeakMap();

// src/HIR/PrintHIR.ts
function printFunctionWithOutlined(fn) {
  const output = [printFunction(fn)];
  for (const outlined of fn.env.getOutlinedFunctions()) {
    output.push(`
function ${outlined.fn.id}:
${printHIR(outlined.fn.body)}`);
  }
  return output.join("\n");
}
function printFunction(fn) {
  const output = [];
  let definition = "";
  if (fn.id !== null) {
    definition += fn.id;
  } else {
    definition += "<<anonymous>>";
  }
  if (fn.params.length !== 0) {
    definition += "(" + fn.params.map((param) => {
      if (param.kind === "Identifier") {
        return printPlace(param);
      } else {
        return `...${printPlace(param.place)}`;
      }
    }).join(", ") + ")";
  } else {
    definition += "()";
  }
  definition += `: ${printPlace(fn.returns)}`;
  output.push(definition);
  output.push(...fn.directives);
  output.push(printHIR(fn.body));
  return output.join("\n");
}
function printHIR(ir, options = null) {
  var _a;
  let output = [];
  let indent = " ".repeat((_a = options == null ? void 0 : options.indent) != null ? _a : 0);
  const push2 = (text, indent2 = "  ") => {
    output.push(`${indent2}${text}`);
  };
  for (const [blockId, block] of ir.blocks) {
    output.push(`bb${blockId} (${block.kind}):`);
    if (block.preds.size > 0) {
      const preds = ["predecessor blocks:"];
      for (const pred of block.preds) {
        preds.push(`bb${pred}`);
      }
      push2(preds.join(" "));
    }
    for (const phi of block.phis) {
      push2(printPhi(phi));
    }
    for (const instr of block.instructions) {
      push2(printInstruction(instr));
    }
    const terminal = printTerminal(block.terminal);
    if (Array.isArray(terminal)) {
      terminal.forEach((line2) => push2(line2));
    } else {
      push2(terminal);
    }
  }
  return output.map((line2) => indent + line2).join("\n");
}
function printInstruction(instr) {
  const id = `[${instr.id}]`;
  let value = printInstructionValue(instr.value);
  if (instr.effects != null) {
    value += `
    ${instr.effects.map(printAliasingEffect).join("\n    ")}`;
  }
  if (instr.lvalue !== null) {
    return `${id} ${printPlace(instr.lvalue)} = ${value}`;
  } else {
    return `${id} ${value}`;
  }
}
function printPhi(phi) {
  const items = [];
  items.push(printPlace(phi.place));
  items.push(printMutableRange(phi.place.identifier));
  items.push(printType(phi.place.identifier.type));
  items.push(": phi(");
  const phis = [];
  for (const [blockId, place] of phi.operands) {
    phis.push(`bb${blockId}: ${printPlace(place)}`);
  }
  items.push(phis.join(", "));
  items.push(")");
  return items.join("");
}
function printTerminal(terminal) {
  let value;
  switch (terminal.kind) {
    case "if": {
      value = `[${terminal.id}] If (${printPlace(terminal.test)}) then:bb${terminal.consequent} else:bb${terminal.alternate}${terminal.fallthrough ? ` fallthrough=bb${terminal.fallthrough}` : ""}`;
      break;
    }
    case "branch": {
      value = `[${terminal.id}] Branch (${printPlace(terminal.test)}) then:bb${terminal.consequent} else:bb${terminal.alternate} fallthrough:bb${terminal.fallthrough}`;
      break;
    }
    case "logical": {
      value = `[${terminal.id}] Logical ${terminal.operator} test:bb${terminal.test} fallthrough=bb${terminal.fallthrough}`;
      break;
    }
    case "ternary": {
      value = `[${terminal.id}] Ternary test:bb${terminal.test} fallthrough=bb${terminal.fallthrough}`;
      break;
    }
    case "optional": {
      value = `[${terminal.id}] Optional (optional=${terminal.optional}) test:bb${terminal.test} fallthrough=bb${terminal.fallthrough}`;
      break;
    }
    case "throw": {
      value = `[${terminal.id}] Throw ${printPlace(terminal.value)}`;
      break;
    }
    case "return": {
      value = `[${terminal.id}] Return ${terminal.returnVariant}${terminal.value != null ? " " + printPlace(terminal.value) : ""}`;
      if (terminal.effects != null) {
        value += `
    ${terminal.effects.map(printAliasingEffect).join("\n    ")}`;
      }
      break;
    }
    case "goto": {
      value = `[${terminal.id}] Goto${terminal.variant === "Continue" /* Continue */ ? "(Continue)" : ""} bb${terminal.block}`;
      break;
    }
    case "switch": {
      const output = [];
      output.push(`[${terminal.id}] Switch (${printPlace(terminal.test)})`);
      terminal.cases.forEach((case_) => {
        if (case_.test !== null) {
          output.push(`  Case ${printPlace(case_.test)}: bb${case_.block}`);
        } else {
          output.push(`  Default: bb${case_.block}`);
        }
      });
      if (terminal.fallthrough) {
        output.push(`  Fallthrough: bb${terminal.fallthrough}`);
      }
      value = output;
      break;
    }
    case "do-while": {
      value = `[${terminal.id}] DoWhile loop=${`bb${terminal.loop}`} test=bb${terminal.test} fallthrough=${`bb${terminal.fallthrough}`}`;
      break;
    }
    case "while": {
      value = `[${terminal.id}] While test=bb${terminal.test} loop=${terminal.loop !== null ? `bb${terminal.loop}` : ""} fallthrough=${terminal.fallthrough ? `bb${terminal.fallthrough}` : ""}`;
      break;
    }
    case "for": {
      value = `[${terminal.id}] For init=bb${terminal.init} test=bb${terminal.test} loop=bb${terminal.loop} update=bb${terminal.update} fallthrough=bb${terminal.fallthrough}`;
      break;
    }
    case "for-of": {
      value = `[${terminal.id}] ForOf init=bb${terminal.init} test=bb${terminal.test} loop=bb${terminal.loop} fallthrough=bb${terminal.fallthrough}`;
      break;
    }
    case "for-in": {
      value = `[${terminal.id}] ForIn init=bb${terminal.init} loop=bb${terminal.loop} fallthrough=bb${terminal.fallthrough}`;
      break;
    }
    case "label": {
      value = `[${terminal.id}] Label block=bb${terminal.block} fallthrough=${terminal.fallthrough ? `bb${terminal.fallthrough}` : ""}`;
      break;
    }
    case "sequence": {
      value = `[${terminal.id}] Sequence block=bb${terminal.block} fallthrough=bb${terminal.fallthrough}`;
      break;
    }
    case "unreachable": {
      value = `[${terminal.id}] Unreachable`;
      break;
    }
    case "unsupported": {
      value = `[${terminal.id}] Unsupported`;
      break;
    }
    case "maybe-throw": {
      value = `[${terminal.id}] MaybeThrow continuation=bb${terminal.continuation} handler=bb${terminal.handler}`;
      if (terminal.effects != null) {
        value += `
    ${terminal.effects.map(printAliasingEffect).join("\n    ")}`;
      }
      break;
    }
    case "scope": {
      value = `[${terminal.id}] Scope ${printReactiveScopeSummary(
        terminal.scope
      )} block=bb${terminal.block} fallthrough=bb${terminal.fallthrough}`;
      break;
    }
    case "pruned-scope": {
      value = `[${terminal.id}] <pruned> Scope ${printReactiveScopeSummary(
        terminal.scope
      )} block=bb${terminal.block} fallthrough=bb${terminal.fallthrough}`;
      break;
    }
    case "try": {
      value = `[${terminal.id}] Try block=bb${terminal.block} handler=bb${terminal.handler}${terminal.handlerBinding !== null ? ` handlerBinding=(${printPlace(terminal.handlerBinding)})` : ""} fallthrough=${terminal.fallthrough != null ? `bb${terminal.fallthrough}` : ""}`;
      break;
    }
    default: {
      assertExhaustive(
        terminal,
        `Unexpected terminal kind \`${terminal}\``
      );
    }
  }
  return value;
}
function printHole() {
  return "<hole>";
}
function printObjectPropertyKey(key2) {
  switch (key2.kind) {
    case "identifier":
      return key2.name;
    case "string":
      return `"${key2.name}"`;
    case "computed": {
      return `[${printPlace(key2.name)}]`;
    }
    case "number": {
      return String(key2.name);
    }
  }
}
function printInstructionValue(instrValue) {
  var _a, _b, _c, _d, _e;
  let value = "";
  switch (instrValue.kind) {
    case "ArrayExpression": {
      value = `Array [${instrValue.elements.map((element) => {
        if (element.kind === "Identifier") {
          return printPlace(element);
        } else if (element.kind === "Hole") {
          return printHole();
        } else {
          return `...${printPlace(element.place)}`;
        }
      }).join(", ")}]`;
      break;
    }
    case "ObjectExpression": {
      const properties = [];
      if (instrValue.properties !== null) {
        for (const property of instrValue.properties) {
          if (property.kind === "ObjectProperty") {
            properties.push(
              `${printObjectPropertyKey(property.key)}: ${printPlace(
                property.place
              )}`
            );
          } else {
            properties.push(`...${printPlace(property.place)}`);
          }
        }
      }
      value = `Object { ${properties.join(", ")} }`;
      break;
    }
    case "UnaryExpression": {
      value = `Unary ${printPlace(instrValue.value)}`;
      break;
    }
    case "BinaryExpression": {
      value = `Binary ${printPlace(instrValue.left)} ${instrValue.operator} ${printPlace(instrValue.right)}`;
      break;
    }
    case "NewExpression": {
      value = `New ${printPlace(instrValue.callee)}(${instrValue.args.map((arg) => printPattern(arg)).join(", ")})`;
      break;
    }
    case "CallExpression": {
      value = `Call ${printPlace(instrValue.callee)}(${instrValue.args.map((arg) => printPattern(arg)).join(", ")})`;
      break;
    }
    case "MethodCall": {
      value = `MethodCall ${printPlace(instrValue.receiver)}.${printPlace(
        instrValue.property
      )}(${instrValue.args.map((arg) => printPattern(arg)).join(", ")})`;
      break;
    }
    case "JSXText": {
      value = `JSXText ${JSON.stringify(instrValue.value)}`;
      break;
    }
    case "Primitive": {
      if (instrValue.value === void 0) {
        value = "<undefined>";
      } else {
        value = JSON.stringify(instrValue.value);
      }
      break;
    }
    case "TypeCastExpression": {
      value = `TypeCast ${printPlace(instrValue.value)}: ${printType(
        instrValue.type
      )}`;
      break;
    }
    case "JsxExpression": {
      const propItems = [];
      for (const attribute of instrValue.props) {
        if (attribute.kind === "JsxAttribute") {
          propItems.push(
            `${attribute.name}={${attribute.place !== null ? printPlace(attribute.place) : "<empty>"}}`
          );
        } else {
          propItems.push(`...${printPlace(attribute.argument)}`);
        }
      }
      const tag = instrValue.tag.kind === "Identifier" ? printPlace(instrValue.tag) : instrValue.tag.name;
      const props = propItems.length !== 0 ? " " + propItems.join(" ") : "";
      if (instrValue.children !== null) {
        const children = instrValue.children.map((child) => {
          return `{${printPlace(child)}}`;
        });
        value = `JSX <${tag}${props}${props.length > 0 ? " " : ""}>${children.join("")}</${tag}>`;
      } else {
        value = `JSX <${tag}${props}${props.length > 0 ? " " : ""}/>`;
      }
      break;
    }
    case "JsxFragment": {
      value = `JsxFragment [${instrValue.children.map((child) => printPlace(child)).join(", ")}]`;
      break;
    }
    case "UnsupportedNode": {
      value = `UnsupportedNode ${instrValue.node.type}`;
      break;
    }
    case "LoadLocal": {
      value = `LoadLocal ${printPlace(instrValue.place)}`;
      break;
    }
    case "DeclareLocal": {
      value = `DeclareLocal ${instrValue.lvalue.kind} ${printPlace(
        instrValue.lvalue.place
      )}`;
      break;
    }
    case "DeclareContext": {
      value = `DeclareContext ${instrValue.lvalue.kind} ${printPlace(
        instrValue.lvalue.place
      )}`;
      break;
    }
    case "StoreLocal": {
      value = `StoreLocal ${instrValue.lvalue.kind} ${printPlace(
        instrValue.lvalue.place
      )} = ${printPlace(instrValue.value)}`;
      break;
    }
    case "LoadContext": {
      value = `LoadContext ${printPlace(instrValue.place)}`;
      break;
    }
    case "StoreContext": {
      value = `StoreContext ${instrValue.lvalue.kind} ${printPlace(
        instrValue.lvalue.place
      )} = ${printPlace(instrValue.value)}`;
      break;
    }
    case "Destructure": {
      value = `Destructure ${instrValue.lvalue.kind} ${printPattern(
        instrValue.lvalue.pattern
      )} = ${printPlace(instrValue.value)}`;
      break;
    }
    case "PropertyLoad": {
      value = `PropertyLoad ${printPlace(instrValue.object)}.${instrValue.property}`;
      break;
    }
    case "PropertyStore": {
      value = `PropertyStore ${printPlace(instrValue.object)}.${instrValue.property} = ${printPlace(instrValue.value)}`;
      break;
    }
    case "PropertyDelete": {
      value = `PropertyDelete ${printPlace(instrValue.object)}.${instrValue.property}`;
      break;
    }
    case "ComputedLoad": {
      value = `ComputedLoad ${printPlace(instrValue.object)}[${printPlace(
        instrValue.property
      )}]`;
      break;
    }
    case "ComputedStore": {
      value = `ComputedStore ${printPlace(instrValue.object)}[${printPlace(
        instrValue.property
      )}] = ${printPlace(instrValue.value)}`;
      break;
    }
    case "ComputedDelete": {
      value = `ComputedDelete ${printPlace(instrValue.object)}[${printPlace(
        instrValue.property
      )}]`;
      break;
    }
    case "ObjectMethod":
    case "FunctionExpression": {
      const kind = instrValue.kind === "FunctionExpression" ? "Function" : "ObjectMethod";
      const name = getFunctionName(instrValue, "");
      const fn = printFunction(instrValue.loweredFunc.func).split("\n").map((line2) => `      ${line2}`).join("\n");
      const context = instrValue.loweredFunc.func.context.map((dep) => printPlace(dep)).join(",");
      const aliasingEffects = (_c = (_b = (_a = instrValue.loweredFunc.func.aliasingEffects) == null ? void 0 : _a.map(printAliasingEffect)) == null ? void 0 : _b.join(", ")) != null ? _c : "";
      value = `${kind} ${name} @context[${context}] @aliasingEffects=[${aliasingEffects}]
${fn}`;
      break;
    }
    case "TaggedTemplateExpression": {
      value = `${printPlace(instrValue.tag)}\`${instrValue.value.raw}\``;
      break;
    }
    case "LogicalExpression": {
      value = `Logical ${printInstructionValue(instrValue.left)} ${instrValue.operator} ${printInstructionValue(instrValue.right)}`;
      break;
    }
    case "SequenceExpression": {
      value = [
        `Sequence`,
        ...instrValue.instructions.map(
          (instr) => `    ${printInstruction(instr)}`
        ),
        `    ${printInstructionValue(instrValue.value)}`
      ].join("\n");
      break;
    }
    case "ConditionalExpression": {
      value = `Ternary ${printInstructionValue(
        instrValue.test
      )} ? ${printInstructionValue(
        instrValue.consequent
      )} : ${printInstructionValue(instrValue.alternate)}`;
      break;
    }
    case "TemplateLiteral": {
      value = "`";
      CompilerError.invariant(
        instrValue.subexprs.length === instrValue.quasis.length - 1,
        {
          reason: "Bad assumption about quasi length.",
          description: null,
          loc: instrValue.loc,
          suggestions: null
        }
      );
      for (let i = 0; i < instrValue.subexprs.length; i++) {
        value += instrValue.quasis[i].raw;
        value += `\${${printPlace(instrValue.subexprs[i])}}`;
      }
      value += instrValue.quasis.at(-1).raw + "`";
      break;
    }
    case "LoadGlobal": {
      switch (instrValue.binding.kind) {
        case "Global": {
          value = `LoadGlobal(global) ${instrValue.binding.name}`;
          break;
        }
        case "ModuleLocal": {
          value = `LoadGlobal(module) ${instrValue.binding.name}`;
          break;
        }
        case "ImportDefault": {
          value = `LoadGlobal import ${instrValue.binding.name} from '${instrValue.binding.module}'`;
          break;
        }
        case "ImportNamespace": {
          value = `LoadGlobal import * as ${instrValue.binding.name} from '${instrValue.binding.module}'`;
          break;
        }
        case "ImportSpecifier": {
          if (instrValue.binding.imported !== instrValue.binding.name) {
            value = `LoadGlobal import { ${instrValue.binding.imported} as ${instrValue.binding.name} } from '${instrValue.binding.module}'`;
          } else {
            value = `LoadGlobal import { ${instrValue.binding.name} } from '${instrValue.binding.module}'`;
          }
          break;
        }
        default: {
          assertExhaustive(
            instrValue.binding,
            `Unexpected binding kind \`${instrValue.binding.kind}\``
          );
        }
      }
      break;
    }
    case "StoreGlobal": {
      value = `StoreGlobal ${instrValue.name} = ${printPlace(
        instrValue.value
      )}`;
      break;
    }
    case "OptionalExpression": {
      value = `OptionalExpression ${printInstructionValue(instrValue.value)}`;
      break;
    }
    case "RegExpLiteral": {
      value = `RegExp /${instrValue.pattern}/${instrValue.flags}`;
      break;
    }
    case "MetaProperty": {
      value = `MetaProperty ${instrValue.meta}.${instrValue.property}`;
      break;
    }
    case "Await": {
      value = `Await ${printPlace(instrValue.value)}`;
      break;
    }
    case "GetIterator": {
      value = `GetIterator collection=${printPlace(instrValue.collection)}`;
      break;
    }
    case "IteratorNext": {
      value = `IteratorNext iterator=${printPlace(
        instrValue.iterator
      )} collection=${printPlace(instrValue.collection)}`;
      break;
    }
    case "NextPropertyOf": {
      value = `NextPropertyOf ${printPlace(instrValue.value)}`;
      break;
    }
    case "Debugger": {
      value = `Debugger`;
      break;
    }
    case "PostfixUpdate": {
      value = `PostfixUpdate ${printPlace(instrValue.lvalue)} = ${printPlace(
        instrValue.value
      )} ${instrValue.operation}`;
      break;
    }
    case "PrefixUpdate": {
      value = `PrefixUpdate ${printPlace(instrValue.lvalue)} = ${instrValue.operation} ${printPlace(instrValue.value)}`;
      break;
    }
    case "StartMemoize": {
      value = `StartMemoize deps=${(_e = (_d = instrValue.deps) == null ? void 0 : _d.map((dep) => printManualMemoDependency(dep, false))) != null ? _e : "(none)"}`;
      break;
    }
    case "FinishMemoize": {
      value = `FinishMemoize decl=${printPlace(instrValue.decl)}${instrValue.pruned ? " pruned" : ""}`;
      break;
    }
    default: {
      assertExhaustive(
        instrValue,
        `Unexpected instruction kind '${instrValue.kind}'`
      );
    }
  }
  return value;
}
function isMutable(range) {
  return range.end > range.start + 1;
}
var DEBUG_MUTABLE_RANGES = false;
function printMutableRange(identifier4) {
  var _a, _b, _c;
  if (DEBUG_MUTABLE_RANGES) {
    const range2 = identifier4.mutableRange;
    const scopeRange = (_a = identifier4.scope) == null ? void 0 : _a.range;
    if (scopeRange != null && (scopeRange.start !== range2.start || scopeRange.end !== range2.end)) {
      return `[${range2.start}:${range2.end}] scope=[${scopeRange.start}:${scopeRange.end}]`;
    }
    return isMutable(range2) ? `[${range2.start}:${range2.end}]` : "";
  }
  const range = (_c = (_b = identifier4.scope) == null ? void 0 : _b.range) != null ? _c : identifier4.mutableRange;
  return isMutable(range) ? `[${range.start}:${range.end}]` : "";
}
function printPattern(pattern) {
  switch (pattern.kind) {
    case "ArrayPattern": {
      return "[ " + pattern.items.map((item) => {
        if (item.kind === "Hole") {
          return "<hole>";
        }
        return printPattern(item);
      }).join(", ") + " ]";
    }
    case "ObjectPattern": {
      return "{ " + pattern.properties.map((item) => {
        switch (item.kind) {
          case "ObjectProperty": {
            return `${printObjectPropertyKey(item.key)}: ${printPattern(
              item.place
            )}`;
          }
          case "Spread": {
            return printPattern(item);
          }
          default: {
            assertExhaustive(item, "Unexpected object property kind");
          }
        }
      }).join(", ") + " }";
    }
    case "Spread": {
      return `...${printPlace(pattern.place)}`;
    }
    case "Identifier": {
      return printPlace(pattern);
    }
    default: {
      assertExhaustive(
        pattern,
        `Unexpected pattern kind \`${pattern.kind}\``
      );
    }
  }
}
function printPlace(place) {
  const items = [
    place.effect,
    " ",
    printIdentifier(place.identifier),
    printMutableRange(place.identifier),
    printType(place.identifier.type),
    place.reactive ? "{reactive}" : null
  ];
  return items.filter((x) => x != null).join("");
}
function printIdentifier(id) {
  return `${printName(id.name)}$${id.id}${printScope(id.scope)}`;
}
function printName(name) {
  if (name === null) {
    return "";
  }
  return name.value;
}
function printScope(scope) {
  return `${scope !== null ? `_@${scope.id}` : ""}`;
}
function printManualMemoDependency(val, nameOnly) {
  var _a;
  let rootStr;
  if (val.root.kind === "Global") {
    rootStr = val.root.identifierName;
  } else {
    CompilerError.invariant(((_a = val.root.value.identifier.name) == null ? void 0 : _a.kind) === "named", {
      reason: "DepsValidation: expected named local variable in depslist",
      suggestions: null,
      loc: val.root.value.loc
    });
    rootStr = nameOnly ? val.root.value.identifier.name.value : printIdentifier(val.root.value.identifier);
  }
  return `${rootStr}${val.path.map((v) => `${v.optional ? "?." : "."}${v.property}`).join("")}`;
}
function printType(type) {
  if (type.kind === "Type") return "";
  if (type.kind === "Object" && type.shapeId != null) {
    return `:T${type.kind}<${type.shapeId}>`;
  } else if (type.kind === "Function" && type.shapeId != null) {
    const returnType = printType(type.return);
    return `:T${type.kind}<${type.shapeId}>()${returnType !== "" ? `:  ${returnType}` : ""}`;
  } else {
    return `:T${type.kind}`;
  }
}
function printSourceLocation(loc) {
  if (typeof loc === "symbol") {
    return "generated";
  } else {
    return `${loc.start.line}:${loc.start.column}:${loc.end.line}:${loc.end.column}`;
  }
}
function printSourceLocationLine(loc) {
  if (typeof loc === "symbol") {
    return "generated";
  } else {
    return `${loc.start.line}:${loc.end.line}`;
  }
}
function getFunctionName(instrValue, defaultValue) {
  var _a;
  switch (instrValue.kind) {
    case "FunctionExpression":
      return (_a = instrValue.name) != null ? _a : defaultValue;
    case "ObjectMethod":
      return defaultValue;
  }
}
function printAliasingEffect(effect) {
  var _a;
  switch (effect.kind) {
    case "Assign": {
      return `Assign ${printPlaceForAliasEffect(effect.into)} = ${printPlaceForAliasEffect(effect.from)}`;
    }
    case "Alias": {
      return `Alias ${printPlaceForAliasEffect(effect.into)} <- ${printPlaceForAliasEffect(effect.from)}`;
    }
    case "MaybeAlias": {
      return `MaybeAlias ${printPlaceForAliasEffect(effect.into)} <- ${printPlaceForAliasEffect(effect.from)}`;
    }
    case "Capture": {
      return `Capture ${printPlaceForAliasEffect(effect.into)} <- ${printPlaceForAliasEffect(effect.from)}`;
    }
    case "ImmutableCapture": {
      return `ImmutableCapture ${printPlaceForAliasEffect(effect.into)} <- ${printPlaceForAliasEffect(effect.from)}`;
    }
    case "Create": {
      return `Create ${printPlaceForAliasEffect(effect.into)} = ${effect.value}`;
    }
    case "CreateFrom": {
      return `Create ${printPlaceForAliasEffect(effect.into)} = kindOf(${printPlaceForAliasEffect(effect.from)})`;
    }
    case "CreateFunction": {
      return `Function ${printPlaceForAliasEffect(effect.into)} = Function captures=[${effect.captures.map(printPlaceForAliasEffect).join(", ")}]`;
    }
    case "Apply": {
      const receiverCallee = effect.receiver.identifier.id === effect.function.identifier.id ? printPlaceForAliasEffect(effect.receiver) : `${printPlaceForAliasEffect(effect.receiver)}.${printPlaceForAliasEffect(effect.function)}`;
      const args = effect.args.map((arg) => {
        if (arg.kind === "Identifier") {
          return printPlaceForAliasEffect(arg);
        } else if (arg.kind === "Hole") {
          return " ";
        }
        return `...${printPlaceForAliasEffect(arg.place)}`;
      }).join(", ");
      let signature = "";
      if (effect.signature != null) {
        if (effect.signature.aliasing != null) {
          signature = printAliasingSignature(effect.signature.aliasing);
        } else {
          signature = JSON.stringify(effect.signature, null, 2);
        }
      }
      return `Apply ${printPlaceForAliasEffect(effect.into)} = ${receiverCallee}(${args})${signature != "" ? "\n     " : ""}${signature}`;
    }
    case "Freeze": {
      return `Freeze ${printPlaceForAliasEffect(effect.value)} ${effect.reason}`;
    }
    case "Mutate":
    case "MutateConditionally":
    case "MutateTransitive":
    case "MutateTransitiveConditionally": {
      return `${effect.kind} ${printPlaceForAliasEffect(effect.value)}${effect.kind === "Mutate" && ((_a = effect.reason) == null ? void 0 : _a.kind) === "AssignCurrentProperty" ? " (assign `.current`)" : ""}`;
    }
    case "MutateFrozen": {
      return `MutateFrozen ${printPlaceForAliasEffect(effect.place)} reason=${JSON.stringify(effect.error.reason)}`;
    }
    case "MutateGlobal": {
      return `MutateGlobal ${printPlaceForAliasEffect(effect.place)} reason=${JSON.stringify(effect.error.reason)}`;
    }
    case "Impure": {
      return `Impure ${printPlaceForAliasEffect(effect.place)} reason=${JSON.stringify(effect.error.reason)}`;
    }
    case "Render": {
      return `Render ${printPlaceForAliasEffect(effect.place)}`;
    }
    default: {
      assertExhaustive(effect, `Unexpected kind '${effect.kind}'`);
    }
  }
}
function printPlaceForAliasEffect(place) {
  return printIdentifier(place.identifier);
}
function printAliasingSignature(signature) {
  const tokens = ["function "];
  if (signature.temporaries.length !== 0) {
    tokens.push("<");
    tokens.push(
      signature.temporaries.map((temp) => `$${temp.identifier.id}`).join(", ")
    );
    tokens.push(">");
  }
  tokens.push("(");
  tokens.push("this=$" + String(signature.receiver));
  for (const param of signature.params) {
    tokens.push(", $" + String(param));
  }
  if (signature.rest != null) {
    tokens.push(`, ...$${String(signature.rest)}`);
  }
  tokens.push("): ");
  tokens.push("$" + String(signature.returns) + ":");
  for (const effect of signature.effects) {
    tokens.push("\n  " + printAliasingEffect(effect));
  }
  return tokens.join("");
}

// src/HIR/visitors.ts
function* eachInstructionLValue(instr) {
  if (instr.lvalue !== null) {
    yield instr.lvalue;
  }
  yield* __yieldStar(eachInstructionValueLValue(instr.value));
}
function* eachInstructionValueLValue(value) {
  switch (value.kind) {
    case "DeclareContext":
    case "StoreContext":
    case "DeclareLocal":
    case "StoreLocal": {
      yield value.lvalue.place;
      break;
    }
    case "Destructure": {
      yield* __yieldStar(eachPatternOperand(value.lvalue.pattern));
      break;
    }
    case "PostfixUpdate":
    case "PrefixUpdate": {
      yield value.lvalue;
      break;
    }
  }
}
function* eachInstructionOperand(instr) {
  yield* __yieldStar(eachInstructionValueOperand(instr.value));
}
function* eachInstructionValueOperand(instrValue) {
  switch (instrValue.kind) {
    case "NewExpression":
    case "CallExpression": {
      yield instrValue.callee;
      yield* __yieldStar(eachCallArgument(instrValue.args));
      break;
    }
    case "BinaryExpression": {
      yield instrValue.left;
      yield instrValue.right;
      break;
    }
    case "MethodCall": {
      yield instrValue.receiver;
      yield instrValue.property;
      yield* __yieldStar(eachCallArgument(instrValue.args));
      break;
    }
    case "DeclareContext":
    case "DeclareLocal": {
      break;
    }
    case "LoadLocal":
    case "LoadContext": {
      yield instrValue.place;
      break;
    }
    case "StoreLocal": {
      yield instrValue.value;
      break;
    }
    case "StoreContext": {
      yield instrValue.lvalue.place;
      yield instrValue.value;
      break;
    }
    case "StoreGlobal": {
      yield instrValue.value;
      break;
    }
    case "Destructure": {
      yield instrValue.value;
      break;
    }
    case "PropertyLoad": {
      yield instrValue.object;
      break;
    }
    case "PropertyDelete": {
      yield instrValue.object;
      break;
    }
    case "PropertyStore": {
      yield instrValue.object;
      yield instrValue.value;
      break;
    }
    case "ComputedLoad": {
      yield instrValue.object;
      yield instrValue.property;
      break;
    }
    case "ComputedDelete": {
      yield instrValue.object;
      yield instrValue.property;
      break;
    }
    case "ComputedStore": {
      yield instrValue.object;
      yield instrValue.property;
      yield instrValue.value;
      break;
    }
    case "UnaryExpression": {
      yield instrValue.value;
      break;
    }
    case "JsxExpression": {
      if (instrValue.tag.kind === "Identifier") {
        yield instrValue.tag;
      }
      for (const attribute of instrValue.props) {
        switch (attribute.kind) {
          case "JsxAttribute": {
            yield attribute.place;
            break;
          }
          case "JsxSpreadAttribute": {
            yield attribute.argument;
            break;
          }
          default: {
            assertExhaustive(
              attribute,
              `Unexpected attribute kind \`${attribute.kind}\``
            );
          }
        }
      }
      if (instrValue.children) {
        yield* __yieldStar(instrValue.children);
      }
      break;
    }
    case "JsxFragment": {
      yield* __yieldStar(instrValue.children);
      break;
    }
    case "ObjectExpression": {
      for (const property of instrValue.properties) {
        if (property.kind === "ObjectProperty" && property.key.kind === "computed") {
          yield property.key.name;
        }
        yield property.place;
      }
      break;
    }
    case "ArrayExpression": {
      for (const element of instrValue.elements) {
        if (element.kind === "Identifier") {
          yield element;
        } else if (element.kind === "Spread") {
          yield element.place;
        }
      }
      break;
    }
    case "ObjectMethod":
    case "FunctionExpression": {
      yield* __yieldStar(instrValue.loweredFunc.func.context);
      break;
    }
    case "TaggedTemplateExpression": {
      yield instrValue.tag;
      break;
    }
    case "TypeCastExpression": {
      yield instrValue.value;
      break;
    }
    case "TemplateLiteral": {
      yield* __yieldStar(instrValue.subexprs);
      break;
    }
    case "Await": {
      yield instrValue.value;
      break;
    }
    case "GetIterator": {
      yield instrValue.collection;
      break;
    }
    case "IteratorNext": {
      yield instrValue.iterator;
      yield instrValue.collection;
      break;
    }
    case "NextPropertyOf": {
      yield instrValue.value;
      break;
    }
    case "PostfixUpdate":
    case "PrefixUpdate": {
      yield instrValue.value;
      break;
    }
    case "StartMemoize": {
      if (instrValue.deps != null) {
        for (const dep of instrValue.deps) {
          if (dep.root.kind === "NamedLocal") {
            yield dep.root.value;
          }
        }
      }
      break;
    }
    case "FinishMemoize": {
      yield instrValue.decl;
      break;
    }
    case "Debugger":
    case "RegExpLiteral":
    case "MetaProperty":
    case "LoadGlobal":
    case "UnsupportedNode":
    case "Primitive":
    case "JSXText": {
      break;
    }
    default: {
      assertExhaustive(
        instrValue,
        `Unexpected instruction kind \`${instrValue.kind}\``
      );
    }
  }
}
function* eachCallArgument(args) {
  for (const arg of args) {
    if (arg.kind === "Identifier") {
      yield arg;
    } else {
      yield arg.place;
    }
  }
}
function doesPatternContainSpreadElement(pattern) {
  switch (pattern.kind) {
    case "ArrayPattern": {
      for (const item of pattern.items) {
        if (item.kind === "Spread") {
          return true;
        }
      }
      break;
    }
    case "ObjectPattern": {
      for (const property of pattern.properties) {
        if (property.kind === "Spread") {
          return true;
        }
      }
      break;
    }
    default: {
      assertExhaustive(
        pattern,
        `Unexpected pattern kind \`${pattern.kind}\``
      );
    }
  }
  return false;
}
function* eachPatternOperand(pattern) {
  switch (pattern.kind) {
    case "ArrayPattern": {
      for (const item of pattern.items) {
        if (item.kind === "Identifier") {
          yield item;
        } else if (item.kind === "Spread") {
          yield item.place;
        } else if (item.kind === "Hole") {
          continue;
        } else {
          assertExhaustive(
            item,
            `Unexpected item kind \`${item.kind}\``
          );
        }
      }
      break;
    }
    case "ObjectPattern": {
      for (const property of pattern.properties) {
        if (property.kind === "ObjectProperty") {
          yield property.place;
        } else if (property.kind === "Spread") {
          yield property.place;
        } else {
          assertExhaustive(
            property,
            `Unexpected item kind \`${property.kind}\``
          );
        }
      }
      break;
    }
    default: {
      assertExhaustive(
        pattern,
        `Unexpected pattern kind \`${pattern.kind}\``
      );
    }
  }
}
function* eachPatternItem(pattern) {
  switch (pattern.kind) {
    case "ArrayPattern": {
      for (const item of pattern.items) {
        if (item.kind === "Identifier") {
          yield item;
        } else if (item.kind === "Spread") {
          yield item;
        } else if (item.kind === "Hole") {
          continue;
        } else {
          assertExhaustive(
            item,
            `Unexpected item kind \`${item.kind}\``
          );
        }
      }
      break;
    }
    case "ObjectPattern": {
      for (const property of pattern.properties) {
        if (property.kind === "ObjectProperty") {
          yield property.place;
        } else if (property.kind === "Spread") {
          yield property;
        } else {
          assertExhaustive(
            property,
            `Unexpected item kind \`${property.kind}\``
          );
        }
      }
      break;
    }
    default: {
      assertExhaustive(
        pattern,
        `Unexpected pattern kind \`${pattern.kind}\``
      );
    }
  }
}
function mapInstructionLValues(instr, fn) {
  switch (instr.value.kind) {
    case "DeclareLocal":
    case "StoreLocal": {
      const lvalue = instr.value.lvalue;
      lvalue.place = fn(lvalue.place);
      break;
    }
    case "Destructure": {
      mapPatternOperands(instr.value.lvalue.pattern, fn);
      break;
    }
    case "PostfixUpdate":
    case "PrefixUpdate": {
      instr.value.lvalue = fn(instr.value.lvalue);
      break;
    }
  }
  if (instr.lvalue !== null) {
    instr.lvalue = fn(instr.lvalue);
  }
}
function mapInstructionOperands(instr, fn) {
  mapInstructionValueOperands(instr.value, fn);
}
function mapInstructionValueOperands(instrValue, fn) {
  switch (instrValue.kind) {
    case "BinaryExpression": {
      instrValue.left = fn(instrValue.left);
      instrValue.right = fn(instrValue.right);
      break;
    }
    case "PropertyLoad": {
      instrValue.object = fn(instrValue.object);
      break;
    }
    case "PropertyDelete": {
      instrValue.object = fn(instrValue.object);
      break;
    }
    case "PropertyStore": {
      instrValue.object = fn(instrValue.object);
      instrValue.value = fn(instrValue.value);
      break;
    }
    case "ComputedLoad": {
      instrValue.object = fn(instrValue.object);
      instrValue.property = fn(instrValue.property);
      break;
    }
    case "ComputedDelete": {
      instrValue.object = fn(instrValue.object);
      instrValue.property = fn(instrValue.property);
      break;
    }
    case "ComputedStore": {
      instrValue.object = fn(instrValue.object);
      instrValue.property = fn(instrValue.property);
      instrValue.value = fn(instrValue.value);
      break;
    }
    case "DeclareContext":
    case "DeclareLocal": {
      break;
    }
    case "LoadLocal":
    case "LoadContext": {
      instrValue.place = fn(instrValue.place);
      break;
    }
    case "StoreLocal": {
      instrValue.value = fn(instrValue.value);
      break;
    }
    case "StoreContext": {
      instrValue.lvalue.place = fn(instrValue.lvalue.place);
      instrValue.value = fn(instrValue.value);
      break;
    }
    case "StoreGlobal": {
      instrValue.value = fn(instrValue.value);
      break;
    }
    case "Destructure": {
      instrValue.value = fn(instrValue.value);
      break;
    }
    case "NewExpression":
    case "CallExpression": {
      instrValue.callee = fn(instrValue.callee);
      instrValue.args = mapCallArguments(instrValue.args, fn);
      break;
    }
    case "MethodCall": {
      instrValue.receiver = fn(instrValue.receiver);
      instrValue.property = fn(instrValue.property);
      instrValue.args = mapCallArguments(instrValue.args, fn);
      break;
    }
    case "UnaryExpression": {
      instrValue.value = fn(instrValue.value);
      break;
    }
    case "JsxExpression": {
      if (instrValue.tag.kind === "Identifier") {
        instrValue.tag = fn(instrValue.tag);
      }
      for (const attribute of instrValue.props) {
        switch (attribute.kind) {
          case "JsxAttribute": {
            attribute.place = fn(attribute.place);
            break;
          }
          case "JsxSpreadAttribute": {
            attribute.argument = fn(attribute.argument);
            break;
          }
          default: {
            assertExhaustive(
              attribute,
              `Unexpected attribute kind \`${attribute.kind}\``
            );
          }
        }
      }
      if (instrValue.children) {
        instrValue.children = instrValue.children.map((p) => fn(p));
      }
      break;
    }
    case "ObjectExpression": {
      for (const property of instrValue.properties) {
        if (property.kind === "ObjectProperty" && property.key.kind === "computed") {
          property.key.name = fn(property.key.name);
        }
        property.place = fn(property.place);
      }
      break;
    }
    case "ArrayExpression": {
      instrValue.elements = instrValue.elements.map((element) => {
        if (element.kind === "Identifier") {
          return fn(element);
        } else if (element.kind === "Spread") {
          element.place = fn(element.place);
          return element;
        } else {
          return element;
        }
      });
      break;
    }
    case "JsxFragment": {
      instrValue.children = instrValue.children.map((e) => fn(e));
      break;
    }
    case "ObjectMethod":
    case "FunctionExpression": {
      instrValue.loweredFunc.func.context = instrValue.loweredFunc.func.context.map((d) => fn(d));
      break;
    }
    case "TaggedTemplateExpression": {
      instrValue.tag = fn(instrValue.tag);
      break;
    }
    case "TypeCastExpression": {
      instrValue.value = fn(instrValue.value);
      break;
    }
    case "TemplateLiteral": {
      instrValue.subexprs = instrValue.subexprs.map(fn);
      break;
    }
    case "Await": {
      instrValue.value = fn(instrValue.value);
      break;
    }
    case "GetIterator": {
      instrValue.collection = fn(instrValue.collection);
      break;
    }
    case "IteratorNext": {
      instrValue.iterator = fn(instrValue.iterator);
      instrValue.collection = fn(instrValue.collection);
      break;
    }
    case "NextPropertyOf": {
      instrValue.value = fn(instrValue.value);
      break;
    }
    case "PostfixUpdate":
    case "PrefixUpdate": {
      instrValue.value = fn(instrValue.value);
      break;
    }
    case "StartMemoize": {
      if (instrValue.deps != null) {
        for (const dep of instrValue.deps) {
          if (dep.root.kind === "NamedLocal") {
            dep.root.value = fn(dep.root.value);
          }
        }
      }
      break;
    }
    case "FinishMemoize": {
      instrValue.decl = fn(instrValue.decl);
      break;
    }
    case "Debugger":
    case "RegExpLiteral":
    case "MetaProperty":
    case "LoadGlobal":
    case "UnsupportedNode":
    case "Primitive":
    case "JSXText": {
      break;
    }
    default: {
      assertExhaustive(instrValue, "Unexpected instruction kind");
    }
  }
}
function mapCallArguments(args, fn) {
  return args.map((arg) => {
    if (arg.kind === "Identifier") {
      return fn(arg);
    } else {
      arg.place = fn(arg.place);
      return arg;
    }
  });
}
function mapPatternOperands(pattern, fn) {
  switch (pattern.kind) {
    case "ArrayPattern": {
      pattern.items = pattern.items.map((item) => {
        if (item.kind === "Identifier") {
          return fn(item);
        } else if (item.kind === "Spread") {
          item.place = fn(item.place);
          return item;
        } else {
          return item;
        }
      });
      break;
    }
    case "ObjectPattern": {
      for (const property of pattern.properties) {
        property.place = fn(property.place);
      }
      break;
    }
    default: {
      assertExhaustive(
        pattern,
        `Unexpected pattern kind \`${pattern.kind}\``
      );
    }
  }
}
function mapTerminalSuccessors(terminal, fn) {
  switch (terminal.kind) {
    case "goto": {
      const target = fn(terminal.block);
      return {
        kind: "goto",
        block: target,
        variant: terminal.variant,
        id: makeInstructionId(0),
        loc: terminal.loc
      };
    }
    case "if": {
      const consequent = fn(terminal.consequent);
      const alternate = fn(terminal.alternate);
      const fallthrough = fn(terminal.fallthrough);
      return {
        kind: "if",
        test: terminal.test,
        consequent,
        alternate,
        fallthrough,
        id: makeInstructionId(0),
        loc: terminal.loc
      };
    }
    case "branch": {
      const consequent = fn(terminal.consequent);
      const alternate = fn(terminal.alternate);
      const fallthrough = fn(terminal.fallthrough);
      return {
        kind: "branch",
        test: terminal.test,
        consequent,
        alternate,
        fallthrough,
        id: makeInstructionId(0),
        loc: terminal.loc
      };
    }
    case "switch": {
      const cases = terminal.cases.map((case_) => {
        const target = fn(case_.block);
        return {
          test: case_.test,
          block: target
        };
      });
      const fallthrough = fn(terminal.fallthrough);
      return {
        kind: "switch",
        test: terminal.test,
        cases,
        fallthrough,
        id: makeInstructionId(0),
        loc: terminal.loc
      };
    }
    case "logical": {
      const test = fn(terminal.test);
      const fallthrough = fn(terminal.fallthrough);
      return {
        kind: "logical",
        test,
        fallthrough,
        operator: terminal.operator,
        id: makeInstructionId(0),
        loc: terminal.loc
      };
    }
    case "ternary": {
      const test = fn(terminal.test);
      const fallthrough = fn(terminal.fallthrough);
      return {
        kind: "ternary",
        test,
        fallthrough,
        id: makeInstructionId(0),
        loc: terminal.loc
      };
    }
    case "optional": {
      const test = fn(terminal.test);
      const fallthrough = fn(terminal.fallthrough);
      return {
        kind: "optional",
        optional: terminal.optional,
        test,
        fallthrough,
        id: makeInstructionId(0),
        loc: terminal.loc
      };
    }
    case "return": {
      return {
        kind: "return",
        returnVariant: terminal.returnVariant,
        loc: terminal.loc,
        value: terminal.value,
        id: makeInstructionId(0),
        effects: terminal.effects
      };
    }
    case "throw": {
      return terminal;
    }
    case "do-while": {
      const loop = fn(terminal.loop);
      const test = fn(terminal.test);
      const fallthrough = fn(terminal.fallthrough);
      return {
        kind: "do-while",
        loc: terminal.loc,
        test,
        loop,
        fallthrough,
        id: makeInstructionId(0)
      };
    }
    case "while": {
      const test = fn(terminal.test);
      const loop = fn(terminal.loop);
      const fallthrough = fn(terminal.fallthrough);
      return {
        kind: "while",
        loc: terminal.loc,
        test,
        loop,
        fallthrough,
        id: makeInstructionId(0)
      };
    }
    case "for": {
      const init = fn(terminal.init);
      const test = fn(terminal.test);
      const update2 = terminal.update !== null ? fn(terminal.update) : null;
      const loop = fn(terminal.loop);
      const fallthrough = fn(terminal.fallthrough);
      return {
        kind: "for",
        loc: terminal.loc,
        init,
        test,
        update: update2,
        loop,
        fallthrough,
        id: makeInstructionId(0)
      };
    }
    case "for-of": {
      const init = fn(terminal.init);
      const loop = fn(terminal.loop);
      const test = fn(terminal.test);
      const fallthrough = fn(terminal.fallthrough);
      return {
        kind: "for-of",
        loc: terminal.loc,
        init,
        test,
        loop,
        fallthrough,
        id: makeInstructionId(0)
      };
    }
    case "for-in": {
      const init = fn(terminal.init);
      const loop = fn(terminal.loop);
      const fallthrough = fn(terminal.fallthrough);
      return {
        kind: "for-in",
        loc: terminal.loc,
        init,
        loop,
        fallthrough,
        id: makeInstructionId(0)
      };
    }
    case "label": {
      const block = fn(terminal.block);
      const fallthrough = fn(terminal.fallthrough);
      return {
        kind: "label",
        block,
        fallthrough,
        id: makeInstructionId(0),
        loc: terminal.loc
      };
    }
    case "sequence": {
      const block = fn(terminal.block);
      const fallthrough = fn(terminal.fallthrough);
      return {
        kind: "sequence",
        block,
        fallthrough,
        id: makeInstructionId(0),
        loc: terminal.loc
      };
    }
    case "maybe-throw": {
      const continuation = fn(terminal.continuation);
      const handler = fn(terminal.handler);
      return {
        kind: "maybe-throw",
        continuation,
        handler,
        id: makeInstructionId(0),
        loc: terminal.loc,
        effects: terminal.effects
      };
    }
    case "try": {
      const block = fn(terminal.block);
      const handler = fn(terminal.handler);
      const fallthrough = fn(terminal.fallthrough);
      return {
        kind: "try",
        block,
        handlerBinding: terminal.handlerBinding,
        handler,
        fallthrough,
        id: makeInstructionId(0),
        loc: terminal.loc
      };
    }
    case "scope":
    case "pruned-scope": {
      const block = fn(terminal.block);
      const fallthrough = fn(terminal.fallthrough);
      return {
        kind: terminal.kind,
        scope: terminal.scope,
        block,
        fallthrough,
        id: makeInstructionId(0),
        loc: terminal.loc
      };
    }
    case "unreachable":
    case "unsupported": {
      return terminal;
    }
    default: {
      assertExhaustive(
        terminal,
        `Unexpected terminal kind \`${terminal.kind}\``
      );
    }
  }
}
function terminalHasFallthrough(terminal) {
  switch (terminal.kind) {
    case "maybe-throw":
    case "goto":
    case "return":
    case "throw":
    case "unreachable":
    case "unsupported": {
      const _ = terminal.fallthrough;
      return false;
    }
    case "branch":
    case "try":
    case "do-while":
    case "for-of":
    case "for-in":
    case "for":
    case "if":
    case "label":
    case "logical":
    case "optional":
    case "sequence":
    case "switch":
    case "ternary":
    case "while":
    case "scope":
    case "pruned-scope": {
      const _ = terminal.fallthrough;
      return true;
    }
    default: {
      assertExhaustive(
        terminal,
        `Unexpected terminal kind \`${terminal.kind}\``
      );
    }
  }
}
function terminalFallthrough(terminal) {
  if (terminalHasFallthrough(terminal)) {
    return terminal.fallthrough;
  } else {
    return null;
  }
}
function* eachTerminalSuccessor(terminal) {
  switch (terminal.kind) {
    case "goto": {
      yield terminal.block;
      break;
    }
    case "if": {
      yield terminal.consequent;
      yield terminal.alternate;
      break;
    }
    case "branch": {
      yield terminal.consequent;
      yield terminal.alternate;
      break;
    }
    case "switch": {
      for (const case_ of terminal.cases) {
        yield case_.block;
      }
      break;
    }
    case "optional":
    case "ternary":
    case "logical": {
      yield terminal.test;
      break;
    }
    case "return": {
      break;
    }
    case "throw": {
      break;
    }
    case "do-while": {
      yield terminal.loop;
      break;
    }
    case "while": {
      yield terminal.test;
      break;
    }
    case "for": {
      yield terminal.init;
      break;
    }
    case "for-of": {
      yield terminal.init;
      break;
    }
    case "for-in": {
      yield terminal.init;
      break;
    }
    case "label": {
      yield terminal.block;
      break;
    }
    case "sequence": {
      yield terminal.block;
      break;
    }
    case "maybe-throw": {
      yield terminal.continuation;
      yield terminal.handler;
      break;
    }
    case "try": {
      yield terminal.block;
      break;
    }
    case "scope":
    case "pruned-scope": {
      yield terminal.block;
      break;
    }
    case "unreachable":
    case "unsupported":
      break;
    default: {
      assertExhaustive(
        terminal,
        `Unexpected terminal kind \`${terminal.kind}\``
      );
    }
  }
}
function mapTerminalOperands(terminal, fn) {
  switch (terminal.kind) {
    case "if": {
      terminal.test = fn(terminal.test);
      break;
    }
    case "branch": {
      terminal.test = fn(terminal.test);
      break;
    }
    case "switch": {
      terminal.test = fn(terminal.test);
      for (const case_ of terminal.cases) {
        if (case_.test === null) {
          continue;
        }
        case_.test = fn(case_.test);
      }
      break;
    }
    case "return":
    case "throw": {
      terminal.value = fn(terminal.value);
      break;
    }
    case "try": {
      if (terminal.handlerBinding !== null) {
        terminal.handlerBinding = fn(terminal.handlerBinding);
      } else {
        terminal.handlerBinding = null;
      }
      break;
    }
    case "maybe-throw":
    case "sequence":
    case "label":
    case "optional":
    case "ternary":
    case "logical":
    case "do-while":
    case "while":
    case "for":
    case "for-of":
    case "for-in":
    case "goto":
    case "unreachable":
    case "unsupported":
    case "scope":
    case "pruned-scope": {
      break;
    }
    default: {
      assertExhaustive(
        terminal,
        `Unexpected terminal kind \`${terminal.kind}\``
      );
    }
  }
}
function* eachTerminalOperand(terminal) {
  switch (terminal.kind) {
    case "if": {
      yield terminal.test;
      break;
    }
    case "branch": {
      yield terminal.test;
      break;
    }
    case "switch": {
      yield terminal.test;
      for (const case_ of terminal.cases) {
        if (case_.test === null) {
          continue;
        }
        yield case_.test;
      }
      break;
    }
    case "return":
    case "throw": {
      yield terminal.value;
      break;
    }
    case "try": {
      if (terminal.handlerBinding !== null) {
        yield terminal.handlerBinding;
      }
      break;
    }
    case "maybe-throw":
    case "sequence":
    case "label":
    case "optional":
    case "ternary":
    case "logical":
    case "do-while":
    case "while":
    case "for":
    case "for-of":
    case "for-in":
    case "goto":
    case "unreachable":
    case "unsupported":
    case "scope":
    case "pruned-scope": {
      break;
    }
    default: {
      assertExhaustive(
        terminal,
        `Unexpected terminal kind \`${terminal.kind}\``
      );
    }
  }
}
var _activeScopes;
var ScopeBlockTraversal = class {
  constructor() {
    // Live stack of active scopes
    __privateAdd(this, _activeScopes, []);
    this.blockInfos = /* @__PURE__ */ new Map();
  }
  recordScopes(block) {
    var _a, _b;
    const blockInfo = this.blockInfos.get(block.id);
    if ((blockInfo == null ? void 0 : blockInfo.kind) === "begin") {
      __privateGet(this, _activeScopes).push(blockInfo.scope.id);
    } else if ((blockInfo == null ? void 0 : blockInfo.kind) === "end") {
      const top = __privateGet(this, _activeScopes).at(-1);
      CompilerError.invariant(blockInfo.scope.id === top, {
        reason: "Expected traversed block fallthrough to match top-most active scope",
        loc: (_b = (_a = block.instructions[0]) == null ? void 0 : _a.loc) != null ? _b : block.terminal.id
      });
      __privateGet(this, _activeScopes).pop();
    }
    if (block.terminal.kind === "scope" || block.terminal.kind === "pruned-scope") {
      CompilerError.invariant(
        !this.blockInfos.has(block.terminal.block) && !this.blockInfos.has(block.terminal.fallthrough),
        {
          reason: "Expected unique scope blocks and fallthroughs",
          loc: block.terminal.loc
        }
      );
      this.blockInfos.set(block.terminal.block, {
        kind: "begin",
        scope: block.terminal.scope,
        pruned: block.terminal.kind === "pruned-scope",
        fallthrough: block.terminal.fallthrough
      });
      this.blockInfos.set(block.terminal.fallthrough, {
        kind: "end",
        scope: block.terminal.scope,
        pruned: block.terminal.kind === "pruned-scope"
      });
    }
  }
  /**
   * @returns if the given scope is currently 'active', i.e. if the scope start
   * block but not the scope fallthrough has been recorded.
   */
  isScopeActive(scopeId) {
    return __privateGet(this, _activeScopes).indexOf(scopeId) !== -1;
  }
  /**
   * The current, innermost active scope.
   */
  get currentScope() {
    var _a;
    return (_a = __privateGet(this, _activeScopes).at(-1)) != null ? _a : null;
  }
};
_activeScopes = new WeakMap();

// src/HIR/AssertConsistentIdentifiers.ts
function assertConsistentIdentifiers(fn) {
  const identifiers = /* @__PURE__ */ new Map();
  const assignments = /* @__PURE__ */ new Set();
  for (const [, block] of fn.body.blocks) {
    for (const phi of block.phis) {
      validate(identifiers, phi.place.identifier);
      for (const [, operand] of phi.operands) {
        validate(identifiers, operand.identifier);
      }
    }
    for (const instr of block.instructions) {
      CompilerError.invariant(instr.lvalue.identifier.name === null, {
        reason: `Expected all lvalues to be temporaries`,
        description: `Found named lvalue \`${instr.lvalue.identifier.name}\``,
        loc: instr.lvalue.loc,
        suggestions: null
      });
      CompilerError.invariant(!assignments.has(instr.lvalue.identifier.id), {
        reason: `Expected lvalues to be assigned exactly once`,
        description: `Found duplicate assignment of '${printPlace(
          instr.lvalue
        )}'`,
        loc: instr.lvalue.loc,
        suggestions: null
      });
      assignments.add(instr.lvalue.identifier.id);
      for (const operand of eachInstructionLValue(instr)) {
        validate(identifiers, operand.identifier, operand.loc);
      }
      for (const operand of eachInstructionValueOperand(instr.value)) {
        validate(identifiers, operand.identifier, operand.loc);
      }
    }
    for (const operand of eachTerminalOperand(block.terminal)) {
      validate(identifiers, operand.identifier, operand.loc);
    }
  }
}
function validate(identifiers, identifier4, loc = null) {
  const previous = identifiers.get(identifier4.id);
  if (previous === void 0) {
    identifiers.set(identifier4.id, identifier4);
  } else {
    CompilerError.invariant(identifier4 === previous, {
      reason: `Duplicate identifier object`,
      description: `Found duplicate identifier object for id ${identifier4.id}`,
      loc: loc != null ? loc : GeneratedSource,
      suggestions: null
    });
  }
}

// src/HIR/AssertTerminalBlocksExist.ts
function assertTerminalSuccessorsExist(fn) {
  for (const [, block] of fn.body.blocks) {
    mapTerminalSuccessors(block.terminal, (successor) => {
      var _a;
      CompilerError.invariant(fn.body.blocks.has(successor), {
        reason: `Terminal successor references unknown block`,
        description: `Block bb${successor} does not exist for terminal '${printTerminal(
          block.terminal
        )}'`,
        loc: (_a = block.terminal.loc) != null ? _a : GeneratedSource,
        suggestions: null
      });
      return successor;
    });
  }
}
function assertTerminalPredsExist(fn) {
  for (const [, block] of fn.body.blocks) {
    for (const pred of block.preds) {
      const predBlock = fn.body.blocks.get(pred);
      CompilerError.invariant(predBlock != null, {
        reason: "Expected predecessor block to exist",
        description: `Block ${block.id} references non-existent ${pred}`,
        loc: GeneratedSource
      });
      CompilerError.invariant(
        [...eachTerminalSuccessor(predBlock.terminal)].includes(block.id),
        {
          reason: "Terminal successor does not reference correct predecessor",
          description: `Block bb${block.id} has bb${predBlock.id} as a predecessor, but bb${predBlock.id}'s successors do not include bb${block.id}`,
          loc: GeneratedSource
        }
      );
    }
  }
}

// src/HIR/AssertValidBlockNesting.ts
function getScopes(fn) {
  const scopes = /* @__PURE__ */ new Set();
  function visitPlace2(place) {
    const scope = place.identifier.scope;
    if (scope != null) {
      if (scope.range.start !== scope.range.end) {
        scopes.add(scope);
      }
    }
  }
  for (const [, block] of fn.body.blocks) {
    for (const instr of block.instructions) {
      for (const operand of eachInstructionLValue(instr)) {
        visitPlace2(operand);
      }
      for (const operand of eachInstructionOperand(instr)) {
        visitPlace2(operand);
      }
    }
    for (const operand of eachTerminalOperand(block.terminal)) {
      visitPlace2(operand);
    }
  }
  return scopes;
}
function rangePreOrderComparator(a, b) {
  const startDiff = a.start - b.start;
  if (startDiff !== 0) return startDiff;
  return b.end - a.end;
}
function recursivelyTraverseItems(items, getRange, context, enter, exit) {
  items.sort((a, b) => rangePreOrderComparator(getRange(a), getRange(b)));
  let activeItems = [];
  const ranges = items.map(getRange);
  for (let i = 0; i < items.length; i++) {
    const curr2 = items[i];
    const currRange = ranges[i];
    for (let i2 = activeItems.length - 1; i2 >= 0; i2--) {
      const maybeParent = activeItems[i2];
      const maybeParentRange = getRange(maybeParent);
      const disjoint = currRange.start >= maybeParentRange.end;
      const nested = currRange.end <= maybeParentRange.end;
      CompilerError.invariant(disjoint || nested, {
        reason: "Invalid nesting in program blocks or scopes",
        description: `Items overlap but are not nested: ${maybeParentRange.start}:${maybeParentRange.end}(${currRange.start}:${currRange.end})`,
        loc: GeneratedSource
      });
      if (disjoint) {
        exit(maybeParent, context);
        activeItems.length = i2;
      } else {
        break;
      }
    }
    enter(curr2, context);
    activeItems.push(curr2);
  }
  let curr = activeItems.pop();
  while (curr != null) {
    exit(curr, context);
    curr = activeItems.pop();
  }
}
var no_op = () => {
};
function assertValidBlockNesting(fn) {
  var _a, _b;
  const scopes = getScopes(fn);
  const blocks = [...scopes].map((scope) => __spreadValues({
    kind: "Scope",
    id: scope.id
  }, scope.range));
  for (const [, block] of fn.body.blocks) {
    const fallthroughId = terminalFallthrough(block.terminal);
    if (fallthroughId != null) {
      const fallthrough = fn.body.blocks.get(fallthroughId);
      const end = (_b = (_a = fallthrough.instructions[0]) == null ? void 0 : _a.id) != null ? _b : fallthrough.terminal.id;
      blocks.push({
        kind: "ProgramBlockSubtree",
        id: block.id,
        start: block.terminal.id,
        end
      });
    }
  }
  recursivelyTraverseItems(blocks, (block) => block, null, no_op, no_op);
}

// src/HIR/AssertValidMutableRanges.ts
function assertValidMutableRanges(fn) {
  for (const [, block] of fn.body.blocks) {
    for (const phi of block.phis) {
      visit(phi.place, `phi for block bb${block.id}`);
      for (const [pred, operand] of phi.operands) {
        visit(operand, `phi predecessor bb${pred} for block bb${block.id}`);
      }
    }
    for (const instr of block.instructions) {
      for (const operand of eachInstructionLValue(instr)) {
        visit(operand, `instruction [${instr.id}]`);
      }
      for (const operand of eachInstructionOperand(instr)) {
        visit(operand, `instruction [${instr.id}]`);
      }
    }
    for (const operand of eachTerminalOperand(block.terminal)) {
      visit(operand, `terminal [${block.terminal.id}]`);
    }
  }
}
function visit(place, description) {
  validateMutableRange(place, place.identifier.mutableRange, description);
  if (place.identifier.scope !== null) {
    validateMutableRange(place, place.identifier.scope.range, description);
  }
}
function validateMutableRange(place, range, description) {
  CompilerError.invariant(
    range.start === 0 && range.end === 0 || range.end > range.start,
    {
      reason: `Invalid mutable range: [${range.start}:${range.end}]`,
      description: `${printPlace(place)} in ${description}`,
      loc: place.loc
    }
  );
}

// src/HIR/BuildHIR.ts
var import_invariant2 = __toESM(require_invariant());

// src/HIR/HIRBuilder.ts
function newBlock(id, kind) {
  return { id, kind, instructions: [] };
}
var _completed, _current, _entry, _scopes, _context, _bindings, _env, _exceptionHandlerStack, _HIRBuilder_instances, resolveBabelBinding_fn;
var HIRBuilder = class {
  constructor(env, options) {
    __privateAdd(this, _HIRBuilder_instances);
    __privateAdd(this, _completed, /* @__PURE__ */ new Map());
    __privateAdd(this, _current);
    __privateAdd(this, _entry);
    __privateAdd(this, _scopes, []);
    __privateAdd(this, _context);
    __privateAdd(this, _bindings);
    __privateAdd(this, _env);
    __privateAdd(this, _exceptionHandlerStack, []);
    this.errors = new CompilerError();
    /**
     * Traversal context: counts the number of `fbt` tag parents
     * of the current babel node.
     */
    this.fbtDepth = 0;
    var _a, _b, _c;
    __privateSet(this, _env, env);
    __privateSet(this, _bindings, (_a = options == null ? void 0 : options.bindings) != null ? _a : /* @__PURE__ */ new Map());
    __privateSet(this, _context, (_b = options == null ? void 0 : options.context) != null ? _b : /* @__PURE__ */ new Map());
    __privateSet(this, _entry, makeBlockId(env.nextBlockId));
    __privateSet(this, _current, newBlock(__privateGet(this, _entry), (_c = options == null ? void 0 : options.entryBlockKind) != null ? _c : "block"));
  }
  get nextIdentifierId() {
    return __privateGet(this, _env).nextIdentifierId;
  }
  get context() {
    return __privateGet(this, _context);
  }
  get bindings() {
    return __privateGet(this, _bindings);
  }
  get environment() {
    return __privateGet(this, _env);
  }
  currentBlockKind() {
    return __privateGet(this, _current).kind;
  }
  // Push a statement or expression onto the current block
  push(instruction) {
    __privateGet(this, _current).instructions.push(instruction);
    const exceptionHandler = __privateGet(this, _exceptionHandlerStack).at(-1);
    if (exceptionHandler !== void 0) {
      const continuationBlock = this.reserve(this.currentBlockKind());
      this.terminateWithContinuation(
        {
          kind: "maybe-throw",
          continuation: continuationBlock.id,
          handler: exceptionHandler,
          id: makeInstructionId(0),
          loc: instruction.loc,
          effects: null
        },
        continuationBlock
      );
    }
  }
  enterTryCatch(handler, fn) {
    __privateGet(this, _exceptionHandlerStack).push(handler);
    fn();
    __privateGet(this, _exceptionHandlerStack).pop();
  }
  resolveThrowHandler() {
    const handler = __privateGet(this, _exceptionHandlerStack).at(-1);
    return handler != null ? handler : null;
  }
  makeTemporary(loc) {
    const id = this.nextIdentifierId;
    return makeTemporaryIdentifier(id, loc);
  }
  /*
   * Maps an Identifier (or JSX identifier) Babel node to an internal `Identifier`
   * which represents the variable being referenced, according to the JS scoping rules.
   *
   * Because Forget does not preserve _all_ block scopes in the input (only those that
   * happen to occur from control flow), this resolution ensures that different variables
   * with the same name are mapped to a unique name. Concretely, this function maintains
   * the invariant that all references to a given variable will return an `Identifier`
   * with the same (unique for the function) `name` and `id`.
   *
   * Example:
   *
   * ```javascript
   * function foo() {
   *    const x = 0;
   *    {
   *      const x = 1;
   *    }
   *    return x;
   * }
   * ```
   *
   * The above converts as follows:
   *
   * ```
   * Const Identifier { name: 'x', id: 0 } = Primitive { value: 0 };
   * Const Identifier { name: 'x_0', id: 1 } = Primitive { value: 1 };
   * Return Identifier { name: 'x', id: 0};
   * ```
   */
  resolveIdentifier(path) {
    const originalName = path.node.name;
    const babelBinding = __privateMethod(this, _HIRBuilder_instances, resolveBabelBinding_fn).call(this, path);
    if (babelBinding == null) {
      return { kind: "Global", name: originalName };
    }
    const outerBinding = __privateGet(this, _env).parentFunction.scope.parent.getBinding(originalName);
    if (babelBinding === outerBinding) {
      const path2 = babelBinding.path;
      if (path2.isImportDefaultSpecifier()) {
        const importDeclaration2 = path2.parentPath;
        return {
          kind: "ImportDefault",
          name: originalName,
          module: importDeclaration2.node.source.value
        };
      } else if (path2.isImportSpecifier()) {
        const importDeclaration2 = path2.parentPath;
        return {
          kind: "ImportSpecifier",
          name: originalName,
          module: importDeclaration2.node.source.value,
          imported: path2.node.imported.type === "Identifier" ? path2.node.imported.name : path2.node.imported.value
        };
      } else if (path2.isImportNamespaceSpecifier()) {
        const importDeclaration2 = path2.parentPath;
        return {
          kind: "ImportNamespace",
          name: originalName,
          module: importDeclaration2.node.source.value
        };
      } else {
        return {
          kind: "ModuleLocal",
          name: originalName
        };
      }
    }
    const resolvedBinding = this.resolveBinding(babelBinding.identifier);
    if (resolvedBinding.name && resolvedBinding.name.value !== originalName) {
      babelBinding.scope.rename(originalName, resolvedBinding.name.value);
    }
    return {
      kind: "Identifier",
      identifier: resolvedBinding,
      bindingKind: babelBinding.kind
    };
  }
  isContextIdentifier(path) {
    const binding = __privateMethod(this, _HIRBuilder_instances, resolveBabelBinding_fn).call(this, path);
    if (binding) {
      const outerBinding = __privateGet(this, _env).parentFunction.scope.parent.getBinding(
        path.node.name
      );
      if (binding === outerBinding) {
        return false;
      }
      return __privateGet(this, _env).isContextIdentifier(binding.identifier);
    } else {
      return false;
    }
  }
  resolveBinding(node) {
    var _a, _b, _c;
    if (node.name === "fbt") {
      CompilerError.throwDiagnostic({
        severity: "Todo" /* Todo */,
        category: "FBT" /* FBT */,
        reason: "Support local variables named `fbt`",
        description: "Local variables named `fbt` may conflict with the fbt plugin and are not yet supported",
        details: [
          {
            kind: "error",
            message: "Rename to avoid conflict with fbt plugin",
            loc: (_a = node.loc) != null ? _a : GeneratedSource
          }
        ]
      });
    }
    if (node.name === "this") {
      CompilerError.throwDiagnostic({
        severity: "UnsupportedJS" /* UnsupportedJS */,
        category: "UnsupportedSyntax" /* UnsupportedSyntax */,
        reason: "`this` is not supported syntax",
        description: "React Compiler does not support compiling functions that use `this`",
        details: [
          {
            kind: "error",
            message: "`this` was used here",
            loc: (_b = node.loc) != null ? _b : GeneratedSource
          }
        ]
      });
    }
    const originalName = node.name;
    let name = originalName;
    let index = 0;
    while (true) {
      const mapping = __privateGet(this, _bindings).get(name);
      if (mapping === void 0) {
        const id = this.nextIdentifierId;
        const identifier4 = {
          id,
          declarationId: makeDeclarationId(id),
          name: makeIdentifierName(name),
          mutableRange: {
            start: makeInstructionId(0),
            end: makeInstructionId(0)
          },
          scope: null,
          type: makeType(),
          loc: (_c = node.loc) != null ? _c : GeneratedSource
        };
        __privateGet(this, _env).programContext.addNewReference(name);
        __privateGet(this, _bindings).set(name, { node, identifier: identifier4 });
        return identifier4;
      } else if (mapping.node === node) {
        return mapping.identifier;
      } else {
        name = `${originalName}_${index++}`;
      }
    }
  }
  // Construct a final CFG from this context
  build() {
    var _a, _b;
    let ir = {
      blocks: __privateGet(this, _completed),
      entry: __privateGet(this, _entry)
    };
    const rpoBlocks = getReversePostorderedBlocks(ir);
    for (const [id, block] of ir.blocks) {
      if (!rpoBlocks.has(id) && block.instructions.some(
        (instr) => instr.value.kind === "FunctionExpression"
      )) {
        CompilerError.throwTodo({
          reason: `Support functions with unreachable code that may contain hoisted declarations`,
          loc: (_b = (_a = block.instructions[0]) == null ? void 0 : _a.loc) != null ? _b : block.terminal.loc,
          description: null,
          suggestions: null
        });
      }
    }
    ir.blocks = rpoBlocks;
    removeUnreachableForUpdates(ir);
    removeDeadDoWhileStatements(ir);
    removeUnnecessaryTryCatch(ir);
    markInstructionIds(ir);
    markPredecessors(ir);
    return ir;
  }
  // Terminate the current block w the given terminal, and start a new block
  terminate(terminal, nextBlockKind) {
    const { id: blockId, kind, instructions } = __privateGet(this, _current);
    __privateGet(this, _completed).set(blockId, {
      kind,
      id: blockId,
      instructions,
      terminal,
      preds: /* @__PURE__ */ new Set(),
      phis: /* @__PURE__ */ new Set()
    });
    if (nextBlockKind) {
      const nextId = __privateGet(this, _env).nextBlockId;
      __privateSet(this, _current, newBlock(nextId, nextBlockKind));
    }
    return blockId;
  }
  /*
   * Terminate the current block w the given terminal, and set the previously
   * reserved block as the new current block
   */
  terminateWithContinuation(terminal, continuation) {
    const { id: blockId, kind, instructions } = __privateGet(this, _current);
    __privateGet(this, _completed).set(blockId, {
      kind,
      id: blockId,
      instructions,
      terminal,
      preds: /* @__PURE__ */ new Set(),
      phis: /* @__PURE__ */ new Set()
    });
    __privateSet(this, _current, continuation);
  }
  /*
   * Reserve a block so that it can be referenced prior to construction.
   * Make this the current block with `terminateWithContinuation()` or
   * call `complete()` to save it without setting it as the current block.
   */
  reserve(kind) {
    return newBlock(makeBlockId(__privateGet(this, _env).nextBlockId), kind);
  }
  // Save a previously reserved block as completed
  complete(block, terminal) {
    const { id: blockId, kind, instructions } = block;
    __privateGet(this, _completed).set(blockId, {
      kind,
      id: blockId,
      instructions,
      terminal,
      preds: /* @__PURE__ */ new Set(),
      phis: /* @__PURE__ */ new Set()
    });
  }
  /*
   * Sets the given wip block as the current block, executes the provided callback to populate the block
   * up to its terminal, and then resets the previous actively block.
   */
  enterReserved(wip, fn) {
    const current = __privateGet(this, _current);
    __privateSet(this, _current, wip);
    const terminal = fn();
    const { id: blockId, kind, instructions } = __privateGet(this, _current);
    __privateGet(this, _completed).set(blockId, {
      kind,
      id: blockId,
      instructions,
      terminal,
      preds: /* @__PURE__ */ new Set(),
      phis: /* @__PURE__ */ new Set()
    });
    __privateSet(this, _current, current);
  }
  /*
   * Create a new block and execute the provided callback with the new block
   * set as the current, resetting to the previously active block upon exit.
   * The lambda must return a terminal node, which is used to terminate the
   * newly constructed block.
   */
  enter(nextBlockKind, fn) {
    const wip = this.reserve(nextBlockKind);
    this.enterReserved(wip, () => {
      return fn(wip.id);
    });
    return wip.id;
  }
  label(label, breakBlock, fn) {
    __privateGet(this, _scopes).push({
      kind: "label",
      breakBlock,
      label
    });
    const value = fn();
    const last = __privateGet(this, _scopes).pop();
    CompilerError.invariant(
      last != null && last.kind === "label" && last.label === label && last.breakBlock === breakBlock,
      {
        reason: "Mismatched label",
        description: null,
        loc: null,
        suggestions: null
      }
    );
    return value;
  }
  switch(label, breakBlock, fn) {
    __privateGet(this, _scopes).push({
      kind: "switch",
      breakBlock,
      label
    });
    const value = fn();
    const last = __privateGet(this, _scopes).pop();
    CompilerError.invariant(
      last != null && last.kind === "switch" && last.label === label && last.breakBlock === breakBlock,
      {
        reason: "Mismatched label",
        description: null,
        loc: null,
        suggestions: null
      }
    );
    return value;
  }
  /*
   * Executes the provided lambda inside a scope in which the provided loop
   * information is cached for lookup with `lookupBreak()` and `lookupContinue()`
   */
  loop(label, continueBlock, breakBlock, fn) {
    __privateGet(this, _scopes).push({
      kind: "loop",
      label,
      continueBlock,
      breakBlock
    });
    const value = fn();
    const last = __privateGet(this, _scopes).pop();
    CompilerError.invariant(
      last != null && last.kind === "loop" && last.label === label && last.continueBlock === continueBlock && last.breakBlock === breakBlock,
      {
        reason: "Mismatched loops",
        description: null,
        loc: null,
        suggestions: null
      }
    );
    return value;
  }
  /*
   * Lookup the block target for a break statement, based on loops and switch statements
   * in scope. Throws if there is no available location to break.
   */
  lookupBreak(label) {
    for (let ii = __privateGet(this, _scopes).length - 1; ii >= 0; ii--) {
      const scope = __privateGet(this, _scopes)[ii];
      if (label === null && (scope.kind === "loop" || scope.kind === "switch") || label === scope.label) {
        return scope.breakBlock;
      }
    }
    CompilerError.invariant(false, {
      reason: "Expected a loop or switch to be in scope",
      description: null,
      loc: null,
      suggestions: null
    });
  }
  /*
   * Lookup the block target for a continue statement, based on loops
   * in scope. Throws if there is no available location to continue, or if the given
   * label does not correspond to a loop (this should also be validated at parse time).
   */
  lookupContinue(label) {
    for (let ii = __privateGet(this, _scopes).length - 1; ii >= 0; ii--) {
      const scope = __privateGet(this, _scopes)[ii];
      if (scope.kind === "loop") {
        if (label === null || label === scope.label) {
          return scope.continueBlock;
        }
      } else if (label !== null && scope.label === label) {
        CompilerError.invariant(false, {
          reason: "Continue may only refer to a labeled loop",
          description: null,
          loc: null,
          suggestions: null
        });
      }
    }
    CompilerError.invariant(false, {
      reason: "Expected a loop to be in scope",
      description: null,
      loc: null,
      suggestions: null
    });
  }
};
_completed = new WeakMap();
_current = new WeakMap();
_entry = new WeakMap();
_scopes = new WeakMap();
_context = new WeakMap();
_bindings = new WeakMap();
_env = new WeakMap();
_exceptionHandlerStack = new WeakMap();
_HIRBuilder_instances = new WeakSet();
resolveBabelBinding_fn = function(path) {
  const originalName = path.node.name;
  const binding = path.scope.getBinding(originalName);
  if (binding == null) {
    return null;
  }
  return binding;
};
function removeUnreachableForUpdates(fn) {
  for (const [, block] of fn.blocks) {
    if (block.terminal.kind === "for" && block.terminal.update !== null && !fn.blocks.has(block.terminal.update)) {
      block.terminal.update = null;
    }
  }
}
function removeDeadDoWhileStatements(func) {
  const visited = /* @__PURE__ */ new Set();
  for (const [_, block] of func.blocks) {
    visited.add(block.id);
  }
  for (const [_, block] of func.blocks) {
    if (block.terminal.kind === "do-while") {
      if (!visited.has(block.terminal.test)) {
        block.terminal = {
          kind: "goto",
          block: block.terminal.loop,
          variant: "Break" /* Break */,
          id: block.terminal.id,
          loc: block.terminal.loc
        };
      }
    }
  }
}
function reversePostorderBlocks(func) {
  const rpoBlocks = getReversePostorderedBlocks(func);
  func.blocks = rpoBlocks;
}
function getReversePostorderedBlocks(func) {
  const visited = /* @__PURE__ */ new Set();
  const used = /* @__PURE__ */ new Set();
  const usedFallthroughs = /* @__PURE__ */ new Set();
  const postorder = [];
  function visit4(blockId, isUsed) {
    const wasUsed = used.has(blockId);
    const wasVisited = visited.has(blockId);
    visited.add(blockId);
    if (isUsed) {
      used.add(blockId);
    }
    if (wasVisited && (wasUsed || !isUsed)) {
      return;
    }
    const block = func.blocks.get(blockId);
    CompilerError.invariant(block != null, {
      reason: "[HIRBuilder] Unexpected null block",
      description: `expected block ${blockId} to exist`,
      loc: GeneratedSource
    });
    const successors = [...eachTerminalSuccessor(block.terminal)].reverse();
    const fallthrough = terminalFallthrough(block.terminal);
    if (fallthrough != null) {
      if (isUsed) {
        usedFallthroughs.add(fallthrough);
      }
      visit4(fallthrough, false);
    }
    for (const successor of successors) {
      visit4(successor, isUsed);
    }
    if (!wasVisited) {
      postorder.push(blockId);
    }
  }
  visit4(func.entry, true);
  const blocks = /* @__PURE__ */ new Map();
  for (const blockId of postorder.reverse()) {
    const block = func.blocks.get(blockId);
    if (used.has(blockId)) {
      blocks.set(blockId, func.blocks.get(blockId));
    } else if (usedFallthroughs.has(blockId)) {
      blocks.set(blockId, __spreadProps(__spreadValues({}, block), {
        instructions: [],
        terminal: {
          kind: "unreachable",
          id: block.terminal.id,
          loc: block.terminal.loc
        }
      }));
    }
  }
  return blocks;
}
function markInstructionIds(func) {
  let id = 0;
  const visited = /* @__PURE__ */ new Set();
  for (const [_, block] of func.blocks) {
    for (const instr of block.instructions) {
      CompilerError.invariant(!visited.has(instr), {
        reason: `${printInstruction(instr)} already visited!`,
        description: null,
        loc: instr.loc,
        suggestions: null
      });
      visited.add(instr);
      instr.id = makeInstructionId(++id);
    }
    block.terminal.id = makeInstructionId(++id);
  }
}
function markPredecessors(func) {
  for (const [, block] of func.blocks) {
    block.preds.clear();
  }
  const visited = /* @__PURE__ */ new Set();
  function visit4(blockId, prevBlock) {
    const block = func.blocks.get(blockId);
    if (block == null) {
      return;
    }
    CompilerError.invariant(block != null, {
      reason: "unexpected missing block",
      description: `block ${blockId}`,
      loc: GeneratedSource
    });
    if (prevBlock) {
      block.preds.add(prevBlock.id);
    }
    if (visited.has(blockId)) {
      return;
    }
    visited.add(blockId);
    const { terminal } = block;
    for (const successor of eachTerminalSuccessor(terminal)) {
      visit4(successor, block);
    }
  }
  visit4(func.entry, null);
}
function removeUnnecessaryTryCatch(fn) {
  for (const [, block] of fn.blocks) {
    if (block.terminal.kind === "try" && !fn.blocks.has(block.terminal.handler)) {
      const handlerId = block.terminal.handler;
      const fallthroughId = block.terminal.fallthrough;
      const fallthrough = fn.blocks.get(fallthroughId);
      block.terminal = {
        kind: "goto",
        block: block.terminal.block,
        id: makeInstructionId(0),
        loc: block.terminal.loc,
        variant: "Break" /* Break */
      };
      if (fallthrough != null) {
        if (fallthrough.preds.size === 1 && fallthrough.preds.has(handlerId)) {
          fn.blocks.delete(fallthroughId);
        } else {
          fallthrough.preds.delete(handlerId);
        }
      }
    }
  }
}
function createTemporaryPlace(env, loc) {
  return {
    kind: "Identifier",
    identifier: makeTemporaryIdentifier(env.nextIdentifierId, loc),
    reactive: false,
    effect: "<unknown>" /* Unknown */,
    loc: GeneratedSource
  };
}
function clonePlaceToTemporary(env, place) {
  const temp = createTemporaryPlace(env, place.loc);
  temp.effect = place.effect;
  temp.identifier.type = place.identifier.type;
  temp.reactive = place.reactive;
  return temp;
}
function fixScopeAndIdentifierRanges(func) {
  var _a, _b;
  for (const [, block] of func.blocks) {
    const terminal = block.terminal;
    if (terminal.kind === "scope" || terminal.kind === "pruned-scope") {
      const fallthroughBlock = func.blocks.get(terminal.fallthrough);
      const firstId = (_b = (_a = fallthroughBlock.instructions[0]) == null ? void 0 : _a.id) != null ? _b : fallthroughBlock.terminal.id;
      terminal.scope.range.start = terminal.id;
      terminal.scope.range.end = firstId;
    }
  }
}

// src/HIR/ObjectShape.ts
var PRIMITIVE_TYPE = {
  kind: "Primitive"
};
var nextAnonId = 0;
function createAnonId() {
  return `<generated_${nextAnonId++}>`;
}
function addFunction(registry, properties, fn, id = null, isConstructor = false) {
  const shapeId = id != null ? id : createAnonId();
  const aliasing = fn.aliasing != null ? parseAliasingSignatureConfig(fn.aliasing, "<builtin>", GeneratedSource) : null;
  addShape(registry, shapeId, properties, __spreadProps(__spreadValues({}, fn), {
    aliasing,
    hookKind: null
  }));
  return {
    kind: "Function",
    return: fn.returnType,
    shapeId,
    isConstructor
  };
}
function addHook(registry, fn, id = null) {
  const shapeId = id != null ? id : createAnonId();
  const aliasing = fn.aliasing != null ? parseAliasingSignatureConfig(fn.aliasing, "<builtin>", GeneratedSource) : null;
  addShape(registry, shapeId, [], __spreadProps(__spreadValues({}, fn), { aliasing }));
  return {
    kind: "Function",
    return: fn.returnType,
    shapeId,
    isConstructor: false
  };
}
function parseAliasingSignatureConfig(typeConfig, moduleName, loc) {
  const lifetimes = /* @__PURE__ */ new Map();
  function define2(temp) {
    CompilerError.invariant(!lifetimes.has(temp), {
      reason: `Invalid type configuration for module`,
      description: `Expected aliasing signature to have unique names for receiver, params, rest, returns, and temporaries in module '${moduleName}'`,
      loc
    });
    const place = signatureArgument(lifetimes.size);
    lifetimes.set(temp, place);
    return place;
  }
  function lookup(temp) {
    const place = lifetimes.get(temp);
    CompilerError.invariant(place != null, {
      reason: `Invalid type configuration for module`,
      description: `Expected aliasing signature effects to reference known names from receiver/params/rest/returns/temporaries, but '${temp}' is not a known name in '${moduleName}'`,
      loc
    });
    return place;
  }
  const receiver = define2(typeConfig.receiver);
  const params = typeConfig.params.map(define2);
  const rest = typeConfig.rest != null ? define2(typeConfig.rest) : null;
  const returns = define2(typeConfig.returns);
  const temporaries = typeConfig.temporaries.map(define2);
  const effects = typeConfig.effects.map(
    (effect) => {
      switch (effect.kind) {
        case "ImmutableCapture":
        case "CreateFrom":
        case "Capture":
        case "Alias":
        case "Assign": {
          const from = lookup(effect.from);
          const into = lookup(effect.into);
          return {
            kind: effect.kind,
            from,
            into
          };
        }
        case "Mutate":
        case "MutateTransitiveConditionally": {
          const value = lookup(effect.value);
          return { kind: effect.kind, value };
        }
        case "Create": {
          const into = lookup(effect.into);
          return {
            kind: "Create",
            into,
            reason: effect.reason,
            value: effect.value
          };
        }
        case "Freeze": {
          const value = lookup(effect.value);
          return {
            kind: "Freeze",
            value,
            reason: effect.reason
          };
        }
        case "Impure": {
          const place = lookup(effect.place);
          return {
            kind: "Impure",
            place,
            error: CompilerError.throwTodo({
              reason: "Support impure effect declarations",
              loc: GeneratedSource
            })
          };
        }
        case "Apply": {
          const receiver2 = lookup(effect.receiver);
          const fn = lookup(effect.function);
          const args = effect.args.map(
            (arg) => {
              if (typeof arg === "string") {
                return lookup(arg);
              } else if (arg.kind === "Spread") {
                return { kind: "Spread", place: lookup(arg.place) };
              } else {
                return arg;
              }
            }
          );
          const into = lookup(effect.into);
          return {
            kind: "Apply",
            receiver: receiver2,
            function: fn,
            mutatesFunction: effect.mutatesFunction,
            args,
            into,
            loc,
            signature: null
          };
        }
        default: {
          assertExhaustive(
            effect,
            `Unexpected effect kind '${effect.kind}'`
          );
        }
      }
    }
  );
  return {
    receiver: receiver.identifier.id,
    params: params.map((p) => p.identifier.id),
    rest: rest != null ? rest.identifier.id : null,
    returns: returns.identifier.id,
    temporaries,
    effects
  };
}
function addObject(registry, id, properties) {
  const shapeId = id != null ? id : createAnonId();
  addShape(registry, shapeId, properties, null);
  return {
    kind: "Object",
    shapeId
  };
}
function addShape(registry, id, properties, functionType2) {
  const shape = {
    properties: new Map(properties),
    functionType: functionType2
  };
  CompilerError.invariant(!registry.has(id), {
    reason: `[ObjectShape] Could not add shape to registry: name ${id} already exists.`,
    description: null,
    loc: null,
    suggestions: null
  });
  registry.set(id, shape);
  return shape;
}
var BuiltInPropsId = "BuiltInProps";
var BuiltInArrayId = "BuiltInArray";
var BuiltInSetId = "BuiltInSet";
var BuiltInMapId = "BuiltInMap";
var BuiltInWeakSetId = "BuiltInWeakSet";
var BuiltInWeakMapId = "BuiltInWeakMap";
var BuiltInFunctionId = "BuiltInFunction";
var BuiltInJsxId = "BuiltInJsx";
var BuiltInObjectId = "BuiltInObject";
var BuiltInUseStateId = "BuiltInUseState";
var BuiltInSetStateId = "BuiltInSetState";
var BuiltInUseActionStateId = "BuiltInUseActionState";
var BuiltInSetActionStateId = "BuiltInSetActionState";
var BuiltInUseRefId = "BuiltInUseRefId";
var BuiltInRefValueId = "BuiltInRefValue";
var BuiltInMixedReadonlyId = "BuiltInMixedReadonly";
var BuiltInUseEffectHookId = "BuiltInUseEffectHook";
var BuiltInUseLayoutEffectHookId = "BuiltInUseLayoutEffectHook";
var BuiltInUseInsertionEffectHookId = "BuiltInUseInsertionEffectHook";
var BuiltInUseOperatorId = "BuiltInUseOperator";
var BuiltInUseReducerId = "BuiltInUseReducer";
var BuiltInDispatchId = "BuiltInDispatch";
var BuiltInUseContextHookId = "BuiltInUseContextHook";
var BuiltInUseTransitionId = "BuiltInUseTransition";
var BuiltInStartTransitionId = "BuiltInStartTransition";
var BuiltInFireId = "BuiltInFire";
var BuiltInFireFunctionId = "BuiltInFireFunction";
var BuiltInUseEffectEventId = "BuiltInUseEffectEvent";
var BuiltinEffectEventId = "BuiltInEffectEventFunction";
var BuiltInAutodepsId = "BuiltInAutoDepsId";
var ReanimatedSharedValueId = "ReanimatedSharedValueId";
var BUILTIN_SHAPES = /* @__PURE__ */ new Map();
addObject(BUILTIN_SHAPES, BuiltInPropsId, [
  ["ref", { kind: "Object", shapeId: BuiltInUseRefId }]
]);
addObject(BUILTIN_SHAPES, BuiltInArrayId, [
  [
    "indexOf",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: "read" /* Read */,
      returnType: { kind: "Primitive" },
      calleeEffect: "read" /* Read */,
      returnValueKind: "primitive" /* Primitive */
    })
  ],
  [
    "includes",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: "read" /* Read */,
      returnType: { kind: "Primitive" },
      calleeEffect: "read" /* Read */,
      returnValueKind: "primitive" /* Primitive */
    })
  ],
  [
    "pop",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: null,
      returnType: { kind: "Poly" },
      calleeEffect: "store" /* Store */,
      returnValueKind: "mutable" /* Mutable */
    })
  ],
  [
    "at",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: ["read" /* Read */],
      restParam: null,
      returnType: { kind: "Poly" },
      calleeEffect: "capture" /* Capture */,
      returnValueKind: "mutable" /* Mutable */
    })
  ],
  [
    "concat",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: "capture" /* Capture */,
      returnType: {
        kind: "Object",
        shapeId: BuiltInArrayId
      },
      calleeEffect: "capture" /* Capture */,
      returnValueKind: "mutable" /* Mutable */
    })
  ],
  ["length", PRIMITIVE_TYPE],
  [
    "push",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: "capture" /* Capture */,
      returnType: PRIMITIVE_TYPE,
      calleeEffect: "store" /* Store */,
      returnValueKind: "primitive" /* Primitive */,
      aliasing: {
        receiver: "@receiver",
        params: [],
        rest: "@rest",
        returns: "@returns",
        temporaries: [],
        effects: [
          // Push directly mutates the array itself
          { kind: "Mutate", value: "@receiver" },
          // The arguments are captured into the array
          {
            kind: "Capture",
            from: "@rest",
            into: "@receiver"
          },
          // Returns the new length, a primitive
          {
            kind: "Create",
            into: "@returns",
            value: "primitive" /* Primitive */,
            reason: "known-return-signature" /* KnownReturnSignature */
          }
        ]
      }
    })
  ],
  [
    "slice",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: "read" /* Read */,
      returnType: {
        kind: "Object",
        shapeId: BuiltInArrayId
      },
      calleeEffect: "capture" /* Capture */,
      returnValueKind: "mutable" /* Mutable */
    })
  ],
  [
    "map",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: "mutate?" /* ConditionallyMutate */,
      returnType: { kind: "Object", shapeId: BuiltInArrayId },
      /*
       * callee is ConditionallyMutate because items of the array
       * flow into the lambda and may be mutated there, even though
       * the array object itself is not modified
       */
      calleeEffect: "mutate?" /* ConditionallyMutate */,
      returnValueKind: "mutable" /* Mutable */,
      noAlias: true,
      mutableOnlyIfOperandsAreMutable: true,
      aliasing: {
        receiver: "@receiver",
        params: ["@callback"],
        rest: null,
        returns: "@returns",
        temporaries: [
          // Temporary representing captured items of the receiver
          "@item",
          // Temporary representing the result of the callback
          "@callbackReturn",
          /*
           * Undefined `this` arg to the callback. Note the signature does not
           * support passing an explicit thisArg second param
           */
          "@thisArg"
        ],
        effects: [
          // Map creates a new mutable array
          {
            kind: "Create",
            into: "@returns",
            value: "mutable" /* Mutable */,
            reason: "known-return-signature" /* KnownReturnSignature */
          },
          // The first arg to the callback is an item extracted from the receiver array
          {
            kind: "CreateFrom",
            from: "@receiver",
            into: "@item"
          },
          // The undefined this for the callback
          {
            kind: "Create",
            into: "@thisArg",
            value: "primitive" /* Primitive */,
            reason: "known-return-signature" /* KnownReturnSignature */
          },
          // calls the callback, returning the result into a temporary
          {
            kind: "Apply",
            receiver: "@thisArg",
            args: ["@item", { kind: "Hole" }, "@receiver"],
            function: "@callback",
            into: "@callbackReturn",
            mutatesFunction: false
          },
          // captures the result of the callback into the return array
          {
            kind: "Capture",
            from: "@callbackReturn",
            into: "@returns"
          }
        ]
      }
    })
  ],
  [
    "flatMap",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: "mutate?" /* ConditionallyMutate */,
      returnType: { kind: "Object", shapeId: BuiltInArrayId },
      /*
       * callee is ConditionallyMutate because items of the array
       * flow into the lambda and may be mutated there, even though
       * the array object itself is not modified
       */
      calleeEffect: "mutate?" /* ConditionallyMutate */,
      returnValueKind: "mutable" /* Mutable */,
      noAlias: true,
      mutableOnlyIfOperandsAreMutable: true
    })
  ],
  [
    "filter",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: "mutate?" /* ConditionallyMutate */,
      returnType: { kind: "Object", shapeId: BuiltInArrayId },
      /*
       * callee is ConditionallyMutate because items of the array
       * flow into the lambda and may be mutated there, even though
       * the array object itself is not modified
       */
      calleeEffect: "mutate?" /* ConditionallyMutate */,
      returnValueKind: "mutable" /* Mutable */,
      noAlias: true,
      mutableOnlyIfOperandsAreMutable: true
    })
  ],
  [
    "every",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: "mutate?" /* ConditionallyMutate */,
      returnType: { kind: "Primitive" },
      /*
       * callee is ConditionallyMutate because items of the array
       * flow into the lambda and may be mutated there, even though
       * the array object itself is not modified
       */
      calleeEffect: "mutate?" /* ConditionallyMutate */,
      returnValueKind: "primitive" /* Primitive */,
      noAlias: true,
      mutableOnlyIfOperandsAreMutable: true
    })
  ],
  [
    "some",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: "mutate?" /* ConditionallyMutate */,
      returnType: { kind: "Primitive" },
      /*
       * callee is ConditionallyMutate because items of the array
       * flow into the lambda and may be mutated there, even though
       * the array object itself is not modified
       */
      calleeEffect: "mutate?" /* ConditionallyMutate */,
      returnValueKind: "primitive" /* Primitive */,
      noAlias: true,
      mutableOnlyIfOperandsAreMutable: true
    })
  ],
  [
    "find",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: "mutate?" /* ConditionallyMutate */,
      returnType: { kind: "Poly" },
      calleeEffect: "mutate?" /* ConditionallyMutate */,
      returnValueKind: "mutable" /* Mutable */,
      noAlias: true,
      mutableOnlyIfOperandsAreMutable: true
    })
  ],
  [
    "findIndex",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: "mutate?" /* ConditionallyMutate */,
      returnType: { kind: "Primitive" },
      /*
       * callee is ConditionallyMutate because items of the array
       * flow into the lambda and may be mutated there, even though
       * the array object itself is not modified
       */
      calleeEffect: "mutate?" /* ConditionallyMutate */,
      returnValueKind: "primitive" /* Primitive */,
      noAlias: true,
      mutableOnlyIfOperandsAreMutable: true
    })
  ],
  [
    "join",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: "read" /* Read */,
      returnType: PRIMITIVE_TYPE,
      calleeEffect: "read" /* Read */,
      returnValueKind: "primitive" /* Primitive */
    })
  ]
  // TODO: rest of Array properties
]);
addObject(BUILTIN_SHAPES, BuiltInObjectId, [
  [
    "toString",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: null,
      returnType: PRIMITIVE_TYPE,
      calleeEffect: "read" /* Read */,
      returnValueKind: "primitive" /* Primitive */
    })
  ]
  /*
   * TODO:
   * hasOwnProperty, isPrototypeOf, propertyIsEnumerable, toLocaleString, valueOf
   */
]);
addObject(BUILTIN_SHAPES, BuiltInSetId, [
  [
    /**
     * add(value)
     * Parameters
     *   value: the value of the element to add to the Set object.
     * Returns the Set object with added value.
     */
    "add",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: ["capture" /* Capture */],
      restParam: null,
      returnType: { kind: "Object", shapeId: BuiltInSetId },
      calleeEffect: "store" /* Store */,
      // returnValueKind is technically dependent on the ValueKind of the set itself
      returnValueKind: "mutable" /* Mutable */,
      aliasing: {
        receiver: "@receiver",
        params: [],
        rest: "@rest",
        returns: "@returns",
        temporaries: [],
        effects: [
          // Set.add returns the receiver Set
          {
            kind: "Assign",
            from: "@receiver",
            into: "@returns"
          },
          // Set.add mutates the set itself
          {
            kind: "Mutate",
            value: "@receiver"
          },
          // Captures the rest params into the set
          {
            kind: "Capture",
            from: "@rest",
            into: "@receiver"
          }
        ]
      }
    })
  ],
  [
    /**
     * clear()
     * Parameters none
     * Returns undefined
     */
    "clear",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: null,
      returnType: PRIMITIVE_TYPE,
      calleeEffect: "store" /* Store */,
      returnValueKind: "primitive" /* Primitive */
    })
  ],
  [
    /**
     * setInstance.delete(value)
     * Returns true if value was already in Set; otherwise false.
     */
    "delete",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: ["read" /* Read */],
      restParam: null,
      returnType: PRIMITIVE_TYPE,
      calleeEffect: "store" /* Store */,
      returnValueKind: "primitive" /* Primitive */
    })
  ],
  [
    "has",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: ["read" /* Read */],
      restParam: null,
      returnType: PRIMITIVE_TYPE,
      calleeEffect: "read" /* Read */,
      returnValueKind: "primitive" /* Primitive */
    })
  ],
  ["size", PRIMITIVE_TYPE],
  [
    /**
     * difference(other)
     * Parameters
     *   other: A Set object, or set-like object.
     * Returns a new Set object containing elements in this set but not in the other set.
     */
    "difference",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: ["capture" /* Capture */],
      restParam: null,
      returnType: { kind: "Object", shapeId: BuiltInSetId },
      calleeEffect: "capture" /* Capture */,
      returnValueKind: "mutable" /* Mutable */
    })
  ],
  [
    /**
     * union(other)
     * Parameters
     *   other: A Set object, or set-like object.
     * Returns a new Set object containing elements in either this set or the other set.
     */
    "union",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: ["capture" /* Capture */],
      restParam: null,
      returnType: { kind: "Object", shapeId: BuiltInSetId },
      calleeEffect: "capture" /* Capture */,
      returnValueKind: "mutable" /* Mutable */
    })
  ],
  [
    /**
     * symmetricalDifference(other)
     * Parameters
     *   other: A Set object, or set-like object.
     * A new Set object containing elements which are in either this set or the other set, but not in both.
     */
    "symmetricalDifference",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: ["capture" /* Capture */],
      restParam: null,
      returnType: { kind: "Object", shapeId: BuiltInSetId },
      calleeEffect: "capture" /* Capture */,
      returnValueKind: "mutable" /* Mutable */
    })
  ],
  [
    /**
     * isSubsetOf(other)
     * Parameters
     *   other: A Set object, or set-like object.
     * Returns true if all elements in this set are also in the other set, and false otherwise.
     */
    "isSubsetOf",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: ["read" /* Read */],
      restParam: null,
      returnType: PRIMITIVE_TYPE,
      calleeEffect: "read" /* Read */,
      returnValueKind: "primitive" /* Primitive */
    })
  ],
  [
    /**
     * isSupersetOf(other)
     * Parameters
     *  other: A Set object, or set-like object.
     * Returns true if all elements in the other set are also in this set, and false otherwise.
     */
    "isSupersetOf",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: ["read" /* Read */],
      restParam: null,
      returnType: PRIMITIVE_TYPE,
      calleeEffect: "read" /* Read */,
      returnValueKind: "primitive" /* Primitive */
    })
  ],
  [
    /**
     * forEach(callbackFn)
     * forEach(callbackFn, thisArg)
     */
    "forEach",
    addFunction(BUILTIN_SHAPES, [], {
      /**
       * see Array.map explanation for why arguments are marked `ConditionallyMutate`
       */
      positionalParams: [],
      restParam: "mutate?" /* ConditionallyMutate */,
      returnType: PRIMITIVE_TYPE,
      calleeEffect: "mutate?" /* ConditionallyMutate */,
      returnValueKind: "primitive" /* Primitive */,
      noAlias: true,
      mutableOnlyIfOperandsAreMutable: true
    })
  ],
  /**
   * Iterators
   */
  [
    "entries",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: null,
      returnType: { kind: "Poly" },
      calleeEffect: "capture" /* Capture */,
      returnValueKind: "mutable" /* Mutable */
    })
  ],
  [
    "keys",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: null,
      returnType: { kind: "Poly" },
      calleeEffect: "capture" /* Capture */,
      returnValueKind: "mutable" /* Mutable */
    })
  ],
  [
    "values",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: null,
      returnType: { kind: "Poly" },
      calleeEffect: "capture" /* Capture */,
      returnValueKind: "mutable" /* Mutable */
    })
  ]
]);
addObject(BUILTIN_SHAPES, BuiltInMapId, [
  [
    /**
     * clear()
     * Parameters none
     * Returns undefined
     */
    "clear",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: null,
      returnType: PRIMITIVE_TYPE,
      calleeEffect: "store" /* Store */,
      returnValueKind: "primitive" /* Primitive */
    })
  ],
  [
    "delete",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: ["read" /* Read */],
      restParam: null,
      returnType: PRIMITIVE_TYPE,
      calleeEffect: "store" /* Store */,
      returnValueKind: "primitive" /* Primitive */
    })
  ],
  [
    "get",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: ["read" /* Read */],
      restParam: null,
      returnType: { kind: "Poly" },
      calleeEffect: "capture" /* Capture */,
      returnValueKind: "mutable" /* Mutable */
    })
  ],
  [
    "has",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: ["read" /* Read */],
      restParam: null,
      returnType: PRIMITIVE_TYPE,
      calleeEffect: "read" /* Read */,
      returnValueKind: "primitive" /* Primitive */
    })
  ],
  [
    /**
     * Params
     *   key: the key of the element to add to the Map object. The key may be
     *   any JavaScript type (any primitive value or any type of JavaScript
     *   object).
     *   value: the value of the element to add to the Map object.
     * Returns the Map object.
     */
    "set",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: ["capture" /* Capture */, "capture" /* Capture */],
      restParam: null,
      returnType: { kind: "Object", shapeId: BuiltInMapId },
      calleeEffect: "store" /* Store */,
      returnValueKind: "mutable" /* Mutable */
    })
  ],
  ["size", PRIMITIVE_TYPE],
  [
    "forEach",
    addFunction(BUILTIN_SHAPES, [], {
      /**
       * see Array.map explanation for why arguments are marked `ConditionallyMutate`
       */
      positionalParams: [],
      restParam: "mutate?" /* ConditionallyMutate */,
      returnType: PRIMITIVE_TYPE,
      calleeEffect: "mutate?" /* ConditionallyMutate */,
      returnValueKind: "primitive" /* Primitive */,
      noAlias: true,
      mutableOnlyIfOperandsAreMutable: true
    })
  ],
  /**
   * Iterators
   */
  [
    "entries",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: null,
      returnType: { kind: "Poly" },
      calleeEffect: "capture" /* Capture */,
      returnValueKind: "mutable" /* Mutable */
    })
  ],
  [
    "keys",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: null,
      returnType: { kind: "Poly" },
      calleeEffect: "capture" /* Capture */,
      returnValueKind: "mutable" /* Mutable */
    })
  ],
  [
    "values",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: null,
      returnType: { kind: "Poly" },
      calleeEffect: "capture" /* Capture */,
      returnValueKind: "mutable" /* Mutable */
    })
  ]
]);
addObject(BUILTIN_SHAPES, BuiltInWeakSetId, [
  [
    /**
     * add(value)
     * Parameters
     *   value: the value of the element to add to the Set object.
     * Returns the Set object with added value.
     */
    "add",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: ["capture" /* Capture */],
      restParam: null,
      returnType: { kind: "Object", shapeId: BuiltInWeakSetId },
      calleeEffect: "store" /* Store */,
      // returnValueKind is technically dependent on the ValueKind of the set itself
      returnValueKind: "mutable" /* Mutable */
    })
  ],
  [
    /**
     * setInstance.delete(value)
     * Returns true if value was already in Set; otherwise false.
     */
    "delete",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: ["read" /* Read */],
      restParam: null,
      returnType: PRIMITIVE_TYPE,
      calleeEffect: "store" /* Store */,
      returnValueKind: "primitive" /* Primitive */
    })
  ],
  [
    "has",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: ["read" /* Read */],
      restParam: null,
      returnType: PRIMITIVE_TYPE,
      calleeEffect: "read" /* Read */,
      returnValueKind: "primitive" /* Primitive */
    })
  ]
]);
addObject(BUILTIN_SHAPES, BuiltInWeakMapId, [
  [
    "delete",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: ["read" /* Read */],
      restParam: null,
      returnType: PRIMITIVE_TYPE,
      calleeEffect: "store" /* Store */,
      returnValueKind: "primitive" /* Primitive */
    })
  ],
  [
    "get",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: ["read" /* Read */],
      restParam: null,
      returnType: { kind: "Poly" },
      calleeEffect: "capture" /* Capture */,
      returnValueKind: "mutable" /* Mutable */
    })
  ],
  [
    "has",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: ["read" /* Read */],
      restParam: null,
      returnType: PRIMITIVE_TYPE,
      calleeEffect: "read" /* Read */,
      returnValueKind: "primitive" /* Primitive */
    })
  ],
  [
    /**
     * Params
     *   key: the key of the element to add to the Map object. The key may be
     *   any JavaScript type (any primitive value or any type of JavaScript
     *   object).
     *   value: the value of the element to add to the Map object.
     * Returns the Map object.
     */
    "set",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: ["capture" /* Capture */, "capture" /* Capture */],
      restParam: null,
      returnType: { kind: "Object", shapeId: BuiltInWeakMapId },
      calleeEffect: "store" /* Store */,
      returnValueKind: "mutable" /* Mutable */
    })
  ]
]);
addObject(BUILTIN_SHAPES, BuiltInUseStateId, [
  ["0", { kind: "Poly" }],
  [
    "1",
    addFunction(
      BUILTIN_SHAPES,
      [],
      {
        positionalParams: [],
        restParam: "freeze" /* Freeze */,
        returnType: PRIMITIVE_TYPE,
        calleeEffect: "read" /* Read */,
        returnValueKind: "primitive" /* Primitive */
      },
      BuiltInSetStateId
    )
  ]
]);
addObject(BUILTIN_SHAPES, BuiltInUseTransitionId, [
  ["0", { kind: "Primitive" }],
  [
    "1",
    addFunction(
      BUILTIN_SHAPES,
      [],
      {
        positionalParams: [],
        restParam: null,
        returnType: PRIMITIVE_TYPE,
        calleeEffect: "read" /* Read */,
        returnValueKind: "primitive" /* Primitive */
      },
      BuiltInStartTransitionId
    )
  ]
]);
addObject(BUILTIN_SHAPES, BuiltInUseActionStateId, [
  ["0", { kind: "Poly" }],
  [
    "1",
    addFunction(
      BUILTIN_SHAPES,
      [],
      {
        positionalParams: [],
        restParam: "freeze" /* Freeze */,
        returnType: PRIMITIVE_TYPE,
        calleeEffect: "read" /* Read */,
        returnValueKind: "primitive" /* Primitive */
      },
      BuiltInSetActionStateId
    )
  ]
]);
addObject(BUILTIN_SHAPES, BuiltInUseReducerId, [
  ["0", { kind: "Poly" }],
  [
    "1",
    addFunction(
      BUILTIN_SHAPES,
      [],
      {
        positionalParams: [],
        restParam: "freeze" /* Freeze */,
        returnType: PRIMITIVE_TYPE,
        calleeEffect: "read" /* Read */,
        returnValueKind: "primitive" /* Primitive */
      },
      BuiltInDispatchId
    )
  ]
]);
addObject(BUILTIN_SHAPES, BuiltInUseRefId, [
  ["current", { kind: "Object", shapeId: BuiltInRefValueId }]
]);
addObject(BUILTIN_SHAPES, BuiltInRefValueId, [
  ["*", { kind: "Object", shapeId: BuiltInRefValueId }]
]);
addObject(BUILTIN_SHAPES, ReanimatedSharedValueId, []);
addFunction(
  BUILTIN_SHAPES,
  [],
  {
    positionalParams: [],
    restParam: "mutate?" /* ConditionallyMutate */,
    returnType: { kind: "Poly" },
    calleeEffect: "mutate?" /* ConditionallyMutate */,
    returnValueKind: "mutable" /* Mutable */
  },
  BuiltinEffectEventId
);
addObject(BUILTIN_SHAPES, BuiltInMixedReadonlyId, [
  [
    "toString",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: "read" /* Read */,
      returnType: PRIMITIVE_TYPE,
      calleeEffect: "read" /* Read */,
      returnValueKind: "primitive" /* Primitive */
    })
  ],
  [
    "indexOf",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: "read" /* Read */,
      returnType: { kind: "Primitive" },
      calleeEffect: "read" /* Read */,
      returnValueKind: "primitive" /* Primitive */
    })
  ],
  [
    "includes",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: "read" /* Read */,
      returnType: { kind: "Primitive" },
      calleeEffect: "read" /* Read */,
      returnValueKind: "primitive" /* Primitive */
    })
  ],
  [
    "at",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: ["read" /* Read */],
      restParam: null,
      returnType: { kind: "Object", shapeId: BuiltInMixedReadonlyId },
      calleeEffect: "capture" /* Capture */,
      returnValueKind: "frozen" /* Frozen */
    })
  ],
  [
    "map",
    addFunction(BUILTIN_SHAPES, [], {
      /**
       * Note `map`'s arguments are annotated as Effect.ConditionallyMutate as
       * calling `<array>.map(fn)` might invoke `fn`, which means replaying its
       * effects.
       *
       * (Note that Effect.Read / Effect.Capture on a function type means
       * potential data dependency or aliasing respectively.)
       */
      positionalParams: [],
      restParam: "mutate?" /* ConditionallyMutate */,
      returnType: { kind: "Object", shapeId: BuiltInArrayId },
      calleeEffect: "mutate?" /* ConditionallyMutate */,
      returnValueKind: "mutable" /* Mutable */,
      noAlias: true
    })
  ],
  [
    "flatMap",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: "mutate?" /* ConditionallyMutate */,
      returnType: { kind: "Object", shapeId: BuiltInArrayId },
      calleeEffect: "mutate?" /* ConditionallyMutate */,
      returnValueKind: "mutable" /* Mutable */,
      noAlias: true
    })
  ],
  [
    "filter",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: "mutate?" /* ConditionallyMutate */,
      returnType: { kind: "Object", shapeId: BuiltInArrayId },
      calleeEffect: "mutate?" /* ConditionallyMutate */,
      returnValueKind: "mutable" /* Mutable */,
      noAlias: true
    })
  ],
  [
    "concat",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: "capture" /* Capture */,
      returnType: {
        kind: "Object",
        shapeId: BuiltInArrayId
      },
      calleeEffect: "capture" /* Capture */,
      returnValueKind: "mutable" /* Mutable */
    })
  ],
  [
    "slice",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: "read" /* Read */,
      returnType: {
        kind: "Object",
        shapeId: BuiltInArrayId
      },
      calleeEffect: "capture" /* Capture */,
      returnValueKind: "mutable" /* Mutable */
    })
  ],
  [
    "every",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: "mutate?" /* ConditionallyMutate */,
      returnType: { kind: "Primitive" },
      calleeEffect: "mutate?" /* ConditionallyMutate */,
      returnValueKind: "primitive" /* Primitive */,
      noAlias: true,
      mutableOnlyIfOperandsAreMutable: true
    })
  ],
  [
    "some",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: "mutate?" /* ConditionallyMutate */,
      returnType: { kind: "Primitive" },
      calleeEffect: "mutate?" /* ConditionallyMutate */,
      returnValueKind: "primitive" /* Primitive */,
      noAlias: true,
      mutableOnlyIfOperandsAreMutable: true
    })
  ],
  [
    "find",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: "mutate?" /* ConditionallyMutate */,
      returnType: { kind: "Object", shapeId: BuiltInMixedReadonlyId },
      calleeEffect: "mutate?" /* ConditionallyMutate */,
      returnValueKind: "frozen" /* Frozen */,
      noAlias: true,
      mutableOnlyIfOperandsAreMutable: true
    })
  ],
  [
    "findIndex",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: "mutate?" /* ConditionallyMutate */,
      returnType: { kind: "Primitive" },
      calleeEffect: "mutate?" /* ConditionallyMutate */,
      returnValueKind: "primitive" /* Primitive */,
      noAlias: true,
      mutableOnlyIfOperandsAreMutable: true
    })
  ],
  [
    "join",
    addFunction(BUILTIN_SHAPES, [], {
      positionalParams: [],
      restParam: "read" /* Read */,
      returnType: PRIMITIVE_TYPE,
      calleeEffect: "read" /* Read */,
      returnValueKind: "primitive" /* Primitive */
    })
  ],
  ["*", { kind: "Object", shapeId: BuiltInMixedReadonlyId }]
]);
addObject(BUILTIN_SHAPES, BuiltInJsxId, []);
addObject(BUILTIN_SHAPES, BuiltInFunctionId, []);
var DefaultMutatingHook = addHook(
  BUILTIN_SHAPES,
  {
    positionalParams: [],
    restParam: "mutate?" /* ConditionallyMutate */,
    returnType: { kind: "Poly" },
    calleeEffect: "read" /* Read */,
    hookKind: "Custom",
    returnValueKind: "mutable" /* Mutable */
  },
  "DefaultMutatingHook"
);
var DefaultNonmutatingHook = addHook(
  BUILTIN_SHAPES,
  {
    positionalParams: [],
    restParam: "freeze" /* Freeze */,
    returnType: { kind: "Poly" },
    calleeEffect: "read" /* Read */,
    hookKind: "Custom",
    returnValueKind: "frozen" /* Frozen */,
    aliasing: {
      receiver: "@receiver",
      params: [],
      rest: "@rest",
      returns: "@returns",
      temporaries: [],
      effects: [
        // Freeze the arguments
        {
          kind: "Freeze",
          value: "@rest",
          reason: "hook-captured" /* HookCaptured */
        },
        // Returns a frozen value
        {
          kind: "Create",
          into: "@returns",
          value: "frozen" /* Frozen */,
          reason: "hook-return" /* HookReturn */
        },
        // May alias any arguments into the return
        {
          kind: "Alias",
          from: "@rest",
          into: "@returns"
        }
      ]
    }
  },
  "DefaultNonmutatingHook"
);
function signatureArgument(id) {
  const place = {
    kind: "Identifier",
    effect: "<unknown>" /* Unknown */,
    loc: GeneratedSource,
    reactive: false,
    identifier: {
      declarationId: makeDeclarationId(id),
      id: makeIdentifierId(id),
      loc: GeneratedSource,
      mutableRange: { start: makeInstructionId(0), end: makeInstructionId(0) },
      name: null,
      scope: null,
      type: makeType()
    }
  };
  return place;
}

// src/HIR/BuildHIR.ts
function lower(func, env, bindings = null, capturedRefs = /* @__PURE__ */ new Map()) {
  var _a, _b, _c;
  const builder = new HIRBuilder(env, {
    bindings,
    context: capturedRefs
  });
  const context = [];
  for (const [ref, loc] of capturedRefs != null ? capturedRefs : []) {
    context.push({
      kind: "Identifier",
      identifier: builder.resolveBinding(ref),
      effect: "<unknown>" /* Unknown */,
      reactive: false,
      loc
    });
  }
  let id = null;
  if (func.isFunctionDeclaration() || func.isFunctionExpression()) {
    const idNode = func.get("id");
    if (hasNode(idNode)) {
      id = idNode.node.name;
    }
  }
  const params = [];
  func.get("params").forEach((param) => {
    var _a2, _b2, _c2, _d, _e, _f, _g, _h, _i;
    if (param.isIdentifier()) {
      const binding = builder.resolveIdentifier(param);
      if (binding.kind !== "Identifier") {
        builder.errors.pushDiagnostic(
          CompilerDiagnostic.create({
            severity: "Invariant" /* Invariant */,
            category: "Invariant" /* Invariant */,
            reason: "Could not find binding",
            description: `[BuildHIR] Could not find binding for param \`${param.node.name}\`.`
          }).withDetail({
            kind: "error",
            loc: (_a2 = param.node.loc) != null ? _a2 : null,
            message: "Could not find binding"
          })
        );
        return;
      }
      const place = {
        kind: "Identifier",
        identifier: binding.identifier,
        effect: "<unknown>" /* Unknown */,
        reactive: false,
        loc: (_b2 = param.node.loc) != null ? _b2 : GeneratedSource
      };
      params.push(place);
    } else if (param.isObjectPattern() || param.isArrayPattern() || param.isAssignmentPattern()) {
      const place = {
        kind: "Identifier",
        identifier: builder.makeTemporary((_c2 = param.node.loc) != null ? _c2 : GeneratedSource),
        effect: "<unknown>" /* Unknown */,
        reactive: false,
        loc: (_d = param.node.loc) != null ? _d : GeneratedSource
      };
      promoteTemporary(place.identifier);
      params.push(place);
      lowerAssignment(
        builder,
        (_e = param.node.loc) != null ? _e : GeneratedSource,
        "Let" /* Let */,
        param,
        place,
        "Assignment"
      );
    } else if (param.isRestElement()) {
      const place = {
        kind: "Identifier",
        identifier: builder.makeTemporary((_f = param.node.loc) != null ? _f : GeneratedSource),
        effect: "<unknown>" /* Unknown */,
        reactive: false,
        loc: (_g = param.node.loc) != null ? _g : GeneratedSource
      };
      params.push({
        kind: "Spread",
        place
      });
      lowerAssignment(
        builder,
        (_h = param.node.loc) != null ? _h : GeneratedSource,
        "Let" /* Let */,
        param.get("argument"),
        place,
        "Assignment"
      );
    } else {
      builder.errors.pushDiagnostic(
        CompilerDiagnostic.create({
          severity: "Todo" /* Todo */,
          category: "Todo" /* Todo */,
          reason: `Handle ${param.node.type} parameters`,
          description: `[BuildHIR] Add support for ${param.node.type} parameters.`
        }).withDetail({
          kind: "error",
          loc: (_i = param.node.loc) != null ? _i : null,
          message: "Unsupported parameter type"
        })
      );
    }
  });
  let directives = [];
  const body = func.get("body");
  if (body.isExpression()) {
    const fallthrough = builder.reserve("block");
    const terminal = {
      kind: "return",
      returnVariant: "Implicit",
      loc: GeneratedSource,
      value: lowerExpressionToTemporary(builder, body),
      id: makeInstructionId(0),
      effects: null
    };
    builder.terminateWithContinuation(terminal, fallthrough);
  } else if (body.isBlockStatement()) {
    lowerStatement(builder, body);
    directives = body.get("directives").map((d) => d.node.value.value);
  } else {
    builder.errors.pushDiagnostic(
      CompilerDiagnostic.create({
        severity: "InvalidJS" /* InvalidJS */,
        category: "Syntax" /* Syntax */,
        reason: `Unexpected function body kind`,
        description: `Expected function body to be an expression or a block statement, got \`${body.type}\`.`
      }).withDetail({
        kind: "error",
        loc: (_a = body.node.loc) != null ? _a : null,
        message: "Expected a block statement or expression"
      })
    );
  }
  if (builder.errors.hasErrors()) {
    return Err(builder.errors);
  }
  builder.terminate(
    {
      kind: "return",
      returnVariant: "Void",
      loc: GeneratedSource,
      value: lowerValueToTemporary(builder, {
        kind: "Primitive",
        value: void 0,
        loc: GeneratedSource
      }),
      id: makeInstructionId(0),
      effects: null
    },
    null
  );
  return Ok({
    id,
    params,
    fnType: bindings == null ? env.fnType : "Other",
    returnTypeAnnotation: null,
    // TODO: extract the actual return type node if present
    returns: createTemporaryPlace(env, (_b = func.node.loc) != null ? _b : GeneratedSource),
    body: builder.build(),
    context,
    generator: func.node.generator === true,
    async: func.node.async === true,
    loc: (_c = func.node.loc) != null ? _c : GeneratedSource,
    env,
    effects: null,
    aliasingEffects: null,
    directives
  });
}
function lowerStatement(builder, stmtPath, label = null) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B, _C, _D, _E, _F, _G, _H, _I, _J, _K, _L, _M, _N, _O, _P, _Q, _R, _S, _T, _U, _V, _W, _X, _Y, _Z, __, _$, _aa, _ba, _ca, _da, _ea, _fa, _ga;
  const stmtNode = stmtPath.node;
  switch (stmtNode.type) {
    case "ThrowStatement": {
      const stmt = stmtPath;
      const value = lowerExpressionToTemporary(builder, stmt.get("argument"));
      const handler = builder.resolveThrowHandler();
      if (handler != null) {
        builder.errors.push({
          reason: "(BuildHIR::lowerStatement) Support ThrowStatement inside of try/catch",
          severity: "Todo" /* Todo */,
          category: "Todo" /* Todo */,
          loc: (_a = stmt.node.loc) != null ? _a : null,
          suggestions: null
        });
      }
      const terminal = {
        kind: "throw",
        value,
        id: makeInstructionId(0),
        loc: (_b = stmt.node.loc) != null ? _b : GeneratedSource
      };
      builder.terminate(terminal, "block");
      return;
    }
    case "ReturnStatement": {
      const stmt = stmtPath;
      const argument = stmt.get("argument");
      let value;
      if (argument.node === null) {
        value = lowerValueToTemporary(builder, {
          kind: "Primitive",
          value: void 0,
          loc: GeneratedSource
        });
      } else {
        value = lowerExpressionToTemporary(
          builder,
          argument
        );
      }
      const terminal = {
        kind: "return",
        returnVariant: "Explicit",
        loc: (_c = stmt.node.loc) != null ? _c : GeneratedSource,
        value,
        id: makeInstructionId(0),
        effects: null
      };
      builder.terminate(terminal, "block");
      return;
    }
    case "IfStatement": {
      const stmt = stmtPath;
      const continuationBlock = builder.reserve("block");
      const consequentBlock = builder.enter("block", (_blockId) => {
        var _a2;
        const consequent = stmt.get("consequent");
        lowerStatement(builder, consequent);
        return {
          kind: "goto",
          block: continuationBlock.id,
          variant: "Break" /* Break */,
          id: makeInstructionId(0),
          loc: (_a2 = consequent.node.loc) != null ? _a2 : GeneratedSource
        };
      });
      let alternateBlock;
      const alternate = stmt.get("alternate");
      if (hasNode(alternate)) {
        alternateBlock = builder.enter("block", (_blockId) => {
          var _a2, _b2;
          lowerStatement(builder, alternate);
          return {
            kind: "goto",
            block: continuationBlock.id,
            variant: "Break" /* Break */,
            id: makeInstructionId(0),
            loc: (_b2 = (_a2 = alternate.node) == null ? void 0 : _a2.loc) != null ? _b2 : GeneratedSource
          };
        });
      } else {
        alternateBlock = continuationBlock.id;
      }
      const test = lowerExpressionToTemporary(builder, stmt.get("test"));
      const terminal = {
        kind: "if",
        test,
        consequent: consequentBlock,
        alternate: alternateBlock,
        fallthrough: continuationBlock.id,
        id: makeInstructionId(0),
        loc: (_d = stmt.node.loc) != null ? _d : GeneratedSource
      };
      builder.terminateWithContinuation(terminal, continuationBlock);
      return;
    }
    case "BlockStatement": {
      const stmt = stmtPath;
      const statements = stmt.get("body");
      const hoistableIdentifiers = /* @__PURE__ */ new Set();
      for (const [, binding] of Object.entries(stmt.scope.bindings)) {
        if (binding.kind !== "param") {
          hoistableIdentifiers.add(binding.identifier);
        }
      }
      for (const s of statements) {
        const willHoist = /* @__PURE__ */ new Set();
        let fnDepth = s.isFunctionDeclaration() ? 1 : 0;
        const withFunctionContext = {
          enter: () => {
            fnDepth++;
          },
          exit: () => {
            fnDepth--;
          }
        };
        s.traverse({
          FunctionExpression: withFunctionContext,
          FunctionDeclaration: withFunctionContext,
          ArrowFunctionExpression: withFunctionContext,
          ObjectMethod: withFunctionContext,
          Identifier(id) {
            const id2 = id;
            if (!id2.isReferencedIdentifier() && // isReferencedIdentifier is broken and returns false for reassignments
            id.parent.type !== "AssignmentExpression") {
              return;
            }
            const binding = id.scope.getBinding(id.node.name);
            if (binding != null && hoistableIdentifiers.has(binding.identifier) && (fnDepth > 0 || binding.kind === "hoisted")) {
              willHoist.add(id);
            }
          }
        });
        s.traverse({
          Identifier(path) {
            if (hoistableIdentifiers.has(path.node)) {
              hoistableIdentifiers.delete(path.node);
            }
          }
        });
        for (const id of willHoist) {
          const binding = stmt.scope.getBinding(id.node.name);
          CompilerError.invariant(binding != null, {
            reason: "Expected to find binding for hoisted identifier",
            description: `Could not find a binding for ${id.node.name}`,
            suggestions: null,
            loc: (_e = id.node.loc) != null ? _e : GeneratedSource
          });
          if (builder.environment.isHoistedIdentifier(binding.identifier)) {
            continue;
          }
          let kind;
          if (binding.kind === "const" || binding.kind === "var") {
            kind = "HoistedConst" /* HoistedConst */;
          } else if (binding.kind === "let") {
            kind = "HoistedLet" /* HoistedLet */;
          } else if (binding.path.isFunctionDeclaration()) {
            kind = "HoistedFunction" /* HoistedFunction */;
          } else if (!binding.path.isVariableDeclarator()) {
            builder.errors.push({
              severity: "Todo" /* Todo */,
              category: "Todo" /* Todo */,
              reason: "Unsupported declaration type for hoisting",
              description: `variable "${binding.identifier.name}" declared with ${binding.path.type}`,
              suggestions: null,
              loc: (_f = id.parentPath.node.loc) != null ? _f : GeneratedSource
            });
            continue;
          } else {
            builder.errors.push({
              severity: "Todo" /* Todo */,
              category: "Todo" /* Todo */,
              reason: "Handle non-const declarations for hoisting",
              description: `variable "${binding.identifier.name}" declared with ${binding.kind}`,
              suggestions: null,
              loc: (_g = id.parentPath.node.loc) != null ? _g : GeneratedSource
            });
            continue;
          }
          const identifier4 = builder.resolveIdentifier(id);
          CompilerError.invariant(identifier4.kind === "Identifier", {
            reason: "Expected hoisted binding to be a local identifier, not a global",
            loc: (_h = id.node.loc) != null ? _h : GeneratedSource
          });
          const place = {
            effect: "<unknown>" /* Unknown */,
            identifier: identifier4.identifier,
            kind: "Identifier",
            reactive: false,
            loc: (_i = id.node.loc) != null ? _i : GeneratedSource
          };
          lowerValueToTemporary(builder, {
            kind: "DeclareContext",
            lvalue: {
              kind,
              place
            },
            loc: (_j = id.node.loc) != null ? _j : GeneratedSource
          });
          builder.environment.addHoistedIdentifier(binding.identifier);
        }
        lowerStatement(builder, s);
      }
      return;
    }
    case "BreakStatement": {
      const stmt = stmtPath;
      const block = builder.lookupBreak((_l = (_k = stmt.node.label) == null ? void 0 : _k.name) != null ? _l : null);
      builder.terminate(
        {
          kind: "goto",
          block,
          variant: "Break" /* Break */,
          id: makeInstructionId(0),
          loc: (_m = stmt.node.loc) != null ? _m : GeneratedSource
        },
        "block"
      );
      return;
    }
    case "ContinueStatement": {
      const stmt = stmtPath;
      const block = builder.lookupContinue((_o = (_n = stmt.node.label) == null ? void 0 : _n.name) != null ? _o : null);
      builder.terminate(
        {
          kind: "goto",
          block,
          variant: "Continue" /* Continue */,
          id: makeInstructionId(0),
          loc: (_p = stmt.node.loc) != null ? _p : GeneratedSource
        },
        "block"
      );
      return;
    }
    case "ForStatement": {
      const stmt = stmtPath;
      const testBlock = builder.reserve("loop");
      const continuationBlock = builder.reserve("block");
      const initBlock = builder.enter("loop", (_blockId) => {
        var _a2, _b2, _c2, _d2;
        const init = stmt.get("init");
        if (!init.isVariableDeclaration()) {
          builder.errors.push({
            reason: "(BuildHIR::lowerStatement) Handle non-variable initialization in ForStatement",
            severity: "Todo" /* Todo */,
            category: "Todo" /* Todo */,
            loc: (_a2 = stmt.node.loc) != null ? _a2 : null,
            suggestions: null
          });
          return {
            kind: "unsupported",
            id: makeInstructionId(0),
            loc: (_c2 = (_b2 = init.node) == null ? void 0 : _b2.loc) != null ? _c2 : GeneratedSource
          };
        }
        lowerStatement(builder, init);
        return {
          kind: "goto",
          block: testBlock.id,
          variant: "Break" /* Break */,
          id: makeInstructionId(0),
          loc: (_d2 = init.node.loc) != null ? _d2 : GeneratedSource
        };
      });
      let updateBlock = null;
      const update2 = stmt.get("update");
      if (hasNode(update2)) {
        updateBlock = builder.enter("loop", (_blockId) => {
          var _a2, _b2;
          lowerExpressionToTemporary(builder, update2);
          return {
            kind: "goto",
            block: testBlock.id,
            variant: "Break" /* Break */,
            id: makeInstructionId(0),
            loc: (_b2 = (_a2 = update2.node) == null ? void 0 : _a2.loc) != null ? _b2 : GeneratedSource
          };
        });
      }
      const bodyBlock = builder.enter("block", (_blockId) => {
        return builder.loop(
          label,
          updateBlock != null ? updateBlock : testBlock.id,
          continuationBlock.id,
          () => {
            var _a2;
            const body = stmt.get("body");
            lowerStatement(builder, body);
            return {
              kind: "goto",
              block: updateBlock != null ? updateBlock : testBlock.id,
              variant: "Continue" /* Continue */,
              id: makeInstructionId(0),
              loc: (_a2 = body.node.loc) != null ? _a2 : GeneratedSource
            };
          }
        );
      });
      builder.terminateWithContinuation(
        {
          kind: "for",
          loc: (_q = stmtNode.loc) != null ? _q : GeneratedSource,
          init: initBlock,
          test: testBlock.id,
          update: updateBlock,
          loop: bodyBlock,
          fallthrough: continuationBlock.id,
          id: makeInstructionId(0)
        },
        testBlock
      );
      const test = stmt.get("test");
      if (test.node == null) {
        builder.errors.push({
          reason: `(BuildHIR::lowerStatement) Handle empty test in ForStatement`,
          severity: "Todo" /* Todo */,
          category: "Todo" /* Todo */,
          loc: (_r = stmt.node.loc) != null ? _r : null,
          suggestions: null
        });
      } else {
        builder.terminateWithContinuation(
          {
            kind: "branch",
            test: lowerExpressionToTemporary(
              builder,
              test
            ),
            consequent: bodyBlock,
            alternate: continuationBlock.id,
            fallthrough: continuationBlock.id,
            id: makeInstructionId(0),
            loc: (_s = stmt.node.loc) != null ? _s : GeneratedSource
          },
          continuationBlock
        );
      }
      return;
    }
    case "WhileStatement": {
      const stmt = stmtPath;
      const conditionalBlock = builder.reserve("loop");
      const continuationBlock = builder.reserve("block");
      const loopBlock = builder.enter("block", (_blockId) => {
        return builder.loop(
          label,
          conditionalBlock.id,
          continuationBlock.id,
          () => {
            var _a2;
            const body = stmt.get("body");
            lowerStatement(builder, body);
            return {
              kind: "goto",
              block: conditionalBlock.id,
              variant: "Continue" /* Continue */,
              id: makeInstructionId(0),
              loc: (_a2 = body.node.loc) != null ? _a2 : GeneratedSource
            };
          }
        );
      });
      const loc = (_t = stmt.node.loc) != null ? _t : GeneratedSource;
      builder.terminateWithContinuation(
        {
          kind: "while",
          loc,
          test: conditionalBlock.id,
          loop: loopBlock,
          fallthrough: continuationBlock.id,
          id: makeInstructionId(0)
        },
        conditionalBlock
      );
      const test = lowerExpressionToTemporary(builder, stmt.get("test"));
      const terminal = {
        kind: "branch",
        test,
        consequent: loopBlock,
        alternate: continuationBlock.id,
        fallthrough: conditionalBlock.id,
        id: makeInstructionId(0),
        loc: (_u = stmt.node.loc) != null ? _u : GeneratedSource
      };
      builder.terminateWithContinuation(terminal, continuationBlock);
      return;
    }
    case "LabeledStatement": {
      const stmt = stmtPath;
      const label2 = stmt.node.label.name;
      const body = stmt.get("body");
      switch (body.node.type) {
        case "ForInStatement":
        case "ForOfStatement":
        case "ForStatement":
        case "WhileStatement":
        case "DoWhileStatement": {
          lowerStatement(builder, stmt.get("body"), label2);
          break;
        }
        default: {
          const continuationBlock = builder.reserve("block");
          const block = builder.enter("block", () => {
            var _a2;
            const body2 = stmt.get("body");
            builder.label(label2, continuationBlock.id, () => {
              lowerStatement(builder, body2);
            });
            return {
              kind: "goto",
              block: continuationBlock.id,
              variant: "Break" /* Break */,
              id: makeInstructionId(0),
              loc: (_a2 = body2.node.loc) != null ? _a2 : GeneratedSource
            };
          });
          builder.terminateWithContinuation(
            {
              kind: "label",
              block,
              fallthrough: continuationBlock.id,
              id: makeInstructionId(0),
              loc: (_v = stmt.node.loc) != null ? _v : GeneratedSource
            },
            continuationBlock
          );
        }
      }
      return;
    }
    case "SwitchStatement": {
      const stmt = stmtPath;
      const continuationBlock = builder.reserve("block");
      let fallthrough = continuationBlock.id;
      const cases = [];
      let hasDefault = false;
      for (let ii = stmt.get("cases").length - 1; ii >= 0; ii--) {
        const case_ = stmt.get("cases")[ii];
        const testExpr = case_.get("test");
        if (testExpr.node == null) {
          if (hasDefault) {
            builder.errors.push({
              reason: `Expected at most one \`default\` branch in a switch statement, this code should have failed to parse`,
              severity: "InvalidJS" /* InvalidJS */,
              category: "Syntax" /* Syntax */,
              loc: (_w = case_.node.loc) != null ? _w : null,
              suggestions: null
            });
            break;
          }
          hasDefault = true;
        }
        const block = builder.enter("block", (_blockId) => {
          return builder.switch(label, continuationBlock.id, () => {
            var _a2;
            case_.get("consequent").forEach((consequent) => lowerStatement(builder, consequent));
            return {
              kind: "goto",
              block: fallthrough,
              variant: "Break" /* Break */,
              id: makeInstructionId(0),
              loc: (_a2 = case_.node.loc) != null ? _a2 : GeneratedSource
            };
          });
        });
        let test2 = null;
        if (hasNode(testExpr)) {
          test2 = lowerReorderableExpression(builder, testExpr);
        }
        cases.push({
          test: test2,
          block
        });
        fallthrough = block;
      }
      cases.reverse();
      if (!hasDefault) {
        cases.push({ test: null, block: continuationBlock.id });
      }
      const test = lowerExpressionToTemporary(
        builder,
        stmt.get("discriminant")
      );
      builder.terminateWithContinuation(
        {
          kind: "switch",
          test,
          cases,
          fallthrough: continuationBlock.id,
          id: makeInstructionId(0),
          loc: (_x = stmt.node.loc) != null ? _x : GeneratedSource
        },
        continuationBlock
      );
      return;
    }
    case "VariableDeclaration": {
      const stmt = stmtPath;
      const nodeKind = stmt.node.kind;
      if (nodeKind === "var") {
        builder.errors.push({
          reason: `(BuildHIR::lowerStatement) Handle ${nodeKind} kinds in VariableDeclaration`,
          severity: "Todo" /* Todo */,
          category: "Todo" /* Todo */,
          loc: (_y = stmt.node.loc) != null ? _y : null,
          suggestions: null
        });
        return;
      }
      const kind = nodeKind === "let" ? "Let" /* Let */ : "Const" /* Const */;
      for (const declaration of stmt.get("declarations")) {
        const id = declaration.get("id");
        const init = declaration.get("init");
        if (hasNode(init)) {
          const value = lowerExpressionToTemporary(builder, init);
          lowerAssignment(
            builder,
            (_z = stmt.node.loc) != null ? _z : GeneratedSource,
            kind,
            id,
            value,
            id.isObjectPattern() || id.isArrayPattern() ? "Destructure" : "Assignment"
          );
        } else if (id.isIdentifier()) {
          const binding = builder.resolveIdentifier(id);
          if (binding.kind !== "Identifier") {
            builder.errors.push({
              reason: `(BuildHIR::lowerAssignment) Could not find binding for declaration.`,
              severity: "Invariant" /* Invariant */,
              category: "Invariant" /* Invariant */,
              loc: (_A = id.node.loc) != null ? _A : null,
              suggestions: null
            });
          } else {
            const place = {
              effect: "<unknown>" /* Unknown */,
              identifier: binding.identifier,
              kind: "Identifier",
              reactive: false,
              loc: (_B = id.node.loc) != null ? _B : GeneratedSource
            };
            if (builder.isContextIdentifier(id)) {
              if (kind === "Const" /* Const */) {
                const declRangeStart = declaration.parentPath.node.start;
                builder.errors.push({
                  reason: `Expect \`const\` declaration not to be reassigned`,
                  severity: "InvalidJS" /* InvalidJS */,
                  category: "Syntax" /* Syntax */,
                  loc: (_C = id.node.loc) != null ? _C : null,
                  suggestions: [
                    {
                      description: "Change to a `let` declaration",
                      op: 3 /* Replace */,
                      range: [declRangeStart, declRangeStart + 5],
                      // "const".length
                      text: "let"
                    }
                  ]
                });
              }
              lowerValueToTemporary(builder, {
                kind: "DeclareContext",
                lvalue: {
                  kind: "Let" /* Let */,
                  place
                },
                loc: (_D = id.node.loc) != null ? _D : GeneratedSource
              });
            } else {
              const typeAnnotation2 = id.get("typeAnnotation");
              let type;
              if (typeAnnotation2.isTSTypeAnnotation()) {
                const typePath = typeAnnotation2.get("typeAnnotation");
                type = typePath.node;
              } else if (typeAnnotation2.isTypeAnnotation()) {
                const typePath = typeAnnotation2.get("typeAnnotation");
                type = typePath.node;
              } else {
                type = null;
              }
              lowerValueToTemporary(builder, {
                kind: "DeclareLocal",
                lvalue: {
                  kind,
                  place
                },
                type,
                loc: (_E = id.node.loc) != null ? _E : GeneratedSource
              });
            }
          }
        } else {
          builder.errors.push({
            reason: `Expected variable declaration to be an identifier if no initializer was provided`,
            description: `Got a \`${id.type}\``,
            severity: "InvalidJS" /* InvalidJS */,
            category: "Syntax" /* Syntax */,
            loc: (_F = stmt.node.loc) != null ? _F : null,
            suggestions: null
          });
        }
      }
      return;
    }
    case "ExpressionStatement": {
      const stmt = stmtPath;
      const expression = stmt.get("expression");
      lowerExpressionToTemporary(builder, expression);
      return;
    }
    case "DoWhileStatement": {
      const stmt = stmtPath;
      const conditionalBlock = builder.reserve("loop");
      const continuationBlock = builder.reserve("block");
      const loopBlock = builder.enter("block", (_loopBlockId) => {
        return builder.loop(
          label,
          conditionalBlock.id,
          continuationBlock.id,
          () => {
            var _a2;
            const body = stmt.get("body");
            lowerStatement(builder, body);
            return {
              kind: "goto",
              block: conditionalBlock.id,
              variant: "Continue" /* Continue */,
              id: makeInstructionId(0),
              loc: (_a2 = body.node.loc) != null ? _a2 : GeneratedSource
            };
          }
        );
      });
      const loc = (_G = stmt.node.loc) != null ? _G : GeneratedSource;
      builder.terminateWithContinuation(
        {
          kind: "do-while",
          loc,
          test: conditionalBlock.id,
          loop: loopBlock,
          fallthrough: continuationBlock.id,
          id: makeInstructionId(0)
        },
        conditionalBlock
      );
      const test = lowerExpressionToTemporary(builder, stmt.get("test"));
      const terminal = {
        kind: "branch",
        test,
        consequent: loopBlock,
        alternate: continuationBlock.id,
        fallthrough: conditionalBlock.id,
        id: makeInstructionId(0),
        loc
      };
      builder.terminateWithContinuation(terminal, continuationBlock);
      return;
    }
    case "FunctionDeclaration": {
      const stmt = stmtPath;
      stmt.skip();
      CompilerError.invariant(stmt.get("id").type === "Identifier", {
        reason: "function declarations must have a name",
        description: null,
        loc: (_H = stmt.node.loc) != null ? _H : null,
        suggestions: null
      });
      const id = stmt.get("id");
      const fn = lowerValueToTemporary(
        builder,
        lowerFunctionToValue(builder, stmt)
      );
      lowerAssignment(
        builder,
        (_I = stmt.node.loc) != null ? _I : GeneratedSource,
        "Function" /* Function */,
        id,
        fn,
        "Assignment"
      );
      return;
    }
    case "ForOfStatement": {
      const stmt = stmtPath;
      const continuationBlock = builder.reserve("block");
      const initBlock = builder.reserve("loop");
      const testBlock = builder.reserve("loop");
      if (stmt.node.await) {
        builder.errors.push({
          reason: `(BuildHIR::lowerStatement) Handle for-await loops`,
          severity: "Todo" /* Todo */,
          category: "Todo" /* Todo */,
          loc: (_J = stmt.node.loc) != null ? _J : null,
          suggestions: null
        });
        return;
      }
      const loopBlock = builder.enter("block", (_blockId) => {
        return builder.loop(label, initBlock.id, continuationBlock.id, () => {
          var _a2;
          const body = stmt.get("body");
          lowerStatement(builder, body);
          return {
            kind: "goto",
            block: initBlock.id,
            variant: "Continue" /* Continue */,
            id: makeInstructionId(0),
            loc: (_a2 = body.node.loc) != null ? _a2 : GeneratedSource
          };
        });
      });
      const loc = (_K = stmt.node.loc) != null ? _K : GeneratedSource;
      const value = lowerExpressionToTemporary(builder, stmt.get("right"));
      builder.terminateWithContinuation(
        {
          kind: "for-of",
          loc,
          init: initBlock.id,
          test: testBlock.id,
          loop: loopBlock,
          fallthrough: continuationBlock.id,
          id: makeInstructionId(0)
        },
        initBlock
      );
      const iterator = lowerValueToTemporary(builder, {
        kind: "GetIterator",
        loc: value.loc,
        collection: __spreadValues({}, value)
      });
      builder.terminateWithContinuation(
        {
          id: makeInstructionId(0),
          kind: "goto",
          block: testBlock.id,
          variant: "Break" /* Break */,
          loc: (_L = stmt.node.loc) != null ? _L : GeneratedSource
        },
        testBlock
      );
      const left = stmt.get("left");
      const leftLoc = (_M = left.node.loc) != null ? _M : GeneratedSource;
      let test;
      const advanceIterator = lowerValueToTemporary(builder, {
        kind: "IteratorNext",
        loc: leftLoc,
        iterator: __spreadValues({}, iterator),
        collection: __spreadValues({}, value)
      });
      if (left.isVariableDeclaration()) {
        const declarations = left.get("declarations");
        CompilerError.invariant(declarations.length === 1, {
          reason: `Expected only one declaration in the init of a ForOfStatement, got ${declarations.length}`,
          description: null,
          loc: (_N = left.node.loc) != null ? _N : null,
          suggestions: null
        });
        const id = declarations[0].get("id");
        const assign = lowerAssignment(
          builder,
          leftLoc,
          "Let" /* Let */,
          id,
          advanceIterator,
          "Assignment"
        );
        test = lowerValueToTemporary(builder, assign);
      } else {
        CompilerError.invariant(left.isLVal(), {
          loc: leftLoc,
          reason: "Expected ForOf init to be a variable declaration or lval"
        });
        const assign = lowerAssignment(
          builder,
          leftLoc,
          "Reassign" /* Reassign */,
          left,
          advanceIterator,
          "Assignment"
        );
        test = lowerValueToTemporary(builder, assign);
      }
      builder.terminateWithContinuation(
        {
          id: makeInstructionId(0),
          kind: "branch",
          test,
          consequent: loopBlock,
          alternate: continuationBlock.id,
          loc: (_O = stmt.node.loc) != null ? _O : GeneratedSource,
          fallthrough: continuationBlock.id
        },
        continuationBlock
      );
      return;
    }
    case "ForInStatement": {
      const stmt = stmtPath;
      const continuationBlock = builder.reserve("block");
      const initBlock = builder.reserve("loop");
      const loopBlock = builder.enter("block", (_blockId) => {
        return builder.loop(label, initBlock.id, continuationBlock.id, () => {
          var _a2;
          const body = stmt.get("body");
          lowerStatement(builder, body);
          return {
            kind: "goto",
            block: initBlock.id,
            variant: "Continue" /* Continue */,
            id: makeInstructionId(0),
            loc: (_a2 = body.node.loc) != null ? _a2 : GeneratedSource
          };
        });
      });
      const loc = (_P = stmt.node.loc) != null ? _P : GeneratedSource;
      const value = lowerExpressionToTemporary(builder, stmt.get("right"));
      builder.terminateWithContinuation(
        {
          kind: "for-in",
          loc,
          init: initBlock.id,
          loop: loopBlock,
          fallthrough: continuationBlock.id,
          id: makeInstructionId(0)
        },
        initBlock
      );
      const left = stmt.get("left");
      const leftLoc = (_Q = left.node.loc) != null ? _Q : GeneratedSource;
      let test;
      const nextPropertyTemp = lowerValueToTemporary(builder, {
        kind: "NextPropertyOf",
        loc: leftLoc,
        value
      });
      if (left.isVariableDeclaration()) {
        const declarations = left.get("declarations");
        CompilerError.invariant(declarations.length === 1, {
          reason: `Expected only one declaration in the init of a ForInStatement, got ${declarations.length}`,
          description: null,
          loc: (_R = left.node.loc) != null ? _R : null,
          suggestions: null
        });
        const id = declarations[0].get("id");
        const assign = lowerAssignment(
          builder,
          leftLoc,
          "Let" /* Let */,
          id,
          nextPropertyTemp,
          "Assignment"
        );
        test = lowerValueToTemporary(builder, assign);
      } else {
        CompilerError.invariant(left.isLVal(), {
          loc: leftLoc,
          reason: "Expected ForIn init to be a variable declaration or lval"
        });
        const assign = lowerAssignment(
          builder,
          leftLoc,
          "Reassign" /* Reassign */,
          left,
          nextPropertyTemp,
          "Assignment"
        );
        test = lowerValueToTemporary(builder, assign);
      }
      builder.terminateWithContinuation(
        {
          id: makeInstructionId(0),
          kind: "branch",
          test,
          consequent: loopBlock,
          alternate: continuationBlock.id,
          fallthrough: continuationBlock.id,
          loc: (_S = stmt.node.loc) != null ? _S : GeneratedSource
        },
        continuationBlock
      );
      return;
    }
    case "DebuggerStatement": {
      const stmt = stmtPath;
      const loc = (_T = stmt.node.loc) != null ? _T : GeneratedSource;
      builder.push({
        id: makeInstructionId(0),
        lvalue: buildTemporaryPlace(builder, loc),
        value: {
          kind: "Debugger",
          loc
        },
        effects: null,
        loc
      });
      return;
    }
    case "EmptyStatement": {
      return;
    }
    case "TryStatement": {
      const stmt = stmtPath;
      const continuationBlock = builder.reserve("block");
      const handlerPath = stmt.get("handler");
      if (!hasNode(handlerPath)) {
        builder.errors.push({
          reason: `(BuildHIR::lowerStatement) Handle TryStatement without a catch clause`,
          severity: "Todo" /* Todo */,
          category: "Todo" /* Todo */,
          loc: (_U = stmt.node.loc) != null ? _U : null,
          suggestions: null
        });
        return;
      }
      if (hasNode(stmt.get("finalizer"))) {
        builder.errors.push({
          reason: `(BuildHIR::lowerStatement) Handle TryStatement with a finalizer ('finally') clause`,
          severity: "Todo" /* Todo */,
          category: "Todo" /* Todo */,
          loc: (_V = stmt.node.loc) != null ? _V : null,
          suggestions: null
        });
      }
      const handlerBindingPath = handlerPath.get("param");
      let handlerBinding = null;
      if (hasNode(handlerBindingPath)) {
        const place = {
          kind: "Identifier",
          identifier: builder.makeTemporary(
            (_W = handlerBindingPath.node.loc) != null ? _W : GeneratedSource
          ),
          effect: "<unknown>" /* Unknown */,
          reactive: false,
          loc: (_X = handlerBindingPath.node.loc) != null ? _X : GeneratedSource
        };
        promoteTemporary(place.identifier);
        lowerValueToTemporary(builder, {
          kind: "DeclareLocal",
          lvalue: {
            kind: "Catch" /* Catch */,
            place: __spreadValues({}, place)
          },
          type: null,
          loc: (_Y = handlerBindingPath.node.loc) != null ? _Y : GeneratedSource
        });
        handlerBinding = {
          path: handlerBindingPath,
          place
        };
      }
      const handler = builder.enter("catch", (_blockId) => {
        var _a2, _b2;
        if (handlerBinding !== null) {
          lowerAssignment(
            builder,
            (_a2 = handlerBinding.path.node.loc) != null ? _a2 : GeneratedSource,
            "Catch" /* Catch */,
            handlerBinding.path,
            __spreadValues({}, handlerBinding.place),
            "Assignment"
          );
        }
        lowerStatement(builder, handlerPath.get("body"));
        return {
          kind: "goto",
          block: continuationBlock.id,
          variant: "Break" /* Break */,
          id: makeInstructionId(0),
          loc: (_b2 = handlerPath.node.loc) != null ? _b2 : GeneratedSource
        };
      });
      const block = builder.enter("block", (_blockId) => {
        var _a2;
        const block2 = stmt.get("block");
        builder.enterTryCatch(handler, () => {
          lowerStatement(builder, block2);
        });
        return {
          kind: "goto",
          block: continuationBlock.id,
          variant: "Try" /* Try */,
          id: makeInstructionId(0),
          loc: (_a2 = block2.node.loc) != null ? _a2 : GeneratedSource
        };
      });
      builder.terminateWithContinuation(
        {
          kind: "try",
          block,
          handlerBinding: handlerBinding !== null ? __spreadValues({}, handlerBinding.place) : null,
          handler,
          fallthrough: continuationBlock.id,
          id: makeInstructionId(0),
          loc: (_Z = stmt.node.loc) != null ? _Z : GeneratedSource
        },
        continuationBlock
      );
      return;
    }
    case "WithStatement": {
      builder.errors.push({
        reason: `JavaScript 'with' syntax is not supported`,
        description: `'with' syntax is considered deprecated and removed from JavaScript standards, consider alternatives`,
        severity: "UnsupportedJS" /* UnsupportedJS */,
        category: "UnsupportedSyntax" /* UnsupportedSyntax */,
        loc: (__ = stmtPath.node.loc) != null ? __ : null,
        suggestions: null
      });
      lowerValueToTemporary(builder, {
        kind: "UnsupportedNode",
        loc: (_$ = stmtPath.node.loc) != null ? _$ : GeneratedSource,
        node: stmtPath.node
      });
      return;
    }
    case "ClassDeclaration": {
      builder.errors.push({
        reason: "Inline `class` declarations are not supported",
        description: `Move class declarations outside of components/hooks`,
        severity: "UnsupportedJS" /* UnsupportedJS */,
        category: "UnsupportedSyntax" /* UnsupportedSyntax */,
        loc: (_aa = stmtPath.node.loc) != null ? _aa : null,
        suggestions: null
      });
      lowerValueToTemporary(builder, {
        kind: "UnsupportedNode",
        loc: (_ba = stmtPath.node.loc) != null ? _ba : GeneratedSource,
        node: stmtPath.node
      });
      return;
    }
    case "EnumDeclaration":
    case "TSEnumDeclaration": {
      lowerValueToTemporary(builder, {
        kind: "UnsupportedNode",
        loc: (_ca = stmtPath.node.loc) != null ? _ca : GeneratedSource,
        node: stmtPath.node
      });
      return;
    }
    case "ExportAllDeclaration":
    case "ExportDefaultDeclaration":
    case "ExportNamedDeclaration":
    case "ImportDeclaration":
    case "TSExportAssignment":
    case "TSImportEqualsDeclaration": {
      builder.errors.push({
        reason: "JavaScript `import` and `export` statements may only appear at the top level of a module",
        severity: "InvalidJS" /* InvalidJS */,
        category: "Syntax" /* Syntax */,
        loc: (_da = stmtPath.node.loc) != null ? _da : null,
        suggestions: null
      });
      lowerValueToTemporary(builder, {
        kind: "UnsupportedNode",
        loc: (_ea = stmtPath.node.loc) != null ? _ea : GeneratedSource,
        node: stmtPath.node
      });
      return;
    }
    case "TSNamespaceExportDeclaration": {
      builder.errors.push({
        reason: "TypeScript `namespace` statements may only appear at the top level of a module",
        severity: "InvalidJS" /* InvalidJS */,
        category: "Syntax" /* Syntax */,
        loc: (_fa = stmtPath.node.loc) != null ? _fa : null,
        suggestions: null
      });
      lowerValueToTemporary(builder, {
        kind: "UnsupportedNode",
        loc: (_ga = stmtPath.node.loc) != null ? _ga : GeneratedSource,
        node: stmtPath.node
      });
      return;
    }
    case "DeclareClass":
    case "DeclareExportAllDeclaration":
    case "DeclareExportDeclaration":
    case "DeclareFunction":
    case "DeclareInterface":
    case "DeclareModule":
    case "DeclareModuleExports":
    case "DeclareOpaqueType":
    case "DeclareTypeAlias":
    case "DeclareVariable":
    case "InterfaceDeclaration":
    case "OpaqueType":
    case "TSDeclareFunction":
    case "TSInterfaceDeclaration":
    case "TSModuleDeclaration":
    case "TSTypeAliasDeclaration":
    case "TypeAlias": {
      return;
    }
    default: {
      return assertExhaustive(
        stmtNode,
        `Unsupported statement kind '${stmtNode.type}'`
      );
    }
  }
}
function lowerObjectMethod(builder, property) {
  var _a;
  const loc = (_a = property.node.loc) != null ? _a : GeneratedSource;
  const loweredFunc = lowerFunction(builder, property);
  if (!loweredFunc) {
    return { kind: "UnsupportedNode", node: property.node, loc };
  }
  return {
    kind: "ObjectMethod",
    loc,
    loweredFunc
  };
}
function lowerObjectPropertyKey(builder, property) {
  var _a, _b;
  const key2 = property.get("key");
  if (key2.isStringLiteral()) {
    return {
      kind: "string",
      name: key2.node.value
    };
  } else if (property.node.computed && key2.isExpression()) {
    if (!key2.isIdentifier() && !key2.isMemberExpression()) {
      builder.errors.push({
        reason: `(BuildHIR::lowerExpression) Expected Identifier, got ${key2.type} key in ObjectExpression`,
        severity: "Todo" /* Todo */,
        category: "Todo" /* Todo */,
        loc: (_a = key2.node.loc) != null ? _a : null,
        suggestions: null
      });
      return null;
    }
    const place = lowerExpressionToTemporary(builder, key2);
    return {
      kind: "computed",
      name: place
    };
  } else if (key2.isIdentifier()) {
    return {
      kind: "identifier",
      name: key2.node.name
    };
  } else if (key2.isNumericLiteral()) {
    return {
      kind: "identifier",
      name: String(key2.node.value)
    };
  }
  builder.errors.push({
    reason: `(BuildHIR::lowerExpression) Expected Identifier, got ${key2.type} key in ObjectExpression`,
    severity: "Todo" /* Todo */,
    category: "Todo" /* Todo */,
    loc: (_b = key2.node.loc) != null ? _b : null,
    suggestions: null
  });
  return null;
}
function lowerExpression(builder, exprPath) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B, _C, _D, _E, _F, _G, _H, _I, _J, _K, _L, _M, _N, _O, _P, _Q, _R, _S, _T, _U, _V;
  const exprNode = exprPath.node;
  const exprLoc = (_a = exprNode.loc) != null ? _a : GeneratedSource;
  switch (exprNode.type) {
    case "Identifier": {
      const expr = exprPath;
      const place = lowerIdentifier(builder, expr);
      return {
        kind: getLoadKind(builder, expr),
        place,
        loc: exprLoc
      };
    }
    case "NullLiteral": {
      return {
        kind: "Primitive",
        value: null,
        loc: exprLoc
      };
    }
    case "BooleanLiteral":
    case "NumericLiteral":
    case "StringLiteral": {
      const expr = exprPath;
      const value = expr.node.value;
      return {
        kind: "Primitive",
        value,
        loc: exprLoc
      };
    }
    case "ObjectExpression": {
      const expr = exprPath;
      const propertyPaths = expr.get("properties");
      const properties = [];
      for (const propertyPath of propertyPaths) {
        if (propertyPath.isObjectProperty()) {
          const loweredKey = lowerObjectPropertyKey(builder, propertyPath);
          if (!loweredKey) {
            continue;
          }
          const valuePath = propertyPath.get("value");
          if (!valuePath.isExpression()) {
            builder.errors.push({
              reason: `(BuildHIR::lowerExpression) Handle ${valuePath.type} values in ObjectExpression`,
              severity: "Todo" /* Todo */,
              category: "Todo" /* Todo */,
              loc: (_b = valuePath.node.loc) != null ? _b : null,
              suggestions: null
            });
            continue;
          }
          const value = lowerExpressionToTemporary(builder, valuePath);
          properties.push({
            kind: "ObjectProperty",
            type: "property",
            place: value,
            key: loweredKey
          });
        } else if (propertyPath.isSpreadElement()) {
          const place = lowerExpressionToTemporary(
            builder,
            propertyPath.get("argument")
          );
          properties.push({
            kind: "Spread",
            place
          });
        } else if (propertyPath.isObjectMethod()) {
          if (propertyPath.node.kind !== "method") {
            builder.errors.push({
              reason: `(BuildHIR::lowerExpression) Handle ${propertyPath.node.kind} functions in ObjectExpression`,
              severity: "Todo" /* Todo */,
              category: "Todo" /* Todo */,
              loc: (_c = propertyPath.node.loc) != null ? _c : null,
              suggestions: null
            });
            continue;
          }
          const method = lowerObjectMethod(builder, propertyPath);
          const place = lowerValueToTemporary(builder, method);
          const loweredKey = lowerObjectPropertyKey(builder, propertyPath);
          if (!loweredKey) {
            continue;
          }
          properties.push({
            kind: "ObjectProperty",
            type: "method",
            place,
            key: loweredKey
          });
        } else {
          builder.errors.push({
            reason: `(BuildHIR::lowerExpression) Handle ${propertyPath.type} properties in ObjectExpression`,
            severity: "Todo" /* Todo */,
            category: "Todo" /* Todo */,
            loc: (_d = propertyPath.node.loc) != null ? _d : null,
            suggestions: null
          });
          continue;
        }
      }
      return {
        kind: "ObjectExpression",
        properties,
        loc: exprLoc
      };
    }
    case "ArrayExpression": {
      const expr = exprPath;
      let elements = [];
      for (const element of expr.get("elements")) {
        if (element.node == null) {
          elements.push({
            kind: "Hole"
          });
          continue;
        } else if (element.isExpression()) {
          elements.push(lowerExpressionToTemporary(builder, element));
        } else if (element.isSpreadElement()) {
          const place = lowerExpressionToTemporary(
            builder,
            element.get("argument")
          );
          elements.push({ kind: "Spread", place });
        } else {
          builder.errors.push({
            reason: `(BuildHIR::lowerExpression) Handle ${element.type} elements in ArrayExpression`,
            severity: "Todo" /* Todo */,
            category: "Todo" /* Todo */,
            loc: (_e = element.node.loc) != null ? _e : null,
            suggestions: null
          });
          continue;
        }
      }
      return {
        kind: "ArrayExpression",
        elements,
        loc: exprLoc
      };
    }
    case "NewExpression": {
      const expr = exprPath;
      const calleePath = expr.get("callee");
      if (!calleePath.isExpression()) {
        builder.errors.push({
          reason: `Expected an expression as the \`new\` expression receiver (v8 intrinsics are not supported)`,
          description: `Got a \`${calleePath.node.type}\``,
          severity: "InvalidJS" /* InvalidJS */,
          category: "Syntax" /* Syntax */,
          loc: (_f = calleePath.node.loc) != null ? _f : null,
          suggestions: null
        });
        return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
      }
      const callee = lowerExpressionToTemporary(builder, calleePath);
      const args = lowerArguments(builder, expr.get("arguments"));
      return {
        kind: "NewExpression",
        callee,
        args,
        loc: exprLoc
      };
    }
    case "OptionalCallExpression": {
      const expr = exprPath;
      return lowerOptionalCallExpression(builder, expr, null);
    }
    case "CallExpression": {
      const expr = exprPath;
      const calleePath = expr.get("callee");
      if (!calleePath.isExpression()) {
        builder.errors.push({
          reason: `Expected Expression, got ${calleePath.type} in CallExpression (v8 intrinsics not supported). This error is likely caused by a bug in React Compiler. Please file an issue`,
          severity: "Todo" /* Todo */,
          category: "Todo" /* Todo */,
          loc: (_g = calleePath.node.loc) != null ? _g : null,
          suggestions: null
        });
        return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
      }
      if (calleePath.isMemberExpression()) {
        const memberExpr = lowerMemberExpression(builder, calleePath);
        const propertyPlace = lowerValueToTemporary(builder, memberExpr.value);
        const args = lowerArguments(builder, expr.get("arguments"));
        return {
          kind: "MethodCall",
          receiver: memberExpr.object,
          property: __spreadValues({}, propertyPlace),
          args,
          loc: exprLoc
        };
      } else {
        const callee = lowerExpressionToTemporary(builder, calleePath);
        const args = lowerArguments(builder, expr.get("arguments"));
        return {
          kind: "CallExpression",
          callee,
          args,
          loc: exprLoc
        };
      }
    }
    case "BinaryExpression": {
      const expr = exprPath;
      const leftPath = expr.get("left");
      if (!leftPath.isExpression()) {
        builder.errors.push({
          reason: `(BuildHIR::lowerExpression) Expected Expression, got ${leftPath.type} lval in BinaryExpression`,
          severity: "Todo" /* Todo */,
          category: "Todo" /* Todo */,
          loc: (_h = leftPath.node.loc) != null ? _h : null,
          suggestions: null
        });
        return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
      }
      const left = lowerExpressionToTemporary(builder, leftPath);
      const right = lowerExpressionToTemporary(builder, expr.get("right"));
      const operator = expr.node.operator;
      if (operator === "|>") {
        builder.errors.push({
          reason: `(BuildHIR::lowerExpression) Pipe operator not supported`,
          severity: "Todo" /* Todo */,
          category: "Todo" /* Todo */,
          loc: (_i = leftPath.node.loc) != null ? _i : null,
          suggestions: null
        });
        return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
      }
      return {
        kind: "BinaryExpression",
        operator,
        left,
        right,
        loc: exprLoc
      };
    }
    case "SequenceExpression": {
      const expr = exprPath;
      const exprLoc2 = (_j = expr.node.loc) != null ? _j : GeneratedSource;
      const continuationBlock = builder.reserve(builder.currentBlockKind());
      const place = buildTemporaryPlace(builder, exprLoc2);
      const sequenceBlock = builder.enter("sequence", (_) => {
        var _a2;
        let last = null;
        for (const item of expr.get("expressions")) {
          last = lowerExpressionToTemporary(builder, item);
        }
        if (last === null) {
          builder.errors.push({
            reason: `Expected sequence expression to have at least one expression`,
            severity: "InvalidJS" /* InvalidJS */,
            category: "Syntax" /* Syntax */,
            loc: (_a2 = expr.node.loc) != null ? _a2 : null,
            suggestions: null
          });
        } else {
          lowerValueToTemporary(builder, {
            kind: "StoreLocal",
            lvalue: { kind: "Const" /* Const */, place: __spreadValues({}, place) },
            value: last,
            type: null,
            loc: exprLoc2
          });
        }
        return {
          kind: "goto",
          id: makeInstructionId(0),
          block: continuationBlock.id,
          loc: exprLoc2,
          variant: "Break" /* Break */
        };
      });
      builder.terminateWithContinuation(
        {
          kind: "sequence",
          block: sequenceBlock,
          fallthrough: continuationBlock.id,
          id: makeInstructionId(0),
          loc: exprLoc2
        },
        continuationBlock
      );
      return { kind: "LoadLocal", place, loc: place.loc };
    }
    case "ConditionalExpression": {
      const expr = exprPath;
      const exprLoc2 = (_k = expr.node.loc) != null ? _k : GeneratedSource;
      const continuationBlock = builder.reserve(builder.currentBlockKind());
      const testBlock = builder.reserve("value");
      const place = buildTemporaryPlace(builder, exprLoc2);
      const consequentBlock = builder.enter("value", (_blockId) => {
        var _a2;
        const consequentPath = expr.get("consequent");
        const consequent = lowerExpressionToTemporary(builder, consequentPath);
        lowerValueToTemporary(builder, {
          kind: "StoreLocal",
          lvalue: { kind: "Const" /* Const */, place: __spreadValues({}, place) },
          value: consequent,
          type: null,
          loc: exprLoc2
        });
        return {
          kind: "goto",
          block: continuationBlock.id,
          variant: "Break" /* Break */,
          id: makeInstructionId(0),
          loc: (_a2 = consequentPath.node.loc) != null ? _a2 : GeneratedSource
        };
      });
      const alternateBlock = builder.enter("value", (_blockId) => {
        var _a2;
        const alternatePath = expr.get("alternate");
        const alternate = lowerExpressionToTemporary(builder, alternatePath);
        lowerValueToTemporary(builder, {
          kind: "StoreLocal",
          lvalue: { kind: "Const" /* Const */, place: __spreadValues({}, place) },
          value: alternate,
          type: null,
          loc: exprLoc2
        });
        return {
          kind: "goto",
          block: continuationBlock.id,
          variant: "Break" /* Break */,
          id: makeInstructionId(0),
          loc: (_a2 = alternatePath.node.loc) != null ? _a2 : GeneratedSource
        };
      });
      builder.terminateWithContinuation(
        {
          kind: "ternary",
          fallthrough: continuationBlock.id,
          id: makeInstructionId(0),
          test: testBlock.id,
          loc: exprLoc2
        },
        testBlock
      );
      const testPlace = lowerExpressionToTemporary(builder, expr.get("test"));
      builder.terminateWithContinuation(
        {
          kind: "branch",
          test: __spreadValues({}, testPlace),
          consequent: consequentBlock,
          alternate: alternateBlock,
          fallthrough: continuationBlock.id,
          id: makeInstructionId(0),
          loc: exprLoc2
        },
        continuationBlock
      );
      return { kind: "LoadLocal", place, loc: place.loc };
    }
    case "LogicalExpression": {
      const expr = exprPath;
      const exprLoc2 = (_l = expr.node.loc) != null ? _l : GeneratedSource;
      const continuationBlock = builder.reserve(builder.currentBlockKind());
      const testBlock = builder.reserve("value");
      const place = buildTemporaryPlace(builder, exprLoc2);
      const leftPlace = buildTemporaryPlace(
        builder,
        (_m = expr.get("left").node.loc) != null ? _m : GeneratedSource
      );
      const consequent = builder.enter("value", () => {
        lowerValueToTemporary(builder, {
          kind: "StoreLocal",
          lvalue: { kind: "Const" /* Const */, place: __spreadValues({}, place) },
          value: __spreadValues({}, leftPlace),
          type: null,
          loc: leftPlace.loc
        });
        return {
          kind: "goto",
          block: continuationBlock.id,
          variant: "Break" /* Break */,
          id: makeInstructionId(0),
          loc: leftPlace.loc
        };
      });
      const alternate = builder.enter("value", () => {
        const right = lowerExpressionToTemporary(builder, expr.get("right"));
        lowerValueToTemporary(builder, {
          kind: "StoreLocal",
          lvalue: { kind: "Const" /* Const */, place: __spreadValues({}, place) },
          value: __spreadValues({}, right),
          type: null,
          loc: right.loc
        });
        return {
          kind: "goto",
          block: continuationBlock.id,
          variant: "Break" /* Break */,
          id: makeInstructionId(0),
          loc: right.loc
        };
      });
      builder.terminateWithContinuation(
        {
          kind: "logical",
          fallthrough: continuationBlock.id,
          id: makeInstructionId(0),
          test: testBlock.id,
          operator: expr.node.operator,
          loc: exprLoc2
        },
        testBlock
      );
      const leftValue = lowerExpressionToTemporary(builder, expr.get("left"));
      builder.push({
        id: makeInstructionId(0),
        lvalue: __spreadValues({}, leftPlace),
        value: {
          kind: "LoadLocal",
          place: leftValue,
          loc: exprLoc2
        },
        effects: null,
        loc: exprLoc2
      });
      builder.terminateWithContinuation(
        {
          kind: "branch",
          test: __spreadValues({}, leftPlace),
          consequent,
          alternate,
          fallthrough: continuationBlock.id,
          id: makeInstructionId(0),
          loc: exprLoc2
        },
        continuationBlock
      );
      return { kind: "LoadLocal", place, loc: place.loc };
    }
    case "AssignmentExpression": {
      const expr = exprPath;
      const operator = expr.node.operator;
      if (operator === "=") {
        const left2 = expr.get("left");
        if (left2.isLVal()) {
          return lowerAssignment(
            builder,
            (_n = left2.node.loc) != null ? _n : GeneratedSource,
            "Reassign" /* Reassign */,
            left2,
            lowerExpressionToTemporary(builder, expr.get("right")),
            left2.isArrayPattern() || left2.isObjectPattern() ? "Destructure" : "Assignment"
          );
        } else {
          builder.errors.push({
            reason: `(BuildHIR::lowerExpression) Unsupported syntax on the left side of an AssignmentExpression`,
            description: `Expected an LVal, got: ${left2.type}`,
            severity: "Todo" /* Todo */,
            category: "Todo" /* Todo */,
            loc: (_o = left2.node.loc) != null ? _o : null,
            suggestions: null
          });
          return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
        }
      }
      const operators = {
        "+=": "+",
        "-=": "-",
        "/=": "/",
        "%=": "%",
        "*=": "*",
        "**=": "**",
        "&=": "&",
        "|=": "|",
        ">>=": ">>",
        ">>>=": ">>>",
        "<<=": "<<",
        "^=": "^"
      };
      const binaryOperator = operators[operator];
      if (binaryOperator == null) {
        builder.errors.push({
          reason: `(BuildHIR::lowerExpression) Handle ${operator} operators in AssignmentExpression`,
          severity: "Todo" /* Todo */,
          category: "Todo" /* Todo */,
          loc: (_p = expr.node.loc) != null ? _p : null,
          suggestions: null
        });
        return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
      }
      const left = expr.get("left");
      const leftNode = left.node;
      switch (leftNode.type) {
        case "Identifier": {
          const leftExpr = left;
          const leftPlace = lowerExpressionToTemporary(builder, leftExpr);
          const right = lowerExpressionToTemporary(builder, expr.get("right"));
          const binaryPlace = lowerValueToTemporary(builder, {
            kind: "BinaryExpression",
            operator: binaryOperator,
            left: leftPlace,
            right,
            loc: exprLoc
          });
          const binding = builder.resolveIdentifier(leftExpr);
          if (binding.kind === "Identifier") {
            const identifier4 = lowerIdentifier(builder, leftExpr);
            const kind = getStoreKind(builder, leftExpr);
            if (kind === "StoreLocal") {
              lowerValueToTemporary(builder, {
                kind: "StoreLocal",
                lvalue: {
                  place: __spreadValues({}, identifier4),
                  kind: "Reassign" /* Reassign */
                },
                value: __spreadValues({}, binaryPlace),
                type: null,
                loc: exprLoc
              });
              return { kind: "LoadLocal", place: identifier4, loc: exprLoc };
            } else {
              lowerValueToTemporary(builder, {
                kind: "StoreContext",
                lvalue: {
                  place: __spreadValues({}, identifier4),
                  kind: "Reassign" /* Reassign */
                },
                value: __spreadValues({}, binaryPlace),
                loc: exprLoc
              });
              return { kind: "LoadContext", place: identifier4, loc: exprLoc };
            }
          } else {
            const temporary = lowerValueToTemporary(builder, {
              kind: "StoreGlobal",
              name: leftExpr.node.name,
              value: __spreadValues({}, binaryPlace),
              loc: exprLoc
            });
            return { kind: "LoadLocal", place: temporary, loc: temporary.loc };
          }
        }
        case "MemberExpression": {
          const leftExpr = left;
          const { object, property, value } = lowerMemberExpression(
            builder,
            leftExpr
          );
          const previousValuePlace = lowerValueToTemporary(builder, value);
          const newValuePlace = lowerValueToTemporary(builder, {
            kind: "BinaryExpression",
            operator: binaryOperator,
            left: __spreadValues({}, previousValuePlace),
            right: lowerExpressionToTemporary(builder, expr.get("right")),
            loc: (_q = leftExpr.node.loc) != null ? _q : GeneratedSource
          });
          if (typeof property === "string" || typeof property === "number") {
            return {
              kind: "PropertyStore",
              object: __spreadValues({}, object),
              property: makePropertyLiteral(property),
              value: __spreadValues({}, newValuePlace),
              loc: (_r = leftExpr.node.loc) != null ? _r : GeneratedSource
            };
          } else {
            return {
              kind: "ComputedStore",
              object: __spreadValues({}, object),
              property: __spreadValues({}, property),
              value: __spreadValues({}, newValuePlace),
              loc: (_s = leftExpr.node.loc) != null ? _s : GeneratedSource
            };
          }
        }
        default: {
          builder.errors.push({
            reason: `(BuildHIR::lowerExpression) Expected Identifier or MemberExpression, got ${expr.type} lval in AssignmentExpression`,
            severity: "Todo" /* Todo */,
            category: "Todo" /* Todo */,
            loc: (_t = expr.node.loc) != null ? _t : null,
            suggestions: null
          });
          return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
        }
      }
    }
    case "OptionalMemberExpression": {
      const expr = exprPath;
      const { value } = lowerOptionalMemberExpression(builder, expr, null);
      return { kind: "LoadLocal", place: value, loc: value.loc };
    }
    case "MemberExpression": {
      const expr = exprPath;
      const { value } = lowerMemberExpression(builder, expr);
      const place = lowerValueToTemporary(builder, value);
      return { kind: "LoadLocal", place, loc: place.loc };
    }
    case "JSXElement": {
      const expr = exprPath;
      const opening = expr.get("openingElement");
      const openingLoc = (_u = opening.node.loc) != null ? _u : GeneratedSource;
      const tag = lowerJsxElementName(builder, opening.get("name"));
      const props = [];
      for (const attribute of opening.get("attributes")) {
        if (attribute.isJSXSpreadAttribute()) {
          const argument = lowerExpressionToTemporary(
            builder,
            attribute.get("argument")
          );
          props.push({ kind: "JsxSpreadAttribute", argument });
          continue;
        }
        if (!attribute.isJSXAttribute()) {
          builder.errors.push({
            reason: `(BuildHIR::lowerExpression) Handle ${attribute.type} attributes in JSXElement`,
            severity: "Todo" /* Todo */,
            category: "Todo" /* Todo */,
            loc: (_v = attribute.node.loc) != null ? _v : null,
            suggestions: null
          });
          continue;
        }
        const namePath = attribute.get("name");
        let propName;
        if (namePath.isJSXIdentifier()) {
          propName = namePath.node.name;
          if (propName.indexOf(":") !== -1) {
            builder.errors.push({
              reason: `(BuildHIR::lowerExpression) Unexpected colon in attribute name \`${propName}\``,
              severity: "Todo" /* Todo */,
              category: "Todo" /* Todo */,
              loc: (_w = namePath.node.loc) != null ? _w : null,
              suggestions: null
            });
          }
        } else {
          CompilerError.invariant(namePath.isJSXNamespacedName(), {
            reason: "Refinement",
            description: null,
            loc: (_x = namePath.node.loc) != null ? _x : null,
            suggestions: null
          });
          const namespace = namePath.node.namespace.name;
          const name = namePath.node.name.name;
          propName = `${namespace}:${name}`;
        }
        const valueExpr = attribute.get("value");
        let value;
        if (valueExpr.isJSXElement() || valueExpr.isStringLiteral()) {
          value = lowerExpressionToTemporary(builder, valueExpr);
        } else if (valueExpr.type == null) {
          value = lowerValueToTemporary(builder, {
            kind: "Primitive",
            value: true,
            loc: (_y = attribute.node.loc) != null ? _y : GeneratedSource
          });
        } else {
          if (!valueExpr.isJSXExpressionContainer()) {
            builder.errors.push({
              reason: `(BuildHIR::lowerExpression) Handle ${valueExpr.type} attribute values in JSXElement`,
              severity: "Todo" /* Todo */,
              category: "Todo" /* Todo */,
              loc: (_A = (_z = valueExpr.node) == null ? void 0 : _z.loc) != null ? _A : null,
              suggestions: null
            });
            continue;
          }
          const expression = valueExpr.get("expression");
          if (!expression.isExpression()) {
            builder.errors.push({
              reason: `(BuildHIR::lowerExpression) Handle ${expression.type} expressions in JSXExpressionContainer within JSXElement`,
              severity: "Todo" /* Todo */,
              category: "Todo" /* Todo */,
              loc: (_B = valueExpr.node.loc) != null ? _B : null,
              suggestions: null
            });
            continue;
          }
          value = lowerExpressionToTemporary(builder, expression);
        }
        props.push({ kind: "JsxAttribute", name: propName, place: value });
      }
      const isFbt = tag.kind === "BuiltinTag" && (tag.name === "fbt" || tag.name === "fbs");
      if (isFbt) {
        const tagName = tag.name;
        const openingIdentifier = opening.get("name");
        const tagIdentifier = openingIdentifier.isJSXIdentifier() ? builder.resolveIdentifier(openingIdentifier) : null;
        if (tagIdentifier != null) {
          CompilerError.invariant(tagIdentifier.kind !== "Identifier", {
            reason: `<${tagName}> tags should be module-level imports`,
            loc: (_C = openingIdentifier.node.loc) != null ? _C : GeneratedSource,
            description: null,
            suggestions: null
          });
        }
        const fbtLocations = {
          enum: new Array(),
          plural: new Array(),
          pronoun: new Array()
        };
        expr.traverse({
          JSXClosingElement(path) {
            path.skip();
          },
          JSXNamespacedName(path) {
            var _a2, _b2, _c2;
            if (path.node.namespace.name === tagName) {
              switch (path.node.name.name) {
                case "enum":
                  fbtLocations.enum.push((_a2 = path.node.loc) != null ? _a2 : GeneratedSource);
                  break;
                case "plural":
                  fbtLocations.plural.push((_b2 = path.node.loc) != null ? _b2 : GeneratedSource);
                  break;
                case "pronoun":
                  fbtLocations.pronoun.push((_c2 = path.node.loc) != null ? _c2 : GeneratedSource);
                  break;
              }
            }
          }
        });
        for (const [name, locations] of Object.entries(fbtLocations)) {
          if (locations.length > 1) {
            CompilerError.throwDiagnostic({
              severity: "Todo" /* Todo */,
              category: "FBT" /* FBT */,
              reason: "Support duplicate fbt tags",
              description: `Support \`<${tagName}>\` tags with multiple \`<${tagName}:${name}>\` values`,
              details: locations.map((loc) => {
                return {
                  kind: "error",
                  message: `Multiple \`<${tagName}:${name}>\` tags found`,
                  loc
                };
              })
            });
          }
        }
      }
      isFbt && builder.fbtDepth++;
      const children = expr.get("children").map((child) => lowerJsxElement(builder, child)).filter(notNull);
      isFbt && builder.fbtDepth--;
      return {
        kind: "JsxExpression",
        tag,
        props,
        children: children.length === 0 ? null : children,
        loc: exprLoc,
        openingLoc,
        closingLoc: (_E = (_D = expr.get("closingElement").node) == null ? void 0 : _D.loc) != null ? _E : GeneratedSource
      };
    }
    case "JSXFragment": {
      const expr = exprPath;
      const children = expr.get("children").map((child) => lowerJsxElement(builder, child)).filter(notNull);
      return {
        kind: "JsxFragment",
        children,
        loc: exprLoc
      };
    }
    case "ArrowFunctionExpression":
    case "FunctionExpression": {
      const expr = exprPath;
      return lowerFunctionToValue(builder, expr);
    }
    case "TaggedTemplateExpression": {
      const expr = exprPath;
      if (expr.get("quasi").get("expressions").length !== 0) {
        builder.errors.push({
          reason: "(BuildHIR::lowerExpression) Handle tagged template with interpolations",
          severity: "Todo" /* Todo */,
          category: "Todo" /* Todo */,
          loc: (_F = exprPath.node.loc) != null ? _F : null,
          suggestions: null
        });
        return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
      }
      CompilerError.invariant(expr.get("quasi").get("quasis").length == 1, {
        reason: "there should be only one quasi as we don't support interpolations yet",
        description: null,
        loc: (_G = expr.node.loc) != null ? _G : null,
        suggestions: null
      });
      const value = expr.get("quasi").get("quasis").at(0).node.value;
      if (value.raw !== value.cooked) {
        builder.errors.push({
          reason: "(BuildHIR::lowerExpression) Handle tagged template where cooked value is different from raw value",
          severity: "Todo" /* Todo */,
          category: "Todo" /* Todo */,
          loc: (_H = exprPath.node.loc) != null ? _H : null,
          suggestions: null
        });
        return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
      }
      return {
        kind: "TaggedTemplateExpression",
        tag: lowerExpressionToTemporary(builder, expr.get("tag")),
        value,
        loc: exprLoc
      };
    }
    case "TemplateLiteral": {
      const expr = exprPath;
      const subexprs = expr.get("expressions");
      const quasis = expr.get("quasis");
      if (subexprs.length !== quasis.length - 1) {
        builder.errors.push({
          reason: `Unexpected quasi and subexpression lengths in template literal`,
          severity: "InvalidJS" /* InvalidJS */,
          category: "Syntax" /* Syntax */,
          loc: (_I = exprPath.node.loc) != null ? _I : null,
          suggestions: null
        });
        return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
      }
      if (subexprs.some((e) => !e.isExpression())) {
        builder.errors.push({
          reason: `(BuildHIR::lowerAssignment) Handle TSType in TemplateLiteral.`,
          severity: "Todo" /* Todo */,
          category: "Todo" /* Todo */,
          loc: (_J = exprPath.node.loc) != null ? _J : null,
          suggestions: null
        });
        return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
      }
      const subexprPlaces = subexprs.map(
        (e) => lowerExpressionToTemporary(builder, e)
      );
      return {
        kind: "TemplateLiteral",
        subexprs: subexprPlaces,
        quasis: expr.get("quasis").map((q) => q.node.value),
        loc: exprLoc
      };
    }
    case "UnaryExpression": {
      let expr = exprPath;
      if (expr.node.operator === "delete") {
        const argument = expr.get("argument");
        if (argument.isMemberExpression()) {
          const { object, property } = lowerMemberExpression(builder, argument);
          if (typeof property === "string" || typeof property === "number") {
            return {
              kind: "PropertyDelete",
              object,
              property: makePropertyLiteral(property),
              loc: exprLoc
            };
          } else {
            return {
              kind: "ComputedDelete",
              object,
              property,
              loc: exprLoc
            };
          }
        } else {
          builder.errors.push({
            reason: `Only object properties can be deleted`,
            severity: "InvalidJS" /* InvalidJS */,
            category: "Syntax" /* Syntax */,
            loc: (_K = expr.node.loc) != null ? _K : null,
            suggestions: [
              {
                description: "Remove this line",
                range: [expr.node.start, expr.node.end],
                op: 2 /* Remove */
              }
            ]
          });
          return { kind: "UnsupportedNode", node: expr.node, loc: exprLoc };
        }
      } else if (expr.node.operator === "throw") {
        builder.errors.push({
          reason: `Throw expressions are not supported`,
          severity: "InvalidJS" /* InvalidJS */,
          category: "Syntax" /* Syntax */,
          loc: (_L = expr.node.loc) != null ? _L : null,
          suggestions: [
            {
              description: "Remove this line",
              range: [expr.node.start, expr.node.end],
              op: 2 /* Remove */
            }
          ]
        });
        return { kind: "UnsupportedNode", node: expr.node, loc: exprLoc };
      } else {
        return {
          kind: "UnaryExpression",
          operator: expr.node.operator,
          value: lowerExpressionToTemporary(builder, expr.get("argument")),
          loc: exprLoc
        };
      }
    }
    case "AwaitExpression": {
      let expr = exprPath;
      return {
        kind: "Await",
        value: lowerExpressionToTemporary(builder, expr.get("argument")),
        loc: exprLoc
      };
    }
    case "TypeCastExpression": {
      let expr = exprPath;
      const typeAnnotation2 = expr.get("typeAnnotation").get("typeAnnotation");
      return {
        kind: "TypeCastExpression",
        value: lowerExpressionToTemporary(builder, expr.get("expression")),
        typeAnnotation: typeAnnotation2.node,
        typeAnnotationKind: "cast",
        type: lowerType(typeAnnotation2.node),
        loc: exprLoc
      };
    }
    case "TSSatisfiesExpression": {
      let expr = exprPath;
      const typeAnnotation2 = expr.get("typeAnnotation");
      return {
        kind: "TypeCastExpression",
        value: lowerExpressionToTemporary(builder, expr.get("expression")),
        typeAnnotation: typeAnnotation2.node,
        typeAnnotationKind: "satisfies",
        type: lowerType(typeAnnotation2.node),
        loc: exprLoc
      };
    }
    case "TSAsExpression": {
      let expr = exprPath;
      const typeAnnotation2 = expr.get("typeAnnotation");
      return {
        kind: "TypeCastExpression",
        value: lowerExpressionToTemporary(builder, expr.get("expression")),
        typeAnnotation: typeAnnotation2.node,
        typeAnnotationKind: "as",
        type: lowerType(typeAnnotation2.node),
        loc: exprLoc
      };
    }
    case "UpdateExpression": {
      let expr = exprPath;
      const argument = expr.get("argument");
      if (argument.isMemberExpression()) {
        const binaryOperator = expr.node.operator === "++" ? "+" : "-";
        const leftExpr = argument;
        const { object, property, value: value2 } = lowerMemberExpression(
          builder,
          leftExpr
        );
        const previousValuePlace = lowerValueToTemporary(builder, value2);
        const updatedValue = lowerValueToTemporary(builder, {
          kind: "BinaryExpression",
          operator: binaryOperator,
          left: __spreadValues({}, previousValuePlace),
          right: lowerValueToTemporary(builder, {
            kind: "Primitive",
            value: 1,
            loc: GeneratedSource
          }),
          loc: (_M = leftExpr.node.loc) != null ? _M : GeneratedSource
        });
        let newValuePlace;
        if (typeof property === "string" || typeof property === "number") {
          newValuePlace = lowerValueToTemporary(builder, {
            kind: "PropertyStore",
            object: __spreadValues({}, object),
            property: makePropertyLiteral(property),
            value: __spreadValues({}, updatedValue),
            loc: (_N = leftExpr.node.loc) != null ? _N : GeneratedSource
          });
        } else {
          newValuePlace = lowerValueToTemporary(builder, {
            kind: "ComputedStore",
            object: __spreadValues({}, object),
            property: __spreadValues({}, property),
            value: __spreadValues({}, updatedValue),
            loc: (_O = leftExpr.node.loc) != null ? _O : GeneratedSource
          });
        }
        return {
          kind: "LoadLocal",
          place: expr.node.prefix ? __spreadValues({}, newValuePlace) : __spreadValues({}, previousValuePlace),
          loc: exprLoc
        };
      }
      if (!argument.isIdentifier()) {
        builder.errors.push({
          reason: `(BuildHIR::lowerExpression) Handle UpdateExpression with ${argument.type} argument`,
          severity: "Todo" /* Todo */,
          category: "Todo" /* Todo */,
          loc: (_P = exprPath.node.loc) != null ? _P : null,
          suggestions: null
        });
        return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
      } else if (builder.isContextIdentifier(argument)) {
        builder.errors.push({
          reason: `(BuildHIR::lowerExpression) Handle UpdateExpression to variables captured within lambdas.`,
          severity: "Todo" /* Todo */,
          category: "Todo" /* Todo */,
          loc: (_Q = exprPath.node.loc) != null ? _Q : null,
          suggestions: null
        });
        return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
      }
      const lvalue = lowerIdentifierForAssignment(
        builder,
        (_R = argument.node.loc) != null ? _R : GeneratedSource,
        "Reassign" /* Reassign */,
        argument
      );
      if (lvalue === null) {
        if (!builder.errors.hasErrors()) {
          builder.errors.push({
            reason: `(BuildHIR::lowerExpression) Found an invalid UpdateExpression without a previously reported error`,
            severity: "Invariant" /* Invariant */,
            category: "Invariant" /* Invariant */,
            loc: exprLoc,
            suggestions: null
          });
        }
        return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
      } else if (lvalue.kind === "Global") {
        builder.errors.push({
          reason: `(BuildHIR::lowerExpression) Support UpdateExpression where argument is a global`,
          severity: "Todo" /* Todo */,
          category: "Todo" /* Todo */,
          loc: exprLoc,
          suggestions: null
        });
        return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
      }
      const value = lowerIdentifier(builder, argument);
      if (expr.node.prefix) {
        return {
          kind: "PrefixUpdate",
          lvalue,
          operation: expr.node.operator,
          value,
          loc: exprLoc
        };
      } else {
        return {
          kind: "PostfixUpdate",
          lvalue,
          operation: expr.node.operator,
          value,
          loc: exprLoc
        };
      }
    }
    case "RegExpLiteral": {
      let expr = exprPath;
      return {
        kind: "RegExpLiteral",
        pattern: expr.node.pattern,
        flags: expr.node.flags,
        loc: (_S = expr.node.loc) != null ? _S : GeneratedSource
      };
    }
    case "TSInstantiationExpression":
    case "TSNonNullExpression": {
      let expr = exprPath;
      return lowerExpression(builder, expr.get("expression"));
    }
    case "MetaProperty": {
      let expr = exprPath;
      if (expr.node.meta.name === "import" && expr.node.property.name === "meta") {
        return {
          kind: "MetaProperty",
          meta: expr.node.meta.name,
          property: expr.node.property.name,
          loc: (_T = expr.node.loc) != null ? _T : GeneratedSource
        };
      }
      builder.errors.push({
        reason: `(BuildHIR::lowerExpression) Handle MetaProperty expressions other than import.meta`,
        severity: "Todo" /* Todo */,
        category: "Todo" /* Todo */,
        loc: (_U = exprPath.node.loc) != null ? _U : null,
        suggestions: null
      });
      return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
    }
    default: {
      builder.errors.push({
        reason: `(BuildHIR::lowerExpression) Handle ${exprPath.type} expressions`,
        severity: "Todo" /* Todo */,
        category: "Todo" /* Todo */,
        loc: (_V = exprPath.node.loc) != null ? _V : null,
        suggestions: null
      });
      return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
    }
  }
}
function lowerOptionalMemberExpression(builder, expr, parentAlternate) {
  var _a;
  const optional = expr.node.optional;
  const loc = (_a = expr.node.loc) != null ? _a : GeneratedSource;
  const place = buildTemporaryPlace(builder, loc);
  const continuationBlock = builder.reserve(builder.currentBlockKind());
  const consequent = builder.reserve("value");
  const alternate = parentAlternate !== null ? parentAlternate : builder.enter("value", () => {
    const temp = lowerValueToTemporary(builder, {
      kind: "Primitive",
      value: void 0,
      loc
    });
    lowerValueToTemporary(builder, {
      kind: "StoreLocal",
      lvalue: { kind: "Const" /* Const */, place: __spreadValues({}, place) },
      value: __spreadValues({}, temp),
      type: null,
      loc
    });
    return {
      kind: "goto",
      variant: "Break" /* Break */,
      block: continuationBlock.id,
      id: makeInstructionId(0),
      loc
    };
  });
  let object = null;
  const testBlock = builder.enter("value", () => {
    const objectPath = expr.get("object");
    if (objectPath.isOptionalMemberExpression()) {
      const { value } = lowerOptionalMemberExpression(
        builder,
        objectPath,
        alternate
      );
      object = value;
    } else if (objectPath.isOptionalCallExpression()) {
      const value = lowerOptionalCallExpression(builder, objectPath, alternate);
      object = lowerValueToTemporary(builder, value);
    } else {
      object = lowerExpressionToTemporary(builder, objectPath);
    }
    return {
      kind: "branch",
      test: __spreadValues({}, object),
      consequent: consequent.id,
      alternate,
      fallthrough: continuationBlock.id,
      id: makeInstructionId(0),
      loc
    };
  });
  CompilerError.invariant(object !== null, {
    reason: "Satisfy type checker",
    description: null,
    loc: null,
    suggestions: null
  });
  builder.enterReserved(consequent, () => {
    const { value } = lowerMemberExpression(builder, expr, object);
    const temp = lowerValueToTemporary(builder, value);
    lowerValueToTemporary(builder, {
      kind: "StoreLocal",
      lvalue: { kind: "Const" /* Const */, place: __spreadValues({}, place) },
      value: __spreadValues({}, temp),
      type: null,
      loc
    });
    return {
      kind: "goto",
      variant: "Break" /* Break */,
      block: continuationBlock.id,
      id: makeInstructionId(0),
      loc
    };
  });
  builder.terminateWithContinuation(
    {
      kind: "optional",
      optional,
      test: testBlock,
      fallthrough: continuationBlock.id,
      id: makeInstructionId(0),
      loc
    },
    continuationBlock
  );
  return { object, value: place };
}
function lowerOptionalCallExpression(builder, expr, parentAlternate) {
  var _a;
  const optional = expr.node.optional;
  const calleePath = expr.get("callee");
  const loc = (_a = expr.node.loc) != null ? _a : GeneratedSource;
  const place = buildTemporaryPlace(builder, loc);
  const continuationBlock = builder.reserve(builder.currentBlockKind());
  const consequent = builder.reserve("value");
  const alternate = parentAlternate !== null ? parentAlternate : builder.enter("value", () => {
    const temp = lowerValueToTemporary(builder, {
      kind: "Primitive",
      value: void 0,
      loc
    });
    lowerValueToTemporary(builder, {
      kind: "StoreLocal",
      lvalue: { kind: "Const" /* Const */, place: __spreadValues({}, place) },
      value: __spreadValues({}, temp),
      type: null,
      loc
    });
    return {
      kind: "goto",
      variant: "Break" /* Break */,
      block: continuationBlock.id,
      id: makeInstructionId(0),
      loc
    };
  });
  let callee;
  const testBlock = builder.enter("value", () => {
    if (calleePath.isOptionalCallExpression()) {
      const value = lowerOptionalCallExpression(builder, calleePath, alternate);
      const valuePlace = lowerValueToTemporary(builder, value);
      callee = {
        kind: "CallExpression",
        callee: valuePlace
      };
    } else if (calleePath.isOptionalMemberExpression()) {
      const { object, value } = lowerOptionalMemberExpression(
        builder,
        calleePath,
        alternate
      );
      callee = {
        kind: "MethodCall",
        receiver: object,
        property: value
      };
    } else if (calleePath.isMemberExpression()) {
      const memberExpr = lowerMemberExpression(builder, calleePath);
      const propertyPlace = lowerValueToTemporary(builder, memberExpr.value);
      callee = {
        kind: "MethodCall",
        receiver: memberExpr.object,
        property: propertyPlace
      };
    } else {
      callee = {
        kind: "CallExpression",
        callee: lowerExpressionToTemporary(builder, calleePath)
      };
    }
    const testPlace = callee.kind === "CallExpression" ? callee.callee : callee.property;
    return {
      kind: "branch",
      test: __spreadValues({}, testPlace),
      consequent: consequent.id,
      alternate,
      fallthrough: continuationBlock.id,
      id: makeInstructionId(0),
      loc
    };
  });
  builder.enterReserved(consequent, () => {
    const args = lowerArguments(builder, expr.get("arguments"));
    const temp = buildTemporaryPlace(builder, loc);
    if (callee.kind === "CallExpression") {
      builder.push({
        id: makeInstructionId(0),
        lvalue: __spreadValues({}, temp),
        value: {
          kind: "CallExpression",
          callee: __spreadValues({}, callee.callee),
          args,
          loc
        },
        effects: null,
        loc
      });
    } else {
      builder.push({
        id: makeInstructionId(0),
        lvalue: __spreadValues({}, temp),
        value: {
          kind: "MethodCall",
          receiver: __spreadValues({}, callee.receiver),
          property: __spreadValues({}, callee.property),
          args,
          loc
        },
        effects: null,
        loc
      });
    }
    lowerValueToTemporary(builder, {
      kind: "StoreLocal",
      lvalue: { kind: "Const" /* Const */, place: __spreadValues({}, place) },
      value: __spreadValues({}, temp),
      type: null,
      loc
    });
    return {
      kind: "goto",
      variant: "Break" /* Break */,
      block: continuationBlock.id,
      id: makeInstructionId(0),
      loc
    };
  });
  builder.terminateWithContinuation(
    {
      kind: "optional",
      optional,
      test: testBlock,
      fallthrough: continuationBlock.id,
      id: makeInstructionId(0),
      loc
    },
    continuationBlock
  );
  return { kind: "LoadLocal", place, loc: place.loc };
}
function lowerReorderableExpression(builder, expr) {
  var _a;
  if (!isReorderableExpression(builder, expr, true)) {
    builder.errors.push({
      reason: `(BuildHIR::node.lowerReorderableExpression) Expression type \`${expr.type}\` cannot be safely reordered`,
      severity: "Todo" /* Todo */,
      category: "Todo" /* Todo */,
      loc: (_a = expr.node.loc) != null ? _a : null,
      suggestions: null
    });
  }
  return lowerExpressionToTemporary(builder, expr);
}
function isReorderableExpression(builder, expr, allowLocalIdentifiers) {
  switch (expr.node.type) {
    case "Identifier": {
      const binding = builder.resolveIdentifier(expr);
      if (binding.kind === "Identifier") {
        return allowLocalIdentifiers;
      } else {
        return true;
      }
    }
    case "RegExpLiteral":
    case "StringLiteral":
    case "NumericLiteral":
    case "NullLiteral":
    case "BooleanLiteral":
    case "BigIntLiteral": {
      return true;
    }
    case "UnaryExpression": {
      const unary = expr;
      switch (expr.node.operator) {
        case "!":
        case "+":
        case "-": {
          return isReorderableExpression(
            builder,
            unary.get("argument"),
            allowLocalIdentifiers
          );
        }
        default: {
          return false;
        }
      }
    }
    case "TSAsExpression":
    case "TSNonNullExpression":
    case "TypeCastExpression": {
      return isReorderableExpression(
        builder,
        expr.get("expression"),
        allowLocalIdentifiers
      );
    }
    case "LogicalExpression": {
      const logical = expr;
      return isReorderableExpression(
        builder,
        logical.get("left"),
        allowLocalIdentifiers
      ) && isReorderableExpression(
        builder,
        logical.get("right"),
        allowLocalIdentifiers
      );
    }
    case "ConditionalExpression": {
      const conditional = expr;
      return isReorderableExpression(
        builder,
        conditional.get("test"),
        allowLocalIdentifiers
      ) && isReorderableExpression(
        builder,
        conditional.get("consequent"),
        allowLocalIdentifiers
      ) && isReorderableExpression(
        builder,
        conditional.get("alternate"),
        allowLocalIdentifiers
      );
    }
    case "ArrayExpression": {
      return expr.get("elements").every(
        (element) => element.isExpression() && isReorderableExpression(builder, element, allowLocalIdentifiers)
      );
    }
    case "ObjectExpression": {
      return expr.get("properties").every((property) => {
        if (!property.isObjectProperty() || property.node.computed) {
          return false;
        }
        const value = property.get("value");
        return value.isExpression() && isReorderableExpression(builder, value, allowLocalIdentifiers);
      });
    }
    case "MemberExpression": {
      const test = expr;
      let innerObject = test;
      while (innerObject.isMemberExpression()) {
        innerObject = innerObject.get("object");
      }
      if (innerObject.isIdentifier() && builder.resolveIdentifier(innerObject).kind !== "Identifier") {
        return true;
      } else {
        return false;
      }
    }
    case "ArrowFunctionExpression": {
      const fn = expr;
      const body = fn.get("body");
      if (body.node.type === "BlockStatement") {
        return body.node.body.length === 0;
      } else {
        (0, import_invariant2.default)(body.isExpression(), "Expected an expression");
        return isReorderableExpression(
          builder,
          body,
          /* disallow local identifiers in the body */
          false
        );
      }
    }
    case "CallExpression": {
      const call = expr;
      const callee = call.get("callee");
      return callee.isExpression() && isReorderableExpression(builder, callee, allowLocalIdentifiers) && call.get("arguments").every(
        (arg) => arg.isExpression() && isReorderableExpression(builder, arg, allowLocalIdentifiers)
      );
    }
    default: {
      return false;
    }
  }
}
function lowerArguments(builder, expr) {
  var _a;
  let args = [];
  for (const argPath of expr) {
    if (argPath.isSpreadElement()) {
      args.push({
        kind: "Spread",
        place: lowerExpressionToTemporary(builder, argPath.get("argument"))
      });
    } else if (argPath.isExpression()) {
      args.push(lowerExpressionToTemporary(builder, argPath));
    } else {
      builder.errors.push({
        reason: `(BuildHIR::lowerExpression) Handle ${argPath.type} arguments in CallExpression`,
        severity: "Todo" /* Todo */,
        category: "Todo" /* Todo */,
        loc: (_a = argPath.node.loc) != null ? _a : null,
        suggestions: null
      });
    }
  }
  return args;
}
function lowerMemberExpression(builder, expr, loweredObject = null) {
  var _a, _b, _c;
  const exprNode = expr.node;
  const exprLoc = (_a = exprNode.loc) != null ? _a : GeneratedSource;
  const objectNode = expr.get("object");
  const propertyNode = expr.get("property");
  const object = loweredObject != null ? loweredObject : lowerExpressionToTemporary(builder, objectNode);
  if (!expr.node.computed || expr.node.property.type === "NumericLiteral") {
    let property;
    if (propertyNode.isIdentifier()) {
      property = makePropertyLiteral(propertyNode.node.name);
    } else if (propertyNode.isNumericLiteral()) {
      property = makePropertyLiteral(propertyNode.node.value);
    } else {
      builder.errors.push({
        reason: `(BuildHIR::lowerMemberExpression) Handle ${propertyNode.type} property`,
        severity: "Todo" /* Todo */,
        category: "Todo" /* Todo */,
        loc: (_b = propertyNode.node.loc) != null ? _b : null,
        suggestions: null
      });
      return {
        object,
        property: propertyNode.toString(),
        value: { kind: "UnsupportedNode", node: exprNode, loc: exprLoc }
      };
    }
    const value = {
      kind: "PropertyLoad",
      object: __spreadValues({}, object),
      property,
      loc: exprLoc
    };
    return { object, property, value };
  } else {
    if (!propertyNode.isExpression()) {
      builder.errors.push({
        reason: `(BuildHIR::lowerMemberExpression) Expected Expression, got ${propertyNode.type} property`,
        severity: "Todo" /* Todo */,
        category: "Todo" /* Todo */,
        loc: (_c = propertyNode.node.loc) != null ? _c : null,
        suggestions: null
      });
      return {
        object,
        property: propertyNode.toString(),
        value: {
          kind: "UnsupportedNode",
          node: exprNode,
          loc: exprLoc
        }
      };
    }
    const property = lowerExpressionToTemporary(builder, propertyNode);
    const value = {
      kind: "ComputedLoad",
      object: __spreadValues({}, object),
      property: __spreadValues({}, property),
      loc: exprLoc
    };
    return { object, property, value };
  }
}
function lowerJsxElementName(builder, exprPath) {
  var _a, _b, _c;
  const exprNode = exprPath.node;
  const exprLoc = (_a = exprNode.loc) != null ? _a : GeneratedSource;
  if (exprPath.isJSXIdentifier()) {
    const tag = exprPath.node.name;
    if (tag.match(/^[A-Z]/)) {
      const kind = getLoadKind(builder, exprPath);
      return lowerValueToTemporary(builder, {
        kind,
        place: lowerIdentifier(builder, exprPath),
        loc: exprLoc
      });
    } else {
      return {
        kind: "BuiltinTag",
        name: tag,
        loc: exprLoc
      };
    }
  } else if (exprPath.isJSXMemberExpression()) {
    return lowerJsxMemberExpression(builder, exprPath);
  } else if (exprPath.isJSXNamespacedName()) {
    const namespace = exprPath.node.namespace.name;
    const name = exprPath.node.name.name;
    const tag = `${namespace}:${name}`;
    if (namespace.indexOf(":") !== -1 || name.indexOf(":") !== -1) {
      builder.errors.push({
        reason: `Expected JSXNamespacedName to have no colons in the namespace or name`,
        description: `Got \`${namespace}\` : \`${name}\``,
        severity: "InvalidJS" /* InvalidJS */,
        category: "Syntax" /* Syntax */,
        loc: (_b = exprPath.node.loc) != null ? _b : null,
        suggestions: null
      });
    }
    const place = lowerValueToTemporary(builder, {
      kind: "Primitive",
      value: tag,
      loc: exprLoc
    });
    return place;
  } else {
    builder.errors.push({
      reason: `(BuildHIR::lowerJsxElementName) Handle ${exprPath.type} tags`,
      severity: "Todo" /* Todo */,
      category: "Todo" /* Todo */,
      loc: (_c = exprPath.node.loc) != null ? _c : null,
      suggestions: null
    });
    return lowerValueToTemporary(builder, {
      kind: "UnsupportedNode",
      node: exprNode,
      loc: exprLoc
    });
  }
}
function lowerJsxMemberExpression(builder, exprPath) {
  var _a, _b, _c;
  const loc = (_a = exprPath.node.loc) != null ? _a : GeneratedSource;
  const object = exprPath.get("object");
  let objectPlace;
  if (object.isJSXMemberExpression()) {
    objectPlace = lowerJsxMemberExpression(builder, object);
  } else {
    CompilerError.invariant(object.isJSXIdentifier(), {
      reason: `TypeScript refinement fail: expected 'JsxIdentifier', got \`${object.node.type}\``,
      description: null,
      loc: (_b = object.node.loc) != null ? _b : null,
      suggestions: null
    });
    const kind = getLoadKind(builder, object);
    objectPlace = lowerValueToTemporary(builder, {
      kind,
      place: lowerIdentifier(builder, object),
      loc: (_c = exprPath.node.loc) != null ? _c : GeneratedSource
    });
  }
  const property = exprPath.get("property").node.name;
  return lowerValueToTemporary(builder, {
    kind: "PropertyLoad",
    object: objectPlace,
    property: makePropertyLiteral(property),
    loc
  });
}
function lowerJsxElement(builder, exprPath) {
  var _a, _b, _c;
  const exprNode = exprPath.node;
  const exprLoc = (_a = exprNode.loc) != null ? _a : GeneratedSource;
  if (exprPath.isJSXElement() || exprPath.isJSXFragment()) {
    return lowerExpressionToTemporary(builder, exprPath);
  } else if (exprPath.isJSXExpressionContainer()) {
    const expression = exprPath.get("expression");
    if (expression.isJSXEmptyExpression()) {
      return null;
    } else {
      CompilerError.invariant(expression.isExpression(), {
        reason: `(BuildHIR::lowerJsxElement) Expected Expression but found ${expression.type}!`,
        description: null,
        loc: (_b = expression.node.loc) != null ? _b : null,
        suggestions: null
      });
      return lowerExpressionToTemporary(builder, expression);
    }
  } else if (exprPath.isJSXText()) {
    let text;
    if (builder.fbtDepth > 0) {
      text = exprPath.node.value;
    } else {
      text = trimJsxText(exprPath.node.value);
    }
    if (text === null) {
      return null;
    }
    const place = lowerValueToTemporary(builder, {
      kind: "JSXText",
      value: text,
      loc: exprLoc
    });
    return place;
  } else {
    builder.errors.push({
      reason: `(BuildHIR::lowerJsxElement) Unhandled JsxElement, got: ${exprPath.type}`,
      severity: "Todo" /* Todo */,
      category: "Todo" /* Todo */,
      loc: (_c = exprPath.node.loc) != null ? _c : null,
      suggestions: null
    });
    const place = lowerValueToTemporary(builder, {
      kind: "UnsupportedNode",
      node: exprNode,
      loc: exprLoc
    });
    return place;
  }
}
function trimJsxText(original) {
  const lines = original.split(/\r\n|\n|\r/);
  let lastNonEmptyLine = 0;
  for (let i = 0; i < lines.length; i++) {
    if (lines[i].match(/[^ \t]/)) {
      lastNonEmptyLine = i;
    }
  }
  let str = "";
  for (let i = 0; i < lines.length; i++) {
    const line2 = lines[i];
    const isFirstLine = i === 0;
    const isLastLine = i === lines.length - 1;
    const isLastNonEmptyLine = i === lastNonEmptyLine;
    let trimmedLine = line2.replace(/\t/g, " ");
    if (!isFirstLine) {
      trimmedLine = trimmedLine.replace(/^[ ]+/, "");
    }
    if (!isLastLine) {
      trimmedLine = trimmedLine.replace(/[ ]+$/, "");
    }
    if (trimmedLine) {
      if (!isLastNonEmptyLine) {
        trimmedLine += " ";
      }
      str += trimmedLine;
    }
  }
  if (str.length !== 0) {
    return str;
  } else {
    return null;
  }
}
function lowerFunctionToValue(builder, expr) {
  var _a, _b, _c, _d;
  const exprNode = expr.node;
  const exprLoc = (_a = exprNode.loc) != null ? _a : GeneratedSource;
  let name = null;
  if (expr.isFunctionExpression()) {
    name = (_d = (_c = (_b = expr.get("id")) == null ? void 0 : _b.node) == null ? void 0 : _c.name) != null ? _d : null;
  }
  const loweredFunc = lowerFunction(builder, expr);
  if (!loweredFunc) {
    return { kind: "UnsupportedNode", node: exprNode, loc: exprLoc };
  }
  return {
    kind: "FunctionExpression",
    name,
    type: expr.node.type,
    loc: exprLoc,
    loweredFunc
  };
}
function lowerFunction(builder, expr) {
  const componentScope = builder.environment.parentFunction.scope;
  const capturedContext = gatherCapturedContext(expr, componentScope);
  const lowering = lower(
    expr,
    builder.environment,
    builder.bindings,
    new Map([...builder.context, ...capturedContext])
  );
  let loweredFunc;
  if (lowering.isErr()) {
    const functionErrors = lowering.unwrapErr();
    builder.errors.merge(functionErrors);
    return null;
  }
  loweredFunc = lowering.unwrap();
  return {
    func: loweredFunc
  };
}
function lowerExpressionToTemporary(builder, exprPath) {
  const value = lowerExpression(builder, exprPath);
  return lowerValueToTemporary(builder, value);
}
function lowerValueToTemporary(builder, value) {
  if (value.kind === "LoadLocal" && value.place.identifier.name === null) {
    return value.place;
  }
  const place = buildTemporaryPlace(builder, value.loc);
  builder.push({
    id: makeInstructionId(0),
    lvalue: __spreadValues({}, place),
    value,
    effects: null,
    loc: value.loc
  });
  return place;
}
function lowerIdentifier(builder, exprPath) {
  var _a, _b;
  const exprNode = exprPath.node;
  const exprLoc = (_a = exprNode.loc) != null ? _a : GeneratedSource;
  const binding = builder.resolveIdentifier(exprPath);
  switch (binding.kind) {
    case "Identifier": {
      const place = {
        kind: "Identifier",
        identifier: binding.identifier,
        effect: "<unknown>" /* Unknown */,
        reactive: false,
        loc: exprLoc
      };
      return place;
    }
    default: {
      if (binding.kind === "Global" && binding.name === "eval") {
        builder.errors.push({
          reason: `The 'eval' function is not supported`,
          description: "Eval is an anti-pattern in JavaScript, and the code executed cannot be evaluated by React Compiler",
          severity: "UnsupportedJS" /* UnsupportedJS */,
          category: "UnsupportedSyntax" /* UnsupportedSyntax */,
          loc: (_b = exprPath.node.loc) != null ? _b : null,
          suggestions: null
        });
      }
      return lowerValueToTemporary(builder, {
        kind: "LoadGlobal",
        binding,
        loc: exprLoc
      });
    }
  }
}
function buildTemporaryPlace(builder, loc) {
  const place = {
    kind: "Identifier",
    identifier: builder.makeTemporary(loc),
    effect: "<unknown>" /* Unknown */,
    reactive: false,
    loc
  };
  return place;
}
function getStoreKind(builder, identifier4) {
  const isContext = builder.isContextIdentifier(identifier4);
  return isContext ? "StoreContext" : "StoreLocal";
}
function getLoadKind(builder, identifier4) {
  const isContext = builder.isContextIdentifier(identifier4);
  return isContext ? "LoadContext" : "LoadLocal";
}
function lowerIdentifierForAssignment(builder, loc, kind, path) {
  var _a, _b;
  const binding = builder.resolveIdentifier(path);
  if (binding.kind !== "Identifier") {
    if (kind === "Reassign" /* Reassign */) {
      return { kind: "Global", name: path.node.name };
    } else {
      builder.errors.push({
        reason: `(BuildHIR::lowerAssignment) Could not find binding for declaration.`,
        severity: "Invariant" /* Invariant */,
        category: "Invariant" /* Invariant */,
        loc: (_a = path.node.loc) != null ? _a : null,
        suggestions: null
      });
      return null;
    }
  } else if (binding.bindingKind === "const" && kind === "Reassign" /* Reassign */) {
    builder.errors.push({
      reason: `Cannot reassign a \`const\` variable`,
      severity: "InvalidJS" /* InvalidJS */,
      category: "Syntax" /* Syntax */,
      loc: (_b = path.node.loc) != null ? _b : null,
      description: binding.identifier.name != null ? `\`${binding.identifier.name.value}\` is declared as const` : null
    });
    return null;
  }
  const place = {
    kind: "Identifier",
    identifier: binding.identifier,
    effect: "<unknown>" /* Unknown */,
    reactive: false,
    loc
  };
  return place;
}
function lowerAssignment(builder, loc, kind, lvaluePath, value, assignmentKind) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A;
  const lvalueNode = lvaluePath.node;
  switch (lvalueNode.type) {
    case "Identifier": {
      const lvalue = lvaluePath;
      const place = lowerIdentifierForAssignment(builder, loc, kind, lvalue);
      if (place === null) {
        return {
          kind: "UnsupportedNode",
          loc: (_a = lvalue.node.loc) != null ? _a : GeneratedSource,
          node: lvalue.node
        };
      } else if (place.kind === "Global") {
        const temporary2 = lowerValueToTemporary(builder, {
          kind: "StoreGlobal",
          name: place.name,
          value,
          loc
        });
        return { kind: "LoadLocal", place: temporary2, loc: temporary2.loc };
      }
      const isHoistedIdentifier = builder.environment.isHoistedIdentifier(
        lvalue.node
      );
      let temporary;
      if (builder.isContextIdentifier(lvalue)) {
        if (kind === "Const" /* Const */ && !isHoistedIdentifier) {
          builder.errors.push({
            reason: `Expected \`const\` declaration not to be reassigned`,
            severity: "InvalidJS" /* InvalidJS */,
            category: "Syntax" /* Syntax */,
            loc: (_b = lvalue.node.loc) != null ? _b : null,
            suggestions: null
          });
        }
        if (kind !== "Const" /* Const */ && kind !== "Reassign" /* Reassign */ && kind !== "Let" /* Let */ && kind !== "Function" /* Function */) {
          builder.errors.push({
            reason: `Unexpected context variable kind`,
            severity: "InvalidJS" /* InvalidJS */,
            category: "Syntax" /* Syntax */,
            loc: (_c = lvalue.node.loc) != null ? _c : null,
            suggestions: null
          });
          temporary = lowerValueToTemporary(builder, {
            kind: "UnsupportedNode",
            node: lvalueNode,
            loc: (_d = lvalueNode.loc) != null ? _d : GeneratedSource
          });
        } else {
          temporary = lowerValueToTemporary(builder, {
            kind: "StoreContext",
            lvalue: { place: __spreadValues({}, place), kind },
            value,
            loc
          });
        }
      } else {
        const typeAnnotation2 = lvalue.get("typeAnnotation");
        let type;
        if (typeAnnotation2.isTSTypeAnnotation()) {
          const typePath = typeAnnotation2.get("typeAnnotation");
          type = typePath.node;
        } else if (typeAnnotation2.isTypeAnnotation()) {
          const typePath = typeAnnotation2.get("typeAnnotation");
          type = typePath.node;
        } else {
          type = null;
        }
        temporary = lowerValueToTemporary(builder, {
          kind: "StoreLocal",
          lvalue: { place: __spreadValues({}, place), kind },
          value,
          type,
          loc
        });
      }
      return { kind: "LoadLocal", place: temporary, loc: temporary.loc };
    }
    case "MemberExpression": {
      CompilerError.invariant(kind === "Reassign" /* Reassign */, {
        reason: "MemberExpression may only appear in an assignment expression",
        description: null,
        loc: (_e = lvaluePath.node.loc) != null ? _e : null,
        suggestions: null
      });
      const lvalue = lvaluePath;
      const property = lvalue.get("property");
      const object = lowerExpressionToTemporary(builder, lvalue.get("object"));
      if (!lvalue.node.computed || lvalue.get("property").isNumericLiteral()) {
        let temporary;
        if (property.isIdentifier()) {
          temporary = lowerValueToTemporary(builder, {
            kind: "PropertyStore",
            object,
            property: makePropertyLiteral(property.node.name),
            value,
            loc
          });
        } else if (property.isNumericLiteral()) {
          temporary = lowerValueToTemporary(builder, {
            kind: "PropertyStore",
            object,
            property: makePropertyLiteral(property.node.value),
            value,
            loc
          });
        } else {
          builder.errors.push({
            reason: `(BuildHIR::lowerAssignment) Handle ${property.type} properties in MemberExpression`,
            severity: "Todo" /* Todo */,
            category: "Todo" /* Todo */,
            loc: (_f = property.node.loc) != null ? _f : null,
            suggestions: null
          });
          return { kind: "UnsupportedNode", node: lvalueNode, loc };
        }
        return { kind: "LoadLocal", place: temporary, loc: temporary.loc };
      } else {
        if (!property.isExpression()) {
          builder.errors.push({
            reason: "(BuildHIR::lowerAssignment) Expected private name to appear as a non-computed property",
            severity: "Todo" /* Todo */,
            category: "Todo" /* Todo */,
            loc: (_g = property.node.loc) != null ? _g : null,
            suggestions: null
          });
          return { kind: "UnsupportedNode", node: lvalueNode, loc };
        }
        const propertyPlace = lowerExpressionToTemporary(builder, property);
        const temporary = lowerValueToTemporary(builder, {
          kind: "ComputedStore",
          object,
          property: propertyPlace,
          value,
          loc
        });
        return { kind: "LoadLocal", place: temporary, loc: temporary.loc };
      }
    }
    case "ArrayPattern": {
      const lvalue = lvaluePath;
      const elements = lvalue.get("elements");
      const items = [];
      const followups = [];
      const forceTemporaries = kind === "Reassign" /* Reassign */ && (elements.some((element) => !element.isIdentifier()) || elements.some(
        (element) => element.isIdentifier() && (getStoreKind(builder, element) !== "StoreLocal" || builder.resolveIdentifier(element).kind !== "Identifier")
      ));
      for (let i = 0; i < elements.length; i++) {
        const element = elements[i];
        if (element.node == null) {
          items.push({
            kind: "Hole"
          });
          continue;
        }
        if (element.isRestElement()) {
          const argument = element.get("argument");
          if (argument.isIdentifier() && !forceTemporaries && (assignmentKind === "Assignment" || getStoreKind(builder, argument) === "StoreLocal")) {
            const identifier4 = lowerIdentifierForAssignment(
              builder,
              (_h = element.node.loc) != null ? _h : GeneratedSource,
              kind,
              argument
            );
            if (identifier4 === null) {
              continue;
            } else if (identifier4.kind === "Global") {
              builder.errors.push({
                severity: "Todo" /* Todo */,
                category: "Todo" /* Todo */,
                reason: "Expected reassignment of globals to enable forceTemporaries",
                loc: (_i = element.node.loc) != null ? _i : GeneratedSource
              });
              continue;
            }
            items.push({
              kind: "Spread",
              place: identifier4
            });
          } else {
            const temp = buildTemporaryPlace(
              builder,
              (_j = element.node.loc) != null ? _j : GeneratedSource
            );
            promoteTemporary(temp.identifier);
            items.push({
              kind: "Spread",
              place: __spreadValues({}, temp)
            });
            followups.push({ place: temp, path: argument });
          }
        } else if (element.isIdentifier() && !forceTemporaries && (assignmentKind === "Assignment" || getStoreKind(builder, element) === "StoreLocal")) {
          const identifier4 = lowerIdentifierForAssignment(
            builder,
            (_k = element.node.loc) != null ? _k : GeneratedSource,
            kind,
            element
          );
          if (identifier4 === null) {
            continue;
          } else if (identifier4.kind === "Global") {
            builder.errors.push({
              severity: "Todo" /* Todo */,
              category: "Todo" /* Todo */,
              reason: "Expected reassignment of globals to enable forceTemporaries",
              loc: (_l = element.node.loc) != null ? _l : GeneratedSource
            });
            continue;
          }
          items.push(identifier4);
        } else {
          const temp = buildTemporaryPlace(
            builder,
            (_m = element.node.loc) != null ? _m : GeneratedSource
          );
          promoteTemporary(temp.identifier);
          items.push(__spreadValues({}, temp));
          followups.push({ place: temp, path: element });
        }
      }
      const temporary = lowerValueToTemporary(builder, {
        kind: "Destructure",
        lvalue: {
          kind,
          pattern: {
            kind: "ArrayPattern",
            items
          }
        },
        value,
        loc
      });
      for (const { place, path } of followups) {
        lowerAssignment(
          builder,
          (_n = path.node.loc) != null ? _n : loc,
          kind,
          path,
          place,
          assignmentKind
        );
      }
      return { kind: "LoadLocal", place: temporary, loc: value.loc };
    }
    case "ObjectPattern": {
      const lvalue = lvaluePath;
      const propertiesPaths = lvalue.get("properties");
      const properties = [];
      const followups = [];
      const forceTemporaries = kind === "Reassign" /* Reassign */ && propertiesPaths.some(
        (property) => property.isRestElement() || property.isObjectProperty() && (!property.get("value").isIdentifier() || builder.resolveIdentifier(
          property.get("value")
        ).kind !== "Identifier")
      );
      for (let i = 0; i < propertiesPaths.length; i++) {
        const property = propertiesPaths[i];
        if (property.isRestElement()) {
          const argument = property.get("argument");
          if (!argument.isIdentifier()) {
            builder.errors.push({
              reason: `(BuildHIR::lowerAssignment) Handle ${argument.node.type} rest element in ObjectPattern`,
              severity: "Todo" /* Todo */,
              category: "Todo" /* Todo */,
              loc: (_o = argument.node.loc) != null ? _o : null,
              suggestions: null
            });
            continue;
          }
          if (forceTemporaries || getStoreKind(builder, argument) === "StoreContext") {
            const temp = buildTemporaryPlace(
              builder,
              (_p = property.node.loc) != null ? _p : GeneratedSource
            );
            promoteTemporary(temp.identifier);
            properties.push({
              kind: "Spread",
              place: __spreadValues({}, temp)
            });
            followups.push({ place: temp, path: argument });
          } else {
            const identifier4 = lowerIdentifierForAssignment(
              builder,
              (_q = property.node.loc) != null ? _q : GeneratedSource,
              kind,
              argument
            );
            if (identifier4 === null) {
              continue;
            } else if (identifier4.kind === "Global") {
              builder.errors.push({
                severity: "Todo" /* Todo */,
                category: "Todo" /* Todo */,
                reason: "Expected reassignment of globals to enable forceTemporaries",
                loc: (_r = property.node.loc) != null ? _r : GeneratedSource
              });
              continue;
            }
            properties.push({
              kind: "Spread",
              place: identifier4
            });
          }
        } else {
          if (!property.isObjectProperty()) {
            builder.errors.push({
              reason: `(BuildHIR::lowerAssignment) Handle ${property.type} properties in ObjectPattern`,
              severity: "Todo" /* Todo */,
              category: "Todo" /* Todo */,
              loc: (_s = property.node.loc) != null ? _s : null,
              suggestions: null
            });
            continue;
          }
          if (property.node.computed) {
            builder.errors.push({
              reason: `(BuildHIR::lowerAssignment) Handle computed properties in ObjectPattern`,
              severity: "Todo" /* Todo */,
              category: "Todo" /* Todo */,
              loc: (_t = property.node.loc) != null ? _t : null,
              suggestions: null
            });
            continue;
          }
          const loweredKey = lowerObjectPropertyKey(builder, property);
          if (!loweredKey) {
            continue;
          }
          const element = property.get("value");
          if (!element.isLVal()) {
            builder.errors.push({
              reason: `(BuildHIR::lowerAssignment) Expected object property value to be an LVal, got: ${element.type}`,
              severity: "Todo" /* Todo */,
              category: "Todo" /* Todo */,
              loc: (_u = element.node.loc) != null ? _u : null,
              suggestions: null
            });
            continue;
          }
          if (element.isIdentifier() && !forceTemporaries && (assignmentKind === "Assignment" || getStoreKind(builder, element) === "StoreLocal")) {
            const identifier4 = lowerIdentifierForAssignment(
              builder,
              (_v = element.node.loc) != null ? _v : GeneratedSource,
              kind,
              element
            );
            if (identifier4 === null) {
              continue;
            } else if (identifier4.kind === "Global") {
              builder.errors.push({
                severity: "Todo" /* Todo */,
                category: "Todo" /* Todo */,
                reason: "Expected reassignment of globals to enable forceTemporaries",
                loc: (_w = element.node.loc) != null ? _w : GeneratedSource
              });
              continue;
            }
            properties.push({
              kind: "ObjectProperty",
              type: "property",
              place: identifier4,
              key: loweredKey
            });
          } else {
            const temp = buildTemporaryPlace(
              builder,
              (_x = element.node.loc) != null ? _x : GeneratedSource
            );
            promoteTemporary(temp.identifier);
            properties.push({
              kind: "ObjectProperty",
              type: "property",
              place: __spreadValues({}, temp),
              key: loweredKey
            });
            followups.push({ place: temp, path: element });
          }
        }
      }
      const temporary = lowerValueToTemporary(builder, {
        kind: "Destructure",
        lvalue: {
          kind,
          pattern: {
            kind: "ObjectPattern",
            properties
          }
        },
        value,
        loc
      });
      for (const { place, path } of followups) {
        lowerAssignment(
          builder,
          (_y = path.node.loc) != null ? _y : loc,
          kind,
          path,
          place,
          assignmentKind
        );
      }
      return { kind: "LoadLocal", place: temporary, loc: value.loc };
    }
    case "AssignmentPattern": {
      const lvalue = lvaluePath;
      const loc2 = (_z = lvalue.node.loc) != null ? _z : GeneratedSource;
      const temp = buildTemporaryPlace(builder, loc2);
      const testBlock = builder.reserve("value");
      const continuationBlock = builder.reserve(builder.currentBlockKind());
      const consequent = builder.enter("value", () => {
        const defaultValue = lowerReorderableExpression(
          builder,
          lvalue.get("right")
        );
        lowerValueToTemporary(builder, {
          kind: "StoreLocal",
          lvalue: { kind: "Const" /* Const */, place: __spreadValues({}, temp) },
          value: __spreadValues({}, defaultValue),
          type: null,
          loc: loc2
        });
        return {
          kind: "goto",
          variant: "Break" /* Break */,
          block: continuationBlock.id,
          id: makeInstructionId(0),
          loc: loc2
        };
      });
      const alternate = builder.enter("value", () => {
        lowerValueToTemporary(builder, {
          kind: "StoreLocal",
          lvalue: { kind: "Const" /* Const */, place: __spreadValues({}, temp) },
          value: __spreadValues({}, value),
          type: null,
          loc: loc2
        });
        return {
          kind: "goto",
          variant: "Break" /* Break */,
          block: continuationBlock.id,
          id: makeInstructionId(0),
          loc: loc2
        };
      });
      builder.terminateWithContinuation(
        {
          kind: "ternary",
          test: testBlock.id,
          fallthrough: continuationBlock.id,
          id: makeInstructionId(0),
          loc: loc2
        },
        testBlock
      );
      const undef = lowerValueToTemporary(builder, {
        kind: "Primitive",
        value: void 0,
        loc: loc2
      });
      const test = lowerValueToTemporary(builder, {
        kind: "BinaryExpression",
        left: __spreadValues({}, value),
        operator: "===",
        right: __spreadValues({}, undef),
        loc: loc2
      });
      builder.terminateWithContinuation(
        {
          kind: "branch",
          test: __spreadValues({}, test),
          consequent,
          alternate,
          fallthrough: continuationBlock.id,
          id: makeInstructionId(0),
          loc: loc2
        },
        continuationBlock
      );
      return lowerAssignment(
        builder,
        loc2,
        kind,
        lvalue.get("left"),
        temp,
        assignmentKind
      );
    }
    default: {
      builder.errors.push({
        reason: `(BuildHIR::lowerAssignment) Handle ${lvaluePath.type} assignments`,
        severity: "Todo" /* Todo */,
        category: "Todo" /* Todo */,
        loc: (_A = lvaluePath.node.loc) != null ? _A : null,
        suggestions: null
      });
      return { kind: "UnsupportedNode", node: lvalueNode, loc };
    }
  }
}
function captureScopes({ from, to }) {
  let scopes = /* @__PURE__ */ new Set();
  while (from) {
    scopes.add(from);
    if (from === to) {
      break;
    }
    from = from.parent;
  }
  return scopes;
}
function gatherCapturedContext(fn, componentScope) {
  const capturedIds = /* @__PURE__ */ new Map();
  const pureScopes = captureScopes({
    from: fn.scope.parent,
    to: componentScope
  });
  function handleMaybeDependency(path) {
    var _a, _b;
    let baseIdentifier;
    if (path.isJSXOpeningElement()) {
      const name = path.get("name");
      if (!(name.isJSXMemberExpression() || name.isJSXIdentifier())) {
        return;
      }
      let current = name;
      while (current.isJSXMemberExpression()) {
        current = current.get("object");
      }
      (0, import_invariant2.default)(
        current.isJSXIdentifier(),
        "Invalid logic in gatherCapturedDeps"
      );
      baseIdentifier = current;
    } else {
      baseIdentifier = path;
    }
    path.skip();
    const binding = baseIdentifier.scope.getBinding(baseIdentifier.node.name);
    if (binding !== void 0 && pureScopes.has(binding.scope) && !capturedIds.has(binding.identifier)) {
      capturedIds.set(
        binding.identifier,
        (_b = (_a = path.node.loc) != null ? _a : binding.identifier.loc) != null ? _b : GeneratedSource
      );
    }
  }
  fn.traverse({
    TypeAnnotation(path) {
      path.skip();
    },
    TSTypeAnnotation(path) {
      path.skip();
    },
    TypeAlias(path) {
      path.skip();
    },
    TSTypeAliasDeclaration(path) {
      path.skip();
    },
    Expression(path) {
      if (path.isAssignmentExpression()) {
        const left = path.get("left");
        if (left.isIdentifier()) {
          handleMaybeDependency(left);
        }
        return;
      } else if (path.isJSXElement()) {
        handleMaybeDependency(path.get("openingElement"));
      } else if (path.isIdentifier()) {
        handleMaybeDependency(path);
      }
    }
  });
  return capturedIds;
}
function notNull(value) {
  return value !== null;
}
function lowerType(node) {
  switch (node.type) {
    case "GenericTypeAnnotation": {
      const id = node.id;
      if (id.type === "Identifier" && id.name === "Array") {
        return { kind: "Object", shapeId: BuiltInArrayId };
      }
      return makeType();
    }
    case "TSTypeReference": {
      const typeName = node.typeName;
      if (typeName.type === "Identifier" && typeName.name === "Array") {
        return { kind: "Object", shapeId: BuiltInArrayId };
      }
      return makeType();
    }
    case "ArrayTypeAnnotation":
    case "TSArrayType": {
      return { kind: "Object", shapeId: BuiltInArrayId };
    }
    case "BooleanLiteralTypeAnnotation":
    case "BooleanTypeAnnotation":
    case "NullLiteralTypeAnnotation":
    case "NumberLiteralTypeAnnotation":
    case "NumberTypeAnnotation":
    case "StringLiteralTypeAnnotation":
    case "StringTypeAnnotation":
    case "TSBooleanKeyword":
    case "TSNullKeyword":
    case "TSNumberKeyword":
    case "TSStringKeyword":
    case "TSSymbolKeyword":
    case "TSUndefinedKeyword":
    case "TSVoidKeyword":
    case "VoidTypeAnnotation": {
      return { kind: "Primitive" };
    }
    default: {
      return makeType();
    }
  }
}

// src/HIR/BuildReactiveScopeTerminalsHIR.ts
function buildReactiveScopeTerminalsHIR(fn) {
  const queuedRewrites = [];
  recursivelyTraverseItems(
    [...getScopes(fn)],
    (scope) => scope.range,
    {
      fallthroughs: /* @__PURE__ */ new Map(),
      rewrites: queuedRewrites,
      env: fn.env
    },
    pushStartScopeTerminal,
    pushEndScopeTerminal
  );
  const rewrittenFinalBlocks = /* @__PURE__ */ new Map();
  const nextBlocks = /* @__PURE__ */ new Map();
  queuedRewrites.reverse();
  for (const [, block] of fn.body.blocks) {
    const context = {
      nextBlockId: block.id,
      rewrites: [],
      nextPreds: block.preds,
      instrSliceIdx: 0,
      source: block
    };
    for (let i = 0; i < block.instructions.length + 1; i++) {
      const instrId = i < block.instructions.length ? block.instructions[i].id : block.terminal.id;
      let rewrite = queuedRewrites.at(-1);
      while (rewrite != null && rewrite.instrId <= instrId) {
        handleRewrite(rewrite, i, context);
        queuedRewrites.pop();
        rewrite = queuedRewrites.at(-1);
      }
    }
    if (context.rewrites.length > 0) {
      const finalBlock = {
        id: context.nextBlockId,
        kind: block.kind,
        preds: context.nextPreds,
        terminal: block.terminal,
        instructions: block.instructions.slice(context.instrSliceIdx),
        phis: /* @__PURE__ */ new Set()
      };
      context.rewrites.push(finalBlock);
      for (const b of context.rewrites) {
        nextBlocks.set(b.id, b);
      }
      rewrittenFinalBlocks.set(block.id, finalBlock.id);
    } else {
      nextBlocks.set(block.id, block);
    }
  }
  const originalBlocks = fn.body.blocks;
  fn.body.blocks = nextBlocks;
  for (const [, block] of originalBlocks) {
    for (const phi of block.phis) {
      for (const [originalId, value] of phi.operands) {
        const newId = rewrittenFinalBlocks.get(originalId);
        if (newId != null) {
          phi.operands.delete(originalId);
          phi.operands.set(newId, value);
        }
      }
    }
  }
  reversePostorderBlocks(fn.body);
  markPredecessors(fn.body);
  markInstructionIds(fn.body);
  fixScopeAndIdentifierRanges(fn.body);
}
function pushStartScopeTerminal(scope, context) {
  const blockId = context.env.nextBlockId;
  const fallthroughId = context.env.nextBlockId;
  context.rewrites.push({
    kind: "StartScope",
    blockId,
    fallthroughId,
    instrId: scope.range.start,
    scope
  });
  context.fallthroughs.set(scope.id, fallthroughId);
}
function pushEndScopeTerminal(scope, context) {
  const fallthroughId = context.fallthroughs.get(scope.id);
  CompilerError.invariant(fallthroughId != null, {
    reason: "Expected scope to exist",
    loc: GeneratedSource
  });
  context.rewrites.push({
    kind: "EndScope",
    fallthroughId,
    instrId: scope.range.end
  });
}
function handleRewrite(terminalInfo, idx, context) {
  const terminal = terminalInfo.kind === "StartScope" ? {
    kind: "scope",
    fallthrough: terminalInfo.fallthroughId,
    block: terminalInfo.blockId,
    scope: terminalInfo.scope,
    id: terminalInfo.instrId,
    loc: GeneratedSource
  } : {
    kind: "goto",
    variant: "Break" /* Break */,
    block: terminalInfo.fallthroughId,
    id: terminalInfo.instrId,
    loc: GeneratedSource
  };
  const currBlockId = context.nextBlockId;
  context.rewrites.push({
    kind: context.source.kind,
    id: currBlockId,
    instructions: context.source.instructions.slice(context.instrSliceIdx, idx),
    preds: context.nextPreds,
    // Only the first rewrite should reuse source block phis
    phis: context.rewrites.length === 0 ? context.source.phis : /* @__PURE__ */ new Set(),
    terminal
  });
  context.nextPreds = /* @__PURE__ */ new Set([currBlockId]);
  context.nextBlockId = terminalInfo.kind === "StartScope" ? terminalInfo.blockId : terminalInfo.fallthroughId;
  context.instrSliceIdx = idx;
}

// src/HIR/Dominator.ts
var import_pretty_format = __toESM(require_build());
function computePostDominatorTree(fn, options) {
  const graph = buildReverseGraph(fn, options.includeThrowsAsExitNode);
  const nodes = computeImmediateDominators(graph);
  if (!options.includeThrowsAsExitNode) {
    for (const [id] of fn.body.blocks) {
      if (!nodes.has(id)) {
        nodes.set(id, id);
      }
    }
  }
  return new PostDominator(graph.entry, nodes);
}
var _exit, _nodes;
var PostDominator = class {
  constructor(exit, nodes) {
    __privateAdd(this, _exit);
    __privateAdd(this, _nodes);
    __privateSet(this, _exit, exit);
    __privateSet(this, _nodes, nodes);
  }
  // Returns the node representing normal exit from the function, ie return terminals.
  get exit() {
    return __privateGet(this, _exit);
  }
  /*
   * Returns the immediate dominator of the block with @param id if present. Returns null
   * if there is no immediate dominator (ie if the dominator is @param id itself).
   */
  get(id) {
    const dominator = __privateGet(this, _nodes).get(id);
    CompilerError.invariant(dominator !== void 0, {
      reason: "Unknown node",
      description: null,
      loc: null,
      suggestions: null
    });
    return dominator === id ? null : dominator;
  }
  debug() {
    const postDominators = /* @__PURE__ */ new Map();
    for (const [key2, value] of __privateGet(this, _nodes)) {
      postDominators.set(`bb${key2}`, `bb${value}`);
    }
    return (0, import_pretty_format.default)({
      exit: `bb${this.exit}`,
      postDominators
    });
  }
};
_exit = new WeakMap();
_nodes = new WeakMap();
function computeImmediateDominators(graph) {
  const nodes = /* @__PURE__ */ new Map();
  nodes.set(graph.entry, graph.entry);
  let changed = true;
  while (changed) {
    changed = false;
    for (const [id, node] of graph.nodes) {
      if (node.id === graph.entry) {
        continue;
      }
      let newIdom = null;
      for (const pred of node.preds) {
        if (nodes.has(pred)) {
          newIdom = pred;
          break;
        }
      }
      CompilerError.invariant(newIdom !== null, {
        reason: `At least one predecessor must have been visited for block ${id}`,
        description: null,
        loc: null,
        suggestions: null
      });
      for (const pred of node.preds) {
        if (pred === newIdom) {
          continue;
        }
        const predDom = nodes.get(pred);
        if (predDom !== void 0) {
          newIdom = intersect(pred, newIdom, graph, nodes);
        }
      }
      if (nodes.get(id) !== newIdom) {
        nodes.set(id, newIdom);
        changed = true;
      }
    }
  }
  return nodes;
}
function intersect(a, b, graph, nodes) {
  let block1 = graph.nodes.get(a);
  let block2 = graph.nodes.get(b);
  while (block1 !== block2) {
    while (block1.index > block2.index) {
      const dom = nodes.get(block1.id);
      block1 = graph.nodes.get(dom);
    }
    while (block2.index > block1.index) {
      const dom = nodes.get(block2.id);
      block2 = graph.nodes.get(dom);
    }
  }
  return block1.id;
}
function buildReverseGraph(fn, includeThrowsAsExitNode) {
  const nodes = /* @__PURE__ */ new Map();
  const exitId = fn.env.nextBlockId;
  const exit = {
    id: exitId,
    index: 0,
    preds: /* @__PURE__ */ new Set(),
    succs: /* @__PURE__ */ new Set()
  };
  nodes.set(exitId, exit);
  for (const [id, block] of fn.body.blocks) {
    const node = {
      id,
      index: 0,
      preds: new Set(eachTerminalSuccessor(block.terminal)),
      succs: new Set(block.preds)
    };
    if (block.terminal.kind === "return") {
      node.preds.add(exitId);
      exit.succs.add(id);
    } else if (block.terminal.kind === "throw" && includeThrowsAsExitNode) {
      node.preds.add(exitId);
      exit.succs.add(id);
    }
    nodes.set(id, node);
  }
  const visited = /* @__PURE__ */ new Set();
  const postorder = [];
  function visit4(id) {
    if (visited.has(id)) {
      return;
    }
    visited.add(id);
    const node = nodes.get(id);
    for (const successor of node.succs) {
      visit4(successor);
    }
    postorder.push(id);
  }
  visit4(exitId);
  const rpo = { entry: exitId, nodes: /* @__PURE__ */ new Map() };
  let index = 0;
  for (const id of postorder.reverse()) {
    const node = nodes.get(id);
    node.index = index++;
    rpo.nodes.set(id, node);
  }
  return rpo;
}

// node_modules/zod-validation-error/dist/esm/utils/joinPath.js
var identifierRegex = /[$_\p{ID_Start}][$\u200c\u200d\p{ID_Continue}]*/u;
function joinPath(path) {
  if (path.length === 1) {
    return path[0].toString();
  }
  return path.reduce((acc, item) => {
    if (typeof item === "number") {
      return acc + "[" + item.toString() + "]";
    }
    if (item.includes('"')) {
      return acc + '["' + escapeQuotes(item) + '"]';
    }
    if (!identifierRegex.test(item)) {
      return acc + '["' + item + '"]';
    }
    const separator = acc.length === 0 ? "" : ".";
    return acc + separator + item;
  }, "");
}
function escapeQuotes(str) {
  return str.replace(/"/g, '\\"');
}

// node_modules/zod-validation-error/dist/esm/utils/NonEmptyArray.js
function isNonEmptyArray(value) {
  return value.length !== 0;
}

// node_modules/zod-validation-error/dist/esm/ValidationError.js
var MAX_ISSUES_IN_MESSAGE = 99;
var ISSUE_SEPARATOR = "; ";
var UNION_SEPARATOR = ", or ";
var PREFIX = "Validation error";
var PREFIX_SEPARATOR = ": ";
var ValidationError = class extends Error {
  constructor(message, details = []) {
    super(message);
    __publicField(this, "details");
    __publicField(this, "name");
    this.details = details;
    this.name = "ZodValidationError";
  }
  toString() {
    return this.message;
  }
};
function getMessageFromZodIssue(props) {
  const { issue, issueSeparator, unionSeparator, includePath } = props;
  if (issue.code === "invalid_union") {
    return issue.unionErrors.reduce((acc, zodError) => {
      const newIssues = zodError.issues.map((issue2) => getMessageFromZodIssue({
        issue: issue2,
        issueSeparator,
        unionSeparator,
        includePath
      })).join(issueSeparator);
      if (!acc.includes(newIssues)) {
        acc.push(newIssues);
      }
      return acc;
    }, []).join(unionSeparator);
  }
  if (includePath && isNonEmptyArray(issue.path)) {
    if (issue.path.length === 1) {
      const identifier4 = issue.path[0];
      if (typeof identifier4 === "number") {
        return `${issue.message} at index ${identifier4}`;
      }
    }
    return `${issue.message} at "${joinPath(issue.path)}"`;
  }
  return issue.message;
}
function conditionallyPrefixMessage(reason, prefix, prefixSeparator) {
  if (prefix !== null) {
    if (reason.length > 0) {
      return [prefix, reason].join(prefixSeparator);
    }
    return prefix;
  }
  if (reason.length > 0) {
    return reason;
  }
  return PREFIX;
}
function fromZodError(zodError, options = {}) {
  const { maxIssuesInMessage = MAX_ISSUES_IN_MESSAGE, issueSeparator = ISSUE_SEPARATOR, unionSeparator = UNION_SEPARATOR, prefixSeparator = PREFIX_SEPARATOR, prefix = PREFIX, includePath = true } = options;
  const reason = zodError.errors.slice(0, maxIssuesInMessage).map((issue) => getMessageFromZodIssue({
    issue,
    issueSeparator,
    unionSeparator,
    includePath
  })).join(issueSeparator);
  const message = conditionallyPrefixMessage(reason, prefix, prefixSeparator);
  return new ValidationError(message, zodError.errors);
}

// src/HIR/Globals.ts
var DEFAULT_SHAPES = new Map(BUILTIN_SHAPES);
var UNTYPED_GLOBALS = /* @__PURE__ */ new Set([
  "Object",
  "Function",
  "RegExp",
  "Date",
  "Error",
  "TypeError",
  "RangeError",
  "ReferenceError",
  "SyntaxError",
  "URIError",
  "EvalError",
  "DataView",
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Int16Array",
  "Int32Array",
  "WeakMap",
  "Uint8Array",
  "Uint8ClampedArray",
  "Uint16Array",
  "Uint32Array",
  "ArrayBuffer",
  "JSON",
  "console",
  "eval"
]);
var TYPED_GLOBALS = [
  [
    "Object",
    addObject(DEFAULT_SHAPES, "Object", [
      [
        "keys",
        addFunction(DEFAULT_SHAPES, [], {
          positionalParams: ["read" /* Read */],
          restParam: null,
          returnType: { kind: "Object", shapeId: BuiltInArrayId },
          calleeEffect: "read" /* Read */,
          returnValueKind: "mutable" /* Mutable */
        })
      ],
      [
        /**
         * Object.fromEntries(iterable)
         * iterable: An iterable, such as an Array or Map, containing a list of
         *           objects. Each object should have two properties.
         * Returns a new object whose properties are given by the entries of the
         * iterable.
         */
        "fromEntries",
        addFunction(DEFAULT_SHAPES, [], {
          positionalParams: ["mutate?" /* ConditionallyMutate */],
          restParam: null,
          returnType: { kind: "Object", shapeId: BuiltInObjectId },
          calleeEffect: "read" /* Read */,
          returnValueKind: "mutable" /* Mutable */
        })
      ],
      [
        "entries",
        addFunction(DEFAULT_SHAPES, [], {
          positionalParams: ["capture" /* Capture */],
          restParam: null,
          returnType: { kind: "Object", shapeId: BuiltInArrayId },
          calleeEffect: "read" /* Read */,
          returnValueKind: "mutable" /* Mutable */,
          aliasing: {
            receiver: "@receiver",
            params: ["@object"],
            rest: null,
            returns: "@returns",
            temporaries: [],
            effects: [
              {
                kind: "Create",
                into: "@returns",
                reason: "known-return-signature" /* KnownReturnSignature */,
                value: "mutable" /* Mutable */
              },
              // Object values are captured into the return
              {
                kind: "Capture",
                from: "@object",
                into: "@returns"
              }
            ]
          }
        })
      ],
      [
        "keys",
        addFunction(DEFAULT_SHAPES, [], {
          positionalParams: ["read" /* Read */],
          restParam: null,
          returnType: { kind: "Object", shapeId: BuiltInArrayId },
          calleeEffect: "read" /* Read */,
          returnValueKind: "mutable" /* Mutable */,
          aliasing: {
            receiver: "@receiver",
            params: ["@object"],
            rest: null,
            returns: "@returns",
            temporaries: [],
            effects: [
              {
                kind: "Create",
                into: "@returns",
                reason: "known-return-signature" /* KnownReturnSignature */,
                value: "mutable" /* Mutable */
              },
              // Only keys are captured, and keys are immutable
              {
                kind: "ImmutableCapture",
                from: "@object",
                into: "@returns"
              }
            ]
          }
        })
      ],
      [
        "values",
        addFunction(DEFAULT_SHAPES, [], {
          positionalParams: ["capture" /* Capture */],
          restParam: null,
          returnType: { kind: "Object", shapeId: BuiltInArrayId },
          calleeEffect: "read" /* Read */,
          returnValueKind: "mutable" /* Mutable */,
          aliasing: {
            receiver: "@receiver",
            params: ["@object"],
            rest: null,
            returns: "@returns",
            temporaries: [],
            effects: [
              {
                kind: "Create",
                into: "@returns",
                reason: "known-return-signature" /* KnownReturnSignature */,
                value: "mutable" /* Mutable */
              },
              // Object values are captured into the return
              {
                kind: "Capture",
                from: "@object",
                into: "@returns"
              }
            ]
          }
        })
      ]
    ])
  ],
  [
    "Array",
    addObject(DEFAULT_SHAPES, "Array", [
      [
        "isArray",
        // Array.isArray(value)
        addFunction(DEFAULT_SHAPES, [], {
          positionalParams: ["read" /* Read */],
          restParam: null,
          returnType: { kind: "Primitive" },
          calleeEffect: "read" /* Read */,
          returnValueKind: "primitive" /* Primitive */
        })
      ],
      /*
       * https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.from
       * Array.from(arrayLike, optionalFn, optionalThis)
       * Note that the Effect of `arrayLike` is polymorphic i.e.
       *  - Effect.read if
       *     - it does not have an @iterator property and is array-like
       *       (i.e. has a length property)
       *    - it is an iterable object whose iterator does not mutate itself
       *  - Effect.mutate if it is a self-mutative iterator (e.g. a generator
       *    function)
       */
      [
        "from",
        addFunction(DEFAULT_SHAPES, [], {
          positionalParams: [
            "mutate-iterator?" /* ConditionallyMutateIterator */,
            "mutate?" /* ConditionallyMutate */,
            "mutate?" /* ConditionallyMutate */
          ],
          restParam: "read" /* Read */,
          returnType: { kind: "Object", shapeId: BuiltInArrayId },
          calleeEffect: "read" /* Read */,
          returnValueKind: "mutable" /* Mutable */
        })
      ],
      [
        "of",
        // Array.of(element0, ..., elementN)
        addFunction(DEFAULT_SHAPES, [], {
          positionalParams: [],
          restParam: "read" /* Read */,
          returnType: { kind: "Object", shapeId: BuiltInArrayId },
          calleeEffect: "read" /* Read */,
          returnValueKind: "mutable" /* Mutable */
        })
      ]
    ])
  ],
  [
    "performance",
    addObject(DEFAULT_SHAPES, "performance", [
      // Static methods (TODO)
      [
        "now",
        // Date.now()
        addFunction(DEFAULT_SHAPES, [], {
          positionalParams: [],
          restParam: "read" /* Read */,
          returnType: { kind: "Poly" },
          // TODO: could be Primitive, but that would change existing compilation
          calleeEffect: "read" /* Read */,
          returnValueKind: "mutable" /* Mutable */,
          // same here
          impure: true,
          canonicalName: "performance.now"
        })
      ]
    ])
  ],
  [
    "Date",
    addObject(DEFAULT_SHAPES, "Date", [
      // Static methods (TODO)
      [
        "now",
        // Date.now()
        addFunction(DEFAULT_SHAPES, [], {
          positionalParams: [],
          restParam: "read" /* Read */,
          returnType: { kind: "Poly" },
          // TODO: could be Primitive, but that would change existing compilation
          calleeEffect: "read" /* Read */,
          returnValueKind: "mutable" /* Mutable */,
          // same here
          impure: true,
          canonicalName: "Date.now"
        })
      ]
    ])
  ],
  [
    "Math",
    addObject(DEFAULT_SHAPES, "Math", [
      // Static properties (TODO)
      ["PI", { kind: "Primitive" }],
      // Static methods (TODO)
      [
        "max",
        // Math.max(value0, ..., valueN)
        addFunction(DEFAULT_SHAPES, [], {
          positionalParams: [],
          restParam: "read" /* Read */,
          returnType: { kind: "Primitive" },
          calleeEffect: "read" /* Read */,
          returnValueKind: "primitive" /* Primitive */
        })
      ],
      [
        "min",
        // Math.min(value0, ..., valueN)
        addFunction(DEFAULT_SHAPES, [], {
          positionalParams: [],
          restParam: "read" /* Read */,
          returnType: { kind: "Primitive" },
          calleeEffect: "read" /* Read */,
          returnValueKind: "primitive" /* Primitive */
        })
      ],
      [
        "trunc",
        addFunction(DEFAULT_SHAPES, [], {
          positionalParams: [],
          restParam: "read" /* Read */,
          returnType: { kind: "Primitive" },
          calleeEffect: "read" /* Read */,
          returnValueKind: "primitive" /* Primitive */
        })
      ],
      [
        "ceil",
        addFunction(DEFAULT_SHAPES, [], {
          positionalParams: [],
          restParam: "read" /* Read */,
          returnType: { kind: "Primitive" },
          calleeEffect: "read" /* Read */,
          returnValueKind: "primitive" /* Primitive */
        })
      ],
      [
        "floor",
        addFunction(DEFAULT_SHAPES, [], {
          positionalParams: [],
          restParam: "read" /* Read */,
          returnType: { kind: "Primitive" },
          calleeEffect: "read" /* Read */,
          returnValueKind: "primitive" /* Primitive */
        })
      ],
      [
        "pow",
        addFunction(DEFAULT_SHAPES, [], {
          positionalParams: [],
          restParam: "read" /* Read */,
          returnType: { kind: "Primitive" },
          calleeEffect: "read" /* Read */,
          returnValueKind: "primitive" /* Primitive */
        })
      ],
      [
        "random",
        addFunction(DEFAULT_SHAPES, [], {
          positionalParams: [],
          restParam: "read" /* Read */,
          returnType: { kind: "Poly" },
          // TODO: could be Primitive, but that would change existing compilation
          calleeEffect: "read" /* Read */,
          returnValueKind: "mutable" /* Mutable */,
          // same here
          impure: true,
          canonicalName: "Math.random"
        })
      ]
    ])
  ],
  ["Infinity", { kind: "Primitive" }],
  ["NaN", { kind: "Primitive" }],
  [
    "console",
    addObject(DEFAULT_SHAPES, "console", [
      [
        "error",
        addFunction(DEFAULT_SHAPES, [], {
          positionalParams: [],
          restParam: "read" /* Read */,
          returnType: { kind: "Primitive" },
          calleeEffect: "read" /* Read */,
          returnValueKind: "primitive" /* Primitive */
        })
      ],
      [
        "info",
        addFunction(DEFAULT_SHAPES, [], {
          positionalParams: [],
          restParam: "read" /* Read */,
          returnType: { kind: "Primitive" },
          calleeEffect: "read" /* Read */,
          returnValueKind: "primitive" /* Primitive */
        })
      ],
      [
        "log",
        addFunction(DEFAULT_SHAPES, [], {
          positionalParams: [],
          restParam: "read" /* Read */,
          returnType: { kind: "Primitive" },
          calleeEffect: "read" /* Read */,
          returnValueKind: "primitive" /* Primitive */
        })
      ],
      [
        "table",
        addFunction(DEFAULT_SHAPES, [], {
          positionalParams: [],
          restParam: "read" /* Read */,
          returnType: { kind: "Primitive" },
          calleeEffect: "read" /* Read */,
          returnValueKind: "primitive" /* Primitive */
        })
      ],
      [
        "trace",
        addFunction(DEFAULT_SHAPES, [], {
          positionalParams: [],
          restParam: "read" /* Read */,
          returnType: { kind: "Primitive" },
          calleeEffect: "read" /* Read */,
          returnValueKind: "primitive" /* Primitive */
        })
      ],
      [
        "warn",
        addFunction(DEFAULT_SHAPES, [], {
          positionalParams: [],
          restParam: "read" /* Read */,
          returnType: { kind: "Primitive" },
          calleeEffect: "read" /* Read */,
          returnValueKind: "primitive" /* Primitive */
        })
      ]
    ])
  ],
  [
    "Boolean",
    addFunction(DEFAULT_SHAPES, [], {
      positionalParams: [],
      restParam: "read" /* Read */,
      returnType: { kind: "Primitive" },
      calleeEffect: "read" /* Read */,
      returnValueKind: "primitive" /* Primitive */
    })
  ],
  [
    "Number",
    addFunction(DEFAULT_SHAPES, [], {
      positionalParams: [],
      restParam: "read" /* Read */,
      returnType: { kind: "Primitive" },
      calleeEffect: "read" /* Read */,
      returnValueKind: "primitive" /* Primitive */
    })
  ],
  [
    "String",
    addFunction(DEFAULT_SHAPES, [], {
      positionalParams: [],
      restParam: "read" /* Read */,
      returnType: { kind: "Primitive" },
      calleeEffect: "read" /* Read */,
      returnValueKind: "primitive" /* Primitive */
    })
  ],
  [
    "parseInt",
    addFunction(DEFAULT_SHAPES, [], {
      positionalParams: [],
      restParam: "read" /* Read */,
      returnType: { kind: "Primitive" },
      calleeEffect: "read" /* Read */,
      returnValueKind: "primitive" /* Primitive */
    })
  ],
  [
    "parseFloat",
    addFunction(DEFAULT_SHAPES, [], {
      positionalParams: [],
      restParam: "read" /* Read */,
      returnType: { kind: "Primitive" },
      calleeEffect: "read" /* Read */,
      returnValueKind: "primitive" /* Primitive */
    })
  ],
  [
    "isNaN",
    addFunction(DEFAULT_SHAPES, [], {
      positionalParams: [],
      restParam: "read" /* Read */,
      returnType: { kind: "Primitive" },
      calleeEffect: "read" /* Read */,
      returnValueKind: "primitive" /* Primitive */
    })
  ],
  [
    "isFinite",
    addFunction(DEFAULT_SHAPES, [], {
      positionalParams: [],
      restParam: "read" /* Read */,
      returnType: { kind: "Primitive" },
      calleeEffect: "read" /* Read */,
      returnValueKind: "primitive" /* Primitive */
    })
  ],
  [
    "encodeURI",
    addFunction(DEFAULT_SHAPES, [], {
      positionalParams: [],
      restParam: "read" /* Read */,
      returnType: { kind: "Primitive" },
      calleeEffect: "read" /* Read */,
      returnValueKind: "primitive" /* Primitive */
    })
  ],
  [
    "encodeURIComponent",
    addFunction(DEFAULT_SHAPES, [], {
      positionalParams: [],
      restParam: "read" /* Read */,
      returnType: { kind: "Primitive" },
      calleeEffect: "read" /* Read */,
      returnValueKind: "primitive" /* Primitive */
    })
  ],
  [
    "decodeURI",
    addFunction(DEFAULT_SHAPES, [], {
      positionalParams: [],
      restParam: "read" /* Read */,
      returnType: { kind: "Primitive" },
      calleeEffect: "read" /* Read */,
      returnValueKind: "primitive" /* Primitive */
    })
  ],
  [
    "decodeURIComponent",
    addFunction(DEFAULT_SHAPES, [], {
      positionalParams: [],
      restParam: "read" /* Read */,
      returnType: { kind: "Primitive" },
      calleeEffect: "read" /* Read */,
      returnValueKind: "primitive" /* Primitive */
    })
  ],
  [
    "Map",
    addFunction(
      DEFAULT_SHAPES,
      [],
      {
        positionalParams: ["mutate-iterator?" /* ConditionallyMutateIterator */],
        restParam: null,
        returnType: { kind: "Object", shapeId: BuiltInMapId },
        calleeEffect: "read" /* Read */,
        returnValueKind: "mutable" /* Mutable */
      },
      null,
      true
    )
  ],
  [
    "Set",
    addFunction(
      DEFAULT_SHAPES,
      [],
      {
        positionalParams: ["mutate-iterator?" /* ConditionallyMutateIterator */],
        restParam: null,
        returnType: { kind: "Object", shapeId: BuiltInSetId },
        calleeEffect: "read" /* Read */,
        returnValueKind: "mutable" /* Mutable */
      },
      null,
      true
    )
  ],
  [
    "WeakMap",
    addFunction(
      DEFAULT_SHAPES,
      [],
      {
        positionalParams: ["mutate-iterator?" /* ConditionallyMutateIterator */],
        restParam: null,
        returnType: { kind: "Object", shapeId: BuiltInWeakMapId },
        calleeEffect: "read" /* Read */,
        returnValueKind: "mutable" /* Mutable */
      },
      null,
      true
    )
  ],
  [
    "WeakSet",
    addFunction(
      DEFAULT_SHAPES,
      [],
      {
        positionalParams: ["mutate-iterator?" /* ConditionallyMutateIterator */],
        restParam: null,
        returnType: { kind: "Object", shapeId: BuiltInWeakSetId },
        calleeEffect: "read" /* Read */,
        returnValueKind: "mutable" /* Mutable */
      },
      null,
      true
    )
  ]
  // TODO: rest of Global objects
];
var REACT_APIS = [
  [
    "useContext",
    addHook(
      DEFAULT_SHAPES,
      {
        positionalParams: [],
        restParam: "read" /* Read */,
        returnType: { kind: "Poly" },
        calleeEffect: "read" /* Read */,
        hookKind: "useContext",
        returnValueKind: "frozen" /* Frozen */,
        returnValueReason: "context" /* Context */
      },
      BuiltInUseContextHookId
    )
  ],
  [
    "useState",
    addHook(DEFAULT_SHAPES, {
      positionalParams: [],
      restParam: "freeze" /* Freeze */,
      returnType: { kind: "Object", shapeId: BuiltInUseStateId },
      calleeEffect: "read" /* Read */,
      hookKind: "useState",
      returnValueKind: "frozen" /* Frozen */,
      returnValueReason: "state" /* State */
    })
  ],
  [
    "useActionState",
    addHook(DEFAULT_SHAPES, {
      positionalParams: [],
      restParam: "freeze" /* Freeze */,
      returnType: { kind: "Object", shapeId: BuiltInUseActionStateId },
      calleeEffect: "read" /* Read */,
      hookKind: "useActionState",
      returnValueKind: "frozen" /* Frozen */,
      returnValueReason: "state" /* State */
    })
  ],
  [
    "useReducer",
    addHook(DEFAULT_SHAPES, {
      positionalParams: [],
      restParam: "freeze" /* Freeze */,
      returnType: { kind: "Object", shapeId: BuiltInUseReducerId },
      calleeEffect: "read" /* Read */,
      hookKind: "useReducer",
      returnValueKind: "frozen" /* Frozen */,
      returnValueReason: "reducer-state" /* ReducerState */
    })
  ],
  [
    "useRef",
    addHook(DEFAULT_SHAPES, {
      positionalParams: [],
      restParam: "capture" /* Capture */,
      returnType: { kind: "Object", shapeId: BuiltInUseRefId },
      calleeEffect: "read" /* Read */,
      hookKind: "useRef",
      returnValueKind: "mutable" /* Mutable */
    })
  ],
  [
    "useImperativeHandle",
    addHook(DEFAULT_SHAPES, {
      positionalParams: [],
      restParam: "freeze" /* Freeze */,
      returnType: { kind: "Primitive" },
      calleeEffect: "read" /* Read */,
      hookKind: "useImperativeHandle",
      returnValueKind: "frozen" /* Frozen */
    })
  ],
  [
    "useMemo",
    addHook(DEFAULT_SHAPES, {
      positionalParams: [],
      restParam: "freeze" /* Freeze */,
      returnType: { kind: "Poly" },
      calleeEffect: "read" /* Read */,
      hookKind: "useMemo",
      returnValueKind: "frozen" /* Frozen */
    })
  ],
  [
    "useCallback",
    addHook(DEFAULT_SHAPES, {
      positionalParams: [],
      restParam: "freeze" /* Freeze */,
      returnType: { kind: "Poly" },
      calleeEffect: "read" /* Read */,
      hookKind: "useCallback",
      returnValueKind: "frozen" /* Frozen */
    })
  ],
  [
    "useEffect",
    addHook(
      DEFAULT_SHAPES,
      {
        positionalParams: [],
        restParam: "freeze" /* Freeze */,
        returnType: { kind: "Primitive" },
        calleeEffect: "read" /* Read */,
        hookKind: "useEffect",
        returnValueKind: "frozen" /* Frozen */,
        aliasing: {
          receiver: "@receiver",
          params: [],
          rest: "@rest",
          returns: "@returns",
          temporaries: ["@effect"],
          effects: [
            // Freezes the function and deps
            {
              kind: "Freeze",
              value: "@rest",
              reason: "effect" /* Effect */
            },
            // Internally creates an effect object that captures the function and deps
            {
              kind: "Create",
              into: "@effect",
              value: "frozen" /* Frozen */,
              reason: "known-return-signature" /* KnownReturnSignature */
            },
            // The effect stores the function and dependencies
            {
              kind: "Capture",
              from: "@rest",
              into: "@effect"
            },
            // Returns undefined
            {
              kind: "Create",
              into: "@returns",
              value: "primitive" /* Primitive */,
              reason: "known-return-signature" /* KnownReturnSignature */
            }
          ]
        }
      },
      BuiltInUseEffectHookId
    )
  ],
  [
    "useLayoutEffect",
    addHook(
      DEFAULT_SHAPES,
      {
        positionalParams: [],
        restParam: "freeze" /* Freeze */,
        returnType: { kind: "Poly" },
        calleeEffect: "read" /* Read */,
        hookKind: "useLayoutEffect",
        returnValueKind: "frozen" /* Frozen */
      },
      BuiltInUseLayoutEffectHookId
    )
  ],
  [
    "useInsertionEffect",
    addHook(
      DEFAULT_SHAPES,
      {
        positionalParams: [],
        restParam: "freeze" /* Freeze */,
        returnType: { kind: "Poly" },
        calleeEffect: "read" /* Read */,
        hookKind: "useInsertionEffect",
        returnValueKind: "frozen" /* Frozen */
      },
      BuiltInUseInsertionEffectHookId
    )
  ],
  [
    "useTransition",
    addHook(DEFAULT_SHAPES, {
      positionalParams: [],
      restParam: null,
      returnType: { kind: "Object", shapeId: BuiltInUseTransitionId },
      calleeEffect: "read" /* Read */,
      hookKind: "useTransition",
      returnValueKind: "frozen" /* Frozen */
    })
  ],
  [
    "use",
    addFunction(
      DEFAULT_SHAPES,
      [],
      {
        positionalParams: [],
        restParam: "freeze" /* Freeze */,
        returnType: { kind: "Poly" },
        calleeEffect: "read" /* Read */,
        returnValueKind: "frozen" /* Frozen */
      },
      BuiltInUseOperatorId
    )
  ],
  [
    "fire",
    addFunction(
      DEFAULT_SHAPES,
      [],
      {
        positionalParams: [],
        restParam: null,
        returnType: {
          kind: "Function",
          return: { kind: "Poly" },
          shapeId: BuiltInFireFunctionId,
          isConstructor: false
        },
        calleeEffect: "read" /* Read */,
        returnValueKind: "frozen" /* Frozen */
      },
      BuiltInFireId
    )
  ],
  [
    "useEffectEvent",
    addHook(
      DEFAULT_SHAPES,
      {
        positionalParams: [],
        restParam: "freeze" /* Freeze */,
        returnType: {
          kind: "Function",
          return: { kind: "Poly" },
          shapeId: BuiltinEffectEventId,
          isConstructor: false
        },
        calleeEffect: "read" /* Read */,
        hookKind: "useEffectEvent",
        // Frozen because it should not mutate any locally-bound values
        returnValueKind: "frozen" /* Frozen */
      },
      BuiltInUseEffectEventId
    )
  ],
  ["AUTODEPS", addObject(DEFAULT_SHAPES, BuiltInAutodepsId, [])]
];
TYPED_GLOBALS.push(
  [
    "React",
    addObject(DEFAULT_SHAPES, null, [
      ...REACT_APIS,
      [
        "createElement",
        addFunction(DEFAULT_SHAPES, [], {
          positionalParams: [],
          restParam: "freeze" /* Freeze */,
          returnType: { kind: "Poly" },
          calleeEffect: "read" /* Read */,
          returnValueKind: "frozen" /* Frozen */
        })
      ],
      [
        "cloneElement",
        addFunction(DEFAULT_SHAPES, [], {
          positionalParams: [],
          restParam: "freeze" /* Freeze */,
          returnType: { kind: "Poly" },
          calleeEffect: "read" /* Read */,
          returnValueKind: "frozen" /* Frozen */
        })
      ],
      [
        "createRef",
        addFunction(DEFAULT_SHAPES, [], {
          positionalParams: [],
          restParam: "capture" /* Capture */,
          // createRef takes no paramters
          returnType: { kind: "Object", shapeId: BuiltInUseRefId },
          calleeEffect: "read" /* Read */,
          returnValueKind: "mutable" /* Mutable */
        })
      ]
    ])
  ],
  [
    "_jsx",
    addFunction(DEFAULT_SHAPES, [], {
      positionalParams: [],
      restParam: "freeze" /* Freeze */,
      returnType: { kind: "Poly" },
      calleeEffect: "read" /* Read */,
      returnValueKind: "frozen" /* Frozen */
    })
  ]
);
var DEFAULT_GLOBALS = new Map(REACT_APIS);
for (const name of UNTYPED_GLOBALS) {
  DEFAULT_GLOBALS.set(name, {
    kind: "Poly"
  });
}
for (const [name, type_] of TYPED_GLOBALS) {
  DEFAULT_GLOBALS.set(name, type_);
}
DEFAULT_GLOBALS.set(
  "globalThis",
  addObject(DEFAULT_SHAPES, "globalThis", TYPED_GLOBALS)
);
DEFAULT_GLOBALS.set(
  "global",
  addObject(DEFAULT_SHAPES, "global", TYPED_GLOBALS)
);
function installTypeConfig(globals, shapes, typeConfig, moduleName, loc) {
  var _a, _b, _c, _d;
  switch (typeConfig.kind) {
    case "type": {
      switch (typeConfig.name) {
        case "Array": {
          return { kind: "Object", shapeId: BuiltInArrayId };
        }
        case "MixedReadonly": {
          return { kind: "Object", shapeId: BuiltInMixedReadonlyId };
        }
        case "Primitive": {
          return { kind: "Primitive" };
        }
        case "Ref": {
          return { kind: "Object", shapeId: BuiltInUseRefId };
        }
        case "Any": {
          return { kind: "Poly" };
        }
        default: {
          assertExhaustive(
            typeConfig.name,
            `Unexpected type '${typeConfig.name}'`
          );
        }
      }
    }
    case "function": {
      return addFunction(shapes, [], {
        positionalParams: typeConfig.positionalParams,
        restParam: typeConfig.restParam,
        calleeEffect: typeConfig.calleeEffect,
        returnType: installTypeConfig(
          globals,
          shapes,
          typeConfig.returnType,
          moduleName,
          loc
        ),
        returnValueKind: typeConfig.returnValueKind,
        noAlias: typeConfig.noAlias === true,
        mutableOnlyIfOperandsAreMutable: typeConfig.mutableOnlyIfOperandsAreMutable === true,
        aliasing: typeConfig.aliasing
      });
    }
    case "hook": {
      return addHook(shapes, {
        hookKind: "Custom",
        positionalParams: (_a = typeConfig.positionalParams) != null ? _a : [],
        restParam: (_b = typeConfig.restParam) != null ? _b : "freeze" /* Freeze */,
        calleeEffect: "read" /* Read */,
        returnType: installTypeConfig(
          globals,
          shapes,
          typeConfig.returnType,
          moduleName,
          loc
        ),
        returnValueKind: (_c = typeConfig.returnValueKind) != null ? _c : "frozen" /* Frozen */,
        noAlias: typeConfig.noAlias === true,
        aliasing: typeConfig.aliasing
      });
    }
    case "object": {
      return addObject(
        shapes,
        null,
        Object.entries((_d = typeConfig.properties) != null ? _d : {}).map(([key2, value]) => {
          var _a2;
          const type = installTypeConfig(
            globals,
            shapes,
            value,
            moduleName,
            loc
          );
          const expectHook = isHookName(key2);
          let isHook2 = false;
          if (type.kind === "Function" && type.shapeId !== null) {
            const functionType2 = shapes.get(type.shapeId);
            if (((_a2 = functionType2 == null ? void 0 : functionType2.functionType) == null ? void 0 : _a2.hookKind) !== null) {
              isHook2 = true;
            }
          }
          if (expectHook !== isHook2) {
            CompilerError.throwInvalidConfig({
              reason: `Invalid type configuration for module`,
              description: `Expected type for object property '${key2}' from module '${moduleName}' ${expectHook ? "to be a hook" : "not to be a hook"} based on the property name`,
              loc
            });
          }
          return [key2, type];
        })
      );
    }
    default: {
      assertExhaustive(
        typeConfig,
        `Unexpected type kind '${typeConfig.kind}'`
      );
    }
  }
}
function getReanimatedModuleType(registry) {
  const frozenHooks = [
    "useFrameCallback",
    "useAnimatedStyle",
    "useAnimatedProps",
    "useAnimatedScrollHandler",
    "useAnimatedReaction",
    "useWorkletCallback"
  ];
  const reanimatedType = [];
  for (const hook of frozenHooks) {
    reanimatedType.push([
      hook,
      addHook(registry, {
        positionalParams: [],
        restParam: "freeze" /* Freeze */,
        returnType: { kind: "Poly" },
        returnValueKind: "frozen" /* Frozen */,
        noAlias: true,
        calleeEffect: "read" /* Read */,
        hookKind: "Custom"
      })
    ]);
  }
  const mutableHooks = ["useSharedValue", "useDerivedValue"];
  for (const hook of mutableHooks) {
    reanimatedType.push([
      hook,
      addHook(registry, {
        positionalParams: [],
        restParam: "freeze" /* Freeze */,
        returnType: { kind: "Object", shapeId: ReanimatedSharedValueId },
        returnValueKind: "mutable" /* Mutable */,
        noAlias: true,
        calleeEffect: "read" /* Read */,
        hookKind: "Custom"
      })
    ]);
  }
  const funcs = [
    "withTiming",
    "withSpring",
    "createAnimatedPropAdapter",
    "withDecay",
    "withRepeat",
    "runOnUI",
    "executeOnUIRuntimeSync"
  ];
  for (const fn of funcs) {
    reanimatedType.push([
      fn,
      addFunction(registry, [], {
        positionalParams: [],
        restParam: "read" /* Read */,
        returnType: { kind: "Poly" },
        calleeEffect: "read" /* Read */,
        returnValueKind: "mutable" /* Mutable */,
        noAlias: true
      })
    ]);
  }
  return addObject(registry, null, reanimatedType);
}

// src/HIR/TypeSchema.ts
var import_types = require("@babel/types");
var ObjectPropertiesSchema = z.record(
  z.string(),
  z.lazy(() => TypeSchema)
).refine((record) => {
  return Object.keys(record).every(
    (key2) => key2 === "*" || key2 === "default" || (0, import_types.isValidIdentifier)(key2)
  );
}, 'Expected all "object" property names to be valid identifier, `*` to match any property, of `default` to define a module default export');
var ObjectTypeSchema = z.object({
  kind: z.literal("object"),
  properties: ObjectPropertiesSchema.nullable()
});
var LifetimeIdSchema = z.string().refine((id) => id.startsWith("@"), {
  message: "Placeholder names must start with '@'"
});
var FreezeEffectSchema = z.object({
  kind: z.literal("Freeze"),
  value: LifetimeIdSchema,
  reason: ValueReasonSchema
});
var MutateEffectSchema = z.object({
  kind: z.literal("Mutate"),
  value: LifetimeIdSchema
});
var MutateTransitiveConditionallySchema = z.object({
  kind: z.literal("MutateTransitiveConditionally"),
  value: LifetimeIdSchema
});
var CreateEffectSchema = z.object({
  kind: z.literal("Create"),
  into: LifetimeIdSchema,
  value: ValueKindSchema,
  reason: ValueReasonSchema
});
var AssignEffectSchema = z.object({
  kind: z.literal("Assign"),
  from: LifetimeIdSchema,
  into: LifetimeIdSchema
});
var AliasEffectSchema = z.object({
  kind: z.literal("Alias"),
  from: LifetimeIdSchema,
  into: LifetimeIdSchema
});
var ImmutableCaptureEffectSchema = z.object({
  kind: z.literal("ImmutableCapture"),
  from: LifetimeIdSchema,
  into: LifetimeIdSchema
});
var CaptureEffectSchema = z.object({
  kind: z.literal("Capture"),
  from: LifetimeIdSchema,
  into: LifetimeIdSchema
});
var CreateFromEffectSchema = z.object({
  kind: z.literal("CreateFrom"),
  from: LifetimeIdSchema,
  into: LifetimeIdSchema
});
var ApplyArgSchema = z.union([
  LifetimeIdSchema,
  z.object({
    kind: z.literal("Spread"),
    place: LifetimeIdSchema
  }),
  z.object({
    kind: z.literal("Hole")
  })
]);
var ApplyEffectSchema = z.object({
  kind: z.literal("Apply"),
  receiver: LifetimeIdSchema,
  function: LifetimeIdSchema,
  mutatesFunction: z.boolean(),
  args: z.array(ApplyArgSchema),
  into: LifetimeIdSchema
});
var ImpureEffectSchema = z.object({
  kind: z.literal("Impure"),
  place: LifetimeIdSchema
});
var AliasingEffectSchema = z.union([
  FreezeEffectSchema,
  CreateEffectSchema,
  CreateFromEffectSchema,
  AssignEffectSchema,
  AliasEffectSchema,
  CaptureEffectSchema,
  ImmutableCaptureEffectSchema,
  ImpureEffectSchema,
  MutateEffectSchema,
  MutateTransitiveConditionallySchema,
  ApplyEffectSchema
]);
var AliasingSignatureSchema = z.object({
  receiver: LifetimeIdSchema,
  params: z.array(LifetimeIdSchema),
  rest: LifetimeIdSchema.nullable(),
  returns: LifetimeIdSchema,
  effects: z.array(AliasingEffectSchema),
  temporaries: z.array(LifetimeIdSchema)
});
var FunctionTypeSchema = z.object({
  kind: z.literal("function"),
  positionalParams: z.array(EffectSchema),
  restParam: EffectSchema.nullable(),
  calleeEffect: EffectSchema,
  returnType: z.lazy(() => TypeSchema),
  returnValueKind: ValueKindSchema,
  noAlias: z.boolean().nullable().optional(),
  mutableOnlyIfOperandsAreMutable: z.boolean().nullable().optional(),
  impure: z.boolean().nullable().optional(),
  canonicalName: z.string().nullable().optional(),
  aliasing: AliasingSignatureSchema.nullable().optional()
});
var HookTypeSchema = z.object({
  kind: z.literal("hook"),
  positionalParams: z.array(EffectSchema).nullable().optional(),
  restParam: EffectSchema.nullable().optional(),
  returnType: z.lazy(() => TypeSchema),
  returnValueKind: ValueKindSchema.nullable().optional(),
  noAlias: z.boolean().nullable().optional(),
  aliasing: AliasingSignatureSchema.nullable().optional()
});
var BuiltInTypeSchema = z.union([
  z.literal("Any"),
  z.literal("Ref"),
  z.literal("Array"),
  z.literal("Primitive"),
  z.literal("MixedReadonly")
]);
var TypeReferenceSchema = z.object({
  kind: z.literal("type"),
  name: BuiltInTypeSchema
});
var TypeSchema = z.union([
  ObjectTypeSchema,
  FunctionTypeSchema,
  HookTypeSchema,
  TypeReferenceSchema
]);

// src/Flood/TypeErrors.ts
function unsupportedTypeAnnotation(desc, loc) {
  CompilerError.throwInvalidJS({
    reason: `Typedchecker does not currently support type annotation: ${desc}`,
    loc
  });
}

// src/Flood/Types.ts
var opaqueLinearId = Symbol();
var opaqueTypeParameterId = Symbol();
function makeTypeParameterId(id) {
  CompilerError.invariant(id >= 0 && Number.isInteger(id), {
    reason: "Expected TypeParameterId to be a non-negative integer",
    description: null,
    loc: null,
    suggestions: null
  });
  return id;
}
var opaqueNominalId = Symbol();
function makeNominalId(id) {
  return id;
}
var opaqueVariableId = Symbol();
var DUMMY_NOMINAL = makeNominalId(0);
function convertFlowType(flowType, loc) {
  let nextGenericId = 0;
  function convertFlowTypeImpl(flowType2, loc2, genericEnv, platform, poly = null) {
    var _a, _b, _c;
    switch (flowType2.kind) {
      case "TypeApp": {
        if (flowType2.type.kind === "Def" && flowType2.type.def.kind === "Poly" && flowType2.type.def.t_out.kind === "Def" && flowType2.type.def.t_out.def.kind === "Type" && flowType2.type.def.t_out.def.type.kind === "Opaque" && flowType2.type.def.t_out.def.type.opaquetype.opaque_name === "Client" && flowType2.targs.length === 1) {
          return convertFlowTypeImpl(
            flowType2.targs[0],
            loc2,
            genericEnv,
            "client"
          );
        } else if (flowType2.type.kind === "Def" && flowType2.type.def.kind === "Poly" && flowType2.type.def.t_out.kind === "Def" && flowType2.type.def.t_out.def.kind === "Type" && flowType2.type.def.t_out.def.type.kind === "Opaque" && flowType2.type.def.t_out.def.type.opaquetype.opaque_name === "Server" && flowType2.targs.length === 1) {
          return convertFlowTypeImpl(
            flowType2.targs[0],
            loc2,
            genericEnv,
            "server"
          );
        }
        return Resolved.todo(platform);
      }
      case "Open":
        return Resolved.mixed(platform);
      case "Any":
        return Resolved.todo(platform);
      case "Annot":
        return convertFlowTypeImpl(
          flowType2.type,
          loc2,
          genericEnv,
          platform,
          poly
        );
      case "Opaque": {
        if (flowType2.opaquetype.opaque_name === "Client" && flowType2.opaquetype.super_t != null) {
          return convertFlowTypeImpl(
            flowType2.opaquetype.super_t,
            loc2,
            genericEnv,
            "client"
          );
        }
        if (flowType2.opaquetype.opaque_name === "Server" && flowType2.opaquetype.super_t != null) {
          return convertFlowTypeImpl(
            flowType2.opaquetype.super_t,
            loc2,
            genericEnv,
            "server"
          );
        }
        const t6 = (_a = flowType2.opaquetype.underlying_t) != null ? _a : flowType2.opaquetype.super_t;
        if (t6 != null) {
          return convertFlowTypeImpl(t6, loc2, genericEnv, platform, poly);
        } else {
          return Resolved.todo(platform);
        }
      }
      case "Def": {
        switch (flowType2.def.kind) {
          case "EnumValue":
            return convertFlowTypeImpl(
              flowType2.def.enum_info.representation_t,
              loc2,
              genericEnv,
              platform,
              poly
            );
          case "EnumObject":
            return Resolved.enum(platform);
          case "Empty":
            return Resolved.todo(platform);
          case "Instance": {
            const members = /* @__PURE__ */ new Map();
            for (const key2 in flowType2.def.instance.inst.own_props) {
              const prop = flowType2.def.instance.inst.own_props[key2];
              if (prop.kind === "Field") {
                members.set(
                  key2,
                  convertFlowTypeImpl(prop.type, loc2, genericEnv, platform)
                );
              } else {
                CompilerError.invariant(false, {
                  reason: `Unsupported property kind ${prop.kind}`,
                  loc: GeneratedSource
                });
              }
            }
            return Resolved.class(
              (_b = flowType2.def.instance.inst.class_name) != null ? _b : "[anonymous class]",
              members,
              platform
            );
          }
          case "Type":
            return convertFlowTypeImpl(
              flowType2.def.type,
              loc2,
              genericEnv,
              platform,
              poly
            );
          case "NumGeneral":
          case "SingletonNum":
            return Resolved.number(platform);
          case "StrGeneral":
          case "SingletonStr":
            return Resolved.string(platform);
          case "BoolGeneral":
          case "SingletonBool":
            return Resolved.boolean(platform);
          case "Void":
            return Resolved.void(platform);
          case "Null":
            return Resolved.void(platform);
          case "Mixed":
            return Resolved.mixed(platform);
          case "Arr": {
            if (flowType2.def.arrtype.kind === "ArrayAT" || flowType2.def.arrtype.kind === "ROArrayAT") {
              return Resolved.array(
                convertFlowTypeImpl(
                  flowType2.def.arrtype.elem_t,
                  loc2,
                  genericEnv,
                  platform
                ),
                platform
              );
            } else {
              return Resolved.tuple(
                DUMMY_NOMINAL,
                flowType2.def.arrtype.elements.map(
                  (t6) => convertFlowTypeImpl(t6.t, loc2, genericEnv, platform)
                ),
                platform
              );
            }
          }
          case "Obj": {
            const members = /* @__PURE__ */ new Map();
            for (const key2 in flowType2.def.objtype.props) {
              const prop = flowType2.def.objtype.props[key2];
              if (prop.kind === "Field") {
                members.set(
                  key2,
                  convertFlowTypeImpl(prop.type, loc2, genericEnv, platform)
                );
              } else {
                CompilerError.invariant(false, {
                  reason: `Unsupported property kind ${prop.kind}`,
                  loc: GeneratedSource
                });
              }
            }
            return Resolved.object(DUMMY_NOMINAL, members, platform);
          }
          case "Class": {
            if (flowType2.def.type.kind === "ThisInstance") {
              const members = /* @__PURE__ */ new Map();
              for (const key2 in flowType2.def.type.instance.inst.own_props) {
                const prop = flowType2.def.type.instance.inst.own_props[key2];
                if (prop.kind === "Field") {
                  members.set(
                    key2,
                    convertFlowTypeImpl(prop.type, loc2, genericEnv, platform)
                  );
                } else {
                  CompilerError.invariant(false, {
                    reason: `Unsupported property kind ${prop.kind}`,
                    loc: GeneratedSource
                  });
                }
              }
              return Resolved.class(
                (_c = flowType2.def.type.instance.inst.class_name) != null ? _c : "[anonymous class]",
                members,
                platform
              );
            }
            CompilerError.invariant(false, {
              reason: `Unsupported class instance type ${flowType2.def.type.kind}`,
              loc: GeneratedSource
            });
          }
          case "Fun":
            return Resolved.function(
              poly,
              flowType2.def.funtype.params.map(
                (p) => convertFlowTypeImpl(p.type, loc2, genericEnv, platform)
              ),
              convertFlowTypeImpl(
                flowType2.def.funtype.return_t,
                loc2,
                genericEnv,
                platform
              ),
              platform
            );
          case "Poly": {
            let newEnv = genericEnv;
            const poly2 = flowType2.def.tparams.map((p) => {
              const id = makeTypeParameterId(nextGenericId++);
              const bound = convertFlowTypeImpl(p.bound, loc2, newEnv, platform);
              newEnv = new Map(newEnv);
              newEnv.set(p.name, id);
              return {
                name: p.name,
                id,
                bound
              };
            });
            return convertFlowTypeImpl(
              flowType2.def.t_out,
              loc2,
              newEnv,
              platform,
              poly2
            );
          }
          case "ReactAbstractComponent": {
            const props = /* @__PURE__ */ new Map();
            let children = null;
            const propsType = convertFlowTypeImpl(
              flowType2.def.config,
              loc2,
              genericEnv,
              platform
            );
            if (propsType.type.kind === "Object") {
              propsType.type.members.forEach((v, k) => {
                if (k === "children") {
                  children = v;
                } else {
                  props.set(k, v);
                }
              });
            } else {
              CompilerError.invariant(false, {
                reason: `Unsupported component props type ${propsType.type.kind}`,
                loc: GeneratedSource
              });
            }
            return Resolved.component(props, children, platform);
          }
          case "Renders":
            return Resolved.todo(platform);
          default:
            unsupportedTypeAnnotation("Renders", GeneratedSource);
        }
      }
      case "Generic": {
        const id = genericEnv.get(flowType2.name);
        if (id == null) {
          unsupportedTypeAnnotation(flowType2.name, GeneratedSource);
        }
        return Resolved.generic(
          id,
          platform,
          convertFlowTypeImpl(flowType2.bound, loc2, genericEnv, platform)
        );
      }
      case "Union": {
        const members = flowType2.members.map(
          (t6) => convertFlowTypeImpl(t6, loc2, genericEnv, platform)
        );
        if (members.length === 1) {
          return members[0];
        }
        if (members[0].type.kind === "Number" || members[0].type.kind === "String" || members[0].type.kind === "Boolean") {
          const dupes = members.filter(
            (t6) => t6.type.kind === members[0].type.kind
          );
          if (dupes.length === members.length) {
            return members[0];
          }
        }
        if (members[0].type.kind === "Array" && (members[0].type.element.type.kind === "Number" || members[0].type.element.type.kind === "String" || members[0].type.element.type.kind === "Boolean")) {
          const first = members[0].type.element;
          const dupes = members.filter(
            (t6) => t6.type.kind === "Array" && t6.type.element.type.kind === first.type.kind
          );
          if (dupes.length === members.length) {
            return members[0];
          }
        }
        return Resolved.union(members, platform);
      }
      case "Eval": {
        if (flowType2.destructor.kind === "ReactDRO" || flowType2.destructor.kind === "ReactCheckComponentConfig") {
          return convertFlowTypeImpl(
            flowType2.type,
            loc2,
            genericEnv,
            platform,
            poly
          );
        }
        unsupportedTypeAnnotation(
          `EvalT(${flowType2.destructor.kind})`,
          GeneratedSource
        );
      }
      case "Optional": {
        return Resolved.union(
          [
            convertFlowTypeImpl(flowType2.type, loc2, genericEnv, platform),
            Resolved.void(platform)
          ],
          platform
        );
      }
      default:
        unsupportedTypeAnnotation(flowType2.kind, GeneratedSource);
    }
  }
  return convertFlowTypeImpl(flowType, loc, /* @__PURE__ */ new Map(), "shared");
}
function serializeLoc(location) {
  return `${location.start.line}:${location.start.column}-${location.end.line}:${location.end.column}`;
}
function buildTypeEnvironment(flowOutput) {
  const result = /* @__PURE__ */ new Map();
  for (const item of flowOutput) {
    const loc = {
      start: {
        line: item.loc.start.line,
        column: item.loc.start.column - 1,
        index: item.loc.start.index
      },
      end: item.loc.end,
      filename: item.loc.filename,
      identifierName: item.loc.identifierName
    };
    result.set(serializeLoc(loc), item.type);
  }
  return result;
}
var lastFlowSource = null;
var lastFlowResult = null;
var _nextNominalId, _nextTypeParameterId, _types, _bindings2, _generics, _flowTypes;
var FlowTypeEnv = class {
  constructor() {
    this.moduleEnv = /* @__PURE__ */ new Map();
    __privateAdd(this, _nextNominalId, 0);
    __privateAdd(this, _nextTypeParameterId, 0);
    __privateAdd(this, _types, /* @__PURE__ */ new Map());
    __privateAdd(this, _bindings2, /* @__PURE__ */ new Map());
    __privateAdd(this, _generics, []);
    __privateAdd(this, _flowTypes, /* @__PURE__ */ new Map());
  }
  init(env, source2) {
    CompilerError.invariant(env.config.flowTypeProvider != null, {
      reason: "Expected flowDumpTypes to be defined in environment config",
      loc: GeneratedSource
    });
    let stdout;
    if (source2 === lastFlowSource) {
      stdout = lastFlowResult;
    } else {
      lastFlowSource = source2;
      lastFlowResult = env.config.flowTypeProvider(source2);
      stdout = lastFlowResult;
    }
    const flowTypes = buildTypeEnvironment(stdout);
    const resolvedFlowTypes = /* @__PURE__ */ new Map();
    for (const [loc, type] of flowTypes) {
      if (typeof loc === "symbol") continue;
      resolvedFlowTypes.set(loc, convertFlowType(JSON.parse(type), loc));
    }
    __privateSet(this, _flowTypes, resolvedFlowTypes);
  }
  setType(identifier4, type) {
    if (typeof identifier4.loc !== "symbol" && __privateGet(this, _flowTypes).has(serializeLoc(identifier4.loc))) {
      return;
    }
    __privateGet(this, _types).set(identifier4.id, type);
  }
  getType(identifier4) {
    const result = this.getTypeOrNull(identifier4);
    if (result == null) {
      throw new Error(
        `Type not found for ${identifier4.id}, ${typeof identifier4.loc === "symbol" ? "generated loc" : serializeLoc(identifier4.loc)}`
      );
    }
    return result;
  }
  getTypeOrNull(identifier4) {
    var _a;
    const result = (_a = __privateGet(this, _types).get(identifier4.id)) != null ? _a : null;
    if (result == null && typeof identifier4.loc !== "symbol") {
      const flowType = __privateGet(this, _flowTypes).get(serializeLoc(identifier4.loc));
      return flowType != null ? flowType : null;
    }
    return result;
  }
  getTypeByLoc(loc) {
    if (typeof loc === "symbol") {
      return null;
    }
    const flowType = __privateGet(this, _flowTypes).get(serializeLoc(loc));
    return flowType != null ? flowType : null;
  }
  nextNominalId() {
    return makeNominalId(__privateWrapper(this, _nextNominalId)._++);
  }
  nextTypeParameterId() {
    return makeTypeParameterId(__privateWrapper(this, _nextTypeParameterId)._++);
  }
  addBinding(bindingIdentifier, type) {
    __privateGet(this, _bindings2).set(bindingIdentifier, type);
  }
  resolveBinding(bindingIdentifier) {
    var _a;
    return (_a = __privateGet(this, _bindings2).get(bindingIdentifier)) != null ? _a : null;
  }
  pushGeneric(name, generic) {
    __privateGet(this, _generics).unshift([name, generic]);
  }
  popGeneric(name) {
    for (let i = 0; i < __privateGet(this, _generics).length; i++) {
      if (__privateGet(this, _generics)[i][0] === name) {
        __privateGet(this, _generics).splice(i, 1);
        return;
      }
    }
  }
  /**
   * Look up bound polymorphic types
   * @param name
   * @returns
   */
  getGeneric(name) {
    for (const [eltName, param] of __privateGet(this, _generics)) {
      if (name === eltName) {
        return param;
      }
    }
    return null;
  }
};
_nextNominalId = new WeakMap();
_nextTypeParameterId = new WeakMap();
_types = new WeakMap();
_bindings2 = new WeakMap();
_generics = new WeakMap();
_flowTypes = new WeakMap();
var Primitives = {
  number(platform) {
    return { kind: "Concrete", type: { kind: "Number" }, platform };
  },
  string(platform) {
    return { kind: "Concrete", type: { kind: "String" }, platform };
  },
  boolean(platform) {
    return { kind: "Concrete", type: { kind: "Boolean" }, platform };
  },
  void(platform) {
    return { kind: "Concrete", type: { kind: "Void" }, platform };
  },
  mixed(platform) {
    return { kind: "Concrete", type: { kind: "Mixed" }, platform };
  },
  enum(platform) {
    return { kind: "Concrete", type: { kind: "Enum" }, platform };
  },
  todo(platform) {
    return { kind: "Concrete", type: { kind: "Mixed" }, platform };
  }
};
var Resolved = __spreadProps(__spreadValues({}, Primitives), {
  nullable(type, platform) {
    return { kind: "Concrete", type: { kind: "Nullable", type }, platform };
  },
  array(element, platform) {
    return { kind: "Concrete", type: { kind: "Array", element }, platform };
  },
  set(element, platform) {
    return { kind: "Concrete", type: { kind: "Set", element }, platform };
  },
  map(key2, value, platform) {
    return { kind: "Concrete", type: { kind: "Map", key: key2, value }, platform };
  },
  function(typeParameters, params, returnType, platform) {
    return {
      kind: "Concrete",
      type: { kind: "Function", typeParameters, params, returnType },
      platform
    };
  },
  component(props, children, platform) {
    return {
      kind: "Concrete",
      type: { kind: "Component", props, children },
      platform
    };
  },
  object(id, members, platform) {
    return {
      kind: "Concrete",
      type: {
        kind: "Object",
        id,
        members
      },
      platform
    };
  },
  class(name, members, platform) {
    return {
      kind: "Concrete",
      type: {
        kind: "Instance",
        name,
        members
      },
      platform
    };
  },
  tuple(id, members, platform) {
    return {
      kind: "Concrete",
      type: {
        kind: "Tuple",
        id,
        members
      },
      platform
    };
  },
  generic(id, platform, bound = Primitives.mixed(platform)) {
    return {
      kind: "Concrete",
      type: {
        kind: "Generic",
        id,
        bound
      },
      platform
    };
  },
  union(members, platform) {
    return {
      kind: "Concrete",
      type: {
        kind: "Union",
        members
      },
      platform
    };
  }
});

// src/HIR/Environment.ts
var ReactElementSymbolSchema = z.object({
  elementSymbol: z.union([
    z.literal("react.element"),
    z.literal("react.transitional.element")
  ]),
  globalDevVar: z.string()
});
var ExternalFunctionSchema = z.object({
  // Source for the imported module that exports the `importSpecifierName` functions
  source: z.string(),
  // Unique name for the feature flag test condition, eg `isForgetEnabled_ProjectName`
  importSpecifierName: z.string()
});
var InstrumentationSchema = z.object({
  fn: ExternalFunctionSchema,
  gating: ExternalFunctionSchema.nullable(),
  globalGating: z.string().nullable()
}).refine(
  (opts) => opts.gating != null || opts.globalGating != null,
  "Expected at least one of gating or globalGating"
);
var USE_FIRE_FUNCTION_NAME = "useFire";
var EMIT_FREEZE_GLOBAL_GATING = "__DEV__";
var MacroMethodSchema = z.union([
  z.object({ type: z.literal("wildcard") }),
  z.object({ type: z.literal("name"), name: z.string() })
]);
var MacroSchema = z.union([
  z.string(),
  z.tuple([z.string(), z.array(MacroMethodSchema)])
]);
var HookSchema = z.object({
  /*
   * The effect of arguments to this hook. Describes whether the hook may or may
   * not mutate arguments, etc.
   */
  effectKind: z.nativeEnum(Effect),
  /*
   * The kind of value returned by the hook. Allows indicating that a hook returns
   * a primitive or already-frozen value, which can allow more precise memoization
   * of callers.
   */
  valueKind: z.nativeEnum(ValueKind),
  /*
   * Specifies whether hook arguments may be aliased by other arguments or by the
   * return value of the function. Defaults to false. When enabled, this allows the
   * compiler to avoid memoizing arguments.
   */
  noAlias: z.boolean().default(false),
  /*
   * Specifies whether the hook returns data that is composed of:
   * - undefined
   * - null
   * - boolean
   * - number
   * - string
   * - arrays whose items are also transitiveMixed
   * - objects whose values are also transitiveMixed
   *
   * Many state management and data-fetching APIs return data that meets
   * this criteria since this is JSON + undefined. Forget can compile
   * hooks that return transitively mixed data more optimally because it
   * can make inferences about some method calls (especially array methods
   * like `data.items.map(...)` since these builtin types have few built-in
   * methods.
   */
  transitiveMixedData: z.boolean().default(false)
});
var EnvironmentConfigSchema = z.object({
  customHooks: z.map(z.string(), HookSchema).default(/* @__PURE__ */ new Map()),
  /**
   * A function that, given the name of a module, can optionally return a description
   * of that module's type signature.
   */
  moduleTypeProvider: z.nullable(z.function().args(z.string())).default(null),
  /**
   * A list of functions which the application compiles as macros, where
   * the compiler must ensure they are not compiled to rename the macro or separate the
   * "function" from its argument.
   *
   * For example, Meta has some APIs such as `featureflag("name-of-feature-flag")` which
   * are rewritten by a plugin. Assigning `featureflag` to a temporary would break the
   * plugin since it looks specifically for the name of the function being invoked, not
   * following aliases.
   */
  customMacros: z.nullable(z.array(MacroSchema)).default(null),
  /**
   * Enable a check that resets the memoization cache when the source code of
   * the file changes. This is intended to support hot module reloading (HMR),
   * where the same runtime component instance will be reused across different
   * versions of the component source.
   *
   * When set to
   * - true:  code for HMR support is always generated, regardless of NODE_ENV
   *          or `globalThis.__DEV__`
   * - false: code for HMR support is not generated
   * - null:  (default) code for HMR support is conditionally generated dependent
   *          on `NODE_ENV` and `globalThis.__DEV__` at the time of compilation.
   */
  enableResetCacheOnSourceFileChanges: z.nullable(z.boolean()).default(null),
  /**
   * Enable using information from existing useMemo/useCallback to understand when a value is done
   * being mutated. With this mode enabled, Forget will still discard the actual useMemo/useCallback
   * calls and may memoize slightly differently. However, it will assume that the values produced
   * are not subsequently modified, guaranteeing that the value will be memoized.
   *
   * By preserving guarantees about when values are memoized, this option preserves any existing
   * behavior that depends on referential equality in the original program. Notably, this preserves
   * existing effect behavior (how often effects fire) for effects that rely on referential equality.
   *
   * When disabled, Forget will not only prune useMemo and useCallback calls but also completely ignore
   * them, not using any information from them to guide compilation. Therefore, disabling this flag
   * will produce output that mimics the result from removing all memoization.
   *
   * Our recommendation is to first try running your application with this flag enabled, then attempt
   * to disable this flag and see what changes or breaks. This will mostly likely be effects that
   * depend on referential equality, which can be refactored (TODO guide for this).
   *
   * NOTE: this mode treats freeze as a transitive operation for function expressions. This means
   * that if a useEffect or useCallback references a function value, that function value will be
   * considered frozen, and in turn all of its referenced variables will be considered frozen as well.
   */
  enablePreserveExistingMemoizationGuarantees: z.boolean().default(false),
  /**
   * Validates that all useMemo/useCallback values are also memoized by Forget. This mode can be
   * used with or without @enablePreserveExistingMemoizationGuarantees.
   *
   * With enablePreserveExistingMemoizationGuarantees, this validation enables automatically and
   * verifies that Forget was able to preserve manual memoization semantics under that mode's
   * additional assumptions about the input.
   *
   * With enablePreserveExistingMemoizationGuarantees off, this validation ignores manual memoization
   * when determining program behavior, and only uses information from useMemo/useCallback to check
   * that the memoization was preserved. This can be useful for determining where referential equalities
   * may change under Forget.
   */
  validatePreserveExistingMemoizationGuarantees: z.boolean().default(true),
  /**
   * When this is true, rather than pruning existing manual memoization but ensuring or validating
   * that the memoized values remain memoized, the compiler will simply not prune existing calls to
   * useMemo/useCallback.
   */
  enablePreserveExistingManualUseMemo: z.boolean().default(false),
  // 🌲
  enableForest: z.boolean().default(false),
  /**
   * Enable use of type annotations in the source to drive type inference. By default
   * Forget attemps to infer types using only information that is guaranteed correct
   * given the source, and does not trust user-supplied type annotations. This mode
   * enables trusting user type annotations.
   */
  enableUseTypeAnnotations: z.boolean().default(false),
  /**
   * Allows specifying a function that can populate HIR with type information from
   * Flow
   */
  flowTypeProvider: z.nullable(z.function().args(z.string())).default(null),
  /**
   * Enables inference of optional dependency chains. Without this flag
   * a property chain such as `props?.items?.foo` will infer as a dep on
   * just `props`. With this flag enabled, we'll infer that full path as
   * the dependency.
   */
  enableOptionalDependencies: z.boolean().default(true),
  enableFire: z.boolean().default(false),
  /**
   * Enables inference and auto-insertion of effect dependencies. Takes in an array of
   * configurable module and import pairs to allow for user-land experimentation. For example,
   * [
   *   {
   *     module: 'react',
   *     imported: 'useEffect',
   *     autodepsIndex: 1,
   *   },{
   *     module: 'MyExperimentalEffectHooks',
   *     imported: 'useExperimentalEffect',
   *     autodepsIndex: 2,
   *   },
   * ]
   * would insert dependencies for calls of `useEffect` imported from `react` and calls of
   * useExperimentalEffect` from `MyExperimentalEffectHooks`.
   *
   * `autodepsIndex` tells the compiler which index we expect the AUTODEPS to appear in.
   *  With the configuration above, we'd insert dependencies for `useEffect` if it has two
   *  arguments, and the second is AUTODEPS.
   *
   * Still experimental.
   */
  inferEffectDependencies: z.nullable(
    z.array(
      z.object({
        function: ExternalFunctionSchema,
        autodepsIndex: z.number().min(1, "autodepsIndex must be > 0")
      })
    )
  ).default(null),
  /**
   * Enables inlining ReactElement object literals in place of JSX
   * An alternative to the standard JSX transform which replaces JSX with React's jsxProd() runtime
   * Currently a prod-only optimization, requiring Fast JSX dependencies
   *
   * The symbol configuration is set for backwards compatability with pre-React 19 transforms
   */
  inlineJsxTransform: ReactElementSymbolSchema.nullable().default(null),
  /*
   * Enable validation of hooks to partially check that the component honors the rules of hooks.
   * When disabled, the component is assumed to follow the rules (though the Babel plugin looks
   * for suppressions of the lint rule).
   */
  validateHooksUsage: z.boolean().default(true),
  // Validate that ref values (`ref.current`) are not accessed during render.
  validateRefAccessDuringRender: z.boolean().default(true),
  /*
   * Validates that setState is not unconditionally called during render, as it can lead to
   * infinite loops.
   */
  validateNoSetStateInRender: z.boolean().default(true),
  /**
   * Validates that setState is not called synchronously within an effect (useEffect and friends).
   * Scheduling a setState (with an event listener, subscription, etc) is valid.
   */
  validateNoSetStateInEffects: z.boolean().default(false),
  /**
   * Validates that effects are not used to calculate derived data which could instead be computed
   * during render.
   */
  validateNoDerivedComputationsInEffects: z.boolean().default(false),
  /**
   * Validates against creating JSX within a try block and recommends using an error boundary
   * instead.
   */
  validateNoJSXInTryStatements: z.boolean().default(false),
  /**
   * Validates against dynamically creating components during render.
   */
  validateStaticComponents: z.boolean().default(false),
  /**
   * Validates that the dependencies of all effect hooks are memoized. This helps ensure
   * that Forget does not introduce infinite renders caused by a dependency changing,
   * triggering an effect, which triggers re-rendering, which causes a dependency to change,
   * triggering the effect, etc.
   *
   * Covers useEffect, useLayoutEffect, useInsertionEffect.
   */
  validateMemoizedEffectDependencies: z.boolean().default(false),
  /**
   * Validates that there are no capitalized calls other than those allowed by the allowlist.
   * Calls to capitalized functions are often functions that used to be components and may
   * have lingering hook calls, which makes those calls risky to memoize.
   *
   * You can specify a list of capitalized calls to allowlist using this option. React Compiler
   * always includes its known global functions, including common functions like Boolean and String,
   * in this allowlist. You can enable this validation with no additional allowlisted calls by setting
   * this option to the empty array.
   */
  validateNoCapitalizedCalls: z.nullable(z.array(z.string())).default(null),
  validateBlocklistedImports: z.nullable(z.array(z.string())).default(null),
  /**
   * Validate against impure functions called during render
   */
  validateNoImpureFunctionsInRender: z.boolean().default(false),
  /**
   * Validate against passing mutable functions to hooks
   */
  validateNoFreezingKnownMutableFunctions: z.boolean().default(false),
  /*
   * When enabled, the compiler assumes that hooks follow the Rules of React:
   * - Hooks may memoize computation based on any of their parameters, thus
   *   any arguments to a hook are assumed frozen after calling the hook.
   * - Hooks may memoize the result they return, thus the return value is
   *   assumed frozen.
   */
  enableAssumeHooksFollowRulesOfReact: z.boolean().default(true),
  /**
   * When enabled, the compiler assumes that any values are not subsequently
   * modified after they are captured by a function passed to React. For example,
   * if a value `x` is referenced inside a function expression passed to `useEffect`,
   * then this flag will assume that `x` is not subusequently modified.
   */
  enableTransitivelyFreezeFunctionExpressions: z.boolean().default(true),
  /*
   * Enables codegen mutability debugging. This emits a dev-mode only to log mutations
   * to values that Forget assumes are immutable (for Forget compiled code).
   * For example:
   *   emitFreeze: {
   *     source: 'ReactForgetRuntime',
   *     importSpecifierName: 'makeReadOnly',
   *   }
   *
   * produces:
   *   import {makeReadOnly} from 'ReactForgetRuntime';
   *
   *   function Component(props) {
   *     if (c_0) {
   *       // ...
   *       $[0] = __DEV__ ? makeReadOnly(x) : x;
   *     } else {
   *       x = $[0];
   *     }
   *   }
   */
  enableEmitFreeze: ExternalFunctionSchema.nullable().default(null),
  enableEmitHookGuards: ExternalFunctionSchema.nullable().default(null),
  /**
   * Enable instruction reordering. See InstructionReordering.ts for the details
   * of the approach.
   */
  enableInstructionReordering: z.boolean().default(false),
  /**
   * Enables function outlinining, where anonymous functions that do not close over
   * local variables can be extracted into top-level helper functions.
   */
  enableFunctionOutlining: z.boolean().default(true),
  /**
   * If enabled, this will outline nested JSX into a separate component.
   *
   * This will enable the compiler to memoize the separate component, giving us
   * the same behavior as compiling _within_ the callback.
   *
   * ```
   * function Component(countries, onDelete) {
   *   const name = useFoo();
   *   return countries.map(() => {
   *     return (
   *       <Foo>
   *         <Bar>{name}</Bar>
   *         <Button onclick={onDelete}>delete</Button>
   *       </Foo>
   *     );
   *   });
   * }
   * ```
   *
   * will be transpiled to:
   *
   * ```
   * function Component(countries, onDelete) {
   *   const name = useFoo();
   *   return countries.map(() => {
   *     return (
   *       <Temp name={name} onDelete={onDelete} />
   *     );
   *   });
   * }
   *
   * function Temp({name, onDelete}) {
   *   return (
   *     <Foo>
   *       <Bar>{name}</Bar>
   *       <Button onclick={onDelete}>delete</Button>
   *     </Foo>
   *   );
   * }
   *
   * Both, `Component` and `Temp` will then be memoized by the compiler.
   *
   * With this change, when `countries` is updated by adding one single value,
   * only the newly added value is re-rendered and not the entire list.
   */
  enableJsxOutlining: z.boolean().default(false),
  /*
   * Enables instrumentation codegen. This emits a dev-mode only call to an
   * instrumentation function, for components and hooks that Forget compiles.
   * For example:
   *   instrumentForget: {
   *     import: {
   *       source: 'react-compiler-runtime',
   *       importSpecifierName: 'useRenderCounter',
   *      }
   *   }
   *
   * produces:
   *   import {useRenderCounter} from 'react-compiler-runtime';
   *
   *   function Component(props) {
   *     if (__DEV__) {
   *        useRenderCounter("Component", "/filepath/filename.js");
   *     }
   *     // ...
   *   }
   *
   */
  enableEmitInstrumentForget: InstrumentationSchema.nullable().default(null),
  // Enable validation of mutable ranges
  assertValidMutableRanges: z.boolean().default(false),
  /*
   * Enable emitting "change variables" which store the result of whether a particular
   * reactive scope dependency has changed since the scope was last executed.
   *
   * Ex:
   * ```
   * const c_0 = $[0] !== input; // change variable
   * let output;
   * if (c_0) ...
   * ```
   *
   * Defaults to false, where the comparison is inlined:
   *
   * ```
   * let output;
   * if ($[0] !== input) ...
   * ```
   */
  enableChangeVariableCodegen: z.boolean().default(false),
  /**
   * Enable emitting comments that explain Forget's output, and which
   * values are being checked and which values produced by each memo block.
   *
   * Intended for use in demo purposes (incl playground)
   */
  enableMemoizationComments: z.boolean().default(false),
  /**
   * [TESTING ONLY] Throw an unknown exception during compilation to
   * simulate unexpected exceptions e.g. errors from babel functions.
   */
  throwUnknownException__testonly: z.boolean().default(false),
  /**
   * Enables deps of a function epxression to be treated as conditional. This
   * makes sure we don't load a dep when it's a property (to check if it has
   * changed) and instead check the receiver.
   *
   * This makes sure we don't end up throwing when the reciver is null. Consider
   * this code:
   *
   * ```
   * function getLength() {
   *   return props.bar.length;
   * }
   * ```
   *
   * It's only safe to memoize `getLength` against props, not props.bar, as
   * props.bar could be null when this `getLength` function is created.
   *
   * This does cause the memoization to now be coarse grained, which is
   * non-ideal.
   */
  enableTreatFunctionDepsAsConditional: z.boolean().default(false),
  /**
   * When true, always act as though the dependencies of a memoized value
   * have changed. This makes the compiler not actually perform any optimizations,
   * but is useful for debugging. Implicitly also sets
   * @enablePreserveExistingManualUseMemo, because otherwise memoization in the
   * original source will be disabled as well.
   */
  disableMemoizationForDebugging: z.boolean().default(false),
  /**
   * When true, rather using memoized values, the compiler will always re-compute
   * values, and then use a heuristic to compare the memoized value to the newly
   * computed one. This detects cases where rules of react violations may cause the
   * compiled code to behave differently than the original.
   */
  enableChangeDetectionForDebugging: ExternalFunctionSchema.nullable().default(null),
  /**
   * The react native re-animated library uses custom Babel transforms that
   * requires the calls to library API remain unmodified.
   *
   * If this flag is turned on, the React compiler will use custom type
   * definitions for reanimated library to make it's Babel plugin work
   * with the compiler.
   */
  enableCustomTypeDefinitionForReanimated: z.boolean().default(false),
  /**
   * If specified, this value is used as a pattern for determing which global values should be
   * treated as hooks. The pattern should have a single capture group, which will be used as
   * the hook name for the purposes of resolving hook definitions (for builtin hooks)_.
   *
   * For example, by default `React$useState` would not be treated as a hook. By specifying
   * `hookPattern: 'React$(\w+)'`, the compiler will treat this value equivalently to `useState()`.
   *
   * This setting is intended for cases where Forget is compiling code that has been prebundled
   * and identifiers have been changed.
   */
  hookPattern: z.string().nullable().default(null),
  /**
   * If enabled, this will treat objects named as `ref` or if their names end with the substring `Ref`,
   * and contain a property named `current`, as React refs.
   *
   * ```
   * const ref = useMyRef();
   * const myRef = useMyRef2();
   * useEffect(() => {
   *   ref.current = ...;
   *   myRef.current = ...;
   * })
   * ```
   *
   * Here the variables `ref` and `myRef` will be typed as Refs.
   */
  enableTreatRefLikeIdentifiersAsRefs: z.boolean().default(true),
  /*
   * If specified a value, the compiler lowers any calls to `useContext` to use
   * this value as the callee.
   *
   * A selector function is compiled and passed as an argument along with the
   * context to this function call.
   *
   * The compiler automatically figures out the keys by looking for the immediate
   * destructuring of the return value from the useContext call. In the future,
   * this can be extended to different kinds of context access like property
   * loads and accesses over multiple statements as well.
   *
   * ```
   * // input
   * const {foo, bar} = useContext(MyContext);
   *
   * // output
   * const {foo, bar} = useCompiledContext(MyContext, (c) => [c.foo, c.bar]);
   * ```
   */
  lowerContextAccess: ExternalFunctionSchema.nullable().default(null),
  /**
   * If enabled, will validate useMemos that don't return any values:
   *
   * Valid:
   *   useMemo(() => foo, [foo]);
   *   useMemo(() => { return foo }, [foo]);
   * Invalid:
   *   useMemo(() => { ... }, [...]);
   */
  validateNoVoidUseMemo: z.boolean().default(false),
  /**
   * Validates that Components/Hooks are always defined at module level. This prevents scope
   * reference errors that occur when the compiler attempts to optimize the nested component/hook
   * while its parent function remains uncompiled.
   */
  validateNoDynamicallyCreatedComponentsOrHooks: z.boolean().default(false)
});
var _globals, _shapes, _moduleTypes, _nextIdentifer, _nextBlock, _nextScope, _scope, _outlinedFunctions, _contextIdentifiers, _hoistedIdentifiers, _flowTypeEnvironment, _Environment_instances, resolveModuleType_fn, isKnownReactModule_fn, getCustomHookType_fn;
var Environment2 = class {
  constructor(scope, fnType, compilerMode, config, contextIdentifiers, parentFunction, logger, filename, code, programContext) {
    __privateAdd(this, _Environment_instances);
    __privateAdd(this, _globals);
    __privateAdd(this, _shapes);
    __privateAdd(this, _moduleTypes, /* @__PURE__ */ new Map());
    __privateAdd(this, _nextIdentifer, 0);
    __privateAdd(this, _nextBlock, 0);
    __privateAdd(this, _nextScope, 0);
    __privateAdd(this, _scope);
    __privateAdd(this, _outlinedFunctions, []);
    this.inferredEffectLocations = /* @__PURE__ */ new Set();
    __privateAdd(this, _contextIdentifiers);
    __privateAdd(this, _hoistedIdentifiers);
    __privateAdd(this, _flowTypeEnvironment);
    __privateSet(this, _scope, scope);
    this.fnType = fnType;
    this.compilerMode = compilerMode;
    this.config = config;
    this.filename = filename;
    this.code = code;
    this.logger = logger;
    this.programContext = programContext;
    __privateSet(this, _shapes, new Map(DEFAULT_SHAPES));
    __privateSet(this, _globals, new Map(DEFAULT_GLOBALS));
    this.hasFireRewrite = false;
    this.hasInferredEffect = false;
    if (config.disableMemoizationForDebugging && config.enableChangeDetectionForDebugging != null) {
      CompilerError.throwInvalidConfig({
        reason: `Invalid environment config: the 'disableMemoizationForDebugging' and 'enableChangeDetectionForDebugging' options cannot be used together`,
        description: null,
        loc: null,
        suggestions: null
      });
    }
    for (const [hookName, hook] of this.config.customHooks) {
      CompilerError.invariant(!__privateGet(this, _globals).has(hookName), {
        reason: `[Globals] Found existing definition in global registry for custom hook ${hookName}`,
        description: null,
        loc: null,
        suggestions: null
      });
      __privateGet(this, _globals).set(
        hookName,
        addHook(__privateGet(this, _shapes), {
          positionalParams: [],
          restParam: hook.effectKind,
          returnType: hook.transitiveMixedData ? { kind: "Object", shapeId: BuiltInMixedReadonlyId } : { kind: "Poly" },
          returnValueKind: hook.valueKind,
          calleeEffect: "read" /* Read */,
          hookKind: "Custom",
          noAlias: hook.noAlias
        })
      );
    }
    if (config.enableCustomTypeDefinitionForReanimated) {
      const reanimatedModuleType = getReanimatedModuleType(__privateGet(this, _shapes));
      __privateGet(this, _moduleTypes).set(REANIMATED_MODULE_NAME, reanimatedModuleType);
    }
    this.parentFunction = parentFunction;
    __privateSet(this, _contextIdentifiers, contextIdentifiers);
    __privateSet(this, _hoistedIdentifiers, /* @__PURE__ */ new Set());
    if (config.flowTypeProvider != null) {
      __privateSet(this, _flowTypeEnvironment, new FlowTypeEnv());
      CompilerError.invariant(code != null, {
        reason: "Expected Environment to be initialized with source code when a Flow type provider is specified",
        loc: null
      });
      __privateGet(this, _flowTypeEnvironment).init(this, code);
    } else {
      __privateSet(this, _flowTypeEnvironment, null);
    }
  }
  get typeContext() {
    CompilerError.invariant(__privateGet(this, _flowTypeEnvironment) != null, {
      reason: "Flow type environment not initialized",
      loc: null
    });
    return __privateGet(this, _flowTypeEnvironment);
  }
  get isInferredMemoEnabled() {
    return this.compilerMode !== "no_inferred_memo";
  }
  get nextIdentifierId() {
    return makeIdentifierId(__privateWrapper(this, _nextIdentifer)._++);
  }
  get nextBlockId() {
    return makeBlockId(__privateWrapper(this, _nextBlock)._++);
  }
  get nextScopeId() {
    return makeScopeId(__privateWrapper(this, _nextScope)._++);
  }
  get scope() {
    return __privateGet(this, _scope);
  }
  logErrors(errors) {
    if (errors.isOk() || this.logger == null) {
      return;
    }
    for (const error of errors.unwrapErr().details) {
      this.logger.logEvent(this.filename, {
        kind: "CompileError",
        detail: error,
        fnLoc: null
      });
    }
  }
  isContextIdentifier(node) {
    return __privateGet(this, _contextIdentifiers).has(node);
  }
  isHoistedIdentifier(node) {
    return __privateGet(this, _hoistedIdentifiers).has(node);
  }
  generateGloballyUniqueIdentifierName(name) {
    const identifierNode = __privateGet(this, _scope).generateUidIdentifier(name != null ? name : void 0);
    return makeIdentifierName(identifierNode.name);
  }
  outlineFunction(fn, type) {
    __privateGet(this, _outlinedFunctions).push({ fn, type });
  }
  getOutlinedFunctions() {
    return __privateGet(this, _outlinedFunctions);
  }
  getGlobalDeclaration(binding, loc) {
    var _a, _b, _c, _d;
    if (this.config.hookPattern != null) {
      const match = new RegExp(this.config.hookPattern).exec(binding.name);
      if (match != null && typeof match[1] === "string" && isHookName(match[1])) {
        const resolvedName = match[1];
        return (_a = __privateGet(this, _globals).get(resolvedName)) != null ? _a : __privateMethod(this, _Environment_instances, getCustomHookType_fn).call(this);
      }
    }
    switch (binding.kind) {
      case "ModuleLocal": {
        return isHookName(binding.name) ? __privateMethod(this, _Environment_instances, getCustomHookType_fn).call(this) : null;
      }
      case "Global": {
        return (_b = __privateGet(this, _globals).get(binding.name)) != null ? _b : isHookName(binding.name) ? __privateMethod(this, _Environment_instances, getCustomHookType_fn).call(this) : null;
      }
      case "ImportSpecifier": {
        if (__privateMethod(this, _Environment_instances, isKnownReactModule_fn).call(this, binding.module)) {
          return (_c = __privateGet(this, _globals).get(binding.imported)) != null ? _c : isHookName(binding.imported) || isHookName(binding.name) ? __privateMethod(this, _Environment_instances, getCustomHookType_fn).call(this) : null;
        } else {
          const moduleType = __privateMethod(this, _Environment_instances, resolveModuleType_fn).call(this, binding.module, loc);
          if (moduleType !== null) {
            const importedType = this.getPropertyType(
              moduleType,
              binding.imported
            );
            if (importedType != null) {
              const expectHook = isHookName(binding.imported);
              const isHook2 = getHookKindForType(this, importedType) != null;
              if (expectHook !== isHook2) {
                CompilerError.throwInvalidConfig({
                  reason: `Invalid type configuration for module`,
                  description: `Expected type for \`import {${binding.imported}} from '${binding.module}'\` ${expectHook ? "to be a hook" : "not to be a hook"} based on the exported name`,
                  loc
                });
              }
              return importedType;
            }
          }
          return isHookName(binding.imported) || isHookName(binding.name) ? __privateMethod(this, _Environment_instances, getCustomHookType_fn).call(this) : null;
        }
      }
      case "ImportDefault":
      case "ImportNamespace": {
        if (__privateMethod(this, _Environment_instances, isKnownReactModule_fn).call(this, binding.module)) {
          return (_d = __privateGet(this, _globals).get(binding.name)) != null ? _d : isHookName(binding.name) ? __privateMethod(this, _Environment_instances, getCustomHookType_fn).call(this) : null;
        } else {
          const moduleType = __privateMethod(this, _Environment_instances, resolveModuleType_fn).call(this, binding.module, loc);
          if (moduleType !== null) {
            let importedType = null;
            if (binding.kind === "ImportDefault") {
              const defaultType = this.getPropertyType(moduleType, "default");
              if (defaultType !== null) {
                importedType = defaultType;
              }
            } else {
              importedType = moduleType;
            }
            if (importedType !== null) {
              const expectHook = isHookName(binding.module);
              const isHook2 = getHookKindForType(this, importedType) != null;
              if (expectHook !== isHook2) {
                CompilerError.throwInvalidConfig({
                  reason: `Invalid type configuration for module`,
                  description: `Expected type for \`import ... from '${binding.module}'\` ${expectHook ? "to be a hook" : "not to be a hook"} based on the module name`,
                  loc
                });
              }
              return importedType;
            }
          }
          return isHookName(binding.name) ? __privateMethod(this, _Environment_instances, getCustomHookType_fn).call(this) : null;
        }
      }
    }
  }
  getFallthroughPropertyType(receiver, _property) {
    var _a;
    let shapeId = null;
    if (receiver.kind === "Object" || receiver.kind === "Function") {
      shapeId = receiver.shapeId;
    }
    if (shapeId !== null) {
      const shape = __privateGet(this, _shapes).get(shapeId);
      CompilerError.invariant(shape !== void 0, {
        reason: `[HIR] Forget internal error: cannot resolve shape ${shapeId}`,
        description: null,
        loc: null,
        suggestions: null
      });
      return (_a = shape.properties.get("*")) != null ? _a : null;
    }
    return null;
  }
  getPropertyType(receiver, property) {
    var _a, _b, _c;
    let shapeId = null;
    if (receiver.kind === "Object" || receiver.kind === "Function") {
      shapeId = receiver.shapeId;
    }
    if (shapeId !== null) {
      const shape = __privateGet(this, _shapes).get(shapeId);
      CompilerError.invariant(shape !== void 0, {
        reason: `[HIR] Forget internal error: cannot resolve shape ${shapeId}`,
        description: null,
        loc: null,
        suggestions: null
      });
      if (typeof property === "string") {
        return (_b = (_a = shape.properties.get(property)) != null ? _a : shape.properties.get("*")) != null ? _b : isHookName(property) ? __privateMethod(this, _Environment_instances, getCustomHookType_fn).call(this) : null;
      } else {
        return (_c = shape.properties.get("*")) != null ? _c : null;
      }
    } else if (typeof property === "string" && isHookName(property)) {
      return __privateMethod(this, _Environment_instances, getCustomHookType_fn).call(this);
    }
    return null;
  }
  getFunctionSignature(type) {
    const { shapeId } = type;
    if (shapeId !== null) {
      const shape = __privateGet(this, _shapes).get(shapeId);
      CompilerError.invariant(shape !== void 0, {
        reason: `[HIR] Forget internal error: cannot resolve shape ${shapeId}`,
        description: null,
        loc: null,
        suggestions: null
      });
      return shape.functionType;
    }
    return null;
  }
  addHoistedIdentifier(node) {
    __privateGet(this, _contextIdentifiers).add(node);
    __privateGet(this, _hoistedIdentifiers).add(node);
  }
};
_globals = new WeakMap();
_shapes = new WeakMap();
_moduleTypes = new WeakMap();
_nextIdentifer = new WeakMap();
_nextBlock = new WeakMap();
_nextScope = new WeakMap();
_scope = new WeakMap();
_outlinedFunctions = new WeakMap();
_contextIdentifiers = new WeakMap();
_hoistedIdentifiers = new WeakMap();
_flowTypeEnvironment = new WeakMap();
_Environment_instances = new WeakSet();
resolveModuleType_fn = function(moduleName, loc) {
  let moduleType = __privateGet(this, _moduleTypes).get(moduleName);
  if (moduleType === void 0) {
    if (this.config.moduleTypeProvider == null) {
      return null;
    }
    const unparsedModuleConfig = this.config.moduleTypeProvider(moduleName);
    if (unparsedModuleConfig != null) {
      const parsedModuleConfig = TypeSchema.safeParse(unparsedModuleConfig);
      if (!parsedModuleConfig.success) {
        CompilerError.throwInvalidConfig({
          reason: `Could not parse module type, the configured \`moduleTypeProvider\` function returned an invalid module description`,
          description: parsedModuleConfig.error.toString(),
          loc
        });
      }
      const moduleConfig = parsedModuleConfig.data;
      moduleType = installTypeConfig(
        __privateGet(this, _globals),
        __privateGet(this, _shapes),
        moduleConfig,
        moduleName,
        loc
      );
    } else {
      moduleType = null;
    }
    __privateGet(this, _moduleTypes).set(moduleName, moduleType);
  }
  return moduleType;
};
isKnownReactModule_fn = function(moduleName) {
  return moduleName.toLowerCase() === "react" || moduleName.toLowerCase() === "react-dom";
};
getCustomHookType_fn = function() {
  if (this.config.enableAssumeHooksFollowRulesOfReact) {
    return DefaultNonmutatingHook;
  } else {
    return DefaultMutatingHook;
  }
};
Environment2.knownReactModules = ["react", "react-dom"];
var REANIMATED_MODULE_NAME = "react-native-reanimated";
function isHookName(name) {
  return /^use[A-Z0-9]/.test(name);
}
function parseEnvironmentConfig(partialConfig) {
  const config = EnvironmentConfigSchema.safeParse(partialConfig);
  if (config.success) {
    return Ok(config.data);
  } else {
    return Err(config.error);
  }
}
function validateEnvironmentConfig(partialConfig) {
  const config = EnvironmentConfigSchema.safeParse(partialConfig);
  if (config.success) {
    return config.data;
  }
  CompilerError.throwInvalidConfig({
    reason: "Could not validate environment config. Update React Compiler config to fix the error",
    description: `${fromZodError(config.error)}`,
    loc: null,
    suggestions: null
  });
}
function tryParseExternalFunction(maybeExternalFunction) {
  const externalFunction = ExternalFunctionSchema.safeParse(
    maybeExternalFunction
  );
  if (externalFunction.success) {
    return externalFunction.data;
  }
  CompilerError.throwInvalidConfig({
    reason: "Could not parse external function. Update React Compiler config to fix the error",
    description: `${fromZodError(externalFunction.error)}`,
    loc: null,
    suggestions: null
  });
}
var DEFAULT_EXPORT = "default";

// src/HIR/MergeConsecutiveBlocks.ts
function mergeConsecutiveBlocks(fn) {
  const merged = new MergedBlocks();
  const fallthroughBlocks = /* @__PURE__ */ new Set();
  for (const [, block] of fn.body.blocks) {
    const fallthrough = terminalFallthrough(block.terminal);
    if (fallthrough !== null) {
      fallthroughBlocks.add(fallthrough);
    }
    for (const instr of block.instructions) {
      if (instr.value.kind === "FunctionExpression" || instr.value.kind === "ObjectMethod") {
        mergeConsecutiveBlocks(instr.value.loweredFunc.func);
      }
    }
    if (
      // Can only merge blocks with a single predecessor
      block.preds.size !== 1 || // Value blocks cannot merge
      block.kind !== "block" || // Merging across fallthroughs could move the predecessor out of its block scope
      fallthroughBlocks.has(block.id)
    ) {
      continue;
    }
    const originalPredecessorId = Array.from(block.preds)[0];
    const predecessorId = merged.get(originalPredecessorId);
    const predecessor = fn.body.blocks.get(predecessorId);
    CompilerError.invariant(predecessor !== void 0, {
      reason: `Expected predecessor ${predecessorId} to exist`,
      description: null,
      loc: null,
      suggestions: null
    });
    if (predecessor.terminal.kind !== "goto" || predecessor.kind !== "block") {
      continue;
    }
    for (const phi of block.phis) {
      CompilerError.invariant(phi.operands.size === 1, {
        reason: `Found a block with a single predecessor but where a phi has multiple (${phi.operands.size}) operands`,
        description: null,
        loc: null,
        suggestions: null
      });
      const operand = Array.from(phi.operands.values())[0];
      const lvalue = {
        kind: "Identifier",
        identifier: phi.place.identifier,
        effect: "mutate?" /* ConditionallyMutate */,
        reactive: false,
        loc: GeneratedSource
      };
      const instr = {
        id: predecessor.terminal.id,
        lvalue: __spreadValues({}, lvalue),
        value: {
          kind: "LoadLocal",
          place: __spreadValues({}, operand),
          loc: GeneratedSource
        },
        effects: [{ kind: "Alias", from: __spreadValues({}, operand), into: __spreadValues({}, lvalue) }],
        loc: GeneratedSource
      };
      predecessor.instructions.push(instr);
    }
    predecessor.instructions.push(...block.instructions);
    predecessor.terminal = block.terminal;
    merged.merge(block.id, predecessorId);
    fn.body.blocks.delete(block.id);
  }
  for (const [, block] of fn.body.blocks) {
    for (const phi of block.phis) {
      for (const [predecessorId, operand] of phi.operands) {
        const mapped = merged.get(predecessorId);
        if (mapped !== predecessorId) {
          phi.operands.delete(predecessorId);
          phi.operands.set(mapped, operand);
        }
      }
    }
  }
  markPredecessors(fn.body);
  for (const [, { terminal }] of fn.body.blocks) {
    if (terminalHasFallthrough(terminal)) {
      terminal.fallthrough = merged.get(terminal.fallthrough);
    }
  }
}
var _map;
var MergedBlocks = class {
  constructor() {
    __privateAdd(this, _map, /* @__PURE__ */ new Map());
  }
  // Record that @param block was merged into @param into.
  merge(block, into) {
    const target = this.get(into);
    __privateGet(this, _map).set(block, target);
  }
  /*
   * Get the id of the block that @param block has been merged into.
   * This is transitive, in the case that eg @param block was merged
   * into a block which later merged into another block.
   */
  get(block) {
    var _a;
    let current = block;
    while (__privateGet(this, _map).has(current)) {
      current = (_a = __privateGet(this, _map).get(current)) != null ? _a : current;
    }
    return current;
  }
};
_map = new WeakMap();

// src/Utils/DisjointSet.ts
var _entries;
var DisjointSet = class {
  constructor() {
    __privateAdd(this, _entries, /* @__PURE__ */ new Map());
  }
  /*
   * Updates the graph to reflect that the given @param items form a set,
   * linking any previous sets that the items were part of into a single
   * set.
   */
  union(items) {
    const first = items.shift();
    CompilerError.invariant(first != null, {
      reason: "Expected set to be non-empty",
      description: null,
      loc: null,
      suggestions: null
    });
    let root2 = this.find(first);
    if (root2 == null) {
      root2 = first;
      __privateGet(this, _entries).set(first, first);
    }
    for (const item of items) {
      let itemParent = __privateGet(this, _entries).get(item);
      if (itemParent == null) {
        __privateGet(this, _entries).set(item, root2);
        continue;
      } else if (itemParent === root2) {
        continue;
      } else {
        let current = item;
        while (itemParent !== root2) {
          __privateGet(this, _entries).set(current, root2);
          current = itemParent;
          itemParent = __privateGet(this, _entries).get(current);
        }
      }
    }
  }
  /*
   * Finds the set to which the given @param item is associated, if @param item
   * is present in this set. If item is not present, returns null.
   *
   * Note that the returned value may be any item in the set to which the input
   * belongs: the only guarantee is that all items in a set will return the same
   * value in between calls to `union()`.
   */
  find(item) {
    if (!__privateGet(this, _entries).has(item)) {
      return null;
    }
    const parent = __privateGet(this, _entries).get(item);
    if (parent === item) {
      return item;
    }
    const root2 = this.find(parent);
    __privateGet(this, _entries).set(item, root2);
    return root2;
  }
  has(item) {
    return __privateGet(this, _entries).has(item);
  }
  /*
   * Forces the set into canonical form, ie with all items pointing directly to
   * their root, and returns a Map representing the mapping of items to their roots.
   */
  canonicalize() {
    const entries = /* @__PURE__ */ new Map();
    for (const item of __privateGet(this, _entries).keys()) {
      const root2 = this.find(item);
      entries.set(item, root2);
    }
    return entries;
  }
  /*
   * Calls the provided callback once for each item in the disjoint set,
   * passing the @param item and the @param group to which it belongs.
   */
  forEach(fn) {
    for (const item of __privateGet(this, _entries).keys()) {
      const group = this.find(item);
      fn(item, group);
    }
  }
  buildSets() {
    const ids = /* @__PURE__ */ new Map();
    const sets = /* @__PURE__ */ new Map();
    this.forEach((identifier4, groupIdentifier) => {
      let id = ids.get(groupIdentifier);
      if (id == null) {
        id = ids.size;
        ids.set(groupIdentifier, id);
      }
      let set = sets.get(id);
      if (set === void 0) {
        set = /* @__PURE__ */ new Set();
        sets.set(id, set);
      }
      set.add(identifier4);
    });
    return [...sets.values()];
  }
  get size() {
    return __privateGet(this, _entries).size;
  }
};
_entries = new WeakMap();

// src/ReactiveScopes/InferReactiveScopeVariables.ts
function inferReactiveScopeVariables(fn) {
  var _a, _b;
  const scopeIdentifiers = findDisjointMutableValues(fn);
  const scopes = /* @__PURE__ */ new Map();
  scopeIdentifiers.forEach((identifier4, groupIdentifier) => {
    let scope = scopes.get(groupIdentifier);
    if (scope === void 0) {
      scope = {
        id: fn.env.nextScopeId,
        range: identifier4.mutableRange,
        dependencies: /* @__PURE__ */ new Set(),
        declarations: /* @__PURE__ */ new Map(),
        reassignments: /* @__PURE__ */ new Set(),
        earlyReturnValue: null,
        merged: /* @__PURE__ */ new Set(),
        loc: identifier4.loc
      };
      scopes.set(groupIdentifier, scope);
    } else {
      if (scope.range.start === 0) {
        scope.range.start = identifier4.mutableRange.start;
      } else if (identifier4.mutableRange.start !== 0) {
        scope.range.start = makeInstructionId(
          Math.min(scope.range.start, identifier4.mutableRange.start)
        );
      }
      scope.range.end = makeInstructionId(
        Math.max(scope.range.end, identifier4.mutableRange.end)
      );
      scope.loc = mergeLocation(scope.loc, identifier4.loc);
    }
    identifier4.scope = scope;
    identifier4.mutableRange = scope.range;
  });
  let maxInstruction = 0;
  for (const [, block] of fn.body.blocks) {
    for (const instr of block.instructions) {
      maxInstruction = makeInstructionId(Math.max(maxInstruction, instr.id));
    }
    maxInstruction = makeInstructionId(
      Math.max(maxInstruction, block.terminal.id)
    );
  }
  for (const [, scope] of scopes) {
    if (scope.range.start === 0 || scope.range.end === 0 || maxInstruction === 0 || scope.range.end > maxInstruction + 1) {
      (_b = (_a = fn.env.logger) == null ? void 0 : _a.debugLogIRs) == null ? void 0 : _b.call(_a, {
        kind: "hir",
        name: "InferReactiveScopeVariables (invalid scope)",
        value: fn
      });
      CompilerError.invariant(false, {
        reason: `Invalid mutable range for scope`,
        loc: GeneratedSource,
        description: `Scope @${scope.id} has range [${scope.range.start}:${scope.range.end}] but the valid range is [1:${maxInstruction + 1}]`
      });
    }
  }
}
function mergeLocation(l, r) {
  if (l === GeneratedSource) {
    return r;
  } else if (r === GeneratedSource) {
    return l;
  } else {
    return {
      filename: l.filename,
      identifierName: l.identifierName,
      start: {
        index: Math.min(l.start.index, r.start.index),
        line: Math.min(l.start.line, r.start.line),
        column: Math.min(l.start.column, r.start.column)
      },
      end: {
        index: Math.max(l.end.index, r.end.index),
        line: Math.max(l.end.line, r.end.line),
        column: Math.max(l.end.column, r.end.column)
      }
    };
  }
}
function isMutable2(instr, place) {
  return inRange(instr, place.identifier.mutableRange);
}
function inRange({ id }, range) {
  return id >= range.start && id < range.end;
}
function mayAllocate(_env4, instruction) {
  const { value } = instruction;
  switch (value.kind) {
    case "Destructure": {
      return doesPatternContainSpreadElement(value.lvalue.pattern);
    }
    case "PostfixUpdate":
    case "PrefixUpdate":
    case "Await":
    case "DeclareLocal":
    case "DeclareContext":
    case "StoreLocal":
    case "LoadGlobal":
    case "MetaProperty":
    case "TypeCastExpression":
    case "LoadLocal":
    case "LoadContext":
    case "StoreContext":
    case "PropertyDelete":
    case "ComputedLoad":
    case "ComputedDelete":
    case "JSXText":
    case "TemplateLiteral":
    case "Primitive":
    case "GetIterator":
    case "IteratorNext":
    case "NextPropertyOf":
    case "Debugger":
    case "StartMemoize":
    case "FinishMemoize":
    case "UnaryExpression":
    case "BinaryExpression":
    case "PropertyLoad":
    case "StoreGlobal": {
      return false;
    }
    case "TaggedTemplateExpression":
    case "CallExpression":
    case "MethodCall": {
      return instruction.lvalue.identifier.type.kind !== "Primitive";
    }
    case "RegExpLiteral":
    case "PropertyStore":
    case "ComputedStore":
    case "ArrayExpression":
    case "JsxExpression":
    case "JsxFragment":
    case "NewExpression":
    case "ObjectExpression":
    case "UnsupportedNode":
    case "ObjectMethod":
    case "FunctionExpression": {
      return true;
    }
    default: {
      assertExhaustive(
        value,
        `Unexpected value kind \`${value.kind}\``
      );
    }
  }
}
function findDisjointMutableValues(fn) {
  var _a, _b;
  const scopeIdentifiers = new DisjointSet();
  const declarations = /* @__PURE__ */ new Map();
  function declareIdentifier(lvalue) {
    if (!declarations.has(lvalue.identifier.declarationId)) {
      declarations.set(lvalue.identifier.declarationId, lvalue.identifier);
    }
  }
  for (const [_, block] of fn.body.blocks) {
    for (const phi of block.phis) {
      if (phi.place.identifier.mutableRange.start + 1 !== phi.place.identifier.mutableRange.end && phi.place.identifier.mutableRange.end > ((_b = (_a = block.instructions.at(0)) == null ? void 0 : _a.id) != null ? _b : block.terminal.id)) {
        const operands = [phi.place.identifier];
        const declaration = declarations.get(
          phi.place.identifier.declarationId
        );
        if (declaration !== void 0) {
          operands.push(declaration);
        }
        for (const [_2, phiId] of phi.operands) {
          operands.push(phiId.identifier);
        }
        scopeIdentifiers.union(operands);
      } else if (fn.env.config.enableForest) {
        for (const [, phiId] of phi.operands) {
          scopeIdentifiers.union([phi.place.identifier, phiId.identifier]);
        }
      }
    }
    for (const instr of block.instructions) {
      const operands = [];
      const range = instr.lvalue.identifier.mutableRange;
      if (range.end > range.start + 1 || mayAllocate(fn.env, instr)) {
        operands.push(instr.lvalue.identifier);
      }
      if (instr.value.kind === "DeclareLocal" || instr.value.kind === "DeclareContext") {
        declareIdentifier(instr.value.lvalue.place);
      } else if (instr.value.kind === "StoreLocal" || instr.value.kind === "StoreContext") {
        declareIdentifier(instr.value.lvalue.place);
        if (instr.value.lvalue.place.identifier.mutableRange.end > instr.value.lvalue.place.identifier.mutableRange.start + 1) {
          operands.push(instr.value.lvalue.place.identifier);
        }
        if (isMutable2(instr, instr.value.value) && instr.value.value.identifier.mutableRange.start > 0) {
          operands.push(instr.value.value.identifier);
        }
      } else if (instr.value.kind === "Destructure") {
        for (const place of eachPatternOperand(instr.value.lvalue.pattern)) {
          declareIdentifier(place);
          if (place.identifier.mutableRange.end > place.identifier.mutableRange.start + 1) {
            operands.push(place.identifier);
          }
        }
        if (isMutable2(instr, instr.value.value) && instr.value.value.identifier.mutableRange.start > 0) {
          operands.push(instr.value.value.identifier);
        }
      } else if (instr.value.kind === "MethodCall") {
        for (const operand of eachInstructionOperand(instr)) {
          if (isMutable2(instr, operand) && /*
           * exclude global variables from being added to scopes, we can't recreate them!
           * TODO: improve handling of module-scoped variables and globals
           */
          operand.identifier.mutableRange.start > 0) {
            operands.push(operand.identifier);
          }
        }
        operands.push(instr.value.property.identifier);
      } else {
        for (const operand of eachInstructionOperand(instr)) {
          if (isMutable2(instr, operand) && /*
           * exclude global variables from being added to scopes, we can't recreate them!
           * TODO: improve handling of module-scoped variables and globals
           */
          operand.identifier.mutableRange.start > 0) {
            if (instr.value.kind === "FunctionExpression" || instr.value.kind === "ObjectMethod") {
              if (operand.identifier.type.kind === "Primitive") {
                continue;
              }
            }
            operands.push(operand.identifier);
          }
        }
      }
      if (operands.length !== 0) {
        scopeIdentifiers.union(operands);
      }
    }
  }
  return scopeIdentifiers;
}

// src/HIR/MergeOverlappingReactiveScopesHIR.ts
function mergeOverlappingReactiveScopesHIR(fn) {
  const scopesInfo = collectScopeInfo(fn);
  const joinedScopes = getOverlappingReactiveScopes(fn, scopesInfo);
  joinedScopes.forEach((scope, groupScope) => {
    if (scope !== groupScope) {
      groupScope.range.start = makeInstructionId(
        Math.min(groupScope.range.start, scope.range.start)
      );
      groupScope.range.end = makeInstructionId(
        Math.max(groupScope.range.end, scope.range.end)
      );
    }
  });
  for (const [place, originalScope] of scopesInfo.placeScopes) {
    const nextScope = joinedScopes.find(originalScope);
    if (nextScope !== null && nextScope !== originalScope) {
      place.identifier.scope = nextScope;
    }
  }
}
function collectScopeInfo(fn) {
  const scopeStarts = /* @__PURE__ */ new Map();
  const scopeEnds = /* @__PURE__ */ new Map();
  const placeScopes = /* @__PURE__ */ new Map();
  function collectPlaceScope(place) {
    const scope = place.identifier.scope;
    if (scope != null) {
      placeScopes.set(place, scope);
      if (scope.range.start !== scope.range.end) {
        getOrInsertDefault(scopeStarts, scope.range.start, /* @__PURE__ */ new Set()).add(
          scope
        );
        getOrInsertDefault(scopeEnds, scope.range.end, /* @__PURE__ */ new Set()).add(scope);
      }
    }
  }
  for (const [, block] of fn.body.blocks) {
    for (const instr of block.instructions) {
      for (const operand of eachInstructionLValue(instr)) {
        collectPlaceScope(operand);
      }
      for (const operand of eachInstructionOperand(instr)) {
        collectPlaceScope(operand);
      }
    }
    for (const operand of eachTerminalOperand(block.terminal)) {
      collectPlaceScope(operand);
    }
  }
  return {
    scopeStarts: [...scopeStarts.entries()].map(([id, scopes]) => ({ id, scopes })).sort((a, b) => b.id - a.id),
    scopeEnds: [...scopeEnds.entries()].map(([id, scopes]) => ({ id, scopes })).sort((a, b) => b.id - a.id),
    placeScopes
  };
}
function visitInstructionId(id, { scopeEnds, scopeStarts }, { activeScopes, joined }) {
  const scopeEndTop = scopeEnds.at(-1);
  if (scopeEndTop != null && scopeEndTop.id <= id) {
    scopeEnds.pop();
    const scopesSortedStartDescending = [...scopeEndTop.scopes].sort(
      (a, b) => b.range.start - a.range.start
    );
    for (const scope of scopesSortedStartDescending) {
      const idx = activeScopes.indexOf(scope);
      if (idx !== -1) {
        if (idx !== activeScopes.length - 1) {
          joined.union([scope, ...activeScopes.slice(idx + 1)]);
        }
        activeScopes.splice(idx, 1);
      }
    }
  }
  const scopeStartTop = scopeStarts.at(-1);
  if (scopeStartTop != null && scopeStartTop.id <= id) {
    scopeStarts.pop();
    const scopesSortedEndDescending = [...scopeStartTop.scopes].sort(
      (a, b) => b.range.end - a.range.end
    );
    activeScopes.push(...scopesSortedEndDescending);
    for (let i = 1; i < scopesSortedEndDescending.length; i++) {
      const prev = scopesSortedEndDescending[i - 1];
      const curr = scopesSortedEndDescending[i];
      if (prev.range.end === curr.range.end) {
        joined.union([prev, curr]);
      }
    }
  }
}
function visitPlace(id, place, { activeScopes, joined }) {
  const placeScope = getPlaceScope(id, place);
  if (placeScope != null && isMutable2({ id }, place)) {
    const placeScopeIdx = activeScopes.indexOf(placeScope);
    if (placeScopeIdx !== -1 && placeScopeIdx !== activeScopes.length - 1) {
      joined.union([placeScope, ...activeScopes.slice(placeScopeIdx + 1)]);
    }
  }
}
function getOverlappingReactiveScopes(fn, context) {
  const state = {
    joined: new DisjointSet(),
    activeScopes: []
  };
  for (const [, block] of fn.body.blocks) {
    for (const instr of block.instructions) {
      visitInstructionId(instr.id, context, state);
      for (const place of eachInstructionOperand(instr)) {
        if ((instr.value.kind === "FunctionExpression" || instr.value.kind === "ObjectMethod") && place.identifier.type.kind === "Primitive") {
          continue;
        }
        visitPlace(instr.id, place, state);
      }
      for (const place of eachInstructionLValue(instr)) {
        visitPlace(instr.id, place, state);
      }
    }
    visitInstructionId(block.terminal.id, context, state);
    for (const place of eachTerminalOperand(block.terminal)) {
      visitPlace(block.terminal.id, place, state);
    }
  }
  return state.joined;
}

// src/HIR/PruneUnusedLabelsHIR.ts
function pruneUnusedLabelsHIR(fn) {
  var _a;
  const merged = [];
  const rewrites = /* @__PURE__ */ new Map();
  for (const [blockId, block] of fn.body.blocks) {
    const terminal = block.terminal;
    if (terminal.kind === "label") {
      const { block: nextId, fallthrough: fallthroughId } = terminal;
      const next = fn.body.blocks.get(nextId);
      const fallthrough = fn.body.blocks.get(fallthroughId);
      if (next.terminal.kind === "goto" && next.terminal.variant === "Break" /* Break */ && next.terminal.block === fallthroughId) {
        if (next.kind === "block" && fallthrough.kind === "block") {
          merged.push({
            label: blockId,
            next: nextId,
            fallthrough: fallthroughId
          });
        }
      }
    }
  }
  for (const {
    label: originalLabelId,
    next: nextId,
    fallthrough: fallthroughId
  } of merged) {
    const labelId = (_a = rewrites.get(originalLabelId)) != null ? _a : originalLabelId;
    const label = fn.body.blocks.get(labelId);
    const next = fn.body.blocks.get(nextId);
    const fallthrough = fn.body.blocks.get(fallthroughId);
    CompilerError.invariant(
      next.phis.size === 0 && fallthrough.phis.size === 0,
      {
        reason: "Unexpected phis when merging label blocks",
        loc: label.terminal.loc
      }
    );
    CompilerError.invariant(
      next.preds.size === 1 && fallthrough.preds.size === 1 && next.preds.has(originalLabelId) && fallthrough.preds.has(nextId),
      {
        reason: "Unexpected block predecessors when merging label blocks",
        loc: label.terminal.loc
      }
    );
    label.instructions.push(...next.instructions, ...fallthrough.instructions);
    label.terminal = fallthrough.terminal;
    fn.body.blocks.delete(nextId);
    fn.body.blocks.delete(fallthroughId);
    rewrites.set(fallthroughId, labelId);
  }
  for (const [_, block] of fn.body.blocks) {
    for (const pred of block.preds) {
      const rewritten = rewrites.get(pred);
      if (rewritten != null) {
        block.preds.delete(pred);
        block.preds.add(rewritten);
      }
    }
  }
}

// src/Entrypoint/Program.ts
var t4 = __toESM(require("@babel/types"));

// src/Utils/ComponentDeclaration.ts
function isComponentDeclaration(node) {
  return Object.prototype.hasOwnProperty.call(node, "__componentDeclaration");
}

// src/Utils/HookDeclaration.ts
function isHookDeclaration(node) {
  return Object.prototype.hasOwnProperty.call(node, "__hookDeclaration");
}

// src/Entrypoint/Pipeline.ts
var import_pretty_format3 = __toESM(require_build());

// src/HIR/FindContextIdentifiers.ts
var DEFAULT_IDENTIFIER_INFO = {
  reassigned: false,
  reassignedByInnerFn: false,
  referencedByInnerFn: false
};
var withFunctionScope = {
  enter: function(path, state) {
    state.currentFn.push(path);
  },
  exit: function(_, state) {
    state.currentFn.pop();
  }
};
function findContextIdentifiers(func) {
  const state = {
    currentFn: [],
    identifiers: /* @__PURE__ */ new Map()
  };
  func.traverse(
    {
      FunctionDeclaration: withFunctionScope,
      FunctionExpression: withFunctionScope,
      ArrowFunctionExpression: withFunctionScope,
      ObjectMethod: withFunctionScope,
      AssignmentExpression(path, state2) {
        var _a, _b;
        const left = path.get("left");
        if (left.isLVal()) {
          const currentFn = (_a = state2.currentFn.at(-1)) != null ? _a : null;
          handleAssignment(currentFn, state2.identifiers, left);
        } else {
          CompilerError.throwTodo({
            reason: `Unsupported syntax on the left side of an AssignmentExpression`,
            description: `Expected an LVal, got: ${left.type}`,
            loc: (_b = left.node.loc) != null ? _b : null
          });
        }
      },
      UpdateExpression(path, state2) {
        var _a;
        const argument = path.get("argument");
        const currentFn = (_a = state2.currentFn.at(-1)) != null ? _a : null;
        if (argument.isLVal()) {
          handleAssignment(currentFn, state2.identifiers, argument);
        }
      },
      Identifier(path, state2) {
        var _a;
        const currentFn = (_a = state2.currentFn.at(-1)) != null ? _a : null;
        if (path.isReferencedIdentifier()) {
          handleIdentifier(currentFn, state2.identifiers, path);
        }
      }
    },
    state
  );
  const result = /* @__PURE__ */ new Set();
  for (const [id, info] of state.identifiers.entries()) {
    if (info.reassignedByInnerFn) {
      result.add(id);
    } else if (info.reassigned && info.referencedByInnerFn) {
      result.add(id);
    }
  }
  return result;
}
function handleIdentifier(currentFn, identifiers, path) {
  const name = path.node.name;
  const binding = path.scope.getBinding(name);
  if (binding == null) {
    return;
  }
  const identifier4 = getOrInsertDefault(identifiers, binding.identifier, __spreadValues({}, DEFAULT_IDENTIFIER_INFO));
  if (currentFn != null) {
    const bindingAboveLambdaScope = currentFn.scope.parent.getBinding(name);
    if (binding === bindingAboveLambdaScope) {
      identifier4.referencedByInnerFn = true;
    }
  }
}
function handleAssignment(currentFn, identifiers, lvalPath) {
  var _a, _b, _c;
  const lvalNode = lvalPath.node;
  switch (lvalNode.type) {
    case "Identifier": {
      const path = lvalPath;
      const name = path.node.name;
      const binding = path.scope.getBinding(name);
      if (binding == null) {
        break;
      }
      const state = getOrInsertDefault(identifiers, binding.identifier, __spreadValues({}, DEFAULT_IDENTIFIER_INFO));
      state.reassigned = true;
      if (currentFn != null) {
        const bindingAboveLambdaScope = currentFn.scope.parent.getBinding(name);
        if (binding === bindingAboveLambdaScope) {
          state.reassignedByInnerFn = true;
        }
      }
      break;
    }
    case "ArrayPattern": {
      const path = lvalPath;
      for (const element of path.get("elements")) {
        if (nonNull(element)) {
          handleAssignment(currentFn, identifiers, element);
        }
      }
      break;
    }
    case "ObjectPattern": {
      const path = lvalPath;
      for (const property of path.get("properties")) {
        if (property.isObjectProperty()) {
          const valuePath = property.get("value");
          CompilerError.invariant(valuePath.isLVal(), {
            reason: `[FindContextIdentifiers] Expected object property value to be an LVal, got: ${valuePath.type}`,
            description: null,
            loc: (_a = valuePath.node.loc) != null ? _a : GeneratedSource,
            suggestions: null
          });
          handleAssignment(currentFn, identifiers, valuePath);
        } else {
          CompilerError.invariant(property.isRestElement(), {
            reason: `[FindContextIdentifiers] Invalid assumptions for babel types.`,
            description: null,
            loc: (_b = property.node.loc) != null ? _b : GeneratedSource,
            suggestions: null
          });
          handleAssignment(currentFn, identifiers, property);
        }
      }
      break;
    }
    case "AssignmentPattern": {
      const path = lvalPath;
      const left = path.get("left");
      handleAssignment(currentFn, identifiers, left);
      break;
    }
    case "RestElement": {
      const path = lvalPath;
      handleAssignment(currentFn, identifiers, path.get("argument"));
      break;
    }
    case "MemberExpression": {
      break;
    }
    default: {
      CompilerError.throwTodo({
        reason: `[FindContextIdentifiers] Cannot handle Object destructuring assignment target ${lvalNode.type}`,
        description: null,
        loc: (_c = lvalNode.loc) != null ? _c : GeneratedSource,
        suggestions: null
      });
    }
  }
}
function nonNull(t6) {
  return t6.node != null;
}

// src/Optimization/ConstantPropagation.ts
var import_types2 = require("@babel/types");

// src/SSA/EliminateRedundantPhi.ts
var DEBUG = false;
function eliminateRedundantPhi(fn, sharedRewrites) {
  const ir = fn.body;
  const rewrites = sharedRewrites != null ? sharedRewrites : /* @__PURE__ */ new Map();
  let hasBackEdge2 = false;
  const visited = /* @__PURE__ */ new Set();
  let size = rewrites.size;
  do {
    size = rewrites.size;
    for (const [blockId, block] of ir.blocks) {
      if (!hasBackEdge2) {
        for (const predId of block.preds) {
          if (!visited.has(predId)) {
            hasBackEdge2 = true;
          }
        }
      }
      visited.add(blockId);
      phis: for (const phi of block.phis) {
        phi.operands.forEach((place, _) => rewritePlace(place, rewrites));
        let same = null;
        for (const [_, operand] of phi.operands) {
          if (same !== null && operand.identifier.id === same.id || operand.identifier.id === phi.place.identifier.id) {
            continue;
          } else if (same !== null) {
            continue phis;
          } else {
            same = operand.identifier;
          }
        }
        CompilerError.invariant(same !== null, {
          reason: "Expected phis to be non-empty",
          description: null,
          loc: null,
          suggestions: null
        });
        rewrites.set(phi.place.identifier, same);
        block.phis.delete(phi);
      }
      for (const instr of block.instructions) {
        for (const place of eachInstructionLValue(instr)) {
          rewritePlace(place, rewrites);
        }
        for (const place of eachInstructionOperand(instr)) {
          rewritePlace(place, rewrites);
        }
        if (instr.value.kind === "FunctionExpression" || instr.value.kind === "ObjectMethod") {
          const { context } = instr.value.loweredFunc.func;
          for (const place of context) {
            rewritePlace(place, rewrites);
          }
          eliminateRedundantPhi(instr.value.loweredFunc.func, rewrites);
        }
      }
      const { terminal } = block;
      for (const place of eachTerminalOperand(terminal)) {
        rewritePlace(place, rewrites);
      }
    }
  } while (rewrites.size > size && hasBackEdge2);
  if (DEBUG) {
    for (const [, block] of ir.blocks) {
      for (const phi of block.phis) {
        CompilerError.invariant(!rewrites.has(phi.place.identifier), {
          reason: "[EliminateRedundantPhis]: rewrite not complete",
          loc: phi.place.loc
        });
        for (const [, operand] of phi.operands) {
          CompilerError.invariant(!rewrites.has(operand.identifier), {
            reason: "[EliminateRedundantPhis]: rewrite not complete",
            loc: phi.place.loc
          });
        }
      }
    }
  }
}
function rewritePlace(place, rewrites) {
  const rewrite = rewrites.get(place.identifier);
  if (rewrite != null) {
    place.identifier = rewrite;
  }
}

// src/SSA/EnterSSA.ts
var _states, _current2, _blocks, _env2, _unknown, _context2;
var SSABuilder = class {
  constructor(env, blocks) {
    __privateAdd(this, _states, /* @__PURE__ */ new Map());
    __privateAdd(this, _current2, null);
    this.unsealedPreds = /* @__PURE__ */ new Map();
    __privateAdd(this, _blocks);
    __privateAdd(this, _env2);
    __privateAdd(this, _unknown, /* @__PURE__ */ new Set());
    __privateAdd(this, _context2, /* @__PURE__ */ new Set());
    __privateSet(this, _blocks, new Map(blocks));
    __privateSet(this, _env2, env);
  }
  get nextSsaId() {
    return __privateGet(this, _env2).nextIdentifierId;
  }
  defineFunction(func) {
    for (const [id, block] of func.body.blocks) {
      __privateGet(this, _blocks).set(id, block);
    }
  }
  enter(fn) {
    const current = __privateGet(this, _current2);
    fn();
    __privateSet(this, _current2, current);
  }
  state() {
    CompilerError.invariant(__privateGet(this, _current2) !== null, {
      reason: "we need to be in a block to access state!",
      description: null,
      loc: null,
      suggestions: null
    });
    return __privateGet(this, _states).get(__privateGet(this, _current2));
  }
  makeId(oldId) {
    return {
      id: this.nextSsaId,
      declarationId: oldId.declarationId,
      name: oldId.name,
      mutableRange: {
        start: makeInstructionId(0),
        end: makeInstructionId(0)
      },
      scope: null,
      // reset along w the mutable range
      type: makeType(),
      loc: oldId.loc
    };
  }
  defineContext(oldPlace) {
    const newPlace = this.definePlace(oldPlace);
    __privateGet(this, _context2).add(oldPlace.identifier);
    return newPlace;
  }
  definePlace(oldPlace) {
    const oldId = oldPlace.identifier;
    if (__privateGet(this, _unknown).has(oldId)) {
      CompilerError.throwTodo({
        reason: `[hoisting] EnterSSA: Expected identifier to be defined before being used`,
        description: `Identifier ${printIdentifier(oldId)} is undefined`,
        loc: oldPlace.loc,
        suggestions: null
      });
    }
    if (__privateGet(this, _context2).has(oldId)) {
      return this.getPlace(oldPlace);
    }
    const newId = this.makeId(oldId);
    this.state().defs.set(oldId, newId);
    return __spreadProps(__spreadValues({}, oldPlace), {
      identifier: newId
    });
  }
  getPlace(oldPlace) {
    const newId = this.getIdAt(oldPlace, __privateGet(this, _current2).id);
    return __spreadProps(__spreadValues({}, oldPlace), {
      identifier: newId
    });
  }
  getIdAt(oldPlace, blockId) {
    const block = __privateGet(this, _blocks).get(blockId);
    const state = __privateGet(this, _states).get(block);
    if (state.defs.has(oldPlace.identifier)) {
      return state.defs.get(oldPlace.identifier);
    }
    if (block.preds.size == 0) {
      __privateGet(this, _unknown).add(oldPlace.identifier);
      return oldPlace.identifier;
    }
    if (this.unsealedPreds.get(block) > 0) {
      const newId2 = this.makeId(oldPlace.identifier);
      state.incompletePhis.push({
        oldPlace,
        newPlace: __spreadProps(__spreadValues({}, oldPlace), { identifier: newId2 })
      });
      state.defs.set(oldPlace.identifier, newId2);
      return newId2;
    }
    if (block.preds.size == 1) {
      const [pred] = block.preds;
      const newId2 = this.getIdAt(oldPlace, pred);
      state.defs.set(oldPlace.identifier, newId2);
      return newId2;
    }
    const newId = this.makeId(oldPlace.identifier);
    state.defs.set(oldPlace.identifier, newId);
    return this.addPhi(block, oldPlace, __spreadProps(__spreadValues({}, oldPlace), { identifier: newId }));
  }
  addPhi(block, oldPlace, newPlace) {
    const predDefs = /* @__PURE__ */ new Map();
    for (const predBlockId of block.preds) {
      const predId = this.getIdAt(oldPlace, predBlockId);
      predDefs.set(predBlockId, __spreadProps(__spreadValues({}, oldPlace), { identifier: predId }));
    }
    const phi = {
      kind: "Phi",
      place: newPlace,
      operands: predDefs
    };
    block.phis.add(phi);
    return newPlace.identifier;
  }
  fixIncompletePhis(block) {
    const state = __privateGet(this, _states).get(block);
    for (const phi of state.incompletePhis) {
      this.addPhi(block, phi.oldPlace, phi.newPlace);
    }
  }
  startBlock(block) {
    __privateSet(this, _current2, block);
    __privateGet(this, _states).set(block, {
      defs: /* @__PURE__ */ new Map(),
      incompletePhis: []
    });
  }
  print() {
    var _a;
    const text = [];
    for (const [block, state] of __privateGet(this, _states)) {
      text.push(`bb${block.id}:`);
      for (const [oldId, newId] of state.defs) {
        text.push(`  $${printIdentifier(oldId)}: $${printIdentifier(newId)}`);
      }
      for (const incompletePhi of state.incompletePhis) {
        text.push(
          `  iphi $${printPlace(
            incompletePhi.newPlace
          )} = $${printPlace(incompletePhi.oldPlace)}`
        );
      }
    }
    text.push(`current block: bb${(_a = __privateGet(this, _current2)) == null ? void 0 : _a.id}`);
    console.log(text.join("\n"));
  }
};
_states = new WeakMap();
_current2 = new WeakMap();
_blocks = new WeakMap();
_env2 = new WeakMap();
_unknown = new WeakMap();
_context2 = new WeakMap();
function enterSSA(func) {
  const builder = new SSABuilder(func.env, func.body.blocks);
  enterSSAImpl(func, builder, func.body.entry);
}
function enterSSAImpl(func, builder, rootEntry) {
  const visitedBlocks = /* @__PURE__ */ new Set();
  for (const [blockId, block] of func.body.blocks) {
    CompilerError.invariant(!visitedBlocks.has(block), {
      reason: `found a cycle! visiting bb${block.id} again`,
      description: null,
      loc: null,
      suggestions: null
    });
    visitedBlocks.add(block);
    builder.startBlock(block);
    if (blockId === rootEntry) {
      CompilerError.invariant(func.context.length === 0, {
        reason: `Expected function context to be empty for outer function declarations`,
        description: null,
        loc: func.loc,
        suggestions: null
      });
      func.params = func.params.map((param) => {
        if (param.kind === "Identifier") {
          return builder.definePlace(param);
        } else {
          return {
            kind: "Spread",
            place: builder.definePlace(param.place)
          };
        }
      });
    }
    for (const instr of block.instructions) {
      mapInstructionOperands(instr, (place) => builder.getPlace(place));
      mapInstructionLValues(instr, (lvalue) => builder.definePlace(lvalue));
      if (instr.value.kind === "FunctionExpression" || instr.value.kind === "ObjectMethod") {
        const loweredFunc = instr.value.loweredFunc.func;
        const entry = loweredFunc.body.blocks.get(loweredFunc.body.entry);
        CompilerError.invariant(entry.preds.size === 0, {
          reason: "Expected function expression entry block to have zero predecessors",
          description: null,
          loc: null,
          suggestions: null
        });
        entry.preds.add(blockId);
        builder.defineFunction(loweredFunc);
        builder.enter(() => {
          loweredFunc.params = loweredFunc.params.map((param) => {
            if (param.kind === "Identifier") {
              return builder.definePlace(param);
            } else {
              return {
                kind: "Spread",
                place: builder.definePlace(param.place)
              };
            }
          });
          enterSSAImpl(loweredFunc, builder, rootEntry);
        });
        entry.preds.clear();
      }
    }
    mapTerminalOperands(block.terminal, (place) => builder.getPlace(place));
    for (const outputId of eachTerminalSuccessor(block.terminal)) {
      const output = func.body.blocks.get(outputId);
      let count;
      if (builder.unsealedPreds.has(output)) {
        count = builder.unsealedPreds.get(output) - 1;
      } else {
        count = output.preds.size - 1;
      }
      builder.unsealedPreds.set(output, count);
      if (count === 0 && visitedBlocks.has(output)) {
        builder.fixIncompletePhis(output);
      }
    }
  }
}

// src/SSA/RewriteInstructionKindsBasedOnReassignment.ts
function rewriteInstructionKindsBasedOnReassignment(fn) {
  const declarations = /* @__PURE__ */ new Map();
  for (const param of fn.params) {
    let place = param.kind === "Identifier" ? param : param.place;
    if (place.identifier.name !== null) {
      declarations.set(place.identifier.declarationId, {
        kind: "Let" /* Let */,
        place
      });
    }
  }
  for (const place of fn.context) {
    if (place.identifier.name !== null) {
      declarations.set(place.identifier.declarationId, {
        kind: "Let" /* Let */,
        place
      });
    }
  }
  for (const [, block] of fn.body.blocks) {
    for (const instr of block.instructions) {
      const { value } = instr;
      switch (value.kind) {
        case "DeclareLocal": {
          const lvalue = value.lvalue;
          CompilerError.invariant(
            !declarations.has(lvalue.place.identifier.declarationId),
            {
              reason: `Expected variable not to be defined prior to declaration`,
              description: `${printPlace(lvalue.place)} was already defined`,
              loc: lvalue.place.loc
            }
          );
          declarations.set(lvalue.place.identifier.declarationId, lvalue);
          break;
        }
        case "StoreLocal": {
          const lvalue = value.lvalue;
          if (lvalue.place.identifier.name !== null) {
            const declaration = declarations.get(
              lvalue.place.identifier.declarationId
            );
            if (declaration === void 0) {
              CompilerError.invariant(
                !declarations.has(lvalue.place.identifier.declarationId),
                {
                  reason: `Expected variable not to be defined prior to declaration`,
                  description: `${printPlace(lvalue.place)} was already defined`,
                  loc: lvalue.place.loc
                }
              );
              declarations.set(lvalue.place.identifier.declarationId, lvalue);
              lvalue.kind = "Const" /* Const */;
            } else {
              declaration.kind = "Let" /* Let */;
              lvalue.kind = "Reassign" /* Reassign */;
            }
          }
          break;
        }
        case "Destructure": {
          const lvalue = value.lvalue;
          let kind = null;
          for (const place of eachPatternOperand(lvalue.pattern)) {
            if (place.identifier.name === null) {
              CompilerError.invariant(
                kind === null || kind === "Const" /* Const */,
                {
                  reason: `Expected consistent kind for destructuring`,
                  description: `other places were \`${kind}\` but '${printPlace(
                    place
                  )}' is const`,
                  loc: place.loc,
                  suggestions: null
                }
              );
              kind = "Const" /* Const */;
            } else {
              const declaration = declarations.get(
                place.identifier.declarationId
              );
              if (declaration === void 0) {
                CompilerError.invariant(block.kind !== "value", {
                  reason: `TODO: Handle reassignment in a value block where the original declaration was removed by dead code elimination (DCE)`,
                  description: null,
                  loc: place.loc,
                  suggestions: null
                });
                declarations.set(place.identifier.declarationId, lvalue);
                CompilerError.invariant(
                  kind === null || kind === "Const" /* Const */,
                  {
                    reason: `Expected consistent kind for destructuring`,
                    description: `Other places were \`${kind}\` but '${printPlace(
                      place
                    )}' is const`,
                    loc: place.loc,
                    suggestions: null
                  }
                );
                kind = "Const" /* Const */;
              } else {
                CompilerError.invariant(
                  kind === null || kind === "Reassign" /* Reassign */,
                  {
                    reason: `Expected consistent kind for destructuring`,
                    description: `Other places were \`${kind}\` but '${printPlace(
                      place
                    )}' is reassigned`,
                    loc: place.loc,
                    suggestions: null
                  }
                );
                kind = "Reassign" /* Reassign */;
                declaration.kind = "Let" /* Let */;
              }
            }
          }
          CompilerError.invariant(kind !== null, {
            reason: "Expected at least one operand",
            description: null,
            loc: null,
            suggestions: null
          });
          lvalue.kind = kind;
          break;
        }
        case "PostfixUpdate":
        case "PrefixUpdate": {
          const lvalue = value.lvalue;
          const declaration = declarations.get(lvalue.identifier.declarationId);
          CompilerError.invariant(declaration !== void 0, {
            reason: `Expected variable to have been defined`,
            description: `No declaration for ${printPlace(lvalue)}`,
            loc: lvalue.loc
          });
          declaration.kind = "Let" /* Let */;
          break;
        }
      }
    }
  }
}

// src/Optimization/ConstantPropagation.ts
function constantPropagation(fn) {
  const constants = /* @__PURE__ */ new Map();
  constantPropagationImpl(fn, constants);
}
function constantPropagationImpl(fn, constants) {
  while (true) {
    const haveTerminalsChanged = applyConstantPropagation(fn, constants);
    if (!haveTerminalsChanged) {
      break;
    }
    reversePostorderBlocks(fn.body);
    removeUnreachableForUpdates(fn.body);
    removeDeadDoWhileStatements(fn.body);
    removeUnnecessaryTryCatch(fn.body);
    markInstructionIds(fn.body);
    markPredecessors(fn.body);
    for (const [, block] of fn.body.blocks) {
      for (const phi of block.phis) {
        for (const [predecessor] of phi.operands) {
          if (!block.preds.has(predecessor)) {
            phi.operands.delete(predecessor);
          }
        }
      }
    }
    eliminateRedundantPhi(fn);
    mergeConsecutiveBlocks(fn);
    assertConsistentIdentifiers(fn);
    assertTerminalSuccessorsExist(fn);
  }
}
function applyConstantPropagation(fn, constants) {
  let hasChanges = false;
  for (const [, block] of fn.body.blocks) {
    for (const phi of block.phis) {
      let value = evaluatePhi(phi, constants);
      if (value !== null) {
        constants.set(phi.place.identifier.id, value);
      }
    }
    for (let i = 0; i < block.instructions.length; i++) {
      if (block.kind === "sequence" && i === block.instructions.length - 1) {
        continue;
      }
      const instr = block.instructions[i];
      const value = evaluateInstruction(constants, instr);
      if (value !== null) {
        constants.set(instr.lvalue.identifier.id, value);
      }
    }
    const terminal = block.terminal;
    switch (terminal.kind) {
      case "if": {
        const testValue = read2(constants, terminal.test);
        if (testValue !== null && testValue.kind === "Primitive") {
          hasChanges = true;
          const targetBlockId = testValue.value ? terminal.consequent : terminal.alternate;
          block.terminal = {
            kind: "goto",
            variant: "Break" /* Break */,
            block: targetBlockId,
            id: terminal.id,
            loc: terminal.loc
          };
        }
        break;
      }
      default: {
      }
    }
  }
  return hasChanges;
}
function evaluatePhi(phi, constants) {
  var _a;
  let value = null;
  for (const [, operand] of phi.operands) {
    const operandValue = (_a = constants.get(operand.identifier.id)) != null ? _a : null;
    if (operandValue === null) {
      return null;
    }
    if (value === null) {
      value = operandValue;
      continue;
    }
    if (operandValue.kind !== value.kind) {
      return null;
    }
    switch (operandValue.kind) {
      case "Primitive": {
        CompilerError.invariant(value.kind === "Primitive", {
          reason: "value kind expected to be Primitive",
          loc: null,
          suggestions: null
        });
        if (operandValue.value !== value.value) {
          return null;
        }
        break;
      }
      case "LoadGlobal": {
        CompilerError.invariant(value.kind === "LoadGlobal", {
          reason: "value kind expected to be LoadGlobal",
          loc: null,
          suggestions: null
        });
        if (operandValue.binding.name !== value.binding.name) {
          return null;
        }
        break;
      }
      default:
        return null;
    }
  }
  return value;
}
function evaluateInstruction(constants, instr) {
  const value = instr.value;
  switch (value.kind) {
    case "Primitive": {
      return value;
    }
    case "LoadGlobal": {
      return value;
    }
    case "ComputedLoad": {
      const property = read2(constants, value.property);
      if (property !== null && property.kind === "Primitive" && (typeof property.value === "string" && (0, import_types2.isValidIdentifier)(property.value) || typeof property.value === "number")) {
        const nextValue = {
          kind: "PropertyLoad",
          loc: value.loc,
          property: makePropertyLiteral(property.value),
          object: value.object
        };
        instr.value = nextValue;
      }
      return null;
    }
    case "ComputedStore": {
      const property = read2(constants, value.property);
      if (property !== null && property.kind === "Primitive" && (typeof property.value === "string" && (0, import_types2.isValidIdentifier)(property.value) || typeof property.value === "number")) {
        const nextValue = {
          kind: "PropertyStore",
          loc: value.loc,
          property: makePropertyLiteral(property.value),
          object: value.object,
          value: value.value
        };
        instr.value = nextValue;
      }
      return null;
    }
    case "PostfixUpdate": {
      const previous = read2(constants, value.value);
      if (previous !== null && previous.kind === "Primitive" && typeof previous.value === "number") {
        const next = value.operation === "++" ? previous.value + 1 : previous.value - 1;
        constants.set(value.lvalue.identifier.id, {
          kind: "Primitive",
          value: next,
          loc: value.loc
        });
        return previous;
      }
      return null;
    }
    case "PrefixUpdate": {
      const previous = read2(constants, value.value);
      if (previous !== null && previous.kind === "Primitive" && typeof previous.value === "number") {
        const next = {
          kind: "Primitive",
          value: value.operation === "++" ? previous.value + 1 : previous.value - 1,
          loc: value.loc
        };
        constants.set(value.lvalue.identifier.id, next);
        return next;
      }
      return null;
    }
    case "UnaryExpression": {
      switch (value.operator) {
        case "!": {
          const operand = read2(constants, value.value);
          if (operand !== null && operand.kind === "Primitive") {
            const result = {
              kind: "Primitive",
              value: !operand.value,
              loc: value.loc
            };
            instr.value = result;
            return result;
          }
          return null;
        }
        case "-": {
          const operand = read2(constants, value.value);
          if (operand !== null && operand.kind === "Primitive" && typeof operand.value === "number") {
            const result = {
              kind: "Primitive",
              value: operand.value * -1,
              loc: value.loc
            };
            instr.value = result;
            return result;
          }
          return null;
        }
        default:
          return null;
      }
    }
    case "BinaryExpression": {
      const lhsValue = read2(constants, value.left);
      const rhsValue = read2(constants, value.right);
      if (lhsValue !== null && rhsValue !== null && lhsValue.kind === "Primitive" && rhsValue.kind === "Primitive") {
        const lhs = lhsValue.value;
        const rhs = rhsValue.value;
        let result = null;
        switch (value.operator) {
          case "+": {
            if (typeof lhs === "number" && typeof rhs === "number") {
              result = { kind: "Primitive", value: lhs + rhs, loc: value.loc };
            } else if (typeof lhs === "string" && typeof rhs === "string") {
              result = { kind: "Primitive", value: lhs + rhs, loc: value.loc };
            }
            break;
          }
          case "-": {
            if (typeof lhs === "number" && typeof rhs === "number") {
              result = { kind: "Primitive", value: lhs - rhs, loc: value.loc };
            }
            break;
          }
          case "*": {
            if (typeof lhs === "number" && typeof rhs === "number") {
              result = { kind: "Primitive", value: lhs * rhs, loc: value.loc };
            }
            break;
          }
          case "/": {
            if (typeof lhs === "number" && typeof rhs === "number") {
              result = { kind: "Primitive", value: lhs / rhs, loc: value.loc };
            }
            break;
          }
          case "|": {
            if (typeof lhs === "number" && typeof rhs === "number") {
              result = { kind: "Primitive", value: lhs | rhs, loc: value.loc };
            }
            break;
          }
          case "&": {
            if (typeof lhs === "number" && typeof rhs === "number") {
              result = { kind: "Primitive", value: lhs & rhs, loc: value.loc };
            }
            break;
          }
          case "^": {
            if (typeof lhs === "number" && typeof rhs === "number") {
              result = { kind: "Primitive", value: lhs ^ rhs, loc: value.loc };
            }
            break;
          }
          case "<<": {
            if (typeof lhs === "number" && typeof rhs === "number") {
              result = { kind: "Primitive", value: lhs << rhs, loc: value.loc };
            }
            break;
          }
          case ">>": {
            if (typeof lhs === "number" && typeof rhs === "number") {
              result = { kind: "Primitive", value: lhs >> rhs, loc: value.loc };
            }
            break;
          }
          case ">>>": {
            if (typeof lhs === "number" && typeof rhs === "number") {
              result = {
                kind: "Primitive",
                value: lhs >>> rhs,
                loc: value.loc
              };
            }
            break;
          }
          case "%": {
            if (typeof lhs === "number" && typeof rhs === "number") {
              result = { kind: "Primitive", value: lhs % rhs, loc: value.loc };
            }
            break;
          }
          case "**": {
            if (typeof lhs === "number" && typeof rhs === "number") {
              result = { kind: "Primitive", value: __pow(lhs, rhs), loc: value.loc };
            }
            break;
          }
          case "<": {
            if (typeof lhs === "number" && typeof rhs === "number") {
              result = { kind: "Primitive", value: lhs < rhs, loc: value.loc };
            }
            break;
          }
          case "<=": {
            if (typeof lhs === "number" && typeof rhs === "number") {
              result = { kind: "Primitive", value: lhs <= rhs, loc: value.loc };
            }
            break;
          }
          case ">": {
            if (typeof lhs === "number" && typeof rhs === "number") {
              result = { kind: "Primitive", value: lhs > rhs, loc: value.loc };
            }
            break;
          }
          case ">=": {
            if (typeof lhs === "number" && typeof rhs === "number") {
              result = { kind: "Primitive", value: lhs >= rhs, loc: value.loc };
            }
            break;
          }
          case "==": {
            result = { kind: "Primitive", value: lhs == rhs, loc: value.loc };
            break;
          }
          case "===": {
            result = { kind: "Primitive", value: lhs === rhs, loc: value.loc };
            break;
          }
          case "!=": {
            result = { kind: "Primitive", value: lhs != rhs, loc: value.loc };
            break;
          }
          case "!==": {
            result = { kind: "Primitive", value: lhs !== rhs, loc: value.loc };
            break;
          }
          default: {
            break;
          }
        }
        if (result !== null) {
          instr.value = result;
          return result;
        }
      }
      return null;
    }
    case "PropertyLoad": {
      const objectValue = read2(constants, value.object);
      if (objectValue !== null) {
        if (objectValue.kind === "Primitive" && typeof objectValue.value === "string" && value.property === "length") {
          const result = {
            kind: "Primitive",
            value: objectValue.value.length,
            loc: value.loc
          };
          instr.value = result;
          return result;
        }
      }
      return null;
    }
    case "TemplateLiteral": {
      if (value.subexprs.length === 0) {
        const result2 = {
          kind: "Primitive",
          value: value.quasis.map((q) => q.cooked).join(""),
          loc: value.loc
        };
        instr.value = result2;
        return result2;
      }
      if (value.subexprs.length !== value.quasis.length - 1) {
        return null;
      }
      if (value.quasis.some((q) => q.cooked === void 0)) {
        return null;
      }
      let quasiIndex = 0;
      let resultString = value.quasis[quasiIndex].cooked;
      ++quasiIndex;
      for (const subExpr of value.subexprs) {
        const subExprValue = read2(constants, subExpr);
        if (!subExprValue || subExprValue.kind !== "Primitive") {
          return null;
        }
        const expressionValue = subExprValue.value;
        if (typeof expressionValue !== "number" && typeof expressionValue !== "string" && typeof expressionValue !== "boolean" && !(typeof expressionValue === "object" && expressionValue === null)) {
          return null;
        }
        const suffix = value.quasis[quasiIndex].cooked;
        ++quasiIndex;
        if (suffix === void 0) {
          return null;
        }
        resultString = resultString.concat(expressionValue, suffix);
      }
      const result = {
        kind: "Primitive",
        value: resultString,
        loc: value.loc
      };
      instr.value = result;
      return result;
    }
    case "LoadLocal": {
      const placeValue = read2(constants, value.place);
      if (placeValue !== null) {
        instr.value = placeValue;
      }
      return placeValue;
    }
    case "StoreLocal": {
      const placeValue = read2(constants, value.value);
      if (placeValue !== null) {
        constants.set(value.lvalue.place.identifier.id, placeValue);
      }
      return placeValue;
    }
    case "ObjectMethod":
    case "FunctionExpression": {
      constantPropagationImpl(value.loweredFunc.func, constants);
      return null;
    }
    default: {
      return null;
    }
  }
}
function read2(constants, place) {
  var _a;
  return (_a = constants.get(place.identifier.id)) != null ? _a : null;
}

// src/Optimization/DeadCodeElimination.ts
function deadCodeElimination(fn) {
  const state = findReferencedIdentifiers(fn);
  for (const [, block] of fn.body.blocks) {
    for (const phi of block.phis) {
      if (!state.isIdOrNameUsed(phi.place.identifier)) {
        block.phis.delete(phi);
      }
    }
    retainWhere(
      block.instructions,
      (instr) => state.isIdOrNameUsed(instr.lvalue.identifier)
    );
    for (let i = 0; i < block.instructions.length; i++) {
      const isBlockValue = block.kind !== "block" && i === block.instructions.length - 1;
      if (!isBlockValue) {
        rewriteInstruction(block.instructions[i], state);
      }
    }
  }
  retainWhere(
    fn.context,
    (contextVar) => state.isIdOrNameUsed(contextVar.identifier)
  );
}
var State = class {
  constructor() {
    this.named = /* @__PURE__ */ new Set();
    this.identifiers = /* @__PURE__ */ new Set();
  }
  // Mark the identifier as being referenced (not dead code)
  reference(identifier4) {
    this.identifiers.add(identifier4.id);
    if (identifier4.name !== null) {
      this.named.add(identifier4.name.value);
    }
  }
  /*
   * Check if any version of the given identifier is used somewhere.
   * This checks both for usage of this specific identifer id (ssa id)
   * and (for named identifiers) for any usages of that identifier name.
   */
  isIdOrNameUsed(identifier4) {
    return this.identifiers.has(identifier4.id) || identifier4.name !== null && this.named.has(identifier4.name.value);
  }
  /*
   * Like `used()`, but only checks for usages of this specific identifier id
   * (ssa id).
   */
  isIdUsed(identifier4) {
    return this.identifiers.has(identifier4.id);
  }
  get count() {
    return this.identifiers.size;
  }
};
function findReferencedIdentifiers(fn) {
  const hasLoop = hasBackEdge(fn);
  const reversedBlocks = [...fn.body.blocks.values()].reverse();
  const state = new State();
  let size = state.count;
  do {
    size = state.count;
    for (const block of reversedBlocks) {
      for (const operand of eachTerminalOperand(block.terminal)) {
        state.reference(operand.identifier);
      }
      for (let i = block.instructions.length - 1; i >= 0; i--) {
        const instr = block.instructions[i];
        const isBlockValue = block.kind !== "block" && i === block.instructions.length - 1;
        if (isBlockValue) {
          state.reference(instr.lvalue.identifier);
          for (const place of eachInstructionValueOperand(instr.value)) {
            state.reference(place.identifier);
          }
        } else if (state.isIdOrNameUsed(instr.lvalue.identifier) || !pruneableValue(instr.value, state)) {
          state.reference(instr.lvalue.identifier);
          if (instr.value.kind === "StoreLocal") {
            if (instr.value.lvalue.kind === "Reassign" /* Reassign */ || state.isIdUsed(instr.value.lvalue.place.identifier)) {
              state.reference(instr.value.value.identifier);
            }
          } else {
            for (const operand of eachInstructionValueOperand(instr.value)) {
              state.reference(operand.identifier);
            }
          }
        }
      }
      for (const phi of block.phis) {
        if (state.isIdOrNameUsed(phi.place.identifier)) {
          for (const [_pred, operand] of phi.operands) {
            state.reference(operand.identifier);
          }
        }
      }
    }
  } while (state.count > size && hasLoop);
  return state;
}
function rewriteInstruction(instr, state) {
  if (instr.value.kind === "Destructure") {
    switch (instr.value.lvalue.pattern.kind) {
      case "ArrayPattern": {
        let lastEntryIndex = 0;
        const items = instr.value.lvalue.pattern.items;
        for (let i = 0; i < items.length; i++) {
          const item = items[i];
          if (item.kind === "Identifier") {
            if (!state.isIdOrNameUsed(item.identifier)) {
              items[i] = { kind: "Hole" };
            } else {
              lastEntryIndex = i;
            }
          } else if (item.kind === "Spread") {
            if (!state.isIdOrNameUsed(item.place.identifier)) {
              items[i] = { kind: "Hole" };
            } else {
              lastEntryIndex = i;
            }
          }
        }
        items.length = lastEntryIndex + 1;
        break;
      }
      case "ObjectPattern": {
        let nextProperties = null;
        for (const property of instr.value.lvalue.pattern.properties) {
          if (property.kind === "ObjectProperty") {
            if (state.isIdOrNameUsed(property.place.identifier)) {
              nextProperties != null ? nextProperties : nextProperties = [];
              nextProperties.push(property);
            }
          } else {
            if (state.isIdOrNameUsed(property.place.identifier)) {
              nextProperties = null;
              break;
            }
          }
        }
        if (nextProperties !== null) {
          instr.value.lvalue.pattern.properties = nextProperties;
        }
        break;
      }
      default: {
        assertExhaustive(
          instr.value.lvalue.pattern,
          `Unexpected pattern kind '${instr.value.lvalue.pattern.kind}'`
        );
      }
    }
  } else if (instr.value.kind === "StoreLocal") {
    if (instr.value.lvalue.kind !== "Reassign" /* Reassign */ && !state.isIdUsed(instr.value.lvalue.place.identifier)) {
      instr.value = {
        kind: "DeclareLocal",
        lvalue: instr.value.lvalue,
        type: instr.value.type,
        loc: instr.value.loc
      };
    }
  }
}
function pruneableValue(value, state) {
  switch (value.kind) {
    case "DeclareLocal": {
      return !state.isIdOrNameUsed(value.lvalue.place.identifier);
    }
    case "StoreLocal": {
      if (value.lvalue.kind === "Reassign" /* Reassign */) {
        return !state.isIdUsed(value.lvalue.place.identifier);
      }
      return !state.isIdOrNameUsed(value.lvalue.place.identifier);
    }
    case "Destructure": {
      let isIdOrNameUsed = false;
      let isIdUsed = false;
      for (const place of eachPatternOperand(value.lvalue.pattern)) {
        if (state.isIdUsed(place.identifier)) {
          isIdOrNameUsed = true;
          isIdUsed = true;
        } else if (state.isIdOrNameUsed(place.identifier)) {
          isIdOrNameUsed = true;
        }
      }
      if (value.lvalue.kind === "Reassign" /* Reassign */) {
        return !isIdUsed;
      } else {
        return !isIdOrNameUsed;
      }
    }
    case "PostfixUpdate":
    case "PrefixUpdate": {
      return !state.isIdUsed(value.lvalue.identifier);
    }
    case "Debugger": {
      return false;
    }
    case "Await":
    case "CallExpression":
    case "ComputedDelete":
    case "ComputedStore":
    case "PropertyDelete":
    case "MethodCall":
    case "PropertyStore":
    case "StoreGlobal": {
      return false;
    }
    case "NewExpression":
    case "UnsupportedNode":
    case "TaggedTemplateExpression": {
      return false;
    }
    case "GetIterator":
    case "NextPropertyOf":
    case "IteratorNext": {
      return false;
    }
    case "LoadContext":
    case "DeclareContext":
    case "StoreContext": {
      return false;
    }
    case "StartMemoize":
    case "FinishMemoize": {
      return false;
    }
    case "RegExpLiteral":
    case "MetaProperty":
    case "LoadGlobal":
    case "ArrayExpression":
    case "BinaryExpression":
    case "ComputedLoad":
    case "ObjectMethod":
    case "FunctionExpression":
    case "LoadLocal":
    case "JsxExpression":
    case "JsxFragment":
    case "JSXText":
    case "ObjectExpression":
    case "Primitive":
    case "PropertyLoad":
    case "TemplateLiteral":
    case "TypeCastExpression":
    case "UnaryExpression": {
      return true;
    }
    default: {
      assertExhaustive(
        value,
        `Unexepcted value kind \`${value.kind}\``
      );
    }
  }
}
function hasBackEdge(fn) {
  return findBlocksWithBackEdges(fn).size > 0;
}
function findBlocksWithBackEdges(fn) {
  const visited = /* @__PURE__ */ new Set();
  const blocks = /* @__PURE__ */ new Set();
  for (const [blockId, block] of fn.body.blocks) {
    for (const predId of block.preds) {
      if (!visited.has(predId)) {
        blocks.add(blockId);
      }
    }
    visited.add(blockId);
  }
  return blocks;
}

// src/Optimization/PruneMaybeThrows.ts
function pruneMaybeThrows(fn) {
  const terminalMapping = pruneMaybeThrowsImpl(fn);
  if (terminalMapping) {
    reversePostorderBlocks(fn.body);
    removeUnreachableForUpdates(fn.body);
    removeDeadDoWhileStatements(fn.body);
    removeUnnecessaryTryCatch(fn.body);
    markInstructionIds(fn.body);
    mergeConsecutiveBlocks(fn);
    for (const [, block] of fn.body.blocks) {
      for (const phi of block.phis) {
        for (const [predecessor, operand] of phi.operands) {
          if (!block.preds.has(predecessor)) {
            const mappedTerminal = terminalMapping.get(predecessor);
            CompilerError.invariant(mappedTerminal != null, {
              reason: `Expected non-existing phi operand's predecessor to have been mapped to a new terminal`,
              loc: GeneratedSource,
              description: `Could not find mapping for predecessor bb${predecessor} in block bb${block.id} for phi ${printPlace(phi.place)}`,
              suggestions: null
            });
            phi.operands.delete(predecessor);
            phi.operands.set(mappedTerminal, operand);
          }
        }
      }
    }
    assertConsistentIdentifiers(fn);
    assertTerminalSuccessorsExist(fn);
  }
}
function pruneMaybeThrowsImpl(fn) {
  var _a;
  const terminalMapping = /* @__PURE__ */ new Map();
  for (const [_, block] of fn.body.blocks) {
    const terminal = block.terminal;
    if (terminal.kind !== "maybe-throw") {
      continue;
    }
    const canThrow = block.instructions.some(
      (instr) => instructionMayThrow(instr)
    );
    if (!canThrow) {
      const source2 = (_a = terminalMapping.get(block.id)) != null ? _a : block.id;
      terminalMapping.set(terminal.continuation, source2);
      block.terminal = {
        kind: "goto",
        block: terminal.continuation,
        variant: "Break" /* Break */,
        id: terminal.id,
        loc: terminal.loc
      };
    }
  }
  return terminalMapping.size > 0 ? terminalMapping : null;
}
function instructionMayThrow(instr) {
  switch (instr.value.kind) {
    case "Primitive":
    case "ArrayExpression":
    case "ObjectExpression": {
      return false;
    }
    default: {
      return true;
    }
  }
}

// src/Optimization/InlineJsxTransform.ts
function inlineJsxTransform(fn, inlineJsxTransformConfig) {
  var _a;
  const inlinedJsxDeclarations = /* @__PURE__ */ new Map();
  for (const [_, currentBlock] of [...fn.body.blocks]) {
    let fallthroughBlockInstructions = null;
    const instructionCount = currentBlock.instructions.length;
    for (let i = 0; i < instructionCount; i++) {
      const instr = currentBlock.instructions[i];
      if (currentBlock.kind === "value") {
        (_a = fn.env.logger) == null ? void 0 : _a.logEvent(fn.env.filename, {
          kind: "CompileDiagnostic",
          fnLoc: null,
          detail: {
            category: "Todo" /* Todo */,
            reason: "JSX Inlining is not supported on value blocks",
            loc: instr.loc
          }
        });
        continue;
      }
      switch (instr.value.kind) {
        case "JsxExpression":
        case "JsxFragment": {
          const currentBlockInstructions = currentBlock.instructions.slice(
            0,
            i
          );
          const thenBlockInstructions = currentBlock.instructions.slice(
            i,
            i + 1
          );
          const elseBlockInstructions = [];
          fallthroughBlockInstructions != null ? fallthroughBlockInstructions : fallthroughBlockInstructions = currentBlock.instructions.slice(
            i + 1
          );
          const fallthroughBlockId = fn.env.nextBlockId;
          const fallthroughBlock = {
            kind: currentBlock.kind,
            id: fallthroughBlockId,
            instructions: fallthroughBlockInstructions,
            terminal: currentBlock.terminal,
            preds: /* @__PURE__ */ new Set(),
            phis: /* @__PURE__ */ new Set()
          };
          const varPlace = createTemporaryPlace(fn.env, instr.value.loc);
          promoteTemporary(varPlace.identifier);
          const varLValuePlace = createTemporaryPlace(fn.env, instr.value.loc);
          const thenVarPlace = __spreadProps(__spreadValues({}, varPlace), {
            identifier: forkTemporaryIdentifier(
              fn.env.nextIdentifierId,
              varPlace.identifier
            )
          });
          const elseVarPlace = __spreadProps(__spreadValues({}, varPlace), {
            identifier: forkTemporaryIdentifier(
              fn.env.nextIdentifierId,
              varPlace.identifier
            )
          });
          const varInstruction = {
            id: makeInstructionId(0),
            lvalue: __spreadValues({}, varLValuePlace),
            value: {
              kind: "DeclareLocal",
              lvalue: { place: __spreadValues({}, varPlace), kind: "Let" /* Let */ },
              type: null,
              loc: instr.value.loc
            },
            effects: null,
            loc: instr.loc
          };
          currentBlockInstructions.push(varInstruction);
          const devGlobalPlace = createTemporaryPlace(fn.env, instr.value.loc);
          const devGlobalInstruction = {
            id: makeInstructionId(0),
            lvalue: __spreadProps(__spreadValues({}, devGlobalPlace), { effect: "mutate" /* Mutate */ }),
            value: {
              kind: "LoadGlobal",
              binding: {
                kind: "Global",
                name: inlineJsxTransformConfig.globalDevVar
              },
              loc: instr.value.loc
            },
            effects: null,
            loc: instr.loc
          };
          currentBlockInstructions.push(devGlobalInstruction);
          const thenBlockId = fn.env.nextBlockId;
          const elseBlockId = fn.env.nextBlockId;
          const ifTerminal = {
            kind: "if",
            test: __spreadProps(__spreadValues({}, devGlobalPlace), { effect: "read" /* Read */ }),
            consequent: thenBlockId,
            alternate: elseBlockId,
            fallthrough: fallthroughBlockId,
            loc: instr.loc,
            id: makeInstructionId(0)
          };
          currentBlock.instructions = currentBlockInstructions;
          currentBlock.terminal = ifTerminal;
          const thenBlock = {
            id: thenBlockId,
            instructions: thenBlockInstructions,
            kind: "block",
            phis: /* @__PURE__ */ new Set(),
            preds: /* @__PURE__ */ new Set(),
            terminal: {
              kind: "goto",
              block: fallthroughBlockId,
              variant: "Break" /* Break */,
              id: makeInstructionId(0),
              loc: instr.loc
            }
          };
          fn.body.blocks.set(thenBlockId, thenBlock);
          const resassignElsePlace = createTemporaryPlace(
            fn.env,
            instr.value.loc
          );
          const reassignElseInstruction = {
            id: makeInstructionId(0),
            lvalue: __spreadValues({}, resassignElsePlace),
            value: {
              kind: "StoreLocal",
              lvalue: {
                place: elseVarPlace,
                kind: "Reassign" /* Reassign */
              },
              value: __spreadValues({}, instr.lvalue),
              type: null,
              loc: instr.value.loc
            },
            effects: null,
            loc: instr.loc
          };
          thenBlockInstructions.push(reassignElseInstruction);
          const elseBlockTerminal = {
            kind: "goto",
            block: fallthroughBlockId,
            variant: "Break" /* Break */,
            id: makeInstructionId(0),
            loc: instr.loc
          };
          const elseBlock = {
            id: elseBlockId,
            instructions: elseBlockInstructions,
            kind: "block",
            phis: /* @__PURE__ */ new Set(),
            preds: /* @__PURE__ */ new Set(),
            terminal: elseBlockTerminal
          };
          fn.body.blocks.set(elseBlockId, elseBlock);
          const { refProperty, keyProperty, propsProperty } = createPropsProperties(
            fn,
            instr,
            elseBlockInstructions,
            instr.value.kind === "JsxExpression" ? instr.value.props : [],
            instr.value.children
          );
          const reactElementInstructionPlace = createTemporaryPlace(
            fn.env,
            instr.value.loc
          );
          const reactElementInstruction = {
            id: makeInstructionId(0),
            lvalue: __spreadProps(__spreadValues({}, reactElementInstructionPlace), { effect: "store" /* Store */ }),
            value: {
              kind: "ObjectExpression",
              properties: [
                createSymbolProperty(
                  fn,
                  instr,
                  elseBlockInstructions,
                  "$$typeof",
                  inlineJsxTransformConfig.elementSymbol
                ),
                instr.value.kind === "JsxExpression" ? createTagProperty(
                  fn,
                  instr,
                  elseBlockInstructions,
                  instr.value.tag
                ) : createSymbolProperty(
                  fn,
                  instr,
                  elseBlockInstructions,
                  "type",
                  "react.fragment"
                ),
                refProperty,
                keyProperty,
                propsProperty
              ],
              loc: instr.value.loc
            },
            effects: null,
            loc: instr.loc
          };
          elseBlockInstructions.push(reactElementInstruction);
          const reassignConditionalInstruction = {
            id: makeInstructionId(0),
            lvalue: __spreadValues({}, createTemporaryPlace(fn.env, instr.value.loc)),
            value: {
              kind: "StoreLocal",
              lvalue: {
                place: __spreadValues({}, elseVarPlace),
                kind: "Reassign" /* Reassign */
              },
              value: __spreadValues({}, reactElementInstruction.lvalue),
              type: null,
              loc: instr.value.loc
            },
            effects: null,
            loc: instr.loc
          };
          elseBlockInstructions.push(reassignConditionalInstruction);
          const operands = /* @__PURE__ */ new Map();
          operands.set(thenBlockId, __spreadValues({}, elseVarPlace));
          operands.set(elseBlockId, __spreadValues({}, thenVarPlace));
          const phiIdentifier = forkTemporaryIdentifier(
            fn.env.nextIdentifierId,
            varPlace.identifier
          );
          const phiPlace = __spreadProps(__spreadValues({}, createTemporaryPlace(fn.env, instr.value.loc)), {
            identifier: phiIdentifier
          });
          const phis = /* @__PURE__ */ new Set([
            {
              kind: "Phi",
              operands,
              place: phiPlace
            }
          ]);
          fallthroughBlock.phis = phis;
          fn.body.blocks.set(fallthroughBlockId, fallthroughBlock);
          inlinedJsxDeclarations.set(instr.lvalue.identifier.declarationId, {
            identifier: phiIdentifier,
            blockIdsToIgnore: /* @__PURE__ */ new Set([thenBlockId, elseBlockId])
          });
          break;
        }
        case "FunctionExpression":
        case "ObjectMethod": {
          inlineJsxTransform(
            instr.value.loweredFunc.func,
            inlineJsxTransformConfig
          );
          break;
        }
      }
    }
  }
  for (const [blockId, block] of fn.body.blocks) {
    for (const instr of block.instructions) {
      mapInstructionOperands(
        instr,
        (place) => handlePlace(place, blockId, inlinedJsxDeclarations)
      );
      mapInstructionLValues(
        instr,
        (lvalue) => handlelValue(lvalue, blockId, inlinedJsxDeclarations)
      );
      mapInstructionValueOperands(
        instr.value,
        (place) => handlePlace(place, blockId, inlinedJsxDeclarations)
      );
    }
    mapTerminalOperands(
      block.terminal,
      (place) => handlePlace(place, blockId, inlinedJsxDeclarations)
    );
    if (block.terminal.kind === "scope") {
      const scope = block.terminal.scope;
      for (const dep of scope.dependencies) {
        dep.identifier = handleIdentifier2(
          dep.identifier,
          inlinedJsxDeclarations
        );
      }
      for (const [origId, decl] of [...scope.declarations]) {
        const newDecl = handleIdentifier2(
          decl.identifier,
          inlinedJsxDeclarations
        );
        if (newDecl.id !== origId) {
          scope.declarations.delete(origId);
          scope.declarations.set(decl.identifier.id, {
            identifier: newDecl,
            scope: decl.scope
          });
        }
      }
    }
  }
  reversePostorderBlocks(fn.body);
  markPredecessors(fn.body);
  markInstructionIds(fn.body);
  fixScopeAndIdentifierRanges(fn.body);
}
function createSymbolProperty(fn, instr, nextInstructions, propertyName, symbolName) {
  const symbolPlace = createTemporaryPlace(fn.env, instr.value.loc);
  const symbolInstruction = {
    id: makeInstructionId(0),
    lvalue: __spreadProps(__spreadValues({}, symbolPlace), { effect: "mutate" /* Mutate */ }),
    value: {
      kind: "LoadGlobal",
      binding: { kind: "Global", name: "Symbol" },
      loc: instr.value.loc
    },
    effects: null,
    loc: instr.loc
  };
  nextInstructions.push(symbolInstruction);
  const symbolForPlace = createTemporaryPlace(fn.env, instr.value.loc);
  const symbolForInstruction = {
    id: makeInstructionId(0),
    lvalue: __spreadProps(__spreadValues({}, symbolForPlace), { effect: "read" /* Read */ }),
    value: {
      kind: "PropertyLoad",
      object: __spreadValues({}, symbolInstruction.lvalue),
      property: makePropertyLiteral("for"),
      loc: instr.value.loc
    },
    effects: null,
    loc: instr.loc
  };
  nextInstructions.push(symbolForInstruction);
  const symbolValuePlace = createTemporaryPlace(fn.env, instr.value.loc);
  const symbolValueInstruction = {
    id: makeInstructionId(0),
    lvalue: __spreadProps(__spreadValues({}, symbolValuePlace), { effect: "mutate" /* Mutate */ }),
    value: {
      kind: "Primitive",
      value: symbolName,
      loc: instr.value.loc
    },
    effects: null,
    loc: instr.loc
  };
  nextInstructions.push(symbolValueInstruction);
  const $$typeofPlace = createTemporaryPlace(fn.env, instr.value.loc);
  const $$typeofInstruction = {
    id: makeInstructionId(0),
    lvalue: __spreadProps(__spreadValues({}, $$typeofPlace), { effect: "mutate" /* Mutate */ }),
    value: {
      kind: "MethodCall",
      receiver: symbolInstruction.lvalue,
      property: symbolForInstruction.lvalue,
      args: [symbolValueInstruction.lvalue],
      loc: instr.value.loc
    },
    effects: null,
    loc: instr.loc
  };
  const $$typeofProperty = {
    kind: "ObjectProperty",
    key: { name: propertyName, kind: "string" },
    type: "property",
    place: __spreadProps(__spreadValues({}, $$typeofPlace), { effect: "capture" /* Capture */ })
  };
  nextInstructions.push($$typeofInstruction);
  return $$typeofProperty;
}
function createTagProperty(fn, instr, nextInstructions, componentTag) {
  let tagProperty;
  switch (componentTag.kind) {
    case "BuiltinTag": {
      const tagPropertyPlace = createTemporaryPlace(fn.env, instr.value.loc);
      const tagInstruction = {
        id: makeInstructionId(0),
        lvalue: __spreadProps(__spreadValues({}, tagPropertyPlace), { effect: "mutate" /* Mutate */ }),
        value: {
          kind: "Primitive",
          value: componentTag.name,
          loc: instr.value.loc
        },
        effects: null,
        loc: instr.loc
      };
      tagProperty = {
        kind: "ObjectProperty",
        key: { name: "type", kind: "string" },
        type: "property",
        place: __spreadProps(__spreadValues({}, tagPropertyPlace), { effect: "capture" /* Capture */ })
      };
      nextInstructions.push(tagInstruction);
      break;
    }
    case "Identifier": {
      tagProperty = {
        kind: "ObjectProperty",
        key: { name: "type", kind: "string" },
        type: "property",
        place: __spreadProps(__spreadValues({}, componentTag), { effect: "capture" /* Capture */ })
      };
      break;
    }
  }
  return tagProperty;
}
function createPropsProperties(fn, instr, nextInstructions, propAttributes, children) {
  let refProperty;
  let keyProperty;
  const props = [];
  const jsxAttributesWithoutKey = propAttributes.filter(
    (p) => p.kind === "JsxAttribute" && p.name !== "key"
  );
  const jsxSpreadAttributes = propAttributes.filter(
    (p) => p.kind === "JsxSpreadAttribute"
  );
  const spreadPropsOnly = jsxAttributesWithoutKey.length === 0 && jsxSpreadAttributes.length === 1;
  propAttributes.forEach((prop) => {
    switch (prop.kind) {
      case "JsxAttribute": {
        switch (prop.name) {
          case "key": {
            keyProperty = {
              kind: "ObjectProperty",
              key: { name: "key", kind: "string" },
              type: "property",
              place: __spreadValues({}, prop.place)
            };
            break;
          }
          case "ref": {
            refProperty = {
              kind: "ObjectProperty",
              key: { name: "ref", kind: "string" },
              type: "property",
              place: __spreadValues({}, prop.place)
            };
            const refPropProperty = {
              kind: "ObjectProperty",
              key: { name: "ref", kind: "string" },
              type: "property",
              place: __spreadValues({}, prop.place)
            };
            props.push(refPropProperty);
            break;
          }
          default: {
            const attributeProperty = {
              kind: "ObjectProperty",
              key: { name: prop.name, kind: "string" },
              type: "property",
              place: __spreadValues({}, prop.place)
            };
            props.push(attributeProperty);
          }
        }
        break;
      }
      case "JsxSpreadAttribute": {
        props.push({
          kind: "Spread",
          place: __spreadValues({}, prop.argument)
        });
        break;
      }
    }
  });
  const propsPropertyPlace = createTemporaryPlace(fn.env, instr.value.loc);
  if (children) {
    let childrenPropProperty;
    if (children.length === 1) {
      childrenPropProperty = {
        kind: "ObjectProperty",
        key: { name: "children", kind: "string" },
        type: "property",
        place: __spreadProps(__spreadValues({}, children[0]), { effect: "capture" /* Capture */ })
      };
    } else {
      const childrenPropPropertyPlace = createTemporaryPlace(
        fn.env,
        instr.value.loc
      );
      const childrenPropInstruction = {
        id: makeInstructionId(0),
        lvalue: __spreadProps(__spreadValues({}, childrenPropPropertyPlace), { effect: "mutate" /* Mutate */ }),
        value: {
          kind: "ArrayExpression",
          elements: [...children],
          loc: instr.value.loc
        },
        effects: null,
        loc: instr.loc
      };
      nextInstructions.push(childrenPropInstruction);
      childrenPropProperty = {
        kind: "ObjectProperty",
        key: { name: "children", kind: "string" },
        type: "property",
        place: __spreadProps(__spreadValues({}, childrenPropPropertyPlace), { effect: "capture" /* Capture */ })
      };
    }
    props.push(childrenPropProperty);
  }
  if (refProperty == null) {
    const refPropertyPlace = createTemporaryPlace(fn.env, instr.value.loc);
    const refInstruction = {
      id: makeInstructionId(0),
      lvalue: __spreadProps(__spreadValues({}, refPropertyPlace), { effect: "mutate" /* Mutate */ }),
      value: {
        kind: "Primitive",
        value: null,
        loc: instr.value.loc
      },
      effects: null,
      loc: instr.loc
    };
    refProperty = {
      kind: "ObjectProperty",
      key: { name: "ref", kind: "string" },
      type: "property",
      place: __spreadProps(__spreadValues({}, refPropertyPlace), { effect: "capture" /* Capture */ })
    };
    nextInstructions.push(refInstruction);
  }
  if (keyProperty == null) {
    const keyPropertyPlace = createTemporaryPlace(fn.env, instr.value.loc);
    const keyInstruction = {
      id: makeInstructionId(0),
      lvalue: __spreadProps(__spreadValues({}, keyPropertyPlace), { effect: "mutate" /* Mutate */ }),
      value: {
        kind: "Primitive",
        value: null,
        loc: instr.value.loc
      },
      effects: null,
      loc: instr.loc
    };
    keyProperty = {
      kind: "ObjectProperty",
      key: { name: "key", kind: "string" },
      type: "property",
      place: __spreadProps(__spreadValues({}, keyPropertyPlace), { effect: "capture" /* Capture */ })
    };
    nextInstructions.push(keyInstruction);
  }
  let propsProperty;
  if (spreadPropsOnly) {
    const spreadProp = jsxSpreadAttributes[0];
    CompilerError.invariant(spreadProp.kind === "JsxSpreadAttribute", {
      reason: "Spread prop attribute must be of kind JSXSpreadAttribute",
      loc: instr.loc
    });
    propsProperty = {
      kind: "ObjectProperty",
      key: { name: "props", kind: "string" },
      type: "property",
      place: __spreadProps(__spreadValues({}, spreadProp.argument), { effect: "mutate" /* Mutate */ })
    };
  } else {
    const propsInstruction = {
      id: makeInstructionId(0),
      lvalue: __spreadProps(__spreadValues({}, propsPropertyPlace), { effect: "mutate" /* Mutate */ }),
      value: {
        kind: "ObjectExpression",
        properties: props,
        loc: instr.value.loc
      },
      effects: null,
      loc: instr.loc
    };
    propsProperty = {
      kind: "ObjectProperty",
      key: { name: "props", kind: "string" },
      type: "property",
      place: __spreadProps(__spreadValues({}, propsPropertyPlace), { effect: "capture" /* Capture */ })
    };
    nextInstructions.push(propsInstruction);
  }
  return { refProperty, keyProperty, propsProperty };
}
function handlePlace(place, blockId, inlinedJsxDeclarations) {
  const inlinedJsxDeclaration = inlinedJsxDeclarations.get(
    place.identifier.declarationId
  );
  if (inlinedJsxDeclaration == null || inlinedJsxDeclaration.blockIdsToIgnore.has(blockId)) {
    return place;
  }
  return __spreadProps(__spreadValues({}, place), { identifier: inlinedJsxDeclaration.identifier });
}
function handlelValue(lvalue, blockId, inlinedJsxDeclarations) {
  const inlinedJsxDeclaration = inlinedJsxDeclarations.get(
    lvalue.identifier.declarationId
  );
  if (inlinedJsxDeclaration == null || inlinedJsxDeclaration.blockIdsToIgnore.has(blockId)) {
    return lvalue;
  }
  return __spreadProps(__spreadValues({}, lvalue), { identifier: inlinedJsxDeclaration.identifier });
}
function handleIdentifier2(identifier4, inlinedJsxDeclarations) {
  const inlinedJsxDeclaration = inlinedJsxDeclarations.get(
    identifier4.declarationId
  );
  return inlinedJsxDeclaration == null ? identifier4 : inlinedJsxDeclaration.identifier;
}

// src/ReactiveScopes/AlignObjectMethodScopes.ts
function findScopesToMerge(fn) {
  const objectMethodDecls = /* @__PURE__ */ new Set();
  const mergeScopesBuilder = new DisjointSet();
  for (const [_, block] of fn.body.blocks) {
    for (const { lvalue, value } of block.instructions) {
      if (value.kind === "ObjectMethod") {
        objectMethodDecls.add(lvalue.identifier);
      } else if (value.kind === "ObjectExpression") {
        for (const operand of eachInstructionValueOperand(value)) {
          if (objectMethodDecls.has(operand.identifier)) {
            const operandScope = operand.identifier.scope;
            const lvalueScope = lvalue.identifier.scope;
            CompilerError.invariant(
              operandScope != null && lvalueScope != null,
              {
                reason: "Internal error: Expected all ObjectExpressions and ObjectMethods to have non-null scope.",
                suggestions: null,
                loc: GeneratedSource
              }
            );
            mergeScopesBuilder.union([operandScope, lvalueScope]);
          }
        }
      }
    }
  }
  return mergeScopesBuilder;
}
function alignObjectMethodScopes(fn) {
  for (const [_, block] of fn.body.blocks) {
    for (const { value } of block.instructions) {
      if (value.kind === "ObjectMethod" || value.kind === "FunctionExpression") {
        alignObjectMethodScopes(value.loweredFunc.func);
      }
    }
  }
  const scopeGroupsMap = findScopesToMerge(fn).canonicalize();
  for (const [scope, root2] of scopeGroupsMap) {
    if (scope !== root2) {
      root2.range.start = makeInstructionId(
        Math.min(scope.range.start, root2.range.start)
      );
      root2.range.end = makeInstructionId(
        Math.max(scope.range.end, root2.range.end)
      );
    }
  }
  for (const [_, block] of fn.body.blocks) {
    for (const {
      lvalue: { identifier: identifier4 }
    } of block.instructions) {
      if (identifier4.scope != null) {
        const root2 = scopeGroupsMap.get(identifier4.scope);
        if (root2 != null) {
          identifier4.scope = root2;
        }
      }
    }
  }
}

// src/ReactiveScopes/visitors.ts
function visitReactiveFunction(fn, visitor, state) {
  visitor.visitBlock(fn.body, state);
}
var ReactiveFunctionVisitor = class {
  visitID(_id, _state) {
  }
  visitParam(_place, _state) {
  }
  visitLValue(_id, _lvalue, _state) {
  }
  visitPlace(_id, _place, _state) {
  }
  visitReactiveFunctionValue(_id, _dependencies2, _fn, _state) {
  }
  visitValue(id, value, state) {
    this.traverseValue(id, value, state);
  }
  traverseValue(id, value, state) {
    switch (value.kind) {
      case "OptionalExpression": {
        this.visitValue(id, value.value, state);
        break;
      }
      case "LogicalExpression": {
        this.visitValue(id, value.left, state);
        this.visitValue(id, value.right, state);
        break;
      }
      case "ConditionalExpression": {
        this.visitValue(id, value.test, state);
        this.visitValue(id, value.consequent, state);
        this.visitValue(id, value.alternate, state);
        break;
      }
      case "SequenceExpression": {
        for (const instr of value.instructions) {
          this.visitInstruction(instr, state);
        }
        this.visitValue(value.id, value.value, state);
        break;
      }
      default: {
        for (const place of eachInstructionValueOperand(value)) {
          this.visitPlace(id, place, state);
        }
      }
    }
  }
  visitInstruction(instruction, state) {
    this.traverseInstruction(instruction, state);
  }
  traverseInstruction(instruction, state) {
    this.visitID(instruction.id, state);
    for (const operand of eachInstructionLValue(instruction)) {
      this.visitLValue(instruction.id, operand, state);
    }
    this.visitValue(instruction.id, instruction.value, state);
  }
  visitTerminal(stmt, state) {
    this.traverseTerminal(stmt, state);
  }
  traverseTerminal(stmt, state) {
    const { terminal } = stmt;
    if (terminal.id !== null) {
      this.visitID(terminal.id, state);
    }
    switch (terminal.kind) {
      case "break":
      case "continue": {
        break;
      }
      case "return": {
        this.visitPlace(terminal.id, terminal.value, state);
        break;
      }
      case "throw": {
        this.visitPlace(terminal.id, terminal.value, state);
        break;
      }
      case "for": {
        this.visitValue(terminal.id, terminal.init, state);
        this.visitValue(terminal.id, terminal.test, state);
        this.visitBlock(terminal.loop, state);
        if (terminal.update !== null) {
          this.visitValue(terminal.id, terminal.update, state);
        }
        break;
      }
      case "for-of": {
        this.visitValue(terminal.id, terminal.init, state);
        this.visitValue(terminal.id, terminal.test, state);
        this.visitBlock(terminal.loop, state);
        break;
      }
      case "for-in": {
        this.visitValue(terminal.id, terminal.init, state);
        this.visitBlock(terminal.loop, state);
        break;
      }
      case "do-while": {
        this.visitBlock(terminal.loop, state);
        this.visitValue(terminal.id, terminal.test, state);
        break;
      }
      case "while": {
        this.visitValue(terminal.id, terminal.test, state);
        this.visitBlock(terminal.loop, state);
        break;
      }
      case "if": {
        this.visitPlace(terminal.id, terminal.test, state);
        this.visitBlock(terminal.consequent, state);
        if (terminal.alternate !== null) {
          this.visitBlock(terminal.alternate, state);
        }
        break;
      }
      case "switch": {
        this.visitPlace(terminal.id, terminal.test, state);
        for (const case_ of terminal.cases) {
          if (case_.test !== null) {
            this.visitPlace(terminal.id, case_.test, state);
          }
          if (case_.block !== void 0) {
            this.visitBlock(case_.block, state);
          }
        }
        break;
      }
      case "label": {
        this.visitBlock(terminal.block, state);
        break;
      }
      case "try": {
        this.visitBlock(terminal.block, state);
        this.visitBlock(terminal.handler, state);
        break;
      }
      default: {
        assertExhaustive(
          terminal,
          `Unexpected terminal kind \`${terminal.kind}\``
        );
      }
    }
  }
  visitScope(scope, state) {
    this.traverseScope(scope, state);
  }
  traverseScope(scope, state) {
    this.visitBlock(scope.instructions, state);
  }
  visitPrunedScope(scopeBlock, state) {
    this.traversePrunedScope(scopeBlock, state);
  }
  traversePrunedScope(scopeBlock, state) {
    this.visitBlock(scopeBlock.instructions, state);
  }
  visitBlock(block, state) {
    this.traverseBlock(block, state);
  }
  traverseBlock(block, state) {
    for (const instr of block) {
      switch (instr.kind) {
        case "instruction": {
          this.visitInstruction(instr.instruction, state);
          break;
        }
        case "scope": {
          this.visitScope(instr, state);
          break;
        }
        case "pruned-scope": {
          this.visitPrunedScope(instr, state);
          break;
        }
        case "terminal": {
          this.visitTerminal(instr, state);
          break;
        }
        default: {
          assertExhaustive(
            instr,
            `Unexpected instruction kind \`${instr.kind}\``
          );
        }
      }
    }
  }
  visitHirFunction(fn, state) {
    for (const param of fn.params) {
      const place = param.kind === "Identifier" ? param : param.place;
      this.visitParam(place, state);
    }
    for (const [, block] of fn.body.blocks) {
      for (const instr of block.instructions) {
        this.visitInstruction(instr, state);
        if (instr.value.kind === "FunctionExpression" || instr.value.kind === "ObjectMethod") {
          this.visitHirFunction(instr.value.loweredFunc.func, state);
        }
      }
      for (const operand of eachTerminalOperand(block.terminal)) {
        this.visitPlace(block.terminal.id, operand, state);
      }
    }
  }
};
var ReactiveFunctionTransform = class extends ReactiveFunctionVisitor {
  traverseBlock(block, state) {
    let nextBlock = null;
    for (let i = 0; i < block.length; i++) {
      const instr = block[i];
      let transformed;
      switch (instr.kind) {
        case "instruction": {
          transformed = this.transformInstruction(instr.instruction, state);
          break;
        }
        case "scope": {
          transformed = this.transformScope(instr, state);
          break;
        }
        case "pruned-scope": {
          transformed = this.transformPrunedScope(instr, state);
          break;
        }
        case "terminal": {
          transformed = this.transformTerminal(instr, state);
          break;
        }
        default: {
          assertExhaustive(
            instr,
            `Unexpected instruction kind \`${instr.kind}\``
          );
        }
      }
      switch (transformed.kind) {
        case "keep": {
          if (nextBlock !== null) {
            nextBlock.push(instr);
          }
          break;
        }
        case "remove": {
          if (nextBlock === null) {
            nextBlock = block.slice(0, i);
          }
          break;
        }
        case "replace": {
          nextBlock != null ? nextBlock : nextBlock = block.slice(0, i);
          nextBlock.push(transformed.value);
          break;
        }
        case "replace-many": {
          nextBlock != null ? nextBlock : nextBlock = block.slice(0, i);
          nextBlock.push(...transformed.value);
          break;
        }
      }
    }
    if (nextBlock !== null) {
      block.length = 0;
      block.push(...nextBlock);
    }
  }
  transformInstruction(instruction, state) {
    this.visitInstruction(instruction, state);
    return { kind: "keep" };
  }
  transformTerminal(stmt, state) {
    this.visitTerminal(stmt, state);
    return { kind: "keep" };
  }
  transformScope(scope, state) {
    this.visitScope(scope, state);
    return { kind: "keep" };
  }
  transformPrunedScope(scope, state) {
    this.visitPrunedScope(scope, state);
    return { kind: "keep" };
  }
  transformValue(id, value, state) {
    this.visitValue(id, value, state);
    return { kind: "keep" };
  }
  transformReactiveFunctionValue(id, dependencies, fn, state) {
    this.visitReactiveFunctionValue(id, dependencies, fn, state);
    return { kind: "keep" };
  }
  traverseValue(id, value, state) {
    switch (value.kind) {
      case "OptionalExpression": {
        const nextValue = this.transformValue(id, value.value, state);
        if (nextValue.kind === "replace") {
          value.value = nextValue.value;
        }
        break;
      }
      case "LogicalExpression": {
        const left = this.transformValue(id, value.left, state);
        if (left.kind === "replace") {
          value.left = left.value;
        }
        const right = this.transformValue(id, value.right, state);
        if (right.kind === "replace") {
          value.right = right.value;
        }
        break;
      }
      case "ConditionalExpression": {
        const test = this.transformValue(id, value.test, state);
        if (test.kind === "replace") {
          value.test = test.value;
        }
        const consequent = this.transformValue(id, value.consequent, state);
        if (consequent.kind === "replace") {
          value.consequent = consequent.value;
        }
        const alternate = this.transformValue(id, value.alternate, state);
        if (alternate.kind === "replace") {
          value.alternate = alternate.value;
        }
        break;
      }
      case "SequenceExpression": {
        for (const instr of value.instructions) {
          this.visitInstruction(instr, state);
        }
        const nextValue = this.transformValue(value.id, value.value, state);
        if (nextValue.kind === "replace") {
          value.value = nextValue.value;
        }
        break;
      }
      default: {
        for (const place of eachInstructionValueOperand(value)) {
          this.visitPlace(id, place, state);
        }
      }
    }
  }
  traverseInstruction(instruction, state) {
    this.visitID(instruction.id, state);
    for (const operand of eachInstructionLValue(instruction)) {
      this.visitLValue(instruction.id, operand, state);
    }
    const nextValue = this.transformValue(
      instruction.id,
      instruction.value,
      state
    );
    if (nextValue.kind === "replace") {
      instruction.value = nextValue.value;
    }
  }
  traverseTerminal(stmt, state) {
    const { terminal } = stmt;
    if (terminal.id !== null) {
      this.visitID(terminal.id, state);
    }
    switch (terminal.kind) {
      case "break":
      case "continue": {
        break;
      }
      case "return": {
        this.visitPlace(terminal.id, terminal.value, state);
        break;
      }
      case "throw": {
        this.visitPlace(terminal.id, terminal.value, state);
        break;
      }
      case "for": {
        const init = this.transformValue(terminal.id, terminal.init, state);
        if (init.kind === "replace") {
          terminal.init = init.value;
        }
        const test = this.transformValue(terminal.id, terminal.test, state);
        if (test.kind === "replace") {
          terminal.test = test.value;
        }
        if (terminal.update !== null) {
          const update2 = this.transformValue(
            terminal.id,
            terminal.update,
            state
          );
          if (update2.kind === "replace") {
            terminal.update = update2.value;
          }
        }
        this.visitBlock(terminal.loop, state);
        break;
      }
      case "for-of": {
        const init = this.transformValue(terminal.id, terminal.init, state);
        if (init.kind === "replace") {
          terminal.init = init.value;
        }
        const test = this.transformValue(terminal.id, terminal.test, state);
        if (test.kind === "replace") {
          terminal.test = test.value;
        }
        this.visitBlock(terminal.loop, state);
        break;
      }
      case "for-in": {
        const init = this.transformValue(terminal.id, terminal.init, state);
        if (init.kind === "replace") {
          terminal.init = init.value;
        }
        this.visitBlock(terminal.loop, state);
        break;
      }
      case "do-while": {
        this.visitBlock(terminal.loop, state);
        const test = this.transformValue(terminal.id, terminal.test, state);
        if (test.kind === "replace") {
          terminal.test = test.value;
        }
        break;
      }
      case "while": {
        const test = this.transformValue(terminal.id, terminal.test, state);
        if (test.kind === "replace") {
          terminal.test = test.value;
        }
        this.visitBlock(terminal.loop, state);
        break;
      }
      case "if": {
        this.visitPlace(terminal.id, terminal.test, state);
        this.visitBlock(terminal.consequent, state);
        if (terminal.alternate !== null) {
          this.visitBlock(terminal.alternate, state);
        }
        break;
      }
      case "switch": {
        this.visitPlace(terminal.id, terminal.test, state);
        for (const case_ of terminal.cases) {
          if (case_.test !== null) {
            this.visitPlace(terminal.id, case_.test, state);
          }
          if (case_.block !== void 0) {
            this.visitBlock(case_.block, state);
          }
        }
        break;
      }
      case "label": {
        this.visitBlock(terminal.block, state);
        break;
      }
      case "try": {
        this.visitBlock(terminal.block, state);
        if (terminal.handlerBinding !== null) {
          this.visitPlace(terminal.id, terminal.handlerBinding, state);
        }
        this.visitBlock(terminal.handler, state);
        break;
      }
      default: {
        assertExhaustive(
          terminal,
          `Unexpected terminal kind \`${terminal.kind}\``
        );
      }
    }
  }
};
function* eachReactiveValueOperand(instrValue) {
  switch (instrValue.kind) {
    case "OptionalExpression": {
      yield* __yieldStar(eachReactiveValueOperand(instrValue.value));
      break;
    }
    case "LogicalExpression": {
      yield* __yieldStar(eachReactiveValueOperand(instrValue.left));
      yield* __yieldStar(eachReactiveValueOperand(instrValue.right));
      break;
    }
    case "SequenceExpression": {
      for (const instr of instrValue.instructions) {
        yield* __yieldStar(eachReactiveValueOperand(instr.value));
      }
      yield* __yieldStar(eachReactiveValueOperand(instrValue.value));
      break;
    }
    case "ConditionalExpression": {
      yield* __yieldStar(eachReactiveValueOperand(instrValue.test));
      yield* __yieldStar(eachReactiveValueOperand(instrValue.consequent));
      yield* __yieldStar(eachReactiveValueOperand(instrValue.alternate));
      break;
    }
    default: {
      yield* __yieldStar(eachInstructionValueOperand(instrValue));
    }
  }
}

// src/ReactiveScopes/AssertScopeInstructionsWithinScope.ts
function assertScopeInstructionsWithinScopes(fn) {
  const existingScopes = /* @__PURE__ */ new Set();
  visitReactiveFunction(fn, new FindAllScopesVisitor(), existingScopes);
  visitReactiveFunction(
    fn,
    new CheckInstructionsAgainstScopesVisitor(),
    existingScopes
  );
}
var FindAllScopesVisitor = class extends ReactiveFunctionVisitor {
  visitScope(block, state) {
    this.traverseScope(block, state);
    state.add(block.scope.id);
  }
};
var CheckInstructionsAgainstScopesVisitor = class extends ReactiveFunctionVisitor {
  constructor() {
    super(...arguments);
    this.activeScopes = /* @__PURE__ */ new Set();
  }
  visitPlace(id, place, state) {
    const scope = getPlaceScope(id, place);
    if (scope !== null && // is there a scope for this at all, or did we end up pruning this scope?
    state.has(scope.id) && /*
     * if the scope exists somewhere, it must be active or else this is a straggler
     * instruction
     */
    !this.activeScopes.has(scope.id)) {
      CompilerError.invariant(false, {
        description: `Instruction [${id}] is part of scope @${scope.id}, but that scope has already completed.`,
        loc: place.loc,
        reason: "Encountered an instruction that should be part of a scope, but where that scope has already completed",
        suggestions: null
      });
    }
  }
  visitScope(block, state) {
    this.activeScopes.add(block.scope.id);
    this.traverseScope(block, state);
    this.activeScopes.delete(block.scope.id);
  }
};

// src/ReactiveScopes/AssertWellFormedBreakTargets.ts
function assertWellFormedBreakTargets(fn) {
  visitReactiveFunction(fn, new Visitor(), /* @__PURE__ */ new Set());
}
var Visitor = class extends ReactiveFunctionVisitor {
  visitTerminal(stmt, seenLabels) {
    if (stmt.label != null) {
      seenLabels.add(stmt.label.id);
    }
    const terminal = stmt.terminal;
    if (terminal.kind === "break" || terminal.kind === "continue") {
      CompilerError.invariant(seenLabels.has(terminal.target), {
        reason: "Unexpected break to invalid label",
        loc: stmt.terminal.loc
      });
    }
  }
};

// src/ReactiveScopes/BuildReactiveFunction.ts
function buildReactiveFunction(fn) {
  const cx = new Context(fn.body);
  const driver = new Driver(cx);
  const body = driver.traverseBlock(cx.block(fn.body.entry));
  return {
    loc: fn.loc,
    id: fn.id,
    params: fn.params,
    generator: fn.generator,
    async: fn.async,
    body,
    env: fn.env,
    directives: fn.directives
  };
}
var Driver = class {
  constructor(cx) {
    this.cx = cx;
  }
  traverseBlock(block) {
    const blockValue = [];
    this.visitBlock(block, blockValue);
    return blockValue;
  }
  visitBlock(block, blockValue) {
    var _a;
    CompilerError.invariant(!this.cx.emitted.has(block.id), {
      reason: `Cannot emit the same block twice: bb${block.id}`,
      description: null,
      loc: null,
      suggestions: null
    });
    this.cx.emitted.add(block.id);
    for (const instruction of block.instructions) {
      blockValue.push({
        kind: "instruction",
        instruction
      });
    }
    const terminal = block.terminal;
    const scheduleIds = [];
    switch (terminal.kind) {
      case "return": {
        blockValue.push({
          kind: "terminal",
          terminal: {
            kind: "return",
            loc: terminal.loc,
            value: terminal.value,
            id: terminal.id
          },
          label: null
        });
        break;
      }
      case "throw": {
        blockValue.push({
          kind: "terminal",
          terminal: {
            kind: "throw",
            loc: terminal.loc,
            value: terminal.value,
            id: terminal.id
          },
          label: null
        });
        break;
      }
      case "if": {
        const fallthroughId = this.cx.reachable(terminal.fallthrough) && !this.cx.isScheduled(terminal.fallthrough) ? terminal.fallthrough : null;
        const alternateId = terminal.alternate !== terminal.fallthrough ? terminal.alternate : null;
        if (fallthroughId !== null) {
          const scheduleId = this.cx.schedule(fallthroughId, "if");
          scheduleIds.push(scheduleId);
        }
        let consequent = null;
        if (this.cx.isScheduled(terminal.consequent)) {
          CompilerError.invariant(false, {
            reason: `Unexpected 'if' where the consequent is already scheduled`,
            loc: terminal.loc
          });
        } else {
          consequent = this.traverseBlock(
            this.cx.ir.blocks.get(terminal.consequent)
          );
        }
        let alternate = null;
        if (alternateId !== null) {
          if (this.cx.isScheduled(alternateId)) {
            CompilerError.invariant(false, {
              reason: `Unexpected 'if' where the alternate is already scheduled`,
              loc: terminal.loc
            });
          } else {
            alternate = this.traverseBlock(this.cx.ir.blocks.get(alternateId));
          }
        }
        this.cx.unscheduleAll(scheduleIds);
        blockValue.push({
          kind: "terminal",
          terminal: {
            kind: "if",
            loc: terminal.loc,
            test: terminal.test,
            consequent: consequent != null ? consequent : this.emptyBlock(),
            alternate,
            id: terminal.id
          },
          label: fallthroughId == null ? null : {
            id: fallthroughId,
            implicit: false
          }
        });
        if (fallthroughId !== null) {
          this.visitBlock(this.cx.ir.blocks.get(fallthroughId), blockValue);
        }
        break;
      }
      case "switch": {
        const fallthroughId = this.cx.reachable(terminal.fallthrough) && !this.cx.isScheduled(terminal.fallthrough) ? terminal.fallthrough : null;
        if (fallthroughId !== null) {
          const scheduleId = this.cx.schedule(fallthroughId, "switch");
          scheduleIds.push(scheduleId);
        }
        const cases = [];
        [...terminal.cases].reverse().forEach((case_, _index) => {
          const test = case_.test;
          let consequent;
          if (this.cx.isScheduled(case_.block)) {
            CompilerError.invariant(case_.block === terminal.fallthrough, {
              reason: `Unexpected 'switch' where a case is already scheduled and block is not the fallthrough`,
              loc: terminal.loc
            });
            return;
          } else {
            consequent = this.traverseBlock(
              this.cx.ir.blocks.get(case_.block)
            );
            const scheduleId = this.cx.schedule(case_.block, "case");
            scheduleIds.push(scheduleId);
          }
          cases.push({ test, block: consequent });
        });
        cases.reverse();
        this.cx.unscheduleAll(scheduleIds);
        blockValue.push({
          kind: "terminal",
          terminal: {
            kind: "switch",
            loc: terminal.loc,
            test: terminal.test,
            cases,
            id: terminal.id
          },
          label: fallthroughId == null ? null : {
            id: fallthroughId,
            implicit: false
          }
        });
        if (fallthroughId !== null) {
          this.visitBlock(this.cx.ir.blocks.get(fallthroughId), blockValue);
        }
        break;
      }
      case "do-while": {
        const fallthroughId = !this.cx.isScheduled(terminal.fallthrough) ? terminal.fallthrough : null;
        const loopId = !this.cx.isScheduled(terminal.loop) && terminal.loop !== terminal.fallthrough ? terminal.loop : null;
        const scheduleId = this.cx.scheduleLoop(
          terminal.fallthrough,
          terminal.test,
          terminal.loop
        );
        scheduleIds.push(scheduleId);
        let loopBody;
        if (loopId) {
          loopBody = this.traverseBlock(this.cx.ir.blocks.get(loopId));
        } else {
          CompilerError.invariant(false, {
            reason: `Unexpected 'do-while' where the loop is already scheduled`,
            loc: terminal.loc
          });
        }
        const testValue = this.visitValueBlock(
          terminal.test,
          terminal.loc
        ).value;
        this.cx.unscheduleAll(scheduleIds);
        blockValue.push({
          kind: "terminal",
          terminal: {
            kind: "do-while",
            loc: terminal.loc,
            test: testValue,
            loop: loopBody,
            id: terminal.id
          },
          label: fallthroughId == null ? null : {
            id: fallthroughId,
            implicit: false
          }
        });
        if (fallthroughId !== null) {
          this.visitBlock(this.cx.ir.blocks.get(fallthroughId), blockValue);
        }
        break;
      }
      case "while": {
        const fallthroughId = this.cx.reachable(terminal.fallthrough) && !this.cx.isScheduled(terminal.fallthrough) ? terminal.fallthrough : null;
        const loopId = !this.cx.isScheduled(terminal.loop) && terminal.loop !== terminal.fallthrough ? terminal.loop : null;
        const scheduleId = this.cx.scheduleLoop(
          terminal.fallthrough,
          terminal.test,
          terminal.loop
        );
        scheduleIds.push(scheduleId);
        const testValue = this.visitValueBlock(
          terminal.test,
          terminal.loc
        ).value;
        let loopBody;
        if (loopId) {
          loopBody = this.traverseBlock(this.cx.ir.blocks.get(loopId));
        } else {
          CompilerError.invariant(false, {
            reason: `Unexpected 'while' where the loop is already scheduled`,
            loc: terminal.loc
          });
        }
        this.cx.unscheduleAll(scheduleIds);
        blockValue.push({
          kind: "terminal",
          terminal: {
            kind: "while",
            loc: terminal.loc,
            test: testValue,
            loop: loopBody,
            id: terminal.id
          },
          label: fallthroughId == null ? null : {
            id: fallthroughId,
            implicit: false
          }
        });
        if (fallthroughId !== null) {
          this.visitBlock(this.cx.ir.blocks.get(fallthroughId), blockValue);
        }
        break;
      }
      case "for": {
        const loopId = !this.cx.isScheduled(terminal.loop) && terminal.loop !== terminal.fallthrough ? terminal.loop : null;
        const fallthroughId = !this.cx.isScheduled(terminal.fallthrough) ? terminal.fallthrough : null;
        const scheduleId = this.cx.scheduleLoop(
          terminal.fallthrough,
          (_a = terminal.update) != null ? _a : terminal.test,
          terminal.loop
        );
        scheduleIds.push(scheduleId);
        const init = this.visitValueBlock(terminal.init, terminal.loc);
        const initBlock = this.cx.ir.blocks.get(init.block);
        let initValue = init.value;
        if (initValue.kind === "SequenceExpression") {
          const last = initBlock.instructions.at(-1);
          initValue.instructions.push(last);
          initValue.value = {
            kind: "Primitive",
            value: void 0,
            loc: terminal.loc
          };
        } else {
          initValue = {
            kind: "SequenceExpression",
            instructions: [initBlock.instructions.at(-1)],
            id: terminal.id,
            loc: terminal.loc,
            value: {
              kind: "Primitive",
              value: void 0,
              loc: terminal.loc
            }
          };
        }
        const testValue = this.visitValueBlock(
          terminal.test,
          terminal.loc
        ).value;
        const updateValue = terminal.update !== null ? this.visitValueBlock(terminal.update, terminal.loc).value : null;
        let loopBody;
        if (loopId) {
          loopBody = this.traverseBlock(this.cx.ir.blocks.get(loopId));
        } else {
          CompilerError.invariant(false, {
            reason: `Unexpected 'for' where the loop is already scheduled`,
            loc: terminal.loc
          });
        }
        this.cx.unscheduleAll(scheduleIds);
        blockValue.push({
          kind: "terminal",
          terminal: {
            kind: "for",
            loc: terminal.loc,
            init: initValue,
            test: testValue,
            update: updateValue,
            loop: loopBody,
            id: terminal.id
          },
          label: fallthroughId == null ? null : { id: fallthroughId, implicit: false }
        });
        if (fallthroughId !== null) {
          this.visitBlock(this.cx.ir.blocks.get(fallthroughId), blockValue);
        }
        break;
      }
      case "for-of": {
        const loopId = !this.cx.isScheduled(terminal.loop) && terminal.loop !== terminal.fallthrough ? terminal.loop : null;
        const fallthroughId = !this.cx.isScheduled(terminal.fallthrough) ? terminal.fallthrough : null;
        const scheduleId = this.cx.scheduleLoop(
          terminal.fallthrough,
          terminal.init,
          terminal.loop
        );
        scheduleIds.push(scheduleId);
        const init = this.visitValueBlock(terminal.init, terminal.loc);
        const initBlock = this.cx.ir.blocks.get(init.block);
        let initValue = init.value;
        if (initValue.kind === "SequenceExpression") {
          const last = initBlock.instructions.at(-1);
          initValue.instructions.push(last);
          initValue.value = {
            kind: "Primitive",
            value: void 0,
            loc: terminal.loc
          };
        } else {
          initValue = {
            kind: "SequenceExpression",
            instructions: [initBlock.instructions.at(-1)],
            id: terminal.id,
            loc: terminal.loc,
            value: {
              kind: "Primitive",
              value: void 0,
              loc: terminal.loc
            }
          };
        }
        const test = this.visitValueBlock(terminal.test, terminal.loc);
        const testBlock = this.cx.ir.blocks.get(test.block);
        let testValue = test.value;
        if (testValue.kind === "SequenceExpression") {
          const last = testBlock.instructions.at(-1);
          testValue.instructions.push(last);
          testValue.value = {
            kind: "Primitive",
            value: void 0,
            loc: terminal.loc
          };
        } else {
          testValue = {
            kind: "SequenceExpression",
            instructions: [testBlock.instructions.at(-1)],
            id: terminal.id,
            loc: terminal.loc,
            value: {
              kind: "Primitive",
              value: void 0,
              loc: terminal.loc
            }
          };
        }
        let loopBody;
        if (loopId) {
          loopBody = this.traverseBlock(this.cx.ir.blocks.get(loopId));
        } else {
          CompilerError.invariant(false, {
            reason: `Unexpected 'for-of' where the loop is already scheduled`,
            loc: terminal.loc
          });
        }
        this.cx.unscheduleAll(scheduleIds);
        blockValue.push({
          kind: "terminal",
          terminal: {
            kind: "for-of",
            loc: terminal.loc,
            init: initValue,
            test: testValue,
            loop: loopBody,
            id: terminal.id
          },
          label: fallthroughId == null ? null : { id: fallthroughId, implicit: false }
        });
        if (fallthroughId !== null) {
          this.visitBlock(this.cx.ir.blocks.get(fallthroughId), blockValue);
        }
        break;
      }
      case "for-in": {
        const loopId = !this.cx.isScheduled(terminal.loop) && terminal.loop !== terminal.fallthrough ? terminal.loop : null;
        const fallthroughId = !this.cx.isScheduled(terminal.fallthrough) ? terminal.fallthrough : null;
        const scheduleId = this.cx.scheduleLoop(
          terminal.fallthrough,
          terminal.init,
          terminal.loop
        );
        scheduleIds.push(scheduleId);
        const init = this.visitValueBlock(terminal.init, terminal.loc);
        const initBlock = this.cx.ir.blocks.get(init.block);
        let initValue = init.value;
        if (initValue.kind === "SequenceExpression") {
          const last = initBlock.instructions.at(-1);
          initValue.instructions.push(last);
          initValue.value = {
            kind: "Primitive",
            value: void 0,
            loc: terminal.loc
          };
        } else {
          initValue = {
            kind: "SequenceExpression",
            instructions: [initBlock.instructions.at(-1)],
            id: terminal.id,
            loc: terminal.loc,
            value: {
              kind: "Primitive",
              value: void 0,
              loc: terminal.loc
            }
          };
        }
        let loopBody;
        if (loopId) {
          loopBody = this.traverseBlock(this.cx.ir.blocks.get(loopId));
        } else {
          CompilerError.invariant(false, {
            reason: `Unexpected 'for-in' where the loop is already scheduled`,
            loc: terminal.loc
          });
        }
        this.cx.unscheduleAll(scheduleIds);
        blockValue.push({
          kind: "terminal",
          terminal: {
            kind: "for-in",
            loc: terminal.loc,
            init: initValue,
            loop: loopBody,
            id: terminal.id
          },
          label: fallthroughId == null ? null : { id: fallthroughId, implicit: false }
        });
        if (fallthroughId !== null) {
          this.visitBlock(this.cx.ir.blocks.get(fallthroughId), blockValue);
        }
        break;
      }
      case "branch": {
        let consequent = null;
        if (this.cx.isScheduled(terminal.consequent)) {
          const break_ = this.visitBreak(
            terminal.consequent,
            terminal.id,
            terminal.loc
          );
          if (break_ !== null) {
            consequent = [break_];
          }
        } else {
          consequent = this.traverseBlock(
            this.cx.ir.blocks.get(terminal.consequent)
          );
        }
        let alternate = null;
        if (this.cx.isScheduled(terminal.alternate)) {
          CompilerError.invariant(false, {
            reason: `Unexpected 'branch' where the alternate is already scheduled`,
            loc: terminal.loc
          });
        } else {
          alternate = this.traverseBlock(
            this.cx.ir.blocks.get(terminal.alternate)
          );
        }
        blockValue.push({
          kind: "terminal",
          terminal: {
            kind: "if",
            loc: terminal.loc,
            test: terminal.test,
            consequent: consequent != null ? consequent : this.emptyBlock(),
            alternate,
            id: terminal.id
          },
          label: null
        });
        break;
      }
      case "label": {
        const fallthroughId = this.cx.reachable(terminal.fallthrough) && !this.cx.isScheduled(terminal.fallthrough) ? terminal.fallthrough : null;
        if (fallthroughId !== null) {
          const scheduleId = this.cx.schedule(fallthroughId, "if");
          scheduleIds.push(scheduleId);
        }
        let block2;
        if (this.cx.isScheduled(terminal.block)) {
          CompilerError.invariant(false, {
            reason: `Unexpected 'label' where the block is already scheduled`,
            loc: terminal.loc
          });
        } else {
          block2 = this.traverseBlock(this.cx.ir.blocks.get(terminal.block));
        }
        this.cx.unscheduleAll(scheduleIds);
        blockValue.push({
          kind: "terminal",
          terminal: {
            kind: "label",
            loc: terminal.loc,
            block: block2,
            id: terminal.id
          },
          label: fallthroughId == null ? null : { id: fallthroughId, implicit: false }
        });
        if (fallthroughId !== null) {
          this.visitBlock(this.cx.ir.blocks.get(fallthroughId), blockValue);
        }
        break;
      }
      case "sequence":
      case "optional":
      case "ternary":
      case "logical": {
        const fallthroughId = terminal.fallthrough !== null && !this.cx.isScheduled(terminal.fallthrough) ? terminal.fallthrough : null;
        if (fallthroughId !== null) {
          const scheduleId = this.cx.schedule(fallthroughId, "if");
          scheduleIds.push(scheduleId);
        }
        const { place, value } = this.visitValueBlockTerminal(terminal);
        this.cx.unscheduleAll(scheduleIds);
        blockValue.push({
          kind: "instruction",
          instruction: {
            id: terminal.id,
            lvalue: place,
            value,
            loc: terminal.loc
          }
        });
        if (fallthroughId !== null) {
          this.visitBlock(this.cx.ir.blocks.get(fallthroughId), blockValue);
        }
        break;
      }
      case "goto": {
        switch (terminal.variant) {
          case "Break" /* Break */: {
            const break_ = this.visitBreak(
              terminal.block,
              terminal.id,
              terminal.loc
            );
            if (break_ !== null) {
              blockValue.push(break_);
            }
            break;
          }
          case "Continue" /* Continue */: {
            const continue_ = this.visitContinue(
              terminal.block,
              terminal.id,
              terminal.loc
            );
            if (continue_ !== null) {
              blockValue.push(continue_);
            }
            break;
          }
          case "Try" /* Try */: {
            break;
          }
          default: {
            assertExhaustive(
              terminal.variant,
              `Unexpected goto variant \`${terminal.variant}\``
            );
          }
        }
        break;
      }
      case "maybe-throw": {
        if (!this.cx.isScheduled(terminal.continuation)) {
          this.visitBlock(
            this.cx.ir.blocks.get(terminal.continuation),
            blockValue
          );
        }
        break;
      }
      case "try": {
        const fallthroughId = this.cx.reachable(terminal.fallthrough) && !this.cx.isScheduled(terminal.fallthrough) ? terminal.fallthrough : null;
        if (fallthroughId !== null) {
          const scheduleId = this.cx.schedule(fallthroughId, "if");
          scheduleIds.push(scheduleId);
        }
        this.cx.scheduleCatchHandler(terminal.handler);
        const block2 = this.traverseBlock(
          this.cx.ir.blocks.get(terminal.block)
        );
        const handler = this.traverseBlock(
          this.cx.ir.blocks.get(terminal.handler)
        );
        this.cx.unscheduleAll(scheduleIds);
        blockValue.push({
          kind: "terminal",
          label: fallthroughId == null ? null : { id: fallthroughId, implicit: false },
          terminal: {
            kind: "try",
            loc: terminal.loc,
            block: block2,
            handlerBinding: terminal.handlerBinding,
            handler,
            id: terminal.id
          }
        });
        if (fallthroughId !== null) {
          this.visitBlock(this.cx.ir.blocks.get(fallthroughId), blockValue);
        }
        break;
      }
      case "pruned-scope":
      case "scope": {
        const fallthroughId = !this.cx.isScheduled(terminal.fallthrough) ? terminal.fallthrough : null;
        if (fallthroughId !== null) {
          const scheduleId = this.cx.schedule(fallthroughId, "if");
          scheduleIds.push(scheduleId);
          this.cx.scopeFallthroughs.add(fallthroughId);
        }
        let block2;
        if (this.cx.isScheduled(terminal.block)) {
          CompilerError.invariant(false, {
            reason: `Unexpected 'scope' where the block is already scheduled`,
            loc: terminal.loc
          });
        } else {
          block2 = this.traverseBlock(this.cx.ir.blocks.get(terminal.block));
        }
        this.cx.unscheduleAll(scheduleIds);
        blockValue.push({
          kind: terminal.kind,
          instructions: block2,
          scope: terminal.scope
        });
        if (fallthroughId !== null) {
          this.visitBlock(this.cx.ir.blocks.get(fallthroughId), blockValue);
        }
        break;
      }
      case "unreachable": {
        break;
      }
      case "unsupported": {
        CompilerError.invariant(false, {
          reason: "Unexpected unsupported terminal",
          description: null,
          loc: terminal.loc,
          suggestions: null
        });
      }
      default: {
        assertExhaustive(terminal, "Unexpected terminal");
      }
    }
  }
  visitValueBlock(id, loc) {
    const defaultBlock = this.cx.ir.blocks.get(id);
    if (defaultBlock.terminal.kind === "branch") {
      const instructions = defaultBlock.instructions;
      if (instructions.length === 0) {
        return {
          block: defaultBlock.id,
          place: defaultBlock.terminal.test,
          value: {
            kind: "LoadLocal",
            place: defaultBlock.terminal.test,
            loc: defaultBlock.terminal.test.loc
          },
          id: defaultBlock.terminal.id
        };
      } else if (defaultBlock.instructions.length === 1) {
        const instr = defaultBlock.instructions[0];
        CompilerError.invariant(
          instr.lvalue.identifier.id === defaultBlock.terminal.test.identifier.id,
          {
            reason: "Expected branch block to end in an instruction that sets the test value",
            description: null,
            loc: instr.lvalue.loc,
            suggestions: null
          }
        );
        return {
          block: defaultBlock.id,
          place: instr.lvalue,
          value: instr.value,
          id: instr.id
        };
      } else {
        const instr = defaultBlock.instructions.at(-1);
        const sequence = {
          kind: "SequenceExpression",
          instructions: defaultBlock.instructions.slice(0, -1),
          id: instr.id,
          value: instr.value,
          loc
        };
        return {
          block: defaultBlock.id,
          place: defaultBlock.terminal.test,
          value: sequence,
          id: defaultBlock.terminal.id
        };
      }
    } else if (defaultBlock.terminal.kind === "goto") {
      const instructions = defaultBlock.instructions;
      if (instructions.length === 0) {
        CompilerError.invariant(false, {
          reason: "Expected goto value block to have at least one instruction",
          description: null,
          loc: null,
          suggestions: null
        });
      } else if (defaultBlock.instructions.length === 1) {
        const instr = defaultBlock.instructions[0];
        let place = instr.lvalue;
        let value = instr.value;
        if (
          /*
           * Value blocks generally end in a StoreLocal to assign the value of the
           * expression for this branch. These StoreLocal instructions can be pruned,
           * since we represent the value blocks as a compund value in ReactiveFunction
           * (no phis). However, it's also possible to have a value block that ends in
           * an AssignmentExpression, which we need to keep. So we only prune
           * StoreLocal for temporaries — any named/promoted values must be used
           * elsewhere and aren't safe to prune.
           */
          value.kind === "StoreLocal" && value.lvalue.place.identifier.name === null
        ) {
          place = value.lvalue.place;
          value = {
            kind: "LoadLocal",
            place: value.value,
            loc: value.value.loc
          };
        }
        return {
          block: defaultBlock.id,
          place,
          value,
          id: instr.id
        };
      } else {
        const instr = defaultBlock.instructions.at(-1);
        let place = instr.lvalue;
        let value = instr.value;
        if (
          /*
           * Value blocks generally end in a StoreLocal to assign the value of the
           * expression for this branch. These StoreLocal instructions can be pruned,
           * since we represent the value blocks as a compund value in ReactiveFunction
           * (no phis). However, it's also possible to have a value block that ends in
           * an AssignmentExpression, which we need to keep. So we only prune
           * StoreLocal for temporaries — any named/promoted values must be used
           * elsewhere and aren't safe to prune.
           */
          value.kind === "StoreLocal" && value.lvalue.place.identifier.name === null
        ) {
          place = value.lvalue.place;
          value = {
            kind: "LoadLocal",
            place: value.value,
            loc: value.value.loc
          };
        }
        const sequence = {
          kind: "SequenceExpression",
          instructions: defaultBlock.instructions.slice(0, -1),
          id: instr.id,
          value,
          loc
        };
        return {
          block: defaultBlock.id,
          place,
          value: sequence,
          id: instr.id
        };
      }
    } else {
      const init = this.visitValueBlockTerminal(defaultBlock.terminal);
      const final = this.visitValueBlock(init.fallthrough, loc);
      const sequence = {
        kind: "SequenceExpression",
        instructions: [
          ...defaultBlock.instructions,
          {
            id: init.id,
            loc,
            lvalue: init.place,
            value: init.value
          }
        ],
        id: final.id,
        value: final.value,
        loc
      };
      return {
        block: init.fallthrough,
        value: sequence,
        place: final.place,
        id: final.id
      };
    }
  }
  visitValueBlockTerminal(terminal) {
    switch (terminal.kind) {
      case "sequence": {
        const block = this.visitValueBlock(terminal.block, terminal.loc);
        return {
          value: block.value,
          place: block.place,
          fallthrough: terminal.fallthrough,
          id: terminal.id
        };
      }
      case "optional": {
        const test = this.visitValueBlock(terminal.test, terminal.loc);
        const testBlock = this.cx.ir.blocks.get(test.block);
        if (testBlock.terminal.kind !== "branch") {
          CompilerError.throwTodo({
            reason: `Unexpected terminal kind \`${testBlock.terminal.kind}\` for optional test block`,
            description: null,
            loc: testBlock.terminal.loc,
            suggestions: null
          });
        }
        const consequent = this.visitValueBlock(
          testBlock.terminal.consequent,
          terminal.loc
        );
        const call = {
          kind: "SequenceExpression",
          instructions: [
            {
              id: test.id,
              loc: testBlock.terminal.loc,
              lvalue: test.place,
              value: test.value
            }
          ],
          id: consequent.id,
          value: consequent.value,
          loc: terminal.loc
        };
        return {
          place: __spreadValues({}, consequent.place),
          value: {
            kind: "OptionalExpression",
            optional: terminal.optional,
            value: call,
            id: terminal.id,
            loc: terminal.loc
          },
          fallthrough: terminal.fallthrough,
          id: terminal.id
        };
      }
      case "logical": {
        const test = this.visitValueBlock(terminal.test, terminal.loc);
        const testBlock = this.cx.ir.blocks.get(test.block);
        if (testBlock.terminal.kind !== "branch") {
          CompilerError.throwTodo({
            reason: `Unexpected terminal kind \`${testBlock.terminal.kind}\` for logical test block`,
            description: null,
            loc: testBlock.terminal.loc,
            suggestions: null
          });
        }
        const leftFinal = this.visitValueBlock(
          testBlock.terminal.consequent,
          terminal.loc
        );
        const left = {
          kind: "SequenceExpression",
          instructions: [
            {
              id: test.id,
              loc: terminal.loc,
              lvalue: test.place,
              value: test.value
            }
          ],
          id: leftFinal.id,
          value: leftFinal.value,
          loc: terminal.loc
        };
        const right = this.visitValueBlock(
          testBlock.terminal.alternate,
          terminal.loc
        );
        const value = {
          kind: "LogicalExpression",
          operator: terminal.operator,
          left,
          right: right.value,
          loc: terminal.loc
        };
        return {
          place: __spreadValues({}, leftFinal.place),
          value,
          fallthrough: terminal.fallthrough,
          id: terminal.id
        };
      }
      case "ternary": {
        const test = this.visitValueBlock(terminal.test, terminal.loc);
        const testBlock = this.cx.ir.blocks.get(test.block);
        if (testBlock.terminal.kind !== "branch") {
          CompilerError.throwTodo({
            reason: `Unexpected terminal kind \`${testBlock.terminal.kind}\` for ternary test block`,
            description: null,
            loc: testBlock.terminal.loc,
            suggestions: null
          });
        }
        const consequent = this.visitValueBlock(
          testBlock.terminal.consequent,
          terminal.loc
        );
        const alternate = this.visitValueBlock(
          testBlock.terminal.alternate,
          terminal.loc
        );
        const value = {
          kind: "ConditionalExpression",
          test: test.value,
          consequent: consequent.value,
          alternate: alternate.value,
          loc: terminal.loc
        };
        return {
          place: __spreadValues({}, consequent.place),
          value,
          fallthrough: terminal.fallthrough,
          id: terminal.id
        };
      }
      case "maybe-throw": {
        CompilerError.throwTodo({
          reason: `Support value blocks (conditional, logical, optional chaining, etc) within a try/catch statement`,
          description: null,
          loc: terminal.loc,
          suggestions: null
        });
      }
      case "label": {
        CompilerError.throwTodo({
          reason: `Support labeled statements combined with value blocks (conditional, logical, optional chaining, etc)`,
          description: null,
          loc: terminal.loc,
          suggestions: null
        });
      }
      default: {
        CompilerError.throwTodo({
          reason: `Support \`${terminal.kind}\` as a value block terminal (conditional, logical, optional chaining, etc)`,
          description: null,
          loc: terminal.loc,
          suggestions: null
        });
      }
    }
  }
  emptyBlock() {
    return [];
  }
  visitBreak(block, id, loc) {
    const target = this.cx.getBreakTarget(block);
    if (target === null) {
      CompilerError.invariant(false, {
        reason: "Expected a break target",
        description: null,
        loc: null,
        suggestions: null
      });
    }
    if (this.cx.scopeFallthroughs.has(target.block)) {
      CompilerError.invariant(target.type === "implicit", {
        reason: "Expected reactive scope to implicitly break to fallthrough",
        loc
      });
      return null;
    }
    return {
      kind: "terminal",
      terminal: {
        kind: "break",
        loc,
        target: target.block,
        id,
        targetKind: target.type
      },
      label: null
    };
  }
  visitContinue(block, id, loc) {
    const target = this.cx.getContinueTarget(block);
    CompilerError.invariant(target !== null, {
      reason: `Expected continue target to be scheduled for bb${block}`,
      description: null,
      loc: null,
      suggestions: null
    });
    return {
      kind: "terminal",
      terminal: {
        kind: "continue",
        loc,
        target: target.block,
        id,
        targetKind: target.type
      },
      label: null
    };
  }
};
var _nextScheduleId, _scheduled, _catchHandlers, _controlFlowStack;
var Context = class {
  constructor(ir) {
    __privateAdd(this, _nextScheduleId, 0);
    /*
     * Used to track which blocks *have been* generated already in order to
     * abort if a block is generated a second time. This is an error catching
     * mechanism for debugging purposes, and is not used by the codegen algorithm
     * to drive decisions about how to emit blocks.
     */
    this.emitted = /* @__PURE__ */ new Set();
    this.scopeFallthroughs = /* @__PURE__ */ new Set();
    /*
     * A set of blocks that are already scheduled to be emitted by eg a parent.
     * This allows child nodes to avoid re-emitting the same block and emit eg
     * a break instead.
     */
    __privateAdd(this, _scheduled, /* @__PURE__ */ new Set());
    __privateAdd(this, _catchHandlers, /* @__PURE__ */ new Set());
    /*
     * Represents which control flow operations are currently in scope, with the innermost
     * scope last. Roughly speaking, the last ControlFlowTarget on the stack indicates where
     * control will implicitly transfer, such that gotos to that block can be elided. Gotos
     * targeting items higher up the stack may need labeled break or continue; see
     * getBreakTarget() and getContinueTarget() for more details.
     */
    __privateAdd(this, _controlFlowStack, []);
    this.ir = ir;
  }
  block(id) {
    return this.ir.blocks.get(id);
  }
  scheduleCatchHandler(block) {
    __privateGet(this, _catchHandlers).add(block);
  }
  reachable(id) {
    const block = this.ir.blocks.get(id);
    return block.terminal.kind !== "unreachable";
  }
  /*
   * Record that the given block will be emitted (eg by the codegen of a parent node)
   * so that child nodes can avoid re-emitting it.
   */
  schedule(block, type) {
    const id = __privateWrapper(this, _nextScheduleId)._++;
    CompilerError.invariant(!__privateGet(this, _scheduled).has(block), {
      reason: `Break block is already scheduled: bb${block}`,
      description: null,
      loc: null,
      suggestions: null
    });
    __privateGet(this, _scheduled).add(block);
    __privateGet(this, _controlFlowStack).push({ block, id, type });
    return id;
  }
  scheduleLoop(fallthroughBlock, continueBlock, loopBlock) {
    const id = __privateWrapper(this, _nextScheduleId)._++;
    const ownsBlock = !__privateGet(this, _scheduled).has(fallthroughBlock);
    __privateGet(this, _scheduled).add(fallthroughBlock);
    CompilerError.invariant(!__privateGet(this, _scheduled).has(continueBlock), {
      reason: `Continue block is already scheduled: bb${continueBlock}`,
      description: null,
      loc: null,
      suggestions: null
    });
    __privateGet(this, _scheduled).add(continueBlock);
    let ownsLoop = false;
    if (loopBlock !== null) {
      ownsLoop = !__privateGet(this, _scheduled).has(loopBlock);
      __privateGet(this, _scheduled).add(loopBlock);
    }
    __privateGet(this, _controlFlowStack).push({
      block: fallthroughBlock,
      ownsBlock,
      id,
      type: "loop",
      continueBlock,
      loopBlock,
      ownsLoop
    });
    return id;
  }
  // Removes a block that was scheduled; must be called after that block is emitted.
  unschedule(scheduleId) {
    const last = __privateGet(this, _controlFlowStack).pop();
    CompilerError.invariant(last !== void 0 && last.id === scheduleId, {
      reason: "Can only unschedule the last target",
      description: null,
      loc: null,
      suggestions: null
    });
    if (last.type !== "loop" || last.ownsBlock !== null) {
      __privateGet(this, _scheduled).delete(last.block);
    }
    if (last.type === "loop") {
      __privateGet(this, _scheduled).delete(last.continueBlock);
      if (last.ownsLoop && last.loopBlock !== null) {
        __privateGet(this, _scheduled).delete(last.loopBlock);
      }
    }
  }
  /*
   * Helper to unschedule multiple scheduled blocks. The ids should be in
   * the order in which they were scheduled, ie most recently scheduled last.
   */
  unscheduleAll(scheduleIds) {
    for (let i = scheduleIds.length - 1; i >= 0; i--) {
      this.unschedule(scheduleIds[i]);
    }
  }
  // Check if the given @param block is scheduled or not.
  isScheduled(block) {
    return __privateGet(this, _scheduled).has(block) || __privateGet(this, _catchHandlers).has(block);
  }
  /*
   * Given the current control flow stack, determines how a `break` to the given @param block
   * must be emitted. Returns as follows:
   * - 'implicit' if control would implicitly transfer to that block
   * - 'labeled' if a labeled break is required to transfer control to that block
   * - 'unlabeled' if an unlabeled break would transfer to that block
   * - null if there is no information for this block
   *
   * The returned 'block' value should be used as the label if necessary.
   */
  getBreakTarget(block) {
    let hasPrecedingLoop = false;
    for (let i = __privateGet(this, _controlFlowStack).length - 1; i >= 0; i--) {
      const target = __privateGet(this, _controlFlowStack)[i];
      if (target.block === block) {
        let type;
        if (target.type === "loop") {
          type = hasPrecedingLoop ? "labeled" : "unlabeled";
        } else if (i === __privateGet(this, _controlFlowStack).length - 1) {
          type = "implicit";
        } else {
          type = "labeled";
        }
        return {
          block: target.block,
          type
        };
      }
      hasPrecedingLoop || (hasPrecedingLoop = target.type === "loop");
    }
    CompilerError.invariant(false, {
      reason: "Expected a break target",
      description: null,
      loc: null,
      suggestions: null
    });
  }
  /*
   * Given the current control flow stack, determines how a `continue` to the given @param block
   * must be emitted. Returns as follows:
   * - 'implicit' if control would implicitly continue to that block
   * - 'labeled' if a labeled continue is required to continue to that block
   * - 'unlabeled' if an unlabeled continue would transfer to that block
   * - null if there is no information for this block
   *
   * The returned 'block' value should be used as the label if necessary.
   */
  getContinueTarget(block) {
    let hasPrecedingLoop = false;
    for (let i = __privateGet(this, _controlFlowStack).length - 1; i >= 0; i--) {
      const target = __privateGet(this, _controlFlowStack)[i];
      if (target.type == "loop" && target.continueBlock === block) {
        let type;
        if (hasPrecedingLoop) {
          type = "labeled";
        } else if (i === __privateGet(this, _controlFlowStack).length - 1) {
          type = "implicit";
        } else {
          type = "unlabeled";
        }
        return {
          block: target.block,
          type
        };
      }
      hasPrecedingLoop || (hasPrecedingLoop = target.type === "loop");
    }
    return null;
  }
  debugBreakTargets() {
    return __privateGet(this, _controlFlowStack).map((target) => __spreadValues({}, target));
  }
};
_nextScheduleId = new WeakMap();
_scheduled = new WeakMap();
_catchHandlers = new WeakMap();
_controlFlowStack = new WeakMap();

// src/ReactiveScopes/CodegenReactiveFunction.ts
var t3 = __toESM(require("@babel/types"));
var import_crypto = require("crypto");

// src/ReactiveScopes/MemoizeFbtAndMacroOperandsInSameScope.ts
function memoizeFbtAndMacroOperandsInSameScope(fn) {
  var _a;
  const fbtMacroTags = /* @__PURE__ */ new Set([
    ...Array.from(FBT_TAGS).map((tag) => [tag, []]),
    ...(_a = fn.env.config.customMacros) != null ? _a : []
  ]);
  const fbtValues = /* @__PURE__ */ new Set();
  const macroMethods = /* @__PURE__ */ new Map();
  while (true) {
    let vsize = fbtValues.size;
    let msize = macroMethods.size;
    visit2(fn, fbtMacroTags, fbtValues, macroMethods);
    if (vsize === fbtValues.size && msize === macroMethods.size) {
      break;
    }
  }
  return fbtValues;
}
var FBT_TAGS = /* @__PURE__ */ new Set([
  "fbt",
  "fbt:param",
  "fbs",
  "fbs:param"
]);
var SINGLE_CHILD_FBT_TAGS = /* @__PURE__ */ new Set([
  "fbt:param",
  "fbs:param"
]);
function visit2(fn, fbtMacroTags, fbtValues, macroMethods) {
  for (const [, block] of fn.body.blocks) {
    for (const instruction of block.instructions) {
      const { lvalue, value } = instruction;
      if (lvalue === null) {
        continue;
      }
      if (value.kind === "Primitive" && typeof value.value === "string" && matchesExactTag(value.value, fbtMacroTags)) {
        fbtValues.add(lvalue.identifier.id);
      } else if (value.kind === "LoadGlobal" && matchesExactTag(value.binding.name, fbtMacroTags)) {
        fbtValues.add(lvalue.identifier.id);
      } else if (value.kind === "LoadGlobal" && matchTagRoot(value.binding.name, fbtMacroTags) !== null) {
        const methods = matchTagRoot(value.binding.name, fbtMacroTags);
        macroMethods.set(lvalue.identifier.id, methods);
      } else if (value.kind === "PropertyLoad" && macroMethods.has(value.object.identifier.id)) {
        const methods = macroMethods.get(value.object.identifier.id);
        const newMethods = [];
        for (const method of methods) {
          if (method.length > 0 && (method[0].type === "wildcard" || method[0].type === "name" && method[0].name === value.property)) {
            if (method.length > 1) {
              newMethods.push(method.slice(1));
            } else {
              fbtValues.add(lvalue.identifier.id);
            }
          }
        }
        if (newMethods.length > 0) {
          macroMethods.set(lvalue.identifier.id, newMethods);
        }
      } else if (isFbtCallExpression(fbtValues, value)) {
        const fbtScope = lvalue.identifier.scope;
        if (fbtScope === null) {
          continue;
        }
        for (const operand of eachReactiveValueOperand(value)) {
          operand.identifier.scope = fbtScope;
          expandFbtScopeRange(fbtScope.range, operand.identifier.mutableRange);
          fbtValues.add(operand.identifier.id);
        }
      } else if (isFbtJsxExpression(fbtMacroTags, fbtValues, value) || isFbtJsxChild(fbtValues, lvalue, value)) {
        const fbtScope = lvalue.identifier.scope;
        if (fbtScope === null) {
          continue;
        }
        for (const operand of eachReactiveValueOperand(value)) {
          operand.identifier.scope = fbtScope;
          expandFbtScopeRange(fbtScope.range, operand.identifier.mutableRange);
          fbtValues.add(operand.identifier.id);
        }
      } else if (fbtValues.has(lvalue.identifier.id)) {
        const fbtScope = lvalue.identifier.scope;
        if (fbtScope === null) {
          return;
        }
        for (const operand of eachReactiveValueOperand(value)) {
          if (operand.identifier.name !== null && operand.identifier.name.kind === "named") {
            continue;
          }
          operand.identifier.scope = fbtScope;
          expandFbtScopeRange(fbtScope.range, operand.identifier.mutableRange);
        }
      }
    }
  }
}
function matchesExactTag(s, tags) {
  return Array.from(tags).some(
    (macro) => typeof macro === "string" ? s === macro : macro[1].length === 0 && macro[0] === s
  );
}
function matchTagRoot(s, tags) {
  const methods = [];
  for (const macro of tags) {
    if (typeof macro === "string") {
      continue;
    }
    const [tag, rest] = macro;
    if (tag === s && rest.length > 0) {
      methods.push(rest);
    }
  }
  if (methods.length > 0) {
    return methods;
  } else {
    return null;
  }
}
function isFbtCallExpression(fbtValues, value) {
  return value.kind === "CallExpression" && fbtValues.has(value.callee.identifier.id) || value.kind === "MethodCall" && fbtValues.has(value.property.identifier.id);
}
function isFbtJsxExpression(fbtMacroTags, fbtValues, value) {
  return value.kind === "JsxExpression" && (value.tag.kind === "Identifier" && fbtValues.has(value.tag.identifier.id) || value.tag.kind === "BuiltinTag" && matchesExactTag(value.tag.name, fbtMacroTags));
}
function isFbtJsxChild(fbtValues, lvalue, value) {
  return (value.kind === "JsxExpression" || value.kind === "JsxFragment") && lvalue !== null && fbtValues.has(lvalue.identifier.id);
}
function expandFbtScopeRange(fbtRange, extendWith) {
  if (extendWith.start !== 0) {
    fbtRange.start = makeInstructionId(
      Math.min(fbtRange.start, extendWith.start)
    );
  }
}

// src/ReactiveScopes/CodegenReactiveFunction.ts
var MEMO_CACHE_SENTINEL = "react.memo_cache_sentinel";
var EARLY_RETURN_SENTINEL = "react.early_return_sentinel";
function codegenFunction(fn, {
  uniqueIdentifiers,
  fbtOperands
}) {
  var _a, _b, _c;
  const cx = new Context2(
    fn.env,
    (_a = fn.id) != null ? _a : "[[ anonymous ]]",
    uniqueIdentifiers,
    fbtOperands,
    null
  );
  let fastRefreshState = null;
  if (fn.env.config.enableResetCacheOnSourceFileChanges && fn.env.code !== null) {
    const hash = (0, import_crypto.createHmac)("sha256", fn.env.code).digest("hex");
    fastRefreshState = {
      cacheIndex: cx.nextCacheIndex,
      hash
    };
  }
  const compileResult = codegenReactiveFunction(cx, fn);
  if (compileResult.isErr()) {
    return compileResult;
  }
  const compiled = compileResult.unwrap();
  const hookGuard = fn.env.config.enableEmitHookGuards;
  if (hookGuard != null && fn.env.isInferredMemoEnabled) {
    compiled.body = t3.blockStatement([
      createHookGuard(
        hookGuard,
        fn.env.programContext,
        compiled.body.body,
        0 /* PushHookGuard */,
        1 /* PopHookGuard */
      )
    ]);
  }
  const cacheCount = compiled.memoSlotsUsed;
  if (cacheCount !== 0) {
    const preface = [];
    const useMemoCacheIdentifier = fn.env.programContext.addMemoCacheImport().name;
    preface.push(
      t3.variableDeclaration("const", [
        t3.variableDeclarator(
          t3.identifier(cx.synthesizeName("$")),
          t3.callExpression(t3.identifier(useMemoCacheIdentifier), [
            t3.numericLiteral(cacheCount)
          ])
        )
      ])
    );
    if (fastRefreshState !== null) {
      const index = cx.synthesizeName("$i");
      preface.push(
        t3.ifStatement(
          t3.binaryExpression(
            "!==",
            t3.memberExpression(
              t3.identifier(cx.synthesizeName("$")),
              t3.numericLiteral(fastRefreshState.cacheIndex),
              true
            ),
            t3.stringLiteral(fastRefreshState.hash)
          ),
          t3.blockStatement([
            t3.forStatement(
              t3.variableDeclaration("let", [
                t3.variableDeclarator(t3.identifier(index), t3.numericLiteral(0))
              ]),
              t3.binaryExpression(
                "<",
                t3.identifier(index),
                t3.numericLiteral(cacheCount)
              ),
              t3.assignmentExpression(
                "+=",
                t3.identifier(index),
                t3.numericLiteral(1)
              ),
              t3.blockStatement([
                t3.expressionStatement(
                  t3.assignmentExpression(
                    "=",
                    t3.memberExpression(
                      t3.identifier(cx.synthesizeName("$")),
                      t3.identifier(index),
                      true
                    ),
                    t3.callExpression(
                      t3.memberExpression(
                        t3.identifier("Symbol"),
                        t3.identifier("for")
                      ),
                      [t3.stringLiteral(MEMO_CACHE_SENTINEL)]
                    )
                  )
                )
              ])
            ),
            t3.expressionStatement(
              t3.assignmentExpression(
                "=",
                t3.memberExpression(
                  t3.identifier(cx.synthesizeName("$")),
                  t3.numericLiteral(fastRefreshState.cacheIndex),
                  true
                ),
                t3.stringLiteral(fastRefreshState.hash)
              )
            )
          ])
        )
      );
    }
    compiled.body.body.unshift(...preface);
  }
  const emitInstrumentForget = fn.env.config.enableEmitInstrumentForget;
  if (emitInstrumentForget != null && fn.id != null && fn.env.isInferredMemoEnabled) {
    const gating = emitInstrumentForget.gating != null ? t3.identifier(
      fn.env.programContext.addImportSpecifier(
        emitInstrumentForget.gating
      ).name
    ) : null;
    const globalGating = emitInstrumentForget.globalGating != null ? t3.identifier(emitInstrumentForget.globalGating) : null;
    if (emitInstrumentForget.globalGating != null) {
      const assertResult = fn.env.programContext.assertGlobalBinding(
        emitInstrumentForget.globalGating
      );
      if (assertResult.isErr()) {
        return assertResult;
      }
    }
    let ifTest;
    if (gating != null && globalGating != null) {
      ifTest = t3.logicalExpression("&&", globalGating, gating);
    } else if (gating != null) {
      ifTest = gating;
    } else {
      CompilerError.invariant(globalGating != null, {
        reason: "Bad config not caught! Expected at least one of gating or globalGating",
        loc: null,
        suggestions: null
      });
      ifTest = globalGating;
    }
    const instrumentFnIdentifier = fn.env.programContext.addImportSpecifier(
      emitInstrumentForget.fn
    ).name;
    const test = t3.ifStatement(
      ifTest,
      t3.expressionStatement(
        t3.callExpression(t3.identifier(instrumentFnIdentifier), [
          t3.stringLiteral(fn.id),
          t3.stringLiteral((_b = fn.env.filename) != null ? _b : "")
        ])
      )
    );
    compiled.body.body.unshift(test);
  }
  const outlined = [];
  for (const { fn: outlinedFunction, type } of cx.env.getOutlinedFunctions()) {
    const reactiveFunction = buildReactiveFunction(outlinedFunction);
    pruneUnusedLabels(reactiveFunction);
    pruneUnusedLValues(reactiveFunction);
    pruneHoistedContexts(reactiveFunction);
    const identifiers = renameVariables(reactiveFunction);
    const codegen = codegenReactiveFunction(
      new Context2(
        cx.env,
        (_c = reactiveFunction.id) != null ? _c : "[[ anonymous ]]",
        identifiers,
        cx.fbtOperands
      ),
      reactiveFunction
    );
    if (codegen.isErr()) {
      return codegen;
    }
    outlined.push({ fn: codegen.unwrap(), type });
  }
  compiled.outlined = outlined;
  return compileResult;
}
function codegenReactiveFunction(cx, fn) {
  for (const param of fn.params) {
    const place = param.kind === "Identifier" ? param : param.place;
    cx.temp.set(place.identifier.declarationId, null);
    cx.declare(place.identifier);
  }
  const params = fn.params.map((param) => convertParameter(param));
  const body = codegenBlock(cx, fn.body);
  body.directives = fn.directives.map((d) => t3.directive(t3.directiveLiteral(d)));
  const statements = body.body;
  if (statements.length !== 0) {
    const last = statements[statements.length - 1];
    if (last.type === "ReturnStatement" && last.argument == null) {
      statements.pop();
    }
  }
  if (cx.errors.hasErrors()) {
    return Err(cx.errors);
  }
  const countMemoBlockVisitor = new CountMemoBlockVisitor(fn.env);
  visitReactiveFunction(fn, countMemoBlockVisitor, void 0);
  return Ok({
    type: "CodegenFunction",
    loc: fn.loc,
    id: fn.id !== null ? t3.identifier(fn.id) : null,
    params,
    body,
    generator: fn.generator,
    async: fn.async,
    memoSlotsUsed: cx.nextCacheIndex,
    memoBlocks: countMemoBlockVisitor.memoBlocks,
    memoValues: countMemoBlockVisitor.memoValues,
    prunedMemoBlocks: countMemoBlockVisitor.prunedMemoBlocks,
    prunedMemoValues: countMemoBlockVisitor.prunedMemoValues,
    outlined: [],
    hasFireRewrite: fn.env.hasFireRewrite,
    hasInferredEffect: fn.env.hasInferredEffect,
    inferredEffectLocations: fn.env.inferredEffectLocations
  });
}
var CountMemoBlockVisitor = class extends ReactiveFunctionVisitor {
  constructor(env) {
    super();
    this.memoBlocks = 0;
    this.memoValues = 0;
    this.prunedMemoBlocks = 0;
    this.prunedMemoValues = 0;
    this.env = env;
  }
  visitScope(scopeBlock, state) {
    this.memoBlocks += 1;
    this.memoValues += scopeBlock.scope.declarations.size;
    this.traverseScope(scopeBlock, state);
  }
  visitPrunedScope(scopeBlock, state) {
    this.prunedMemoBlocks += 1;
    this.prunedMemoValues += scopeBlock.scope.declarations.size;
    this.traversePrunedScope(scopeBlock, state);
  }
};
function convertParameter(param) {
  if (param.kind === "Identifier") {
    return convertIdentifier(param.identifier);
  } else {
    return t3.restElement(convertIdentifier(param.place.identifier));
  }
}
var _nextCacheIndex, _declarations;
var Context2 = class {
  constructor(env, fnName, uniqueIdentifiers, fbtOperands, temporaries = null) {
    __privateAdd(this, _nextCacheIndex, 0);
    /**
     * Tracks which named variables have been declared to dedupe declarations,
     * so this uses DeclarationId instead of IdentifierId
     */
    __privateAdd(this, _declarations, /* @__PURE__ */ new Set());
    this.errors = new CompilerError();
    this.objectMethods = /* @__PURE__ */ new Map();
    this.synthesizedNames = /* @__PURE__ */ new Map();
    this.env = env;
    this.fnName = fnName;
    this.uniqueIdentifiers = uniqueIdentifiers;
    this.fbtOperands = fbtOperands;
    this.temp = temporaries !== null ? new Map(temporaries) : /* @__PURE__ */ new Map();
  }
  get nextCacheIndex() {
    return __privateWrapper(this, _nextCacheIndex)._++;
  }
  declare(identifier4) {
    __privateGet(this, _declarations).add(identifier4.declarationId);
  }
  hasDeclared(identifier4) {
    return __privateGet(this, _declarations).has(identifier4.declarationId);
  }
  synthesizeName(name) {
    const previous = this.synthesizedNames.get(name);
    if (previous !== void 0) {
      return previous;
    }
    let validated = makeIdentifierName(name).value;
    let index = 0;
    while (this.uniqueIdentifiers.has(validated)) {
      validated = makeIdentifierName(`${name}${index++}`).value;
    }
    this.uniqueIdentifiers.add(validated);
    this.synthesizedNames.set(name, validated);
    return validated;
  }
};
_nextCacheIndex = new WeakMap();
_declarations = new WeakMap();
function codegenBlock(cx, block) {
  const temp = new Map(cx.temp);
  const result = codegenBlockNoReset(cx, block);
  for (const [key2, value] of cx.temp) {
    if (!temp.has(key2)) {
      continue;
    }
    CompilerError.invariant(temp.get(key2) === value, {
      loc: null,
      reason: "Expected temporary value to be unchanged",
      description: null,
      suggestions: null
    });
  }
  cx.temp = temp;
  return result;
}
function codegenBlockNoReset(cx, block) {
  const statements = [];
  for (const item of block) {
    switch (item.kind) {
      case "instruction": {
        const statement = codegenInstructionNullable(cx, item.instruction);
        if (statement !== null) {
          statements.push(statement);
        }
        break;
      }
      case "pruned-scope": {
        const scopeBlock = codegenBlockNoReset(cx, item.instructions);
        statements.push(...scopeBlock.body);
        break;
      }
      case "scope": {
        const temp = new Map(cx.temp);
        codegenReactiveScope(cx, statements, item.scope, item.instructions);
        cx.temp = temp;
        break;
      }
      case "terminal": {
        const statement = codegenTerminal(cx, item.terminal);
        if (statement === null) {
          break;
        }
        if (item.label !== null && !item.label.implicit) {
          const block2 = statement.type === "BlockStatement" && statement.body.length === 1 ? statement.body[0] : statement;
          statements.push(
            t3.labeledStatement(
              t3.identifier(codegenLabel(item.label.id)),
              block2
            )
          );
        } else if (statement.type === "BlockStatement") {
          statements.push(...statement.body);
        } else {
          statements.push(statement);
        }
        break;
      }
      default: {
        assertExhaustive(
          item,
          `Unexpected item kind \`${item.kind}\``
        );
      }
    }
  }
  return t3.blockStatement(statements);
}
function wrapCacheDep(cx, value) {
  if (cx.env.config.enableEmitFreeze != null && cx.env.isInferredMemoEnabled) {
    const emitFreezeIdentifier = cx.env.programContext.addImportSpecifier(
      cx.env.config.enableEmitFreeze
    ).name;
    cx.env.programContext.assertGlobalBinding(EMIT_FREEZE_GLOBAL_GATING, cx.env.scope).unwrap();
    return t3.conditionalExpression(
      t3.identifier(EMIT_FREEZE_GLOBAL_GATING),
      t3.callExpression(t3.identifier(emitFreezeIdentifier), [
        value,
        t3.stringLiteral(cx.fnName)
      ]),
      value
    );
  } else {
    return value;
  }
}
function codegenReactiveScope(cx, statements, scope, block) {
  const cacheStoreStatements = [];
  const cacheLoadStatements = [];
  const cacheLoads = [];
  const changeExpressions = [];
  const changeExpressionComments = [];
  const outputComments = [];
  for (const dep of [...scope.dependencies].sort(compareScopeDependency)) {
    const index = cx.nextCacheIndex;
    changeExpressionComments.push(printDependencyComment(dep));
    const comparison = t3.binaryExpression(
      "!==",
      t3.memberExpression(
        t3.identifier(cx.synthesizeName("$")),
        t3.numericLiteral(index),
        true
      ),
      codegenDependency(cx, dep)
    );
    if (cx.env.config.enableChangeVariableCodegen) {
      const changeIdentifier = t3.identifier(cx.synthesizeName(`c_${index}`));
      statements.push(
        t3.variableDeclaration("const", [
          t3.variableDeclarator(changeIdentifier, comparison)
        ])
      );
      changeExpressions.push(changeIdentifier);
    } else {
      changeExpressions.push(comparison);
    }
    cacheStoreStatements.push(
      t3.expressionStatement(
        t3.assignmentExpression(
          "=",
          t3.memberExpression(
            t3.identifier(cx.synthesizeName("$")),
            t3.numericLiteral(index),
            true
          ),
          codegenDependency(cx, dep)
        )
      )
    );
  }
  let firstOutputIndex = null;
  for (const [, { identifier: identifier4 }] of [...scope.declarations].sort(
    ([, a], [, b]) => compareScopeDeclaration(a, b)
  )) {
    const index = cx.nextCacheIndex;
    if (firstOutputIndex === null) {
      firstOutputIndex = index;
    }
    CompilerError.invariant(identifier4.name != null, {
      reason: `Expected scope declaration identifier to be named`,
      description: `Declaration \`${printIdentifier(
        identifier4
      )}\` is unnamed in scope @${scope.id}`,
      loc: null,
      suggestions: null
    });
    const name = convertIdentifier(identifier4);
    outputComments.push(name.name);
    if (!cx.hasDeclared(identifier4)) {
      statements.push(
        t3.variableDeclaration("let", [t3.variableDeclarator(name)])
      );
    }
    cacheLoads.push({ name, index, value: wrapCacheDep(cx, name) });
    cx.declare(identifier4);
  }
  for (const reassignment of scope.reassignments) {
    const index = cx.nextCacheIndex;
    if (firstOutputIndex === null) {
      firstOutputIndex = index;
    }
    const name = convertIdentifier(reassignment);
    outputComments.push(name.name);
    cacheLoads.push({ name, index, value: wrapCacheDep(cx, name) });
  }
  let testCondition = changeExpressions.reduce(
    (acc, ident) => {
      if (acc == null) {
        return ident;
      }
      return t3.logicalExpression("||", acc, ident);
    },
    null
  );
  if (testCondition === null) {
    CompilerError.invariant(firstOutputIndex !== null, {
      reason: `Expected scope to have at least one declaration`,
      description: `Scope '@${scope.id}' has no declarations`,
      loc: null,
      suggestions: null
    });
    testCondition = t3.binaryExpression(
      "===",
      t3.memberExpression(
        t3.identifier(cx.synthesizeName("$")),
        t3.numericLiteral(firstOutputIndex),
        true
      ),
      t3.callExpression(
        t3.memberExpression(t3.identifier("Symbol"), t3.identifier("for")),
        [t3.stringLiteral(MEMO_CACHE_SENTINEL)]
      )
    );
  }
  if (cx.env.config.disableMemoizationForDebugging) {
    CompilerError.invariant(
      cx.env.config.enableChangeDetectionForDebugging == null,
      {
        reason: `Expected to not have both change detection enabled and memoization disabled`,
        description: `Incompatible config options`,
        loc: null
      }
    );
    testCondition = t3.logicalExpression(
      "||",
      testCondition,
      t3.booleanLiteral(true)
    );
  }
  let computationBlock = codegenBlock(cx, block);
  let memoStatement;
  const detectionFunction = cx.env.config.enableChangeDetectionForDebugging;
  if (detectionFunction != null && changeExpressions.length > 0) {
    const loc = typeof scope.loc === "symbol" ? "unknown location" : `(${scope.loc.start.line}:${scope.loc.end.line})`;
    const importedDetectionFunctionIdentifier = cx.env.programContext.addImportSpecifier(detectionFunction).name;
    const cacheLoadOldValueStatements = [];
    const changeDetectionStatements = [];
    const idempotenceDetectionStatements = [];
    for (const { name, index, value } of cacheLoads) {
      const loadName = cx.synthesizeName(`old$${name.name}`);
      const slot = t3.memberExpression(
        t3.identifier(cx.synthesizeName("$")),
        t3.numericLiteral(index),
        true
      );
      cacheStoreStatements.push(
        t3.expressionStatement(t3.assignmentExpression("=", slot, value))
      );
      cacheLoadOldValueStatements.push(
        t3.variableDeclaration("let", [
          t3.variableDeclarator(t3.identifier(loadName), slot)
        ])
      );
      changeDetectionStatements.push(
        t3.expressionStatement(
          t3.callExpression(t3.identifier(importedDetectionFunctionIdentifier), [
            t3.identifier(loadName),
            t3.cloneNode(name, true),
            t3.stringLiteral(name.name),
            t3.stringLiteral(cx.fnName),
            t3.stringLiteral("cached"),
            t3.stringLiteral(loc)
          ])
        )
      );
      idempotenceDetectionStatements.push(
        t3.expressionStatement(
          t3.callExpression(t3.identifier(importedDetectionFunctionIdentifier), [
            t3.cloneNode(slot, true),
            t3.cloneNode(name, true),
            t3.stringLiteral(name.name),
            t3.stringLiteral(cx.fnName),
            t3.stringLiteral("recomputed"),
            t3.stringLiteral(loc)
          ])
        )
      );
      idempotenceDetectionStatements.push(
        t3.expressionStatement(t3.assignmentExpression("=", name, slot))
      );
    }
    const condition = cx.synthesizeName("condition");
    const recomputationBlock = t3.cloneNode(computationBlock, true);
    memoStatement = t3.blockStatement([
      ...computationBlock.body,
      t3.variableDeclaration("let", [
        t3.variableDeclarator(t3.identifier(condition), testCondition)
      ]),
      t3.ifStatement(
        t3.unaryExpression("!", t3.identifier(condition)),
        t3.blockStatement([
          ...cacheLoadOldValueStatements,
          ...changeDetectionStatements
        ])
      ),
      ...cacheStoreStatements,
      t3.ifStatement(
        t3.identifier(condition),
        t3.blockStatement([
          ...recomputationBlock.body,
          ...idempotenceDetectionStatements
        ])
      )
    ]);
  } else {
    for (const { name, index, value } of cacheLoads) {
      cacheStoreStatements.push(
        t3.expressionStatement(
          t3.assignmentExpression(
            "=",
            t3.memberExpression(
              t3.identifier(cx.synthesizeName("$")),
              t3.numericLiteral(index),
              true
            ),
            value
          )
        )
      );
      cacheLoadStatements.push(
        t3.expressionStatement(
          t3.assignmentExpression(
            "=",
            name,
            t3.memberExpression(
              t3.identifier(cx.synthesizeName("$")),
              t3.numericLiteral(index),
              true
            )
          )
        )
      );
    }
    computationBlock.body.push(...cacheStoreStatements);
    memoStatement = t3.ifStatement(
      testCondition,
      computationBlock,
      t3.blockStatement(cacheLoadStatements)
    );
  }
  if (cx.env.config.enableMemoizationComments) {
    if (changeExpressionComments.length) {
      t3.addComment(
        memoStatement,
        "leading",
        ` check if ${printDelimitedCommentList(
          changeExpressionComments,
          "or"
        )} changed`,
        true
      );
      t3.addComment(
        memoStatement,
        "leading",
        ` "useMemo" for ${printDelimitedCommentList(outputComments, "and")}:`,
        true
      );
    } else {
      t3.addComment(
        memoStatement,
        "leading",
        " cache value with no dependencies",
        true
      );
      t3.addComment(
        memoStatement,
        "leading",
        ` "useMemo" for ${printDelimitedCommentList(outputComments, "and")}:`,
        true
      );
    }
    if (computationBlock.body.length > 0) {
      t3.addComment(
        computationBlock.body[0],
        "leading",
        ` Inputs changed, recompute`,
        true
      );
    }
    if (cacheLoadStatements.length > 0) {
      t3.addComment(
        cacheLoadStatements[0],
        "leading",
        ` Inputs did not change, use cached value`,
        true
      );
    }
  }
  statements.push(memoStatement);
  const earlyReturnValue = scope.earlyReturnValue;
  if (earlyReturnValue !== null) {
    CompilerError.invariant(
      earlyReturnValue.value.name !== null && earlyReturnValue.value.name.kind === "named",
      {
        reason: `Expected early return value to be promoted to a named variable`,
        loc: earlyReturnValue.loc,
        description: null,
        suggestions: null
      }
    );
    const name = earlyReturnValue.value.name.value;
    statements.push(
      t3.ifStatement(
        t3.binaryExpression(
          "!==",
          t3.identifier(name),
          t3.callExpression(
            t3.memberExpression(t3.identifier("Symbol"), t3.identifier("for")),
            [t3.stringLiteral(EARLY_RETURN_SENTINEL)]
          )
        ),
        t3.blockStatement([t3.returnStatement(t3.identifier(name))])
      )
    );
  }
}
function codegenTerminal(cx, terminal) {
  switch (terminal.kind) {
    case "break": {
      if (terminal.targetKind === "implicit") {
        return null;
      }
      return t3.breakStatement(
        terminal.targetKind === "labeled" ? t3.identifier(codegenLabel(terminal.target)) : null
      );
    }
    case "continue": {
      if (terminal.targetKind === "implicit") {
        return null;
      }
      return t3.continueStatement(
        terminal.targetKind === "labeled" ? t3.identifier(codegenLabel(terminal.target)) : null
      );
    }
    case "for": {
      return t3.forStatement(
        codegenForInit(cx, terminal.init),
        codegenInstructionValueToExpression(cx, terminal.test),
        terminal.update !== null ? codegenInstructionValueToExpression(cx, terminal.update) : null,
        codegenBlock(cx, terminal.loop)
      );
    }
    case "for-in": {
      CompilerError.invariant(terminal.init.kind === "SequenceExpression", {
        reason: `Expected a sequence expression init for for..in`,
        description: `Got \`${terminal.init.kind}\` expression instead`,
        loc: terminal.init.loc,
        suggestions: null
      });
      if (terminal.init.instructions.length !== 2) {
        CompilerError.throwTodo({
          reason: "Support non-trivial for..in inits",
          description: null,
          loc: terminal.init.loc,
          suggestions: null
        });
      }
      const iterableCollection = terminal.init.instructions[0];
      const iterableItem = terminal.init.instructions[1];
      let lval;
      switch (iterableItem.value.kind) {
        case "StoreLocal": {
          lval = codegenLValue(cx, iterableItem.value.lvalue.place);
          break;
        }
        case "Destructure": {
          lval = codegenLValue(cx, iterableItem.value.lvalue.pattern);
          break;
        }
        case "StoreContext": {
          CompilerError.throwTodo({
            reason: "Support non-trivial for..in inits",
            description: null,
            loc: terminal.init.loc,
            suggestions: null
          });
        }
        default:
          CompilerError.invariant(false, {
            reason: `Expected a StoreLocal or Destructure to be assigned to the collection`,
            description: `Found ${iterableItem.value.kind}`,
            loc: iterableItem.value.loc,
            suggestions: null
          });
      }
      let varDeclKind;
      switch (iterableItem.value.lvalue.kind) {
        case "Const" /* Const */:
          varDeclKind = "const";
          break;
        case "Let" /* Let */:
          varDeclKind = "let";
          break;
        case "Reassign" /* Reassign */:
          CompilerError.invariant(false, {
            reason: "Destructure should never be Reassign as it would be an Object/ArrayPattern",
            description: null,
            loc: iterableItem.loc,
            suggestions: null
          });
        case "Catch" /* Catch */:
        case "HoistedConst" /* HoistedConst */:
        case "HoistedLet" /* HoistedLet */:
        case "HoistedFunction" /* HoistedFunction */:
        case "Function" /* Function */:
          CompilerError.invariant(false, {
            reason: `Unexpected ${iterableItem.value.lvalue.kind} variable in for..in collection`,
            description: null,
            loc: iterableItem.loc,
            suggestions: null
          });
        default:
          assertExhaustive(
            iterableItem.value.lvalue.kind,
            `Unhandled lvalue kind: ${iterableItem.value.lvalue.kind}`
          );
      }
      return t3.forInStatement(
        /*
         * Special handling here since we only want the VariableDeclarators without any inits
         * This needs to be updated when we handle non-trivial ForOf inits
         */
        createVariableDeclaration(iterableItem.value.loc, varDeclKind, [
          t3.variableDeclarator(lval, null)
        ]),
        codegenInstructionValueToExpression(cx, iterableCollection.value),
        codegenBlock(cx, terminal.loop)
      );
    }
    case "for-of": {
      CompilerError.invariant(
        terminal.init.kind === "SequenceExpression" && terminal.init.instructions.length === 1 && terminal.init.instructions[0].value.kind === "GetIterator",
        {
          reason: `Expected a single-expression sequence expression init for for..of`,
          description: `Got \`${terminal.init.kind}\` expression instead`,
          loc: terminal.init.loc,
          suggestions: null
        }
      );
      const iterableCollection = terminal.init.instructions[0].value;
      CompilerError.invariant(terminal.test.kind === "SequenceExpression", {
        reason: `Expected a sequence expression test for for..of`,
        description: `Got \`${terminal.init.kind}\` expression instead`,
        loc: terminal.test.loc,
        suggestions: null
      });
      if (terminal.test.instructions.length !== 2) {
        CompilerError.throwTodo({
          reason: "Support non-trivial for..of inits",
          description: null,
          loc: terminal.init.loc,
          suggestions: null
        });
      }
      const iterableItem = terminal.test.instructions[1];
      let lval;
      switch (iterableItem.value.kind) {
        case "StoreLocal": {
          lval = codegenLValue(cx, iterableItem.value.lvalue.place);
          break;
        }
        case "Destructure": {
          lval = codegenLValue(cx, iterableItem.value.lvalue.pattern);
          break;
        }
        case "StoreContext": {
          CompilerError.throwTodo({
            reason: "Support non-trivial for..of inits",
            description: null,
            loc: terminal.init.loc,
            suggestions: null
          });
        }
        default:
          CompilerError.invariant(false, {
            reason: `Expected a StoreLocal or Destructure to be assigned to the collection`,
            description: `Found ${iterableItem.value.kind}`,
            loc: iterableItem.value.loc,
            suggestions: null
          });
      }
      let varDeclKind;
      switch (iterableItem.value.lvalue.kind) {
        case "Const" /* Const */:
          varDeclKind = "const";
          break;
        case "Let" /* Let */:
          varDeclKind = "let";
          break;
        case "Reassign" /* Reassign */:
        case "Catch" /* Catch */:
        case "HoistedConst" /* HoistedConst */:
        case "HoistedLet" /* HoistedLet */:
        case "HoistedFunction" /* HoistedFunction */:
        case "Function" /* Function */:
          CompilerError.invariant(false, {
            reason: `Unexpected ${iterableItem.value.lvalue.kind} variable in for..of collection`,
            description: null,
            loc: iterableItem.loc,
            suggestions: null
          });
        default:
          assertExhaustive(
            iterableItem.value.lvalue.kind,
            `Unhandled lvalue kind: ${iterableItem.value.lvalue.kind}`
          );
      }
      return t3.forOfStatement(
        /*
         * Special handling here since we only want the VariableDeclarators without any inits
         * This needs to be updated when we handle non-trivial ForOf inits
         */
        createVariableDeclaration(iterableItem.value.loc, varDeclKind, [
          t3.variableDeclarator(lval, null)
        ]),
        codegenInstructionValueToExpression(cx, iterableCollection),
        codegenBlock(cx, terminal.loop)
      );
    }
    case "if": {
      const test = codegenPlaceToExpression(cx, terminal.test);
      const consequent = codegenBlock(cx, terminal.consequent);
      let alternate = null;
      if (terminal.alternate !== null) {
        const block = codegenBlock(cx, terminal.alternate);
        if (block.body.length !== 0) {
          alternate = block;
        }
      }
      return t3.ifStatement(test, consequent, alternate);
    }
    case "return": {
      const value = codegenPlaceToExpression(cx, terminal.value);
      if (value.type === "Identifier" && value.name === "undefined") {
        return t3.returnStatement();
      }
      return t3.returnStatement(value);
    }
    case "switch": {
      return t3.switchStatement(
        codegenPlaceToExpression(cx, terminal.test),
        terminal.cases.map((case_) => {
          const test = case_.test !== null ? codegenPlaceToExpression(cx, case_.test) : null;
          const block = codegenBlock(cx, case_.block);
          return t3.switchCase(test, block.body.length === 0 ? [] : [block]);
        })
      );
    }
    case "throw": {
      return t3.throwStatement(codegenPlaceToExpression(cx, terminal.value));
    }
    case "do-while": {
      const test = codegenInstructionValueToExpression(cx, terminal.test);
      return t3.doWhileStatement(test, codegenBlock(cx, terminal.loop));
    }
    case "while": {
      const test = codegenInstructionValueToExpression(cx, terminal.test);
      return t3.whileStatement(test, codegenBlock(cx, terminal.loop));
    }
    case "label": {
      return codegenBlock(cx, terminal.block);
    }
    case "try": {
      let catchParam = null;
      if (terminal.handlerBinding !== null) {
        catchParam = convertIdentifier(terminal.handlerBinding.identifier);
        cx.temp.set(terminal.handlerBinding.identifier.declarationId, null);
      }
      return t3.tryStatement(
        codegenBlock(cx, terminal.block),
        t3.catchClause(catchParam, codegenBlock(cx, terminal.handler))
      );
    }
    default: {
      assertExhaustive(
        terminal,
        `Unexpected terminal kind \`${terminal.kind}\``
      );
    }
  }
}
function codegenInstructionNullable(cx, instr) {
  if (instr.value.kind === "StoreLocal" || instr.value.kind === "StoreContext" || instr.value.kind === "Destructure" || instr.value.kind === "DeclareLocal" || instr.value.kind === "DeclareContext") {
    let kind = instr.value.lvalue.kind;
    let lvalue;
    let value;
    if (instr.value.kind === "StoreLocal") {
      kind = cx.hasDeclared(instr.value.lvalue.place.identifier) ? "Reassign" /* Reassign */ : kind;
      lvalue = instr.value.lvalue.place;
      value = codegenPlaceToExpression(cx, instr.value.value);
    } else if (instr.value.kind === "StoreContext") {
      lvalue = instr.value.lvalue.place;
      value = codegenPlaceToExpression(cx, instr.value.value);
    } else if (instr.value.kind === "DeclareLocal" || instr.value.kind === "DeclareContext") {
      if (cx.hasDeclared(instr.value.lvalue.place.identifier)) {
        return null;
      }
      kind = instr.value.lvalue.kind;
      lvalue = instr.value.lvalue.place;
      value = null;
    } else {
      lvalue = instr.value.lvalue.pattern;
      let hasReassign = false;
      let hasDeclaration = false;
      for (const place of eachPatternOperand(lvalue)) {
        if (kind !== "Reassign" /* Reassign */ && place.identifier.name === null) {
          cx.temp.set(place.identifier.declarationId, null);
        }
        const isDeclared = cx.hasDeclared(place.identifier);
        hasReassign || (hasReassign = isDeclared);
        hasDeclaration || (hasDeclaration = !isDeclared);
      }
      if (hasReassign && hasDeclaration) {
        CompilerError.invariant(false, {
          reason: "Encountered a destructuring operation where some identifiers are already declared (reassignments) but others are not (declarations)",
          description: null,
          loc: instr.loc,
          suggestions: null
        });
      } else if (hasReassign) {
        kind = "Reassign" /* Reassign */;
      }
      value = codegenPlaceToExpression(cx, instr.value.value);
    }
    switch (kind) {
      case "Const" /* Const */: {
        CompilerError.invariant(instr.lvalue === null, {
          reason: `Const declaration cannot be referenced as an expression`,
          description: null,
          loc: instr.value.loc,
          suggestions: null
        });
        return createVariableDeclaration(instr.loc, "const", [
          t3.variableDeclarator(codegenLValue(cx, lvalue), value)
        ]);
      }
      case "Function" /* Function */: {
        CompilerError.invariant(instr.lvalue === null, {
          reason: `Function declaration cannot be referenced as an expression`,
          description: null,
          loc: instr.value.loc,
          suggestions: null
        });
        const genLvalue = codegenLValue(cx, lvalue);
        CompilerError.invariant(genLvalue.type === "Identifier", {
          reason: "Expected an identifier as a function declaration lvalue",
          description: null,
          loc: instr.value.loc,
          suggestions: null
        });
        CompilerError.invariant((value == null ? void 0 : value.type) === "FunctionExpression", {
          reason: "Expected a function as a function declaration value",
          description: `Got ${value == null ? String(value) : value.type} at ${printInstruction(instr)}`,
          loc: instr.value.loc,
          suggestions: null
        });
        return createFunctionDeclaration(
          instr.loc,
          genLvalue,
          value.params,
          value.body,
          value.generator,
          value.async
        );
      }
      case "Let" /* Let */: {
        CompilerError.invariant(instr.lvalue === null, {
          reason: `Const declaration cannot be referenced as an expression`,
          description: null,
          loc: instr.value.loc,
          suggestions: null
        });
        return createVariableDeclaration(instr.loc, "let", [
          t3.variableDeclarator(codegenLValue(cx, lvalue), value)
        ]);
      }
      case "Reassign" /* Reassign */: {
        CompilerError.invariant(value !== null, {
          reason: "Expected a value for reassignment",
          description: null,
          loc: instr.value.loc,
          suggestions: null
        });
        const expr = t3.assignmentExpression(
          "=",
          codegenLValue(cx, lvalue),
          value
        );
        if (instr.lvalue !== null) {
          if (instr.value.kind !== "StoreContext") {
            cx.temp.set(instr.lvalue.identifier.declarationId, expr);
            return null;
          } else {
            const statement = codegenInstruction(cx, instr, expr);
            if (statement.type === "EmptyStatement") {
              return null;
            }
            return statement;
          }
        } else {
          return createExpressionStatement(instr.loc, expr);
        }
      }
      case "Catch" /* Catch */: {
        return t3.emptyStatement();
      }
      case "HoistedLet" /* HoistedLet */:
      case "HoistedConst" /* HoistedConst */:
      case "HoistedFunction" /* HoistedFunction */: {
        CompilerError.invariant(false, {
          reason: `Expected ${kind} to have been pruned in PruneHoistedContexts`,
          description: null,
          loc: instr.loc,
          suggestions: null
        });
      }
      default: {
        assertExhaustive(kind, `Unexpected instruction kind \`${kind}\``);
      }
    }
  } else if (instr.value.kind === "StartMemoize" || instr.value.kind === "FinishMemoize") {
    return null;
  } else if (instr.value.kind === "Debugger") {
    return t3.debuggerStatement();
  } else if (instr.value.kind === "ObjectMethod") {
    CompilerError.invariant(instr.lvalue, {
      reason: "Expected object methods to have a temp lvalue",
      loc: null,
      suggestions: null
    });
    cx.objectMethods.set(instr.lvalue.identifier.id, instr.value);
    return null;
  } else {
    const value = codegenInstructionValue(cx, instr.value);
    const statement = codegenInstruction(cx, instr, value);
    if (statement.type === "EmptyStatement") {
      return null;
    }
    return statement;
  }
}
function codegenForInit(cx, init) {
  if (init.kind === "SequenceExpression") {
    const body = codegenBlock(
      cx,
      init.instructions.map((instruction) => ({
        kind: "instruction",
        instruction
      }))
    ).body;
    const declarators = [];
    let kind = "const";
    body.forEach((instr) => {
      var _a;
      let top = void 0;
      if (instr.type === "ExpressionStatement" && instr.expression.type === "AssignmentExpression" && instr.expression.operator === "=" && instr.expression.left.type === "Identifier" && ((_a = top = declarators.at(-1)) == null ? void 0 : _a.id.type) === "Identifier" && (top == null ? void 0 : top.id.name) === instr.expression.left.name && (top == null ? void 0 : top.init) == null) {
        top.init = instr.expression.right;
      } else {
        CompilerError.invariant(
          instr.type === "VariableDeclaration" && (instr.kind === "let" || instr.kind === "const"),
          {
            reason: "Expected a variable declaration",
            loc: init.loc,
            description: `Got ${instr.type}`,
            suggestions: null
          }
        );
        if (instr.kind === "let") {
          kind = "let";
        }
        declarators.push(...instr.declarations);
      }
    });
    CompilerError.invariant(declarators.length > 0, {
      reason: "Expected a variable declaration",
      loc: init.loc,
      description: null,
      suggestions: null
    });
    return t3.variableDeclaration(kind, declarators);
  } else {
    return codegenInstructionValueToExpression(cx, init);
  }
}
function printDependencyComment(dependency) {
  const identifier4 = convertIdentifier(dependency.identifier);
  let name = identifier4.name;
  if (dependency.path !== null) {
    for (const path of dependency.path) {
      name += `.${path.property}`;
    }
  }
  return name;
}
function printDelimitedCommentList(items, finalCompletion) {
  if (items.length === 2) {
    return items.join(` ${finalCompletion} `);
  } else if (items.length <= 1) {
    return items.join("");
  }
  let output = [];
  for (let i = 0; i < items.length; i++) {
    const item = items[i];
    if (i < items.length - 2) {
      output.push(`${item}, `);
    } else if (i === items.length - 2) {
      output.push(`${item}, ${finalCompletion} `);
    } else {
      output.push(item);
    }
  }
  return output.join("");
}
function codegenDependency(cx, dependency) {
  let object = convertIdentifier(dependency.identifier);
  if (dependency.path.length !== 0) {
    const hasOptional = dependency.path.some((path) => path.optional);
    for (const path of dependency.path) {
      const property = typeof path.property === "string" ? t3.identifier(path.property) : t3.numericLiteral(path.property);
      const isComputed = typeof path.property !== "string";
      if (hasOptional) {
        object = t3.optionalMemberExpression(
          object,
          property,
          isComputed,
          path.optional
        );
      } else {
        object = t3.memberExpression(object, property, isComputed);
      }
    }
  }
  return object;
}
function withLoc(fn) {
  return (loc, ...args) => {
    const node = fn(...args);
    if (loc != null && loc != GeneratedSource) {
      node.loc = loc;
    }
    return node;
  };
}
var createBinaryExpression = withLoc(t3.binaryExpression);
var createExpressionStatement = withLoc(t3.expressionStatement);
var _createLabelledStatement = withLoc(t3.labeledStatement);
var createVariableDeclaration = withLoc(t3.variableDeclaration);
var createFunctionDeclaration = withLoc(t3.functionDeclaration);
var _createWhileStatement = withLoc(t3.whileStatement);
var createTaggedTemplateExpression = withLoc(t3.taggedTemplateExpression);
var createLogicalExpression = withLoc(t3.logicalExpression);
var createSequenceExpression = withLoc(t3.sequenceExpression);
var createConditionalExpression = withLoc(t3.conditionalExpression);
var createTemplateLiteral = withLoc(t3.templateLiteral);
var createJsxNamespacedName = withLoc(t3.jsxNamespacedName);
var createJsxElement = withLoc(t3.jsxElement);
var createJsxAttribute = withLoc(t3.jsxAttribute);
var createJsxIdentifier = withLoc(t3.jsxIdentifier);
var createJsxExpressionContainer = withLoc(t3.jsxExpressionContainer);
var createJsxText = withLoc(t3.jsxText);
var createJsxClosingElement = withLoc(t3.jsxClosingElement);
var createJsxOpeningElement = withLoc(t3.jsxOpeningElement);
var createStringLiteral = withLoc(t3.stringLiteral);
function createHookGuard(guard, context, stmts, before, after) {
  const guardFnName = context.addImportSpecifier(guard).name;
  function createHookGuardImpl(kind) {
    return t3.expressionStatement(
      t3.callExpression(t3.identifier(guardFnName), [t3.numericLiteral(kind)])
    );
  }
  return t3.tryStatement(
    t3.blockStatement([createHookGuardImpl(before), ...stmts]),
    null,
    t3.blockStatement([createHookGuardImpl(after)])
  );
}
function createCallExpression(env, callee, args, loc, isHook2) {
  const callExpr = t3.callExpression(callee, args);
  if (loc != null && loc != GeneratedSource) {
    callExpr.loc = loc;
  }
  const hookGuard = env.config.enableEmitHookGuards;
  if (hookGuard != null && isHook2 && env.isInferredMemoEnabled) {
    const iife = t3.functionExpression(
      null,
      [],
      t3.blockStatement([
        createHookGuard(
          hookGuard,
          env.programContext,
          [t3.returnStatement(callExpr)],
          2 /* AllowHook */,
          3 /* DisallowHook */
        )
      ])
    );
    return t3.callExpression(iife, []);
  } else {
    return callExpr;
  }
}
function codegenLabel(id) {
  return `bb${id}`;
}
function codegenInstruction(cx, instr, value) {
  if (t3.isStatement(value)) {
    return value;
  }
  if (instr.lvalue === null) {
    return t3.expressionStatement(convertValueToExpression(value));
  }
  if (instr.lvalue.identifier.name === null) {
    cx.temp.set(instr.lvalue.identifier.declarationId, value);
    return t3.emptyStatement();
  } else {
    const expressionValue = convertValueToExpression(value);
    if (cx.hasDeclared(instr.lvalue.identifier)) {
      return createExpressionStatement(
        instr.loc,
        t3.assignmentExpression(
          "=",
          convertIdentifier(instr.lvalue.identifier),
          expressionValue
        )
      );
    } else {
      return createVariableDeclaration(instr.loc, "const", [
        t3.variableDeclarator(
          convertIdentifier(instr.lvalue.identifier),
          expressionValue
        )
      ]);
    }
  }
}
function convertValueToExpression(value) {
  if (value.type === "JSXText") {
    return createStringLiteral(value.loc, value.value);
  }
  return value;
}
function codegenInstructionValueToExpression(cx, instrValue) {
  const value = codegenInstructionValue(cx, instrValue);
  return convertValueToExpression(value);
}
function codegenInstructionValue(cx, instrValue) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  let value;
  switch (instrValue.kind) {
    case "ArrayExpression": {
      const elements = instrValue.elements.map((element) => {
        if (element.kind === "Identifier") {
          return codegenPlaceToExpression(cx, element);
        } else if (element.kind === "Spread") {
          return t3.spreadElement(codegenPlaceToExpression(cx, element.place));
        } else {
          return null;
        }
      });
      value = t3.arrayExpression(elements);
      break;
    }
    case "BinaryExpression": {
      const left = codegenPlaceToExpression(cx, instrValue.left);
      const right = codegenPlaceToExpression(cx, instrValue.right);
      value = createBinaryExpression(
        instrValue.loc,
        instrValue.operator,
        left,
        right
      );
      break;
    }
    case "UnaryExpression": {
      value = t3.unaryExpression(
        instrValue.operator,
        codegenPlaceToExpression(cx, instrValue.value)
      );
      break;
    }
    case "Primitive": {
      value = codegenValue(cx, instrValue.loc, instrValue.value);
      break;
    }
    case "CallExpression": {
      if (cx.env.config.enableForest) {
        const callee2 = codegenPlaceToExpression(cx, instrValue.callee);
        const args2 = instrValue.args.map((arg) => codegenArgument(cx, arg));
        value = t3.callExpression(callee2, args2);
        if (instrValue.typeArguments != null) {
          value.typeArguments = t3.typeParameterInstantiation(
            instrValue.typeArguments
          );
        }
        break;
      }
      const isHook2 = getHookKind(cx.env, instrValue.callee.identifier) != null;
      const callee = codegenPlaceToExpression(cx, instrValue.callee);
      const args = instrValue.args.map((arg) => codegenArgument(cx, arg));
      value = createCallExpression(
        cx.env,
        callee,
        args,
        instrValue.loc,
        isHook2
      );
      break;
    }
    case "OptionalExpression": {
      const optionalValue = codegenInstructionValueToExpression(
        cx,
        instrValue.value
      );
      switch (optionalValue.type) {
        case "OptionalCallExpression":
        case "CallExpression": {
          CompilerError.invariant(t3.isExpression(optionalValue.callee), {
            reason: "v8 intrinsics are validated during lowering",
            description: null,
            loc: (_a = optionalValue.callee.loc) != null ? _a : null,
            suggestions: null
          });
          value = t3.optionalCallExpression(
            optionalValue.callee,
            optionalValue.arguments,
            instrValue.optional
          );
          break;
        }
        case "OptionalMemberExpression":
        case "MemberExpression": {
          const property = optionalValue.property;
          CompilerError.invariant(t3.isExpression(property), {
            reason: "Private names are validated during lowering",
            description: null,
            loc: (_b = property.loc) != null ? _b : null,
            suggestions: null
          });
          value = t3.optionalMemberExpression(
            optionalValue.object,
            property,
            optionalValue.computed,
            instrValue.optional
          );
          break;
        }
        default: {
          CompilerError.invariant(false, {
            reason: "Expected an optional value to resolve to a call expression or member expression",
            description: `Got a \`${optionalValue.type}\``,
            loc: instrValue.loc,
            suggestions: null
          });
        }
      }
      break;
    }
    case "MethodCall": {
      const isHook2 = getHookKind(cx.env, instrValue.property.identifier) != null;
      const memberExpr = codegenPlaceToExpression(cx, instrValue.property);
      CompilerError.invariant(
        t3.isMemberExpression(memberExpr) || t3.isOptionalMemberExpression(memberExpr),
        {
          reason: `[Codegen] Internal error: MethodCall::property must be an unpromoted + unmemoized MemberExpression. Got a \`${memberExpr.type}\``,
          description: null,
          loc: (_c = memberExpr.loc) != null ? _c : null,
          suggestions: null
        }
      );
      CompilerError.invariant(
        t3.isNodesEquivalent(
          memberExpr.object,
          codegenPlaceToExpression(cx, instrValue.receiver)
        ),
        {
          reason: "[Codegen] Internal error: Forget should always generate MethodCall::property as a MemberExpression of MethodCall::receiver",
          description: null,
          loc: (_d = memberExpr.loc) != null ? _d : null,
          suggestions: null
        }
      );
      const args = instrValue.args.map((arg) => codegenArgument(cx, arg));
      value = createCallExpression(
        cx.env,
        memberExpr,
        args,
        instrValue.loc,
        isHook2
      );
      break;
    }
    case "NewExpression": {
      const callee = codegenPlaceToExpression(cx, instrValue.callee);
      const args = instrValue.args.map((arg) => codegenArgument(cx, arg));
      value = t3.newExpression(callee, args);
      break;
    }
    case "ObjectExpression": {
      const properties = [];
      for (const property of instrValue.properties) {
        if (property.kind === "ObjectProperty") {
          const key2 = codegenObjectPropertyKey(cx, property.key);
          switch (property.type) {
            case "property": {
              const value2 = codegenPlaceToExpression(cx, property.place);
              properties.push(
                t3.objectProperty(
                  key2,
                  value2,
                  property.key.kind === "computed",
                  key2.type === "Identifier" && value2.type === "Identifier" && value2.name === key2.name
                )
              );
              break;
            }
            case "method": {
              const method = cx.objectMethods.get(property.place.identifier.id);
              CompilerError.invariant(method, {
                reason: "Expected ObjectMethod instruction",
                loc: null,
                suggestions: null
              });
              const loweredFunc = method.loweredFunc;
              const reactiveFunction = buildReactiveFunction(loweredFunc.func);
              pruneUnusedLabels(reactiveFunction);
              pruneUnusedLValues(reactiveFunction);
              const fn = codegenReactiveFunction(
                new Context2(
                  cx.env,
                  (_e = reactiveFunction.id) != null ? _e : "[[ anonymous ]]",
                  cx.uniqueIdentifiers,
                  cx.fbtOperands,
                  cx.temp
                ),
                reactiveFunction
              ).unwrap();
              const babelNode = t3.objectMethod(
                "method",
                key2,
                fn.params,
                fn.body,
                false
              );
              babelNode.async = fn.async;
              babelNode.generator = fn.generator;
              properties.push(babelNode);
              break;
            }
            default:
              assertExhaustive(
                property.type,
                `Unexpected property type: ${property.type}`
              );
          }
        } else {
          properties.push(
            t3.spreadElement(codegenPlaceToExpression(cx, property.place))
          );
        }
      }
      value = t3.objectExpression(properties);
      break;
    }
    case "JSXText": {
      value = createJsxText(instrValue.loc, instrValue.value);
      break;
    }
    case "JsxExpression": {
      const attributes = [];
      for (const attribute of instrValue.props) {
        attributes.push(codegenJsxAttribute(cx, attribute));
      }
      let tagValue = instrValue.tag.kind === "Identifier" ? codegenPlaceToExpression(cx, instrValue.tag) : t3.stringLiteral(instrValue.tag.name);
      let tag;
      if (tagValue.type === "Identifier") {
        tag = createJsxIdentifier(instrValue.tag.loc, tagValue.name);
      } else if (tagValue.type === "MemberExpression") {
        tag = convertMemberExpressionToJsx(tagValue);
      } else {
        CompilerError.invariant(tagValue.type === "StringLiteral", {
          reason: `Expected JSX tag to be an identifier or string, got \`${tagValue.type}\``,
          description: null,
          loc: (_f = tagValue.loc) != null ? _f : null,
          suggestions: null
        });
        if (tagValue.value.indexOf(":") >= 0) {
          const [namespace, name] = tagValue.value.split(":", 2);
          tag = createJsxNamespacedName(
            instrValue.tag.loc,
            createJsxIdentifier(instrValue.tag.loc, namespace),
            createJsxIdentifier(instrValue.tag.loc, name)
          );
        } else {
          tag = createJsxIdentifier(instrValue.loc, tagValue.value);
        }
      }
      let children;
      if (tagValue.type === "StringLiteral" && SINGLE_CHILD_FBT_TAGS.has(tagValue.value)) {
        CompilerError.invariant(instrValue.children != null, {
          loc: instrValue.loc,
          reason: "Expected fbt element to have children",
          suggestions: null,
          description: null
        });
        children = instrValue.children.map(
          (child) => codegenJsxFbtChildElement(cx, child)
        );
      } else {
        children = instrValue.children !== null ? instrValue.children.map((child) => codegenJsxElement(cx, child)) : [];
      }
      value = createJsxElement(
        instrValue.loc,
        createJsxOpeningElement(
          instrValue.openingLoc,
          tag,
          attributes,
          instrValue.children === null
        ),
        instrValue.children !== null ? createJsxClosingElement(instrValue.closingLoc, tag) : null,
        children,
        instrValue.children === null
      );
      break;
    }
    case "JsxFragment": {
      value = t3.jsxFragment(
        t3.jsxOpeningFragment(),
        t3.jsxClosingFragment(),
        instrValue.children.map((child) => codegenJsxElement(cx, child))
      );
      break;
    }
    case "UnsupportedNode": {
      const node = instrValue.node;
      if (!t3.isExpression(node)) {
        return node;
      }
      value = node;
      break;
    }
    case "PropertyStore":
    case "PropertyLoad":
    case "PropertyDelete": {
      let memberExpr;
      if (typeof instrValue.property === "string") {
        memberExpr = t3.memberExpression(
          codegenPlaceToExpression(cx, instrValue.object),
          t3.identifier(instrValue.property)
        );
      } else {
        memberExpr = t3.memberExpression(
          codegenPlaceToExpression(cx, instrValue.object),
          t3.numericLiteral(instrValue.property),
          true
        );
      }
      if (instrValue.kind === "PropertyStore") {
        value = t3.assignmentExpression(
          "=",
          memberExpr,
          codegenPlaceToExpression(cx, instrValue.value)
        );
      } else if (instrValue.kind === "PropertyLoad") {
        value = memberExpr;
      } else {
        value = t3.unaryExpression("delete", memberExpr);
      }
      break;
    }
    case "ComputedStore": {
      value = t3.assignmentExpression(
        "=",
        t3.memberExpression(
          codegenPlaceToExpression(cx, instrValue.object),
          codegenPlaceToExpression(cx, instrValue.property),
          true
        ),
        codegenPlaceToExpression(cx, instrValue.value)
      );
      break;
    }
    case "ComputedLoad": {
      const object = codegenPlaceToExpression(cx, instrValue.object);
      const property = codegenPlaceToExpression(cx, instrValue.property);
      value = t3.memberExpression(object, property, true);
      break;
    }
    case "ComputedDelete": {
      value = t3.unaryExpression(
        "delete",
        t3.memberExpression(
          codegenPlaceToExpression(cx, instrValue.object),
          codegenPlaceToExpression(cx, instrValue.property),
          true
        )
      );
      break;
    }
    case "LoadLocal":
    case "LoadContext": {
      value = codegenPlaceToExpression(cx, instrValue.place);
      break;
    }
    case "FunctionExpression": {
      const loweredFunc = instrValue.loweredFunc.func;
      const reactiveFunction = buildReactiveFunction(loweredFunc);
      pruneUnusedLabels(reactiveFunction);
      pruneUnusedLValues(reactiveFunction);
      pruneHoistedContexts(reactiveFunction);
      const fn = codegenReactiveFunction(
        new Context2(
          cx.env,
          (_g = reactiveFunction.id) != null ? _g : "[[ anonymous ]]",
          cx.uniqueIdentifiers,
          cx.fbtOperands,
          cx.temp
        ),
        reactiveFunction
      ).unwrap();
      if (instrValue.type === "ArrowFunctionExpression") {
        let body = fn.body;
        if (body.body.length === 1 && loweredFunc.directives.length == 0) {
          const stmt = body.body[0];
          if (stmt.type === "ReturnStatement" && stmt.argument != null) {
            body = stmt.argument;
          }
        }
        value = t3.arrowFunctionExpression(fn.params, body, fn.async);
      } else {
        value = t3.functionExpression(
          (_h = fn.id) != null ? _h : instrValue.name != null ? t3.identifier(instrValue.name) : null,
          fn.params,
          fn.body,
          fn.generator,
          fn.async
        );
      }
      break;
    }
    case "TaggedTemplateExpression": {
      value = createTaggedTemplateExpression(
        instrValue.loc,
        codegenPlaceToExpression(cx, instrValue.tag),
        t3.templateLiteral([t3.templateElement(instrValue.value)], [])
      );
      break;
    }
    case "TypeCastExpression": {
      if (t3.isTSType(instrValue.typeAnnotation)) {
        if (instrValue.typeAnnotationKind === "satisfies") {
          value = t3.tsSatisfiesExpression(
            codegenPlaceToExpression(cx, instrValue.value),
            instrValue.typeAnnotation
          );
        } else {
          value = t3.tsAsExpression(
            codegenPlaceToExpression(cx, instrValue.value),
            instrValue.typeAnnotation
          );
        }
      } else {
        value = t3.typeCastExpression(
          codegenPlaceToExpression(cx, instrValue.value),
          t3.typeAnnotation(instrValue.typeAnnotation)
        );
      }
      break;
    }
    case "LogicalExpression": {
      value = createLogicalExpression(
        instrValue.loc,
        instrValue.operator,
        codegenInstructionValueToExpression(cx, instrValue.left),
        codegenInstructionValueToExpression(cx, instrValue.right)
      );
      break;
    }
    case "ConditionalExpression": {
      value = createConditionalExpression(
        instrValue.loc,
        codegenInstructionValueToExpression(cx, instrValue.test),
        codegenInstructionValueToExpression(cx, instrValue.consequent),
        codegenInstructionValueToExpression(cx, instrValue.alternate)
      );
      break;
    }
    case "SequenceExpression": {
      const body = codegenBlockNoReset(
        cx,
        instrValue.instructions.map((instruction) => ({
          kind: "instruction",
          instruction
        }))
      ).body;
      const expressions = body.map((stmt) => {
        var _a2, _b2;
        if (stmt.type === "ExpressionStatement") {
          return stmt.expression;
        } else {
          if (t3.isVariableDeclaration(stmt)) {
            const declarator = stmt.declarations[0];
            cx.errors.push({
              reason: `(CodegenReactiveFunction::codegenInstructionValue) Cannot declare variables in a value block, tried to declare '${declarator.id.name}'`,
              severity: "Todo" /* Todo */,
              category: "Todo" /* Todo */,
              loc: (_a2 = declarator.loc) != null ? _a2 : null,
              suggestions: null
            });
            return t3.stringLiteral(`TODO handle ${declarator.id}`);
          } else {
            cx.errors.push({
              reason: `(CodegenReactiveFunction::codegenInstructionValue) Handle conversion of ${stmt.type} to expression`,
              severity: "Todo" /* Todo */,
              category: "Todo" /* Todo */,
              loc: (_b2 = stmt.loc) != null ? _b2 : null,
              suggestions: null
            });
            return t3.stringLiteral(`TODO handle ${stmt.type}`);
          }
        }
      });
      if (expressions.length === 0) {
        value = codegenInstructionValueToExpression(cx, instrValue.value);
      } else {
        value = createSequenceExpression(instrValue.loc, [
          ...expressions,
          codegenInstructionValueToExpression(cx, instrValue.value)
        ]);
      }
      break;
    }
    case "TemplateLiteral": {
      value = createTemplateLiteral(
        instrValue.loc,
        instrValue.quasis.map((q) => t3.templateElement(q)),
        instrValue.subexprs.map((p) => codegenPlaceToExpression(cx, p))
      );
      break;
    }
    case "LoadGlobal": {
      value = t3.identifier(instrValue.binding.name);
      break;
    }
    case "RegExpLiteral": {
      value = t3.regExpLiteral(instrValue.pattern, instrValue.flags);
      break;
    }
    case "MetaProperty": {
      value = t3.metaProperty(
        t3.identifier(instrValue.meta),
        t3.identifier(instrValue.property)
      );
      break;
    }
    case "Await": {
      value = t3.awaitExpression(codegenPlaceToExpression(cx, instrValue.value));
      break;
    }
    case "GetIterator": {
      value = codegenPlaceToExpression(cx, instrValue.collection);
      break;
    }
    case "IteratorNext": {
      value = codegenPlaceToExpression(cx, instrValue.iterator);
      break;
    }
    case "NextPropertyOf": {
      value = codegenPlaceToExpression(cx, instrValue.value);
      break;
    }
    case "PostfixUpdate": {
      value = t3.updateExpression(
        instrValue.operation,
        codegenPlaceToExpression(cx, instrValue.lvalue),
        false
      );
      break;
    }
    case "PrefixUpdate": {
      value = t3.updateExpression(
        instrValue.operation,
        codegenPlaceToExpression(cx, instrValue.lvalue),
        true
      );
      break;
    }
    case "StoreLocal": {
      CompilerError.invariant(
        instrValue.lvalue.kind === "Reassign" /* Reassign */,
        {
          reason: `Unexpected StoreLocal in codegenInstructionValue`,
          description: null,
          loc: instrValue.loc,
          suggestions: null
        }
      );
      value = t3.assignmentExpression(
        "=",
        codegenLValue(cx, instrValue.lvalue.place),
        codegenPlaceToExpression(cx, instrValue.value)
      );
      break;
    }
    case "StoreGlobal": {
      value = t3.assignmentExpression(
        "=",
        t3.identifier(instrValue.name),
        codegenPlaceToExpression(cx, instrValue.value)
      );
      break;
    }
    case "StartMemoize":
    case "FinishMemoize":
    case "Debugger":
    case "DeclareLocal":
    case "DeclareContext":
    case "Destructure":
    case "ObjectMethod":
    case "StoreContext": {
      CompilerError.invariant(false, {
        reason: `Unexpected ${instrValue.kind} in codegenInstructionValue`,
        description: null,
        loc: instrValue.loc,
        suggestions: null
      });
    }
    default: {
      assertExhaustive(
        instrValue,
        `Unexpected instruction value kind \`${instrValue.kind}\``
      );
    }
  }
  return value;
}
var STRING_REQUIRES_EXPR_CONTAINER_PATTERN = /[\u{0000}-\u{001F}\u{007F}\u{0080}-\u{FFFF}\u{010000}-\u{10FFFF}]|"|\\/u;
function codegenJsxAttribute(cx, attribute) {
  switch (attribute.kind) {
    case "JsxAttribute": {
      let propName;
      if (attribute.name.indexOf(":") === -1) {
        propName = createJsxIdentifier(attribute.place.loc, attribute.name);
      } else {
        const [namespace, name] = attribute.name.split(":", 2);
        propName = createJsxNamespacedName(
          attribute.place.loc,
          createJsxIdentifier(attribute.place.loc, namespace),
          createJsxIdentifier(attribute.place.loc, name)
        );
      }
      const innerValue = codegenPlaceToExpression(cx, attribute.place);
      let value;
      switch (innerValue.type) {
        case "StringLiteral": {
          value = innerValue;
          if (STRING_REQUIRES_EXPR_CONTAINER_PATTERN.test(value.value) && !cx.fbtOperands.has(attribute.place.identifier.id)) {
            value = createJsxExpressionContainer(value.loc, value);
          }
          break;
        }
        default: {
          value = createJsxExpressionContainer(attribute.place.loc, innerValue);
          break;
        }
      }
      return createJsxAttribute(attribute.place.loc, propName, value);
    }
    case "JsxSpreadAttribute": {
      return t3.jsxSpreadAttribute(
        codegenPlaceToExpression(cx, attribute.argument)
      );
    }
    default: {
      assertExhaustive(
        attribute,
        `Unexpected attribute kind \`${attribute.kind}\``
      );
    }
  }
}
var JSX_TEXT_CHILD_REQUIRES_EXPR_CONTAINER_PATTERN = /[<>&{}]/;
function codegenJsxElement(cx, place) {
  const value = codegenPlace(cx, place);
  switch (value.type) {
    case "JSXText": {
      if (JSX_TEXT_CHILD_REQUIRES_EXPR_CONTAINER_PATTERN.test(value.value)) {
        return createJsxExpressionContainer(
          place.loc,
          createStringLiteral(place.loc, value.value)
        );
      }
      return createJsxText(place.loc, value.value);
    }
    case "JSXElement":
    case "JSXFragment": {
      return value;
    }
    default: {
      return createJsxExpressionContainer(place.loc, value);
    }
  }
}
function codegenJsxFbtChildElement(cx, place) {
  const value = codegenPlace(cx, place);
  switch (value.type) {
    // fbt:param only allows JSX element or expression container as children
    case "JSXText":
    case "JSXElement": {
      return value;
    }
    default: {
      return createJsxExpressionContainer(place.loc, value);
    }
  }
}
function convertMemberExpressionToJsx(expr) {
  var _a, _b;
  CompilerError.invariant(expr.property.type === "Identifier", {
    reason: "Expected JSX member expression property to be a string",
    description: null,
    loc: (_a = expr.loc) != null ? _a : null,
    suggestions: null
  });
  const property = t3.jsxIdentifier(expr.property.name);
  if (expr.object.type === "Identifier") {
    return t3.jsxMemberExpression(t3.jsxIdentifier(expr.object.name), property);
  } else {
    CompilerError.invariant(expr.object.type === "MemberExpression", {
      reason: "Expected JSX member expression to be an identifier or nested member expression",
      description: null,
      loc: (_b = expr.object.loc) != null ? _b : null,
      suggestions: null
    });
    const object = convertMemberExpressionToJsx(expr.object);
    return t3.jsxMemberExpression(object, property);
  }
}
function codegenObjectPropertyKey(cx, key2) {
  switch (key2.kind) {
    case "string": {
      return t3.stringLiteral(key2.name);
    }
    case "identifier": {
      return t3.identifier(key2.name);
    }
    case "computed": {
      const expr = codegenPlace(cx, key2.name);
      CompilerError.invariant(t3.isExpression(expr), {
        reason: "Expected object property key to be an expression",
        description: null,
        loc: key2.name.loc,
        suggestions: null
      });
      return expr;
    }
    case "number": {
      return t3.numericLiteral(key2.name);
    }
  }
}
function codegenArrayPattern(cx, pattern) {
  const hasHoles = !pattern.items.every((e) => e.kind !== "Hole");
  if (hasHoles) {
    const result = t3.arrayPattern([]);
    for (const item of pattern.items) {
      if (item.kind === "Hole") {
        result.elements.push(null);
      } else {
        result.elements.push(codegenLValue(cx, item));
      }
    }
    return result;
  } else {
    return t3.arrayPattern(
      pattern.items.map((item) => {
        if (item.kind === "Hole") {
          return null;
        }
        return codegenLValue(cx, item);
      })
    );
  }
}
function codegenLValue(cx, pattern) {
  switch (pattern.kind) {
    case "ArrayPattern": {
      return codegenArrayPattern(cx, pattern);
    }
    case "ObjectPattern": {
      return t3.objectPattern(
        pattern.properties.map((property) => {
          if (property.kind === "ObjectProperty") {
            const key2 = codegenObjectPropertyKey(cx, property.key);
            const value = codegenLValue(cx, property.place);
            return t3.objectProperty(
              key2,
              value,
              property.key.kind === "computed",
              key2.type === "Identifier" && value.type === "Identifier" && value.name === key2.name
            );
          } else {
            return t3.restElement(codegenLValue(cx, property.place));
          }
        })
      );
    }
    case "Spread": {
      return t3.restElement(codegenLValue(cx, pattern.place));
    }
    case "Identifier": {
      return convertIdentifier(pattern.identifier);
    }
    default: {
      assertExhaustive(
        pattern,
        `Unexpected pattern kind \`${pattern.kind}\``
      );
    }
  }
}
function codegenValue(cx, loc, value) {
  if (typeof value === "number") {
    if (value < 0) {
      return t3.unaryExpression("-", t3.numericLiteral(-value), false);
    } else {
      return t3.numericLiteral(value);
    }
  } else if (typeof value === "boolean") {
    return t3.booleanLiteral(value);
  } else if (typeof value === "string") {
    return createStringLiteral(loc, value);
  } else if (value === null) {
    return t3.nullLiteral();
  } else if (value === void 0) {
    return t3.identifier("undefined");
  } else {
    assertExhaustive(value, "Unexpected primitive value kind");
  }
}
function codegenArgument(cx, arg) {
  if (arg.kind === "Identifier") {
    return codegenPlaceToExpression(cx, arg);
  } else {
    return t3.spreadElement(codegenPlaceToExpression(cx, arg.place));
  }
}
function codegenPlaceToExpression(cx, place) {
  const value = codegenPlace(cx, place);
  return convertValueToExpression(value);
}
function codegenPlace(cx, place) {
  let tmp = cx.temp.get(place.identifier.declarationId);
  if (tmp != null) {
    return tmp;
  }
  CompilerError.invariant(place.identifier.name !== null || tmp !== void 0, {
    reason: `[Codegen] No value found for temporary`,
    description: `Value for '${printPlace(
      place
    )}' was not set in the codegen context`,
    loc: place.loc,
    suggestions: null
  });
  const identifier4 = convertIdentifier(place.identifier);
  identifier4.loc = place.loc;
  return identifier4;
}
function convertIdentifier(identifier4) {
  CompilerError.invariant(
    identifier4.name !== null && identifier4.name.kind === "named",
    {
      reason: `Expected temporaries to be promoted to named identifiers in an earlier pass`,
      loc: GeneratedSource,
      description: `identifier ${identifier4.id} is unnamed`,
      suggestions: null
    }
  );
  return t3.identifier(identifier4.name.value);
}
function compareScopeDependency(a, b) {
  var _a, _b;
  CompilerError.invariant(
    ((_a = a.identifier.name) == null ? void 0 : _a.kind) === "named" && ((_b = b.identifier.name) == null ? void 0 : _b.kind) === "named",
    {
      reason: "[Codegen] Expected named identifier for dependency",
      loc: a.identifier.loc
    }
  );
  const aName = [
    a.identifier.name.value,
    ...a.path.map((entry) => `${entry.optional ? "?" : ""}${entry.property}`)
  ].join(".");
  const bName = [
    b.identifier.name.value,
    ...b.path.map((entry) => `${entry.optional ? "?" : ""}${entry.property}`)
  ].join(".");
  if (aName < bName) return -1;
  else if (aName > bName) return 1;
  else return 0;
}
function compareScopeDeclaration(a, b) {
  var _a, _b;
  CompilerError.invariant(
    ((_a = a.identifier.name) == null ? void 0 : _a.kind) === "named" && ((_b = b.identifier.name) == null ? void 0 : _b.kind) === "named",
    {
      reason: "[Codegen] Expected named identifier for declaration",
      loc: a.identifier.loc
    }
  );
  const aName = a.identifier.name.value;
  const bName = b.identifier.name.value;
  if (aName < bName) return -1;
  else if (aName > bName) return 1;
  else return 0;
}

// src/ReactiveScopes/ExtractScopeDeclarationsFromDestructuring.ts
function extractScopeDeclarationsFromDestructuring(fn) {
  const state = new State2(fn.env);
  for (const param of fn.params) {
    const place = param.kind === "Identifier" ? param : param.place;
    state.declared.add(place.identifier.declarationId);
  }
  visitReactiveFunction(fn, new Visitor2(), state);
}
var State2 = class {
  constructor(env) {
    /**
     * We need to track which program variables are already declared to convert
     * declarations into reassignments, so we use DeclarationId
     */
    this.declared = /* @__PURE__ */ new Set();
    this.env = env;
  }
};
var Visitor2 = class extends ReactiveFunctionTransform {
  visitScope(scope, state) {
    for (const [, declaration] of scope.scope.declarations) {
      state.declared.add(declaration.identifier.declarationId);
    }
    this.traverseScope(scope, state);
  }
  transformInstruction(instruction, state) {
    this.visitInstruction(instruction, state);
    if (instruction.value.kind === "Destructure") {
      const transformed = transformDestructuring(
        state,
        instruction,
        instruction.value
      );
      if (transformed) {
        return {
          kind: "replace-many",
          value: transformed.map((instruction2) => ({
            kind: "instruction",
            instruction: instruction2
          }))
        };
      }
    }
    return { kind: "keep" };
  }
};
function transformDestructuring(state, instr, destructure2) {
  let reassigned = /* @__PURE__ */ new Set();
  let hasDeclaration = false;
  for (const place of eachPatternOperand(destructure2.lvalue.pattern)) {
    const isDeclared = state.declared.has(place.identifier.declarationId);
    if (isDeclared) {
      reassigned.add(place.identifier.id);
    }
    hasDeclaration || (hasDeclaration = !isDeclared);
  }
  if (reassigned.size === 0 || !hasDeclaration) {
    return null;
  }
  const instructions = [];
  const renamed = /* @__PURE__ */ new Map();
  mapPatternOperands(destructure2.lvalue.pattern, (place) => {
    if (!reassigned.has(place.identifier.id)) {
      return place;
    }
    const temporary = clonePlaceToTemporary(state.env, place);
    promoteTemporary(temporary.identifier);
    renamed.set(place, temporary);
    return temporary;
  });
  instructions.push(instr);
  for (const [original, temporary] of renamed) {
    instructions.push({
      id: instr.id,
      lvalue: null,
      value: {
        kind: "StoreLocal",
        lvalue: {
          kind: "Reassign" /* Reassign */,
          place: original
        },
        value: temporary,
        type: null,
        loc: destructure2.loc
      },
      loc: instr.loc
    });
  }
  return instructions;
}

// src/ReactiveScopes/MergeReactiveScopesThatInvalidateTogether.ts
function mergeReactiveScopesThatInvalidateTogether(fn) {
  const lastUsageVisitor = new FindLastUsageVisitor();
  visitReactiveFunction(fn, lastUsageVisitor, void 0);
  visitReactiveFunction(fn, new Transform(lastUsageVisitor.lastUsage), null);
}
var DEBUG2 = false;
function log(msg) {
  if (DEBUG2) {
    console.log(msg);
  }
}
var FindLastUsageVisitor = class extends ReactiveFunctionVisitor {
  constructor() {
    super(...arguments);
    /*
     * TODO LeaveSSA: use IdentifierId for more precise tracking
     * Using DeclarationId is necessary for compatible output but produces suboptimal results
     * in cases where a scope defines a variable, but that version is never read and always
     * overwritten later.
     * see reassignment-separate-scopes.js for example
     */
    this.lastUsage = /* @__PURE__ */ new Map();
  }
  visitPlace(id, place, _state) {
    const previousUsage = this.lastUsage.get(place.identifier.declarationId);
    const lastUsage = previousUsage !== void 0 ? makeInstructionId(Math.max(previousUsage, id)) : id;
    this.lastUsage.set(place.identifier.declarationId, lastUsage);
  }
};
var Transform = class extends ReactiveFunctionTransform {
  constructor(lastUsage) {
    super();
    this.temporaries = /* @__PURE__ */ new Map();
    this.lastUsage = lastUsage;
  }
  transformScope(scopeBlock, state) {
    this.visitScope(scopeBlock, scopeBlock.scope.dependencies);
    if (state !== null && areEqualDependencies(state, scopeBlock.scope.dependencies)) {
      return { kind: "replace-many", value: scopeBlock.instructions };
    } else {
      return { kind: "keep" };
    }
  }
  visitBlock(block, state) {
    var _a;
    this.traverseBlock(block, state);
    let current = null;
    const merged = [];
    function reset() {
      CompilerError.invariant(current !== null, {
        loc: null,
        reason: "MergeConsecutiveScopes: expected current scope to be non-null if reset()",
        suggestions: null,
        description: null
      });
      if (current.to > current.from + 1) {
        merged.push(current);
      }
      current = null;
    }
    for (let i = 0; i < block.length; i++) {
      const instr = block[i];
      switch (instr.kind) {
        case "terminal": {
          if (current !== null) {
            log(
              `Reset scope @${current.block.scope.id} from terminal [${instr.terminal.id}]`
            );
            reset();
          }
          break;
        }
        case "pruned-scope": {
          if (current !== null) {
            log(
              `Reset scope @${current.block.scope.id} from pruned scope @${instr.scope.id}`
            );
            reset();
          }
          break;
        }
        case "instruction": {
          switch (instr.instruction.value.kind) {
            case "BinaryExpression":
            case "ComputedLoad":
            case "JSXText":
            case "LoadGlobal":
            case "LoadLocal":
            case "Primitive":
            case "PropertyLoad":
            case "TemplateLiteral":
            case "UnaryExpression": {
              if (current !== null && instr.instruction.lvalue !== null) {
                current.lvalues.add(
                  instr.instruction.lvalue.identifier.declarationId
                );
                if (instr.instruction.value.kind === "LoadLocal") {
                  this.temporaries.set(
                    instr.instruction.lvalue.identifier.declarationId,
                    instr.instruction.value.place.identifier.declarationId
                  );
                }
              }
              break;
            }
            case "StoreLocal": {
              if (current !== null) {
                if (instr.instruction.value.lvalue.kind === "Const" /* Const */) {
                  for (const lvalue of eachInstructionLValue(
                    instr.instruction
                  )) {
                    current.lvalues.add(lvalue.identifier.declarationId);
                  }
                  this.temporaries.set(
                    instr.instruction.value.lvalue.place.identifier.declarationId,
                    (_a = this.temporaries.get(
                      instr.instruction.value.value.identifier.declarationId
                    )) != null ? _a : instr.instruction.value.value.identifier.declarationId
                  );
                } else {
                  log(
                    `Reset scope @${current.block.scope.id} from StoreLocal in [${instr.instruction.id}]`
                  );
                  reset();
                }
              }
              break;
            }
            default: {
              if (current !== null) {
                log(
                  `Reset scope @${current.block.scope.id} from instruction [${instr.instruction.id}]`
                );
                reset();
              }
            }
          }
          break;
        }
        case "scope": {
          if (current !== null && canMergeScopes(current.block, instr, this.temporaries) && areLValuesLastUsedByScope(
            instr.scope,
            current.lvalues,
            this.lastUsage
          )) {
            log(
              `Can merge scope @${current.block.scope.id} with @${instr.scope.id}`
            );
            current.block.scope.range.end = makeInstructionId(
              Math.max(current.block.scope.range.end, instr.scope.range.end)
            );
            for (const [key2, value] of instr.scope.declarations) {
              current.block.scope.declarations.set(key2, value);
            }
            updateScopeDeclarations(current.block.scope, this.lastUsage);
            current.to = i + 1;
            current.lvalues.clear();
            if (!scopeIsEligibleForMerging(instr)) {
              log(
                `  but scope @${instr.scope.id} doesnt guaranteed invalidate so it cannot merge further`
              );
              reset();
            }
          } else {
            if (current !== null) {
              log(
                `Reset scope @${current.block.scope.id}, not mergeable with subsequent scope @${instr.scope.id}`
              );
              reset();
            }
            if (scopeIsEligibleForMerging(instr)) {
              current = {
                block: instr,
                from: i,
                to: i + 1,
                lvalues: /* @__PURE__ */ new Set()
              };
            } else {
              log(
                `scope @${instr.scope.id} doesnt guaranteed invalidate so it cannot merge further`
              );
            }
          }
          break;
        }
        default: {
          assertExhaustive(
            instr,
            `Unexpected instruction kind \`${instr.kind}\``
          );
        }
      }
    }
    if (current !== null) {
      reset();
    }
    if (merged.length) {
      log(`merged ${merged.length} scopes:`);
      for (const entry of merged) {
        log(
          printReactiveScopeSummary(entry.block.scope) + ` from=${entry.from} to=${entry.to}`
        );
      }
    }
    if (merged.length === 0) {
      return;
    }
    const nextInstructions = [];
    let index = 0;
    for (const entry of merged) {
      if (index < entry.from) {
        nextInstructions.push(...block.slice(index, entry.from));
        index = entry.from;
      }
      const mergedScope = block[entry.from];
      CompilerError.invariant(mergedScope.kind === "scope", {
        loc: null,
        reason: "MergeConsecutiveScopes: Expected scope starting index to be a scope",
        description: null,
        suggestions: null
      });
      nextInstructions.push(mergedScope);
      index++;
      while (index < entry.to) {
        const instr = block[index++];
        if (instr.kind === "scope") {
          mergedScope.instructions.push(...instr.instructions);
          mergedScope.scope.merged.add(instr.scope.id);
        } else {
          mergedScope.instructions.push(instr);
        }
      }
    }
    while (index < block.length) {
      nextInstructions.push(block[index++]);
    }
    block.length = 0;
    block.push(...nextInstructions);
  }
};
function updateScopeDeclarations(scope, lastUsage) {
  for (const [id, decl] of scope.declarations) {
    const lastUsedAt = lastUsage.get(decl.identifier.declarationId);
    if (lastUsedAt < scope.range.end) {
      scope.declarations.delete(id);
    }
  }
}
function areLValuesLastUsedByScope(scope, lvalues, lastUsage) {
  for (const lvalue of lvalues) {
    const lastUsedAt = lastUsage.get(lvalue);
    if (lastUsedAt >= scope.range.end) {
      log(`  lvalue ${lvalue} used after scope @${scope.id}, cannot merge`);
      return false;
    }
  }
  return true;
}
function canMergeScopes(current, next, temporaries) {
  if (current.scope.reassignments.size !== 0 || next.scope.reassignments.size !== 0) {
    log(`  cannot merge, has reassignments`);
    return false;
  }
  if (areEqualDependencies(current.scope.dependencies, next.scope.dependencies)) {
    log(`  canMergeScopes: dependencies are equal`);
    return true;
  }
  if (areEqualDependencies(
    new Set(
      [...current.scope.declarations.values()].map((declaration) => ({
        identifier: declaration.identifier,
        reactive: true,
        path: []
      }))
    ),
    next.scope.dependencies
  ) || next.scope.dependencies.size !== 0 && [...next.scope.dependencies].every(
    (dep) => dep.path.length === 0 && isAlwaysInvalidatingType(dep.identifier.type) && Iterable_some(
      current.scope.declarations.values(),
      (decl) => decl.identifier.declarationId === dep.identifier.declarationId || decl.identifier.declarationId === temporaries.get(dep.identifier.declarationId)
    )
  )) {
    log(`  outputs of prev are input to current`);
    return true;
  }
  log(`  cannot merge scopes:`);
  log(
    `  ${printReactiveScopeSummary(current.scope)} ${[...current.scope.declarations.values()].map((decl) => decl.identifier.declarationId)}`
  );
  log(
    `  ${printReactiveScopeSummary(next.scope)} ${[...next.scope.dependencies].map((dep) => {
      var _a;
      return `${dep.identifier.declarationId} ${(_a = temporaries.get(dep.identifier.declarationId)) != null ? _a : dep.identifier.declarationId}`;
    })}`
  );
  return false;
}
function isAlwaysInvalidatingType(type) {
  switch (type.kind) {
    case "Object": {
      switch (type.shapeId) {
        case BuiltInArrayId:
        case BuiltInObjectId:
        case BuiltInFunctionId:
        case BuiltInJsxId: {
          return true;
        }
      }
      break;
    }
    case "Function": {
      return true;
    }
  }
  return false;
}
function areEqualDependencies(a, b) {
  if (a.size !== b.size) {
    return false;
  }
  for (const aValue of a) {
    let found = false;
    for (const bValue of b) {
      if (aValue.identifier.declarationId === bValue.identifier.declarationId && areEqualPaths(aValue.path, bValue.path)) {
        found = true;
        break;
      }
    }
    if (!found) {
      return false;
    }
  }
  return true;
}
function scopeIsEligibleForMerging(scopeBlock) {
  if (scopeBlock.scope.dependencies.size === 0) {
    return true;
  }
  return [...scopeBlock.scope.declarations].some(
    ([, decl]) => isAlwaysInvalidatingType(decl.identifier.type)
  );
}

// src/ReactiveScopes/PromoteUsedTemporaries.ts
var PromoteTemporaries = class extends ReactiveFunctionVisitor {
  visitScope(scopeBlock, state) {
    for (const dep of scopeBlock.scope.dependencies) {
      const { identifier: identifier4 } = dep;
      if (identifier4.name == null) {
        promoteIdentifier(identifier4, state);
      }
    }
    for (const [, declaration] of scopeBlock.scope.declarations) {
      if (declaration.identifier.name == null) {
        promoteIdentifier(declaration.identifier, state);
      }
    }
    this.traverseScope(scopeBlock, state);
  }
  visitPrunedScope(scopeBlock, state) {
    var _a;
    for (const [, declaration] of scopeBlock.scope.declarations) {
      if (declaration.identifier.name == null && ((_a = state.pruned.get(declaration.identifier.declarationId)) == null ? void 0 : _a.usedOutsideScope) === true) {
        promoteIdentifier(declaration.identifier, state);
      }
    }
    this.traversePrunedScope(scopeBlock, state);
  }
  visitParam(place, state) {
    if (place.identifier.name === null) {
      promoteIdentifier(place.identifier, state);
    }
  }
  visitValue(id, value, state) {
    this.traverseValue(id, value, state);
    if (value.kind === "FunctionExpression" || value.kind === "ObjectMethod") {
      this.visitHirFunction(value.loweredFunc.func, state);
    }
  }
  visitReactiveFunctionValue(_id, _dependencies2, fn, state) {
    for (const operand of fn.params) {
      const place = operand.kind === "Identifier" ? operand : operand.place;
      if (place.identifier.name === null) {
        promoteIdentifier(place.identifier, state);
      }
    }
    visitReactiveFunction(fn, this, state);
  }
};
var PromoteAllInstancedOfPromotedTemporaries = class extends ReactiveFunctionVisitor {
  visitPlace(_id, place, state) {
    if (place.identifier.name === null && state.promoted.has(place.identifier.declarationId)) {
      promoteIdentifier(place.identifier, state);
    }
  }
  visitLValue(_id, _lvalue, _state) {
    this.visitPlace(_id, _lvalue, _state);
  }
  traverseScopeIdentifiers(scope, state) {
    for (const [, decl] of scope.declarations) {
      if (decl.identifier.name === null && state.promoted.has(decl.identifier.declarationId)) {
        promoteIdentifier(decl.identifier, state);
      }
    }
    for (const dep of scope.dependencies) {
      if (dep.identifier.name === null && state.promoted.has(dep.identifier.declarationId)) {
        promoteIdentifier(dep.identifier, state);
      }
    }
    for (const reassignment of scope.reassignments) {
      if (reassignment.name === null && state.promoted.has(reassignment.declarationId)) {
        promoteIdentifier(reassignment, state);
      }
    }
  }
  visitScope(scope, state) {
    this.traverseScope(scope, state);
    this.traverseScopeIdentifiers(scope.scope, state);
  }
  visitPrunedScope(scopeBlock, state) {
    this.traversePrunedScope(scopeBlock, state);
    this.traverseScopeIdentifiers(scopeBlock.scope, state);
  }
  visitReactiveFunctionValue(_id, _dependencies2, fn, state) {
    visitReactiveFunction(fn, this, state);
  }
};
var CollectPromotableTemporaries = class extends ReactiveFunctionVisitor {
  constructor() {
    super(...arguments);
    this.activeScopes = [];
  }
  visitPlace(_id, place, state) {
    if (this.activeScopes.length !== 0 && state.pruned.has(place.identifier.declarationId)) {
      const prunedPlace = state.pruned.get(place.identifier.declarationId);
      if (prunedPlace.activeScopes.indexOf(this.activeScopes.at(-1)) === -1) {
        prunedPlace.usedOutsideScope = true;
      }
    }
  }
  visitValue(id, value, state) {
    this.traverseValue(id, value, state);
    if (value.kind === "JsxExpression" && value.tag.kind === "Identifier") {
      state.tags.add(value.tag.identifier.declarationId);
    }
  }
  visitPrunedScope(scopeBlock, state) {
    for (const [_id, decl] of scopeBlock.scope.declarations) {
      state.pruned.set(decl.identifier.declarationId, {
        activeScopes: [...this.activeScopes],
        usedOutsideScope: false
      });
    }
    this.visitBlock(scopeBlock.instructions, state);
  }
  visitScope(scopeBlock, state) {
    this.activeScopes.push(scopeBlock.scope.id);
    this.traverseScope(scopeBlock, state);
    this.activeScopes.pop();
  }
};
var _promotable, _consts, _globals2;
var PromoteInterposedTemporaries = class extends ReactiveFunctionVisitor {
  /*
   * Unpromoted temporaries will be emitted at their use sites rather than as separate
   * declarations. However, this causes errors if an interposing temporary has been
   * promoted, or if an interposing instruction has had its lvalues deleted, because such
   * temporaries will be emitted as separate statements, which can effectively cause
   * code to be reordered, and when that code has side effects that changes program behavior.
   * This visitor promotes temporarties that have such interposing instructions to preserve
   * source ordering.
   */
  constructor(promotable, params) {
    super();
    __privateAdd(this, _promotable);
    __privateAdd(this, _consts, /* @__PURE__ */ new Set());
    __privateAdd(this, _globals2, /* @__PURE__ */ new Set());
    params.forEach((param) => {
      switch (param.kind) {
        case "Identifier":
          __privateGet(this, _consts).add(param.identifier.id);
          break;
        case "Spread":
          __privateGet(this, _consts).add(param.place.identifier.id);
          break;
      }
    });
    __privateSet(this, _promotable, promotable);
  }
  visitPlace(_id, place, state) {
    const promo = state.get(place.identifier.id);
    if (promo) {
      const [identifier4, needsPromotion] = promo;
      if (needsPromotion && identifier4.name === null && !__privateGet(this, _consts).has(identifier4.id)) {
        promoteIdentifier(identifier4, __privateGet(this, _promotable));
      }
    }
  }
  visitInstruction(instruction, state) {
    for (const lval of eachInstructionValueLValue(instruction.value)) {
      CompilerError.invariant(lval.identifier.name != null, {
        reason: "PromoteInterposedTemporaries: Assignment targets not expected to be temporaries",
        loc: instruction.loc
      });
    }
    switch (instruction.value.kind) {
      case "CallExpression":
      case "MethodCall":
      case "Await":
      case "PropertyStore":
      case "PropertyDelete":
      case "ComputedStore":
      case "ComputedDelete":
      case "PostfixUpdate":
      case "PrefixUpdate":
      case "StoreLocal":
      case "StoreContext":
      case "StoreGlobal":
      case "Destructure": {
        let constStore = false;
        if ((instruction.value.kind === "StoreContext" || instruction.value.kind === "StoreLocal") && (instruction.value.lvalue.kind === "Const" || instruction.value.lvalue.kind === "HoistedConst")) {
          __privateGet(this, _consts).add(instruction.value.lvalue.place.identifier.id);
          constStore = true;
        }
        if (instruction.value.kind === "Destructure" && (instruction.value.lvalue.kind === "Const" || instruction.value.lvalue.kind === "HoistedConst")) {
          [...eachPatternOperand(instruction.value.lvalue.pattern)].forEach(
            (ident) => __privateGet(this, _consts).add(ident.identifier.id)
          );
          constStore = true;
        }
        if (instruction.value.kind === "MethodCall") {
          __privateGet(this, _consts).add(instruction.value.property.identifier.id);
        }
        super.visitInstruction(instruction, state);
        if (!constStore && (instruction.lvalue == null || instruction.lvalue.identifier.name != null)) {
          for (const [key2, [ident, _]] of state.entries()) {
            state.set(key2, [ident, true]);
          }
        }
        if (instruction.lvalue && instruction.lvalue.identifier.name === null) {
          state.set(instruction.lvalue.identifier.id, [
            instruction.lvalue.identifier,
            false
          ]);
        }
        break;
      }
      case "DeclareContext":
      case "DeclareLocal": {
        if (instruction.value.lvalue.kind === "Const" || instruction.value.lvalue.kind === "HoistedConst") {
          __privateGet(this, _consts).add(instruction.value.lvalue.place.identifier.id);
        }
        super.visitInstruction(instruction, state);
        break;
      }
      case "LoadContext":
      case "LoadLocal": {
        if (instruction.lvalue && instruction.lvalue.identifier.name === null) {
          if (__privateGet(this, _consts).has(instruction.value.place.identifier.id)) {
            __privateGet(this, _consts).add(instruction.lvalue.identifier.id);
          }
          state.set(instruction.lvalue.identifier.id, [
            instruction.lvalue.identifier,
            false
          ]);
        }
        super.visitInstruction(instruction, state);
        break;
      }
      case "PropertyLoad":
      case "ComputedLoad": {
        if (instruction.lvalue) {
          if (__privateGet(this, _globals2).has(instruction.value.object.identifier.id)) {
            __privateGet(this, _globals2).add(instruction.lvalue.identifier.id);
            __privateGet(this, _consts).add(instruction.lvalue.identifier.id);
          }
          if (instruction.lvalue.identifier.name === null) {
            state.set(instruction.lvalue.identifier.id, [
              instruction.lvalue.identifier,
              false
            ]);
          }
        }
        super.visitInstruction(instruction, state);
        break;
      }
      case "LoadGlobal": {
        instruction.lvalue && __privateGet(this, _globals2).add(instruction.lvalue.identifier.id);
        super.visitInstruction(instruction, state);
        break;
      }
      default: {
        super.visitInstruction(instruction, state);
      }
    }
  }
};
_promotable = new WeakMap();
_consts = new WeakMap();
_globals2 = new WeakMap();
function promoteUsedTemporaries(fn) {
  const state = {
    tags: /* @__PURE__ */ new Set(),
    promoted: /* @__PURE__ */ new Set(),
    pruned: /* @__PURE__ */ new Map()
  };
  visitReactiveFunction(fn, new CollectPromotableTemporaries(), state);
  for (const operand of fn.params) {
    const place = operand.kind === "Identifier" ? operand : operand.place;
    if (place.identifier.name === null) {
      promoteIdentifier(place.identifier, state);
    }
  }
  visitReactiveFunction(fn, new PromoteTemporaries(), state);
  visitReactiveFunction(
    fn,
    new PromoteInterposedTemporaries(state, fn.params),
    /* @__PURE__ */ new Map()
  );
  visitReactiveFunction(
    fn,
    new PromoteAllInstancedOfPromotedTemporaries(),
    state
  );
}
function promoteIdentifier(identifier4, state) {
  CompilerError.invariant(identifier4.name === null, {
    reason: "promoteTemporary: Expected to be called only for temporary variables",
    description: null,
    loc: GeneratedSource,
    suggestions: null
  });
  if (state.tags.has(identifier4.declarationId)) {
    promoteTemporaryJsxTag(identifier4);
  } else {
    promoteTemporary(identifier4);
  }
  state.promoted.add(identifier4.declarationId);
}

// src/ReactiveScopes/PropagateEarlyReturns.ts
function propagateEarlyReturns(fn) {
  visitReactiveFunction(fn, new Transform2(fn.env), {
    withinReactiveScope: false,
    earlyReturnValue: null
  });
}
var Transform2 = class extends ReactiveFunctionTransform {
  constructor(env) {
    super();
    this.env = env;
  }
  visitScope(scopeBlock, parentState) {
    if (scopeBlock.scope.earlyReturnValue !== null) {
      return;
    }
    const innerState = {
      withinReactiveScope: true,
      earlyReturnValue: parentState.earlyReturnValue
    };
    this.traverseScope(scopeBlock, innerState);
    const earlyReturnValue = innerState.earlyReturnValue;
    if (earlyReturnValue !== null) {
      if (!parentState.withinReactiveScope) {
        scopeBlock.scope.earlyReturnValue = earlyReturnValue;
        scopeBlock.scope.declarations.set(earlyReturnValue.value.id, {
          identifier: earlyReturnValue.value,
          scope: scopeBlock.scope
        });
        const instructions = scopeBlock.instructions;
        const loc = earlyReturnValue.loc;
        const sentinelTemp = createTemporaryPlace(this.env, loc);
        const symbolTemp = createTemporaryPlace(this.env, loc);
        const forTemp = createTemporaryPlace(this.env, loc);
        const argTemp = createTemporaryPlace(this.env, loc);
        scopeBlock.instructions = [
          {
            kind: "instruction",
            instruction: {
              id: makeInstructionId(0),
              loc,
              lvalue: __spreadValues({}, symbolTemp),
              value: {
                kind: "LoadGlobal",
                binding: {
                  kind: "Global",
                  name: "Symbol"
                },
                loc
              }
            }
          },
          {
            kind: "instruction",
            instruction: {
              id: makeInstructionId(0),
              loc,
              lvalue: __spreadValues({}, forTemp),
              value: {
                kind: "PropertyLoad",
                object: __spreadValues({}, symbolTemp),
                property: makePropertyLiteral("for"),
                loc
              }
            }
          },
          {
            kind: "instruction",
            instruction: {
              id: makeInstructionId(0),
              loc,
              lvalue: __spreadValues({}, argTemp),
              value: {
                kind: "Primitive",
                value: EARLY_RETURN_SENTINEL,
                loc
              }
            }
          },
          {
            kind: "instruction",
            instruction: {
              id: makeInstructionId(0),
              loc,
              lvalue: __spreadValues({}, sentinelTemp),
              value: {
                kind: "MethodCall",
                receiver: symbolTemp,
                property: forTemp,
                args: [argTemp],
                loc
              }
            }
          },
          {
            kind: "instruction",
            instruction: {
              id: makeInstructionId(0),
              loc,
              lvalue: null,
              value: {
                kind: "StoreLocal",
                loc,
                type: null,
                lvalue: {
                  kind: "Let" /* Let */,
                  place: {
                    kind: "Identifier",
                    effect: "mutate?" /* ConditionallyMutate */,
                    loc,
                    reactive: true,
                    identifier: earlyReturnValue.value
                  }
                },
                value: __spreadValues({}, sentinelTemp)
              }
            }
          },
          {
            kind: "terminal",
            label: {
              id: earlyReturnValue.label,
              implicit: false
            },
            terminal: {
              kind: "label",
              id: makeInstructionId(0),
              loc: GeneratedSource,
              block: instructions
            }
          }
        ];
      } else {
        parentState.earlyReturnValue = earlyReturnValue;
      }
    }
  }
  transformTerminal(stmt, state) {
    if (state.withinReactiveScope && stmt.terminal.kind === "return") {
      const loc = stmt.terminal.value.loc;
      let earlyReturnValue;
      if (state.earlyReturnValue !== null) {
        earlyReturnValue = state.earlyReturnValue;
      } else {
        const identifier4 = createTemporaryPlace(this.env, loc).identifier;
        promoteTemporary(identifier4);
        earlyReturnValue = {
          label: this.env.nextBlockId,
          loc,
          value: identifier4
        };
      }
      state.earlyReturnValue = earlyReturnValue;
      return {
        kind: "replace-many",
        value: [
          {
            kind: "instruction",
            instruction: {
              id: makeInstructionId(0),
              loc,
              lvalue: null,
              value: {
                kind: "StoreLocal",
                loc,
                type: null,
                lvalue: {
                  kind: "Reassign" /* Reassign */,
                  place: {
                    kind: "Identifier",
                    identifier: earlyReturnValue.value,
                    effect: "capture" /* Capture */,
                    loc,
                    reactive: true
                  }
                },
                value: stmt.terminal.value
              }
            }
          },
          {
            kind: "terminal",
            label: null,
            terminal: {
              kind: "break",
              id: makeInstructionId(0),
              loc,
              targetKind: "labeled",
              target: earlyReturnValue.label
            }
          }
        ]
      };
    }
    this.traverseTerminal(stmt, state);
    return { kind: "keep" };
  }
};

// src/Utils/Stack.ts
function empty() {
  return EMPTY;
}
var _value, _next;
var _Node = class _Node {
  constructor(value, next = EMPTY) {
    __privateAdd(this, _value);
    __privateAdd(this, _next);
    __privateSet(this, _value, value);
    __privateSet(this, _next, next);
  }
  push(value) {
    return new _Node(value, this);
  }
  pop() {
    return __privateGet(this, _next);
  }
  find(fn) {
    return fn(__privateGet(this, _value)) ? true : __privateGet(this, _next).find(fn);
  }
  contains(value) {
    return value === __privateGet(this, _value) || __privateGet(this, _next) !== null && __privateGet(this, _next).contains(value);
  }
  each(fn) {
    fn(__privateGet(this, _value));
    __privateGet(this, _next).each(fn);
  }
  get value() {
    return __privateGet(this, _value);
  }
  print(fn) {
    return fn(__privateGet(this, _value)) + __privateGet(this, _next).print(fn);
  }
};
_value = new WeakMap();
_next = new WeakMap();
var Node = _Node;
var Empty = class {
  push(value) {
    return new Node(value, this);
  }
  pop() {
    return this;
  }
  find(_fn) {
    return false;
  }
  contains(_value2) {
    return false;
  }
  each(_fn) {
    return;
  }
  get value() {
    return null;
  }
  print(_) {
    return "";
  }
};
var EMPTY = new Empty();

// src/ReactiveScopes/PruneHoistedContexts.ts
function pruneHoistedContexts(fn) {
  visitReactiveFunction(fn, new Visitor3(), {
    activeScopes: empty(),
    uninitialized: /* @__PURE__ */ new Map()
  });
}
var Visitor3 = class extends ReactiveFunctionTransform {
  visitScope(scope, state) {
    state.activeScopes = state.activeScopes.push(
      new Set(scope.scope.declarations.keys())
    );
    for (const decl of scope.scope.declarations.values()) {
      state.uninitialized.set(decl.identifier.id, { kind: "unknown-kind" });
    }
    this.traverseScope(scope, state);
    state.activeScopes.pop();
    for (const decl of scope.scope.declarations.values()) {
      state.uninitialized.delete(decl.identifier.id);
    }
  }
  visitPlace(_id, place, state) {
    const maybeHoistedFn = state.uninitialized.get(place.identifier.id);
    if ((maybeHoistedFn == null ? void 0 : maybeHoistedFn.kind) === "func" && maybeHoistedFn.definition !== place) {
      CompilerError.throwTodo({
        reason: "[PruneHoistedContexts] Rewrite hoisted function references",
        loc: place.loc
      });
    }
  }
  transformInstruction(instruction, state) {
    if (instruction.value.kind === "DeclareContext") {
      const maybeNonHoisted = convertHoistedLValueKind(
        instruction.value.lvalue.kind
      );
      if (maybeNonHoisted != null) {
        if (maybeNonHoisted === "Function" /* Function */ && state.uninitialized.has(instruction.value.lvalue.place.identifier.id)) {
          state.uninitialized.set(
            instruction.value.lvalue.place.identifier.id,
            {
              kind: "func",
              definition: null
            }
          );
        }
        return { kind: "remove" };
      }
    }
    if (instruction.value.kind === "StoreContext" && instruction.value.lvalue.kind !== "Reassign" /* Reassign */) {
      const lvalueId = instruction.value.lvalue.place.identifier.id;
      const isDeclaredByScope = state.activeScopes.find(
        (scope) => scope.has(lvalueId)
      );
      if (isDeclaredByScope) {
        if (instruction.value.lvalue.kind === "Let" /* Let */ || instruction.value.lvalue.kind === "Const" /* Const */) {
          instruction.value.lvalue.kind = "Reassign" /* Reassign */;
        } else if (instruction.value.lvalue.kind === "Function" /* Function */) {
          const maybeHoistedFn = state.uninitialized.get(lvalueId);
          if (maybeHoistedFn != null) {
            CompilerError.invariant(maybeHoistedFn.kind === "func", {
              reason: "[PruneHoistedContexts] Unexpected hoisted function",
              loc: instruction.loc
            });
            maybeHoistedFn.definition = instruction.value.lvalue.place;
            state.uninitialized.delete(lvalueId);
          }
        } else {
          CompilerError.throwTodo({
            reason: "[PruneHoistedContexts] Unexpected kind",
            description: `(${instruction.value.lvalue.kind})`,
            loc: instruction.loc
          });
        }
      }
    }
    this.visitInstruction(instruction, state);
    return { kind: "keep" };
  }
};

// src/Inference/InferMutationAliasingEffects.ts
var import_pretty_format2 = __toESM(require_build());

// src/Inference/AliasingEffects.ts
function hashEffect(effect) {
  var _a;
  switch (effect.kind) {
    case "Apply": {
      return [
        effect.kind,
        effect.receiver.identifier.id,
        effect.function.identifier.id,
        effect.mutatesFunction,
        effect.args.map((a) => {
          if (a.kind === "Hole") {
            return "";
          } else if (a.kind === "Identifier") {
            return a.identifier.id;
          } else {
            return `...${a.place.identifier.id}`;
          }
        }).join(","),
        effect.into.identifier.id
      ].join(":");
    }
    case "CreateFrom":
    case "ImmutableCapture":
    case "Assign":
    case "Alias":
    case "Capture":
    case "MaybeAlias": {
      return [
        effect.kind,
        effect.from.identifier.id,
        effect.into.identifier.id
      ].join(":");
    }
    case "Create": {
      return [
        effect.kind,
        effect.into.identifier.id,
        effect.value,
        effect.reason
      ].join(":");
    }
    case "Freeze": {
      return [effect.kind, effect.value.identifier.id, effect.reason].join(":");
    }
    case "Impure":
    case "Render": {
      return [effect.kind, effect.place.identifier.id].join(":");
    }
    case "MutateFrozen":
    case "MutateGlobal": {
      return [
        effect.kind,
        effect.place.identifier.id,
        effect.error.severity,
        effect.error.reason,
        effect.error.description,
        printSourceLocation((_a = effect.error.primaryLocation()) != null ? _a : GeneratedSource)
      ].join(":");
    }
    case "Mutate":
    case "MutateConditionally":
    case "MutateTransitive":
    case "MutateTransitiveConditionally": {
      return [effect.kind, effect.value.identifier.id].join(":");
    }
    case "CreateFunction": {
      return [
        effect.kind,
        effect.into.identifier.id,
        // return places are a unique way to identify functions themselves
        effect.function.loweredFunc.func.returns.identifier.id,
        effect.captures.map((p) => p.identifier.id).join(",")
      ].join(":");
    }
  }
}

// src/Inference/InferMutationAliasingEffects.ts
var DEBUG3 = false;
function inferMutationAliasingEffects(fn, { isFunctionExpression } = {
  isFunctionExpression: false
}) {
  const initialState = InferenceState.empty(fn.env, isFunctionExpression);
  const statesByBlock = /* @__PURE__ */ new Map();
  for (const ref of fn.context) {
    const value = {
      kind: "ObjectExpression",
      properties: [],
      loc: ref.loc
    };
    initialState.initialize(value, {
      kind: "context" /* Context */,
      reason: /* @__PURE__ */ new Set(["other" /* Other */])
    });
    initialState.define(ref, value);
  }
  const paramKind = isFunctionExpression ? {
    kind: "mutable" /* Mutable */,
    reason: /* @__PURE__ */ new Set(["other" /* Other */])
  } : {
    kind: "frozen" /* Frozen */,
    reason: /* @__PURE__ */ new Set(["reactive-function-argument" /* ReactiveFunctionArgument */])
  };
  if (fn.fnType === "Component") {
    CompilerError.invariant(fn.params.length <= 2, {
      reason: "Expected React component to have not more than two parameters: one for props and for ref",
      description: null,
      loc: fn.loc,
      suggestions: null
    });
    const [props, ref] = fn.params;
    if (props != null) {
      inferParam(props, initialState, paramKind);
    }
    if (ref != null) {
      const place = ref.kind === "Identifier" ? ref : ref.place;
      const value = {
        kind: "ObjectExpression",
        properties: [],
        loc: place.loc
      };
      initialState.initialize(value, {
        kind: "mutable" /* Mutable */,
        reason: /* @__PURE__ */ new Set(["other" /* Other */])
      });
      initialState.define(place, value);
    }
  } else {
    for (const param of fn.params) {
      inferParam(param, initialState, paramKind);
    }
  }
  const queuedStates = /* @__PURE__ */ new Map();
  function queue(blockId, state) {
    var _a;
    let queuedState = queuedStates.get(blockId);
    if (queuedState != null) {
      state = (_a = queuedState.merge(state)) != null ? _a : queuedState;
      queuedStates.set(blockId, state);
    } else {
      const prevState = statesByBlock.get(blockId);
      const nextState = prevState != null ? prevState.merge(state) : state;
      if (nextState != null) {
        queuedStates.set(blockId, nextState);
      }
    }
  }
  queue(fn.body.entry, initialState);
  const hoistedContextDeclarations = findHoistedContextDeclarations(fn);
  const context = new Context3(
    isFunctionExpression,
    fn,
    hoistedContextDeclarations
  );
  let iterationCount = 0;
  while (queuedStates.size !== 0) {
    iterationCount++;
    if (iterationCount > 100) {
      CompilerError.invariant(false, {
        reason: `[InferMutationAliasingEffects] Potential infinite loop`,
        description: `A value, temporary place, or effect was not cached properly`,
        loc: fn.loc
      });
    }
    for (const [blockId, block] of fn.body.blocks) {
      const incomingState = queuedStates.get(blockId);
      queuedStates.delete(blockId);
      if (incomingState == null) {
        continue;
      }
      statesByBlock.set(blockId, incomingState);
      const state = incomingState.clone();
      inferBlock(context, state, block);
      for (const nextBlockId of eachTerminalSuccessor(block.terminal)) {
        queue(nextBlockId, state);
      }
    }
  }
  return Ok(void 0);
}
function findHoistedContextDeclarations(fn) {
  const hoisted = /* @__PURE__ */ new Map();
  function visit4(place) {
    if (hoisted.has(place.identifier.declarationId) && hoisted.get(place.identifier.declarationId) == null) {
      hoisted.set(place.identifier.declarationId, place);
    }
  }
  for (const block of fn.body.blocks.values()) {
    for (const instr of block.instructions) {
      if (instr.value.kind === "DeclareContext") {
        const kind = instr.value.lvalue.kind;
        if (kind == "HoistedConst" /* HoistedConst */ || kind == "HoistedFunction" /* HoistedFunction */ || kind == "HoistedLet" /* HoistedLet */) {
          hoisted.set(instr.value.lvalue.place.identifier.declarationId, null);
        }
      } else {
        for (const operand of eachInstructionValueOperand(instr.value)) {
          visit4(operand);
        }
      }
    }
    for (const operand of eachTerminalOperand(block.terminal)) {
      visit4(operand);
    }
  }
  return hoisted;
}
var Context3 = class {
  constructor(isFunctionExpression, fn, hoistedContextDeclarations) {
    this.internedEffects = /* @__PURE__ */ new Map();
    this.instructionSignatureCache = /* @__PURE__ */ new Map();
    this.effectInstructionValueCache = /* @__PURE__ */ new Map();
    this.applySignatureCache = /* @__PURE__ */ new Map();
    this.catchHandlers = /* @__PURE__ */ new Map();
    this.functionSignatureCache = /* @__PURE__ */ new Map();
    this.isFuctionExpression = isFunctionExpression;
    this.fn = fn;
    this.hoistedContextDeclarations = hoistedContextDeclarations;
  }
  cacheApplySignature(signature, effect, f) {
    const inner = getOrInsertDefault(
      this.applySignatureCache,
      signature,
      /* @__PURE__ */ new Map()
    );
    return getOrInsertWith(inner, effect, f);
  }
  internEffect(effect) {
    const hash = hashEffect(effect);
    let interned = this.internedEffects.get(hash);
    if (interned == null) {
      this.internedEffects.set(hash, effect);
      interned = effect;
    }
    return interned;
  }
};
function inferParam(param, initialState, paramKind) {
  const place = param.kind === "Identifier" ? param : param.place;
  const value = {
    kind: "Primitive",
    loc: place.loc,
    value: void 0
  };
  initialState.initialize(value, paramKind);
  initialState.define(place, value);
}
function inferBlock(context, state, block) {
  for (const phi of block.phis) {
    state.inferPhi(phi);
  }
  for (const instr of block.instructions) {
    let instructionSignature = context.instructionSignatureCache.get(instr);
    if (instructionSignature == null) {
      instructionSignature = computeSignatureForInstruction(
        context,
        state.env,
        instr
      );
      context.instructionSignatureCache.set(instr, instructionSignature);
    }
    const effects = applySignature(context, state, instructionSignature, instr);
    instr.effects = effects;
  }
  const terminal = block.terminal;
  if (terminal.kind === "try" && terminal.handlerBinding != null) {
    context.catchHandlers.set(terminal.handler, terminal.handlerBinding);
  } else if (terminal.kind === "maybe-throw") {
    const handlerParam = context.catchHandlers.get(terminal.handler);
    if (handlerParam != null) {
      CompilerError.invariant(state.kind(handlerParam) != null, {
        reason: "Expected catch binding to be intialized with a DeclareLocal Catch instruction",
        loc: terminal.loc
      });
      const effects = [];
      for (const instr of block.instructions) {
        if (instr.value.kind === "CallExpression" || instr.value.kind === "MethodCall") {
          state.appendAlias(handlerParam, instr.lvalue);
          const kind = state.kind(instr.lvalue).kind;
          if (kind === "mutable" /* Mutable */ || kind == "context" /* Context */) {
            effects.push(
              context.internEffect({
                kind: "Alias",
                from: instr.lvalue,
                into: handlerParam
              })
            );
          }
        }
      }
      terminal.effects = effects.length !== 0 ? effects : null;
    }
  } else if (terminal.kind === "return") {
    if (!context.isFuctionExpression) {
      terminal.effects = [
        context.internEffect({
          kind: "Freeze",
          value: terminal.value,
          reason: "jsx-captured" /* JsxCaptured */
        })
      ];
    }
  }
}
function applySignature(context, state, signature, instruction) {
  var _a, _b;
  const effects = [];
  if (instruction.value.kind === "FunctionExpression" || instruction.value.kind === "ObjectMethod") {
    const aliasingEffects = (_a = instruction.value.loweredFunc.func.aliasingEffects) != null ? _a : [];
    const context2 = new Set(
      instruction.value.loweredFunc.func.context.map((p) => p.identifier.id)
    );
    for (const effect of aliasingEffects) {
      if (effect.kind === "Mutate" || effect.kind === "MutateTransitive") {
        if (!context2.has(effect.value.identifier.id)) {
          continue;
        }
        const value = state.kind(effect.value);
        switch (value.kind) {
          case "frozen" /* Frozen */: {
            const reason = getWriteErrorReason({
              kind: value.kind,
              reason: value.reason
            });
            const variable = effect.value.identifier.name !== null && effect.value.identifier.name.kind === "named" ? `\`${effect.value.identifier.name.value}\`` : "value";
            const diagnostic = CompilerDiagnostic.create({
              category: "Immutability" /* Immutability */,
              severity: "InvalidReact" /* InvalidReact */,
              reason: "This value cannot be modified",
              description: `${reason}.`
            }).withDetail({
              kind: "error",
              loc: effect.value.loc,
              message: `${variable} cannot be modified`
            });
            if (effect.kind === "Mutate" && ((_b = effect.reason) == null ? void 0 : _b.kind) === "AssignCurrentProperty") {
              diagnostic.withDetail({
                kind: "hint",
                message: `Hint: If this value is a Ref (value returned by \`useRef()\`), rename the variable to end in "Ref".`
              });
            }
            effects.push({
              kind: "MutateFrozen",
              place: effect.value,
              error: diagnostic
            });
          }
        }
      }
    }
  }
  const initialized = /* @__PURE__ */ new Set();
  if (DEBUG3) {
    console.log(printInstruction(instruction));
  }
  for (const effect of signature.effects) {
    applyEffect(context, state, effect, initialized, effects);
  }
  if (DEBUG3) {
    console.log(
      (0, import_pretty_format2.default)(state.debugAbstractValue(state.kind(instruction.lvalue)))
    );
    console.log(
      effects.map((effect) => `  ${printAliasingEffect(effect)}`).join("\n")
    );
  }
  if (!(state.isDefined(instruction.lvalue) && state.kind(instruction.lvalue))) {
    CompilerError.invariant(false, {
      reason: `Expected instruction lvalue to be initialized`,
      loc: instruction.loc
    });
  }
  return effects.length !== 0 ? effects : null;
}
function applyEffect(context, state, _effect, initialized, effects) {
  var _a, _b, _c, _d, _e;
  const effect = context.internEffect(_effect);
  if (DEBUG3) {
    console.log(printAliasingEffect(effect));
  }
  switch (effect.kind) {
    case "Freeze": {
      const didFreeze = state.freeze(effect.value, effect.reason);
      if (didFreeze) {
        effects.push(effect);
      }
      break;
    }
    case "Create": {
      CompilerError.invariant(!initialized.has(effect.into.identifier.id), {
        reason: `Cannot re-initialize variable within an instruction`,
        description: `Re-initialized ${printPlace(effect.into)} in ${printAliasingEffect(effect)}`,
        loc: effect.into.loc
      });
      initialized.add(effect.into.identifier.id);
      let value = context.effectInstructionValueCache.get(effect);
      if (value == null) {
        value = {
          kind: "ObjectExpression",
          properties: [],
          loc: effect.into.loc
        };
        context.effectInstructionValueCache.set(effect, value);
      }
      state.initialize(value, {
        kind: effect.value,
        reason: /* @__PURE__ */ new Set([effect.reason])
      });
      state.define(effect.into, value);
      effects.push(effect);
      break;
    }
    case "ImmutableCapture": {
      const kind = state.kind(effect.from).kind;
      switch (kind) {
        case "global" /* Global */:
        case "primitive" /* Primitive */: {
          break;
        }
        default: {
          effects.push(effect);
        }
      }
      break;
    }
    case "CreateFrom": {
      CompilerError.invariant(!initialized.has(effect.into.identifier.id), {
        reason: `Cannot re-initialize variable within an instruction`,
        description: `Re-initialized ${printPlace(effect.into)} in ${printAliasingEffect(effect)}`,
        loc: effect.into.loc
      });
      initialized.add(effect.into.identifier.id);
      const fromValue = state.kind(effect.from);
      let value = context.effectInstructionValueCache.get(effect);
      if (value == null) {
        value = {
          kind: "ObjectExpression",
          properties: [],
          loc: effect.into.loc
        };
        context.effectInstructionValueCache.set(effect, value);
      }
      state.initialize(value, {
        kind: fromValue.kind,
        reason: new Set(fromValue.reason)
      });
      state.define(effect.into, value);
      switch (fromValue.kind) {
        case "primitive" /* Primitive */:
        case "global" /* Global */: {
          effects.push({
            kind: "Create",
            value: fromValue.kind,
            into: effect.into,
            reason: (_a = [...fromValue.reason][0]) != null ? _a : "other" /* Other */
          });
          break;
        }
        case "frozen" /* Frozen */: {
          effects.push({
            kind: "Create",
            value: fromValue.kind,
            into: effect.into,
            reason: (_b = [...fromValue.reason][0]) != null ? _b : "other" /* Other */
          });
          applyEffect(
            context,
            state,
            {
              kind: "ImmutableCapture",
              from: effect.from,
              into: effect.into
            },
            initialized,
            effects
          );
          break;
        }
        default: {
          effects.push(effect);
        }
      }
      break;
    }
    case "CreateFunction": {
      CompilerError.invariant(!initialized.has(effect.into.identifier.id), {
        reason: `Cannot re-initialize variable within an instruction`,
        description: `Re-initialized ${printPlace(effect.into)} in ${printAliasingEffect(effect)}`,
        loc: effect.into.loc
      });
      initialized.add(effect.into.identifier.id);
      effects.push(effect);
      const hasCaptures = effect.captures.some((capture) => {
        switch (state.kind(capture).kind) {
          case "context" /* Context */:
          case "mutable" /* Mutable */: {
            return true;
          }
          default: {
            return false;
          }
        }
      });
      const hasTrackedSideEffects = (_c = effect.function.loweredFunc.func.aliasingEffects) == null ? void 0 : _c.some(
        (effect2) => (
          // TODO; include "render" here?
          effect2.kind === "MutateFrozen" || effect2.kind === "MutateGlobal" || effect2.kind === "Impure"
        )
      );
      const capturesRef = effect.function.loweredFunc.func.context.some(
        (operand) => isRefOrRefValue(operand.identifier)
      );
      const isMutable3 = hasCaptures || hasTrackedSideEffects || capturesRef;
      for (const operand of effect.function.loweredFunc.func.context) {
        if (operand.effect !== "capture" /* Capture */) {
          continue;
        }
        const kind = state.kind(operand).kind;
        if (kind === "primitive" /* Primitive */ || kind == "frozen" /* Frozen */ || kind == "global" /* Global */) {
          operand.effect = "read" /* Read */;
        }
      }
      state.initialize(effect.function, {
        kind: isMutable3 ? "mutable" /* Mutable */ : "frozen" /* Frozen */,
        reason: /* @__PURE__ */ new Set([])
      });
      state.define(effect.into, effect.function);
      for (const capture of effect.captures) {
        applyEffect(
          context,
          state,
          {
            kind: "Capture",
            from: capture,
            into: effect.into
          },
          initialized,
          effects
        );
      }
      break;
    }
    case "MaybeAlias":
    case "Alias":
    case "Capture": {
      CompilerError.invariant(
        effect.kind === "Capture" || initialized.has(effect.into.identifier.id),
        {
          reason: `Expected destination value to already be initialized within this instruction for Alias effect`,
          description: `Destination ${printPlace(effect.into)} is not initialized in this instruction`,
          loc: effect.into.loc
        }
      );
      const intoKind = state.kind(effect.into).kind;
      let isMutableDesination;
      switch (intoKind) {
        case "context" /* Context */:
        case "mutable" /* Mutable */:
        case "maybefrozen" /* MaybeFrozen */: {
          isMutableDesination = true;
          break;
        }
        default: {
          isMutableDesination = false;
          break;
        }
      }
      const fromKind = state.kind(effect.from).kind;
      let isMutableReferenceType;
      switch (fromKind) {
        case "global" /* Global */:
        case "primitive" /* Primitive */: {
          isMutableReferenceType = false;
          break;
        }
        case "frozen" /* Frozen */: {
          isMutableReferenceType = false;
          applyEffect(
            context,
            state,
            {
              kind: "ImmutableCapture",
              from: effect.from,
              into: effect.into
            },
            initialized,
            effects
          );
          break;
        }
        default: {
          isMutableReferenceType = true;
          break;
        }
      }
      if (isMutableDesination && isMutableReferenceType) {
        effects.push(effect);
      }
      break;
    }
    case "Assign": {
      CompilerError.invariant(!initialized.has(effect.into.identifier.id), {
        reason: `Cannot re-initialize variable within an instruction`,
        description: `Re-initialized ${printPlace(effect.into)} in ${printAliasingEffect(effect)}`,
        loc: effect.into.loc
      });
      initialized.add(effect.into.identifier.id);
      const fromValue = state.kind(effect.from);
      const fromKind = fromValue.kind;
      switch (fromKind) {
        case "frozen" /* Frozen */: {
          applyEffect(
            context,
            state,
            {
              kind: "ImmutableCapture",
              from: effect.from,
              into: effect.into
            },
            initialized,
            effects
          );
          let value = context.effectInstructionValueCache.get(effect);
          if (value == null) {
            value = {
              kind: "Primitive",
              value: void 0,
              loc: effect.from.loc
            };
            context.effectInstructionValueCache.set(effect, value);
          }
          state.initialize(value, {
            kind: fromKind,
            reason: new Set(fromValue.reason)
          });
          state.define(effect.into, value);
          break;
        }
        case "global" /* Global */:
        case "primitive" /* Primitive */: {
          let value = context.effectInstructionValueCache.get(effect);
          if (value == null) {
            value = {
              kind: "Primitive",
              value: void 0,
              loc: effect.from.loc
            };
            context.effectInstructionValueCache.set(effect, value);
          }
          state.initialize(value, {
            kind: fromKind,
            reason: new Set(fromValue.reason)
          });
          state.define(effect.into, value);
          break;
        }
        default: {
          state.assign(effect.into, effect.from);
          effects.push(effect);
          break;
        }
      }
      break;
    }
    case "Apply": {
      const functionValues = state.values(effect.function);
      if (functionValues.length === 1 && functionValues[0].kind === "FunctionExpression" && functionValues[0].loweredFunc.func.aliasingEffects != null) {
        const functionExpr = functionValues[0];
        let signature = context.functionSignatureCache.get(functionExpr);
        if (signature == null) {
          signature = buildSignatureFromFunctionExpression(
            state.env,
            functionExpr
          );
          context.functionSignatureCache.set(functionExpr, signature);
        }
        if (DEBUG3) {
          console.log(
            `constructed alias signature:
${printAliasingSignature(signature)}`
          );
        }
        const signatureEffects2 = context.cacheApplySignature(
          signature,
          effect,
          () => computeEffectsForSignature(
            state.env,
            signature,
            effect.into,
            effect.receiver,
            effect.args,
            functionExpr.loweredFunc.func.context,
            effect.loc
          )
        );
        if (signatureEffects2 != null) {
          applyEffect(
            context,
            state,
            { kind: "MutateTransitiveConditionally", value: effect.function },
            initialized,
            effects
          );
          for (const signatureEffect of signatureEffects2) {
            applyEffect(context, state, signatureEffect, initialized, effects);
          }
          break;
        }
      }
      let signatureEffects = null;
      if (((_d = effect.signature) == null ? void 0 : _d.aliasing) != null) {
        const signature = effect.signature.aliasing;
        signatureEffects = context.cacheApplySignature(
          effect.signature.aliasing,
          effect,
          () => computeEffectsForSignature(
            state.env,
            signature,
            effect.into,
            effect.receiver,
            effect.args,
            [],
            effect.loc
          )
        );
      }
      if (signatureEffects != null) {
        for (const signatureEffect of signatureEffects) {
          applyEffect(context, state, signatureEffect, initialized, effects);
        }
      } else if (effect.signature != null) {
        const legacyEffects = computeEffectsForLegacySignature(
          state,
          effect.signature,
          effect.into,
          effect.receiver,
          effect.args,
          effect.loc
        );
        for (const legacyEffect of legacyEffects) {
          applyEffect(context, state, legacyEffect, initialized, effects);
        }
      } else {
        applyEffect(
          context,
          state,
          {
            kind: "Create",
            into: effect.into,
            value: "mutable" /* Mutable */,
            reason: "other" /* Other */
          },
          initialized,
          effects
        );
        for (const arg of [effect.receiver, effect.function, ...effect.args]) {
          if (arg.kind === "Hole") {
            continue;
          }
          const operand = arg.kind === "Identifier" ? arg : arg.place;
          if (operand !== effect.function || effect.mutatesFunction) {
            applyEffect(
              context,
              state,
              {
                kind: "MutateTransitiveConditionally",
                value: operand
              },
              initialized,
              effects
            );
          }
          const mutateIterator = arg.kind === "Spread" ? conditionallyMutateIterator(operand) : null;
          if (mutateIterator) {
            applyEffect(context, state, mutateIterator, initialized, effects);
          }
          applyEffect(
            context,
            state,
            // OK: recording information flow
            { kind: "MaybeAlias", from: operand, into: effect.into },
            initialized,
            effects
          );
          for (const otherArg of [
            effect.receiver,
            effect.function,
            ...effect.args
          ]) {
            if (otherArg.kind === "Hole") {
              continue;
            }
            const other = otherArg.kind === "Identifier" ? otherArg : otherArg.place;
            if (other === arg) {
              continue;
            }
            applyEffect(
              context,
              state,
              {
                /*
                 * OK: a function might store one operand into another,
                 * but it can't force one to alias another
                 */
                kind: "Capture",
                from: operand,
                into: other
              },
              initialized,
              effects
            );
          }
        }
      }
      break;
    }
    case "Mutate":
    case "MutateConditionally":
    case "MutateTransitive":
    case "MutateTransitiveConditionally": {
      const mutationKind = state.mutate(effect.kind, effect.value);
      if (mutationKind === "mutate") {
        effects.push(effect);
      } else if (mutationKind === "mutate-ref") {
      } else if (mutationKind !== "none" && (effect.kind === "Mutate" || effect.kind === "MutateTransitive")) {
        const value = state.kind(effect.value);
        if (DEBUG3) {
          console.log(`invalid mutation: ${printAliasingEffect(effect)}`);
          console.log((0, import_pretty_format2.default)(state.debugAbstractValue(value)));
        }
        if (mutationKind === "mutate-frozen" && context.hoistedContextDeclarations.has(
          effect.value.identifier.declarationId
        )) {
          const variable = effect.value.identifier.name !== null && effect.value.identifier.name.kind === "named" ? `\`${effect.value.identifier.name.value}\`` : null;
          const hoistedAccess = context.hoistedContextDeclarations.get(
            effect.value.identifier.declarationId
          );
          const diagnostic = CompilerDiagnostic.create({
            category: "Immutability" /* Immutability */,
            severity: "InvalidReact" /* InvalidReact */,
            reason: "Cannot access variable before it is declared",
            description: `${variable != null ? variable : "This variable"} is accessed before it is declared, which prevents the earlier access from updating when this value changes over time.`
          });
          if (hoistedAccess != null && hoistedAccess.loc != effect.value.loc) {
            diagnostic.withDetail({
              kind: "error",
              loc: hoistedAccess.loc,
              message: `${variable != null ? variable : "variable"} accessed before it is declared`
            });
          }
          diagnostic.withDetail({
            kind: "error",
            loc: effect.value.loc,
            message: `${variable != null ? variable : "variable"} is declared here`
          });
          applyEffect(
            context,
            state,
            {
              kind: "MutateFrozen",
              place: effect.value,
              error: diagnostic
            },
            initialized,
            effects
          );
        } else {
          const reason = getWriteErrorReason({
            kind: value.kind,
            reason: value.reason
          });
          const variable = effect.value.identifier.name !== null && effect.value.identifier.name.kind === "named" ? `\`${effect.value.identifier.name.value}\`` : "value";
          const diagnostic = CompilerDiagnostic.create({
            category: "Immutability" /* Immutability */,
            severity: "InvalidReact" /* InvalidReact */,
            reason: "This value cannot be modified",
            description: `${reason}.`
          }).withDetail({
            kind: "error",
            loc: effect.value.loc,
            message: `${variable} cannot be modified`
          });
          if (effect.kind === "Mutate" && ((_e = effect.reason) == null ? void 0 : _e.kind) === "AssignCurrentProperty") {
            diagnostic.withDetail({
              kind: "hint",
              message: `Hint: If this value is a Ref (value returned by \`useRef()\`), rename the variable to end in "Ref".`
            });
          }
          applyEffect(
            context,
            state,
            {
              kind: value.kind === "frozen" /* Frozen */ ? "MutateFrozen" : "MutateGlobal",
              place: effect.value,
              error: diagnostic
            },
            initialized,
            effects
          );
        }
      }
      break;
    }
    case "Impure":
    case "Render":
    case "MutateFrozen":
    case "MutateGlobal": {
      effects.push(effect);
      break;
    }
    default: {
      assertExhaustive(
        effect,
        `Unexpected effect kind '${effect.kind}'`
      );
    }
  }
}
var _isFunctionExpression, _values, _variables;
var _InferenceState = class _InferenceState {
  constructor(env, isFunctionExpression, values, variables) {
    __privateAdd(this, _isFunctionExpression);
    // The kind of each value, based on its allocation site
    __privateAdd(this, _values);
    /*
     * The set of values pointed to by each identifier. This is a set
     * to accomodate phi points (where a variable may have different
     * values from different control flow paths).
     */
    __privateAdd(this, _variables);
    this.env = env;
    __privateSet(this, _isFunctionExpression, isFunctionExpression);
    __privateSet(this, _values, values);
    __privateSet(this, _variables, variables);
  }
  static empty(env, isFunctionExpression) {
    return new _InferenceState(env, isFunctionExpression, /* @__PURE__ */ new Map(), /* @__PURE__ */ new Map());
  }
  get isFunctionExpression() {
    return __privateGet(this, _isFunctionExpression);
  }
  // (Re)initializes a @param value with its default @param kind.
  initialize(value, kind) {
    CompilerError.invariant(value.kind !== "LoadLocal", {
      reason: "[InferMutationAliasingEffects] Expected all top-level identifiers to be defined as variables, not values",
      description: null,
      loc: value.loc,
      suggestions: null
    });
    __privateGet(this, _values).set(value, kind);
  }
  values(place) {
    const values = __privateGet(this, _variables).get(place.identifier.id);
    CompilerError.invariant(values != null, {
      reason: `[InferMutationAliasingEffects] Expected value kind to be initialized`,
      description: `${printPlace(place)}`,
      loc: place.loc,
      suggestions: null
    });
    return Array.from(values);
  }
  // Lookup the kind of the given @param value.
  kind(place) {
    const values = __privateGet(this, _variables).get(place.identifier.id);
    CompilerError.invariant(values != null, {
      reason: `[InferMutationAliasingEffects] Expected value kind to be initialized`,
      description: `${printPlace(place)}`,
      loc: place.loc,
      suggestions: null
    });
    let mergedKind = null;
    for (const value of values) {
      const kind = __privateGet(this, _values).get(value);
      mergedKind = mergedKind !== null ? mergeAbstractValues(mergedKind, kind) : kind;
    }
    CompilerError.invariant(mergedKind !== null, {
      reason: `[InferMutationAliasingEffects] Expected at least one value`,
      description: `No value found at \`${printPlace(place)}\``,
      loc: place.loc,
      suggestions: null
    });
    return mergedKind;
  }
  // Updates the value at @param place to point to the same value as @param value.
  assign(place, value) {
    const values = __privateGet(this, _variables).get(value.identifier.id);
    CompilerError.invariant(values != null, {
      reason: `[InferMutationAliasingEffects] Expected value for identifier to be initialized`,
      description: `${printIdentifier(value.identifier)}`,
      loc: value.loc,
      suggestions: null
    });
    __privateGet(this, _variables).set(place.identifier.id, new Set(values));
  }
  appendAlias(place, value) {
    const values = __privateGet(this, _variables).get(value.identifier.id);
    CompilerError.invariant(values != null, {
      reason: `[InferMutationAliasingEffects] Expected value for identifier to be initialized`,
      description: `${printIdentifier(value.identifier)}`,
      loc: value.loc,
      suggestions: null
    });
    const prevValues = this.values(place);
    __privateGet(this, _variables).set(
      place.identifier.id,
      /* @__PURE__ */ new Set([...prevValues, ...values])
    );
  }
  // Defines (initializing or updating) a variable with a specific kind of value.
  define(place, value) {
    CompilerError.invariant(__privateGet(this, _values).has(value), {
      reason: `[InferMutationAliasingEffects] Expected value to be initialized at '${printSourceLocation(
        value.loc
      )}'`,
      description: printInstructionValue(value),
      loc: value.loc,
      suggestions: null
    });
    __privateGet(this, _variables).set(place.identifier.id, /* @__PURE__ */ new Set([value]));
  }
  isDefined(place) {
    return __privateGet(this, _variables).has(place.identifier.id);
  }
  /**
   * Marks @param place as transitively frozen. Returns true if the value was not
   * already frozen, false if the value is already frozen (or already known immutable).
   */
  freeze(place, reason) {
    const value = this.kind(place);
    switch (value.kind) {
      case "context" /* Context */:
      case "mutable" /* Mutable */:
      case "maybefrozen" /* MaybeFrozen */: {
        const values = this.values(place);
        for (const instrValue of values) {
          this.freezeValue(instrValue, reason);
        }
        return true;
      }
      case "frozen" /* Frozen */:
      case "global" /* Global */:
      case "primitive" /* Primitive */: {
        return false;
      }
      default: {
        assertExhaustive(
          value.kind,
          `Unexpected value kind '${value.kind}'`
        );
      }
    }
  }
  freezeValue(value, reason) {
    __privateGet(this, _values).set(value, {
      kind: "frozen" /* Frozen */,
      reason: /* @__PURE__ */ new Set([reason])
    });
    if (value.kind === "FunctionExpression" && (this.env.config.enablePreserveExistingMemoizationGuarantees || this.env.config.enableTransitivelyFreezeFunctionExpressions)) {
      for (const place of value.loweredFunc.func.context) {
        this.freeze(place, reason);
      }
    }
  }
  mutate(variant, place) {
    if (isRefOrRefValue(place.identifier)) {
      return "mutate-ref";
    }
    const kind = this.kind(place).kind;
    switch (variant) {
      case "MutateConditionally":
      case "MutateTransitiveConditionally": {
        switch (kind) {
          case "mutable" /* Mutable */:
          case "context" /* Context */: {
            return "mutate";
          }
          default: {
            return "none";
          }
        }
      }
      case "Mutate":
      case "MutateTransitive": {
        switch (kind) {
          case "mutable" /* Mutable */:
          case "context" /* Context */: {
            return "mutate";
          }
          case "primitive" /* Primitive */: {
            return "none";
          }
          case "frozen" /* Frozen */: {
            return "mutate-frozen";
          }
          case "global" /* Global */: {
            return "mutate-global";
          }
          case "maybefrozen" /* MaybeFrozen */: {
            return "mutate-frozen";
          }
          default: {
            assertExhaustive(kind, `Unexpected kind ${kind}`);
          }
        }
      }
      default: {
        assertExhaustive(variant, `Unexpected mutation variant ${variant}`);
      }
    }
  }
  /*
   * Combine the contents of @param this and @param other, returning a new
   * instance with the combined changes _if_ there are any changes, or
   * returning null if no changes would occur. Changes include:
   * - new entries in @param other that did not exist in @param this
   * - entries whose values differ in @param this and @param other,
   *    and where joining the values produces a different value than
   *    what was in @param this.
   *
   * Note that values are joined using a lattice operation to ensure
   * termination.
   */
  merge(other) {
    let nextValues = null;
    let nextVariables = null;
    for (const [id, thisValue] of __privateGet(this, _values)) {
      const otherValue = __privateGet(other, _values).get(id);
      if (otherValue !== void 0) {
        const mergedValue = mergeAbstractValues(thisValue, otherValue);
        if (mergedValue !== thisValue) {
          nextValues = nextValues != null ? nextValues : new Map(__privateGet(this, _values));
          nextValues.set(id, mergedValue);
        }
      }
    }
    for (const [id, otherValue] of __privateGet(other, _values)) {
      if (__privateGet(this, _values).has(id)) {
        continue;
      }
      nextValues = nextValues != null ? nextValues : new Map(__privateGet(this, _values));
      nextValues.set(id, otherValue);
    }
    for (const [id, thisValues] of __privateGet(this, _variables)) {
      const otherValues = __privateGet(other, _variables).get(id);
      if (otherValues !== void 0) {
        let mergedValues = null;
        for (const otherValue of otherValues) {
          if (!thisValues.has(otherValue)) {
            mergedValues = mergedValues != null ? mergedValues : new Set(thisValues);
            mergedValues.add(otherValue);
          }
        }
        if (mergedValues !== null) {
          nextVariables = nextVariables != null ? nextVariables : new Map(__privateGet(this, _variables));
          nextVariables.set(id, mergedValues);
        }
      }
    }
    for (const [id, otherValues] of __privateGet(other, _variables)) {
      if (__privateGet(this, _variables).has(id)) {
        continue;
      }
      nextVariables = nextVariables != null ? nextVariables : new Map(__privateGet(this, _variables));
      nextVariables.set(id, new Set(otherValues));
    }
    if (nextVariables === null && nextValues === null) {
      return null;
    } else {
      return new _InferenceState(
        this.env,
        __privateGet(this, _isFunctionExpression),
        nextValues != null ? nextValues : new Map(__privateGet(this, _values)),
        nextVariables != null ? nextVariables : new Map(__privateGet(this, _variables))
      );
    }
  }
  /*
   * Returns a copy of this state.
   * TODO: consider using persistent data structures to make
   * clone cheaper.
   */
  clone() {
    return new _InferenceState(
      this.env,
      __privateGet(this, _isFunctionExpression),
      new Map(__privateGet(this, _values)),
      new Map(__privateGet(this, _variables))
    );
  }
  /*
   * For debugging purposes, dumps the state to a plain
   * object so that it can printed as JSON.
   */
  debug() {
    const result = { values: {}, variables: {} };
    const objects = /* @__PURE__ */ new Map();
    function identify(value) {
      let id = objects.get(value);
      if (id == null) {
        id = objects.size;
        objects.set(value, id);
      }
      return id;
    }
    for (const [value, kind] of __privateGet(this, _values)) {
      const id = identify(value);
      result.values[id] = {
        abstract: this.debugAbstractValue(kind),
        value: printInstructionValue(value)
      };
    }
    for (const [variable, values] of __privateGet(this, _variables)) {
      result.variables[`$${variable}`] = [...values].map(identify);
    }
    return result;
  }
  debugAbstractValue(value) {
    return {
      kind: value.kind,
      reason: [...value.reason]
    };
  }
  inferPhi(phi) {
    const values = /* @__PURE__ */ new Set();
    for (const [_, operand] of phi.operands) {
      const operandValues = __privateGet(this, _variables).get(operand.identifier.id);
      if (operandValues === void 0) continue;
      for (const v of operandValues) {
        values.add(v);
      }
    }
    if (values.size > 0) {
      __privateGet(this, _variables).set(phi.place.identifier.id, values);
    }
  }
};
_isFunctionExpression = new WeakMap();
_values = new WeakMap();
_variables = new WeakMap();
var InferenceState = _InferenceState;
function mergeAbstractValues(a, b) {
  const kind = mergeValueKinds(a.kind, b.kind);
  if (kind === a.kind && kind === b.kind && Set_isSuperset(a.reason, b.reason)) {
    return a;
  }
  const reason = new Set(a.reason);
  for (const r of b.reason) {
    reason.add(r);
  }
  return { kind, reason };
}
function conditionallyMutateIterator(place) {
  if (!(isArrayType(place.identifier) || isSetType(place.identifier) || isMapType(place.identifier))) {
    return {
      kind: "MutateTransitiveConditionally",
      value: place
    };
  }
  return null;
}
function computeSignatureForInstruction(context, env, instr) {
  const { lvalue, value } = instr;
  const effects = [];
  switch (value.kind) {
    case "ArrayExpression": {
      effects.push({
        kind: "Create",
        into: lvalue,
        value: "mutable" /* Mutable */,
        reason: "other" /* Other */
      });
      for (const element of value.elements) {
        if (element.kind === "Identifier") {
          effects.push({
            kind: "Capture",
            from: element,
            into: lvalue
          });
        } else if (element.kind === "Spread") {
          const mutateIterator = conditionallyMutateIterator(element.place);
          if (mutateIterator != null) {
            effects.push(mutateIterator);
          }
          effects.push({
            kind: "Capture",
            from: element.place,
            into: lvalue
          });
        } else {
          continue;
        }
      }
      break;
    }
    case "ObjectExpression": {
      effects.push({
        kind: "Create",
        into: lvalue,
        value: "mutable" /* Mutable */,
        reason: "other" /* Other */
      });
      for (const property of value.properties) {
        if (property.kind === "ObjectProperty") {
          effects.push({
            kind: "Capture",
            from: property.place,
            into: lvalue
          });
        } else {
          effects.push({
            kind: "Capture",
            from: property.place,
            into: lvalue
          });
        }
      }
      break;
    }
    case "Await": {
      effects.push({
        kind: "Create",
        into: lvalue,
        value: "mutable" /* Mutable */,
        reason: "other" /* Other */
      });
      effects.push({ kind: "MutateTransitiveConditionally", value: value.value });
      effects.push({
        kind: "Capture",
        from: value.value,
        into: lvalue
      });
      break;
    }
    case "NewExpression":
    case "CallExpression":
    case "MethodCall": {
      let callee;
      let receiver;
      let mutatesCallee;
      if (value.kind === "NewExpression") {
        callee = value.callee;
        receiver = value.callee;
        mutatesCallee = false;
      } else if (value.kind === "CallExpression") {
        callee = value.callee;
        receiver = value.callee;
        mutatesCallee = true;
      } else if (value.kind === "MethodCall") {
        callee = value.property;
        receiver = value.receiver;
        mutatesCallee = false;
      } else {
        assertExhaustive(
          value,
          `Unexpected value kind '${value.kind}'`
        );
      }
      const signature = getFunctionCallSignature(env, callee.identifier.type);
      effects.push({
        kind: "Apply",
        receiver,
        function: callee,
        mutatesFunction: mutatesCallee,
        args: value.args,
        into: lvalue,
        signature,
        loc: value.loc
      });
      break;
    }
    case "PropertyDelete":
    case "ComputedDelete": {
      effects.push({
        kind: "Create",
        into: lvalue,
        value: "primitive" /* Primitive */,
        reason: "other" /* Other */
      });
      effects.push({ kind: "Mutate", value: value.object });
      break;
    }
    case "PropertyLoad":
    case "ComputedLoad": {
      if (isPrimitiveType(lvalue.identifier)) {
        effects.push({
          kind: "Create",
          into: lvalue,
          value: "primitive" /* Primitive */,
          reason: "other" /* Other */
        });
      } else {
        effects.push({
          kind: "CreateFrom",
          from: value.object,
          into: lvalue
        });
      }
      break;
    }
    case "PropertyStore":
    case "ComputedStore": {
      const mutationReason = value.kind === "PropertyStore" && value.property === "current" ? { kind: "AssignCurrentProperty" } : null;
      effects.push({
        kind: "Mutate",
        value: value.object,
        reason: mutationReason
      });
      effects.push({
        kind: "Capture",
        from: value.value,
        into: value.object
      });
      effects.push({
        kind: "Create",
        into: lvalue,
        value: "primitive" /* Primitive */,
        reason: "other" /* Other */
      });
      break;
    }
    case "ObjectMethod":
    case "FunctionExpression": {
      effects.push({
        kind: "CreateFunction",
        into: lvalue,
        function: value,
        captures: value.loweredFunc.func.context.filter(
          (operand) => operand.effect === "capture" /* Capture */
        )
      });
      break;
    }
    case "GetIterator": {
      effects.push({
        kind: "Create",
        into: lvalue,
        value: "mutable" /* Mutable */,
        reason: "other" /* Other */
      });
      if (isArrayType(value.collection.identifier) || isMapType(value.collection.identifier) || isSetType(value.collection.identifier)) {
        effects.push({
          kind: "Capture",
          from: value.collection,
          into: lvalue
        });
      } else {
        effects.push({ kind: "Alias", from: value.collection, into: lvalue });
        effects.push({
          kind: "MutateTransitiveConditionally",
          value: value.collection
        });
      }
      break;
    }
    case "IteratorNext": {
      effects.push({ kind: "MutateConditionally", value: value.iterator });
      effects.push({
        kind: "CreateFrom",
        from: value.collection,
        into: lvalue
      });
      break;
    }
    case "NextPropertyOf": {
      effects.push({
        kind: "Create",
        into: lvalue,
        value: "primitive" /* Primitive */,
        reason: "other" /* Other */
      });
      break;
    }
    case "JsxExpression":
    case "JsxFragment": {
      effects.push({
        kind: "Create",
        into: lvalue,
        value: "frozen" /* Frozen */,
        reason: "jsx-captured" /* JsxCaptured */
      });
      for (const operand of eachInstructionValueOperand(value)) {
        effects.push({
          kind: "Freeze",
          value: operand,
          reason: "jsx-captured" /* JsxCaptured */
        });
        effects.push({
          kind: "Capture",
          from: operand,
          into: lvalue
        });
      }
      if (value.kind === "JsxExpression") {
        if (value.tag.kind === "Identifier") {
          effects.push({
            kind: "Render",
            place: value.tag
          });
        }
        if (value.children != null) {
          for (const child of value.children) {
            effects.push({
              kind: "Render",
              place: child
            });
          }
        }
        for (const prop of value.props) {
          if (prop.kind === "JsxAttribute" && prop.place.identifier.type.kind === "Function" && (isJsxType(prop.place.identifier.type.return) || prop.place.identifier.type.return.kind === "Phi" && prop.place.identifier.type.return.operands.some(
            (operand) => isJsxType(operand)
          ))) {
            effects.push({
              kind: "Render",
              place: prop.place
            });
          }
        }
      }
      break;
    }
    case "DeclareLocal": {
      effects.push({
        kind: "Create",
        into: value.lvalue.place,
        // TODO: what kind here???
        value: "primitive" /* Primitive */,
        reason: "other" /* Other */
      });
      effects.push({
        kind: "Create",
        into: lvalue,
        // TODO: what kind here???
        value: "primitive" /* Primitive */,
        reason: "other" /* Other */
      });
      break;
    }
    case "Destructure": {
      for (const patternItem of eachPatternItem(value.lvalue.pattern)) {
        const place = patternItem.kind === "Identifier" ? patternItem : patternItem.place;
        if (isPrimitiveType(place.identifier)) {
          effects.push({
            kind: "Create",
            into: place,
            value: "primitive" /* Primitive */,
            reason: "other" /* Other */
          });
        } else if (patternItem.kind === "Identifier") {
          effects.push({
            kind: "CreateFrom",
            from: value.value,
            into: place
          });
        } else {
          effects.push({
            kind: "Create",
            into: place,
            reason: "other" /* Other */,
            value: "mutable" /* Mutable */
          });
          effects.push({
            kind: "Capture",
            from: value.value,
            into: place
          });
        }
      }
      effects.push({ kind: "Assign", from: value.value, into: lvalue });
      break;
    }
    case "LoadContext": {
      effects.push({ kind: "CreateFrom", from: value.place, into: lvalue });
      break;
    }
    case "DeclareContext": {
      const kind = value.lvalue.kind;
      if (!context.hoistedContextDeclarations.has(
        value.lvalue.place.identifier.declarationId
      ) || kind === "HoistedConst" /* HoistedConst */ || kind === "HoistedFunction" /* HoistedFunction */ || kind === "HoistedLet" /* HoistedLet */) {
        effects.push({
          kind: "Create",
          into: value.lvalue.place,
          value: "mutable" /* Mutable */,
          reason: "other" /* Other */
        });
      } else {
        effects.push({ kind: "Mutate", value: value.lvalue.place });
      }
      effects.push({
        kind: "Create",
        into: lvalue,
        // The result can't be referenced so this value doesn't matter
        value: "primitive" /* Primitive */,
        reason: "other" /* Other */
      });
      break;
    }
    case "StoreContext": {
      if (value.lvalue.kind === "Reassign" /* Reassign */ || context.hoistedContextDeclarations.has(
        value.lvalue.place.identifier.declarationId
      )) {
        effects.push({ kind: "Mutate", value: value.lvalue.place });
      } else {
        effects.push({
          kind: "Create",
          into: value.lvalue.place,
          value: "mutable" /* Mutable */,
          reason: "other" /* Other */
        });
      }
      effects.push({
        kind: "Capture",
        from: value.value,
        into: value.lvalue.place
      });
      effects.push({ kind: "Assign", from: value.value, into: lvalue });
      break;
    }
    case "LoadLocal": {
      effects.push({ kind: "Assign", from: value.place, into: lvalue });
      break;
    }
    case "StoreLocal": {
      effects.push({
        kind: "Assign",
        from: value.value,
        into: value.lvalue.place
      });
      effects.push({ kind: "Assign", from: value.value, into: lvalue });
      break;
    }
    case "PostfixUpdate":
    case "PrefixUpdate": {
      effects.push({
        kind: "Create",
        into: lvalue,
        value: "primitive" /* Primitive */,
        reason: "other" /* Other */
      });
      effects.push({
        kind: "Create",
        into: value.lvalue,
        value: "primitive" /* Primitive */,
        reason: "other" /* Other */
      });
      break;
    }
    case "StoreGlobal": {
      const variable = `\`${value.name}\``;
      effects.push({
        kind: "MutateGlobal",
        place: value.value,
        error: CompilerDiagnostic.create({
          category: "Globals" /* Globals */,
          severity: "InvalidReact" /* InvalidReact */,
          reason: "Cannot reassign variables declared outside of the component/hook",
          description: `Variable ${variable} is declared outside of the component/hook. Reassigning this value during render is a form of side effect, which can cause unpredictable behavior depending on when the component happens to re-render. If this variable is used in rendering, use useState instead. Otherwise, consider updating it in an effect. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#side-effects-must-run-outside-of-render)`
        }).withDetail({
          kind: "error",
          loc: instr.loc,
          message: `${variable} cannot be reassigned`
        })
      });
      effects.push({ kind: "Assign", from: value.value, into: lvalue });
      break;
    }
    case "TypeCastExpression": {
      effects.push({ kind: "Assign", from: value.value, into: lvalue });
      break;
    }
    case "LoadGlobal": {
      effects.push({
        kind: "Create",
        into: lvalue,
        value: "global" /* Global */,
        reason: "global" /* Global */
      });
      break;
    }
    case "StartMemoize":
    case "FinishMemoize": {
      if (env.config.enablePreserveExistingMemoizationGuarantees) {
        for (const operand of eachInstructionValueOperand(value)) {
          effects.push({
            kind: "Freeze",
            value: operand,
            reason: "other" /* Other */
          });
        }
      }
      effects.push({
        kind: "Create",
        into: lvalue,
        value: "primitive" /* Primitive */,
        reason: "other" /* Other */
      });
      break;
    }
    case "TaggedTemplateExpression":
    case "BinaryExpression":
    case "Debugger":
    case "JSXText":
    case "MetaProperty":
    case "Primitive":
    case "RegExpLiteral":
    case "TemplateLiteral":
    case "UnaryExpression":
    case "UnsupportedNode": {
      effects.push({
        kind: "Create",
        into: lvalue,
        value: "primitive" /* Primitive */,
        reason: "other" /* Other */
      });
      break;
    }
  }
  return {
    effects
  };
}
function computeEffectsForLegacySignature(state, signature, lvalue, receiver, args, loc) {
  var _a, _b;
  const returnValueReason = (_a = signature.returnValueReason) != null ? _a : "other" /* Other */;
  const effects = [];
  effects.push({
    kind: "Create",
    into: lvalue,
    value: signature.returnValueKind,
    reason: returnValueReason
  });
  if (signature.impure && state.env.config.validateNoImpureFunctionsInRender) {
    effects.push({
      kind: "Impure",
      place: receiver,
      error: CompilerDiagnostic.create({
        category: "Purity" /* Purity */,
        severity: "InvalidReact" /* InvalidReact */,
        reason: "Cannot call impure function during render",
        description: (signature.canonicalName != null ? `\`${signature.canonicalName}\` is an impure function. ` : "") + "Calling an impure function can produce unstable results that update unpredictably when the component happens to re-render. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#components-and-hooks-must-be-idempotent)"
      }).withDetail({
        kind: "error",
        loc,
        message: "Cannot call impure function"
      })
    });
  }
  const stores = [];
  const captures = [];
  function visit4(place, effect) {
    switch (effect) {
      case "store" /* Store */: {
        effects.push({
          kind: "Mutate",
          value: place
        });
        stores.push(place);
        break;
      }
      case "capture" /* Capture */: {
        captures.push(place);
        break;
      }
      case "mutate?" /* ConditionallyMutate */: {
        effects.push({
          kind: "MutateTransitiveConditionally",
          value: place
        });
        break;
      }
      case "mutate-iterator?" /* ConditionallyMutateIterator */: {
        const mutateIterator = conditionallyMutateIterator(place);
        if (mutateIterator != null) {
          effects.push(mutateIterator);
        }
        effects.push({
          kind: "Capture",
          from: place,
          into: lvalue
        });
        break;
      }
      case "freeze" /* Freeze */: {
        effects.push({
          kind: "Freeze",
          value: place,
          reason: returnValueReason
        });
        break;
      }
      case "mutate" /* Mutate */: {
        effects.push({ kind: "MutateTransitive", value: place });
        break;
      }
      case "read" /* Read */: {
        effects.push({
          kind: "ImmutableCapture",
          from: place,
          into: lvalue
        });
        break;
      }
    }
  }
  if (signature.mutableOnlyIfOperandsAreMutable && areArgumentsImmutableAndNonMutating(state, args)) {
    effects.push({
      kind: "Alias",
      from: receiver,
      into: lvalue
    });
    for (const arg of args) {
      if (arg.kind === "Hole") {
        continue;
      }
      const place = arg.kind === "Identifier" ? arg : arg.place;
      effects.push({
        kind: "ImmutableCapture",
        from: place,
        into: lvalue
      });
    }
    return effects;
  }
  if (signature.calleeEffect !== "capture" /* Capture */) {
    effects.push({
      kind: "Alias",
      from: receiver,
      into: lvalue
    });
  }
  visit4(receiver, signature.calleeEffect);
  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    if (arg.kind === "Hole") {
      continue;
    }
    const place = arg.kind === "Identifier" ? arg : arg.place;
    const signatureEffect = arg.kind === "Identifier" && i < signature.positionalParams.length ? signature.positionalParams[i] : (_b = signature.restParam) != null ? _b : "mutate?" /* ConditionallyMutate */;
    const effect = getArgumentEffect(signatureEffect, arg);
    visit4(place, effect);
  }
  if (captures.length !== 0) {
    if (stores.length === 0) {
      for (const capture of captures) {
        effects.push({ kind: "Alias", from: capture, into: lvalue });
      }
    } else {
      for (const capture of captures) {
        for (const store of stores) {
          effects.push({ kind: "Capture", from: capture, into: store });
        }
      }
    }
  }
  return effects;
}
function areArgumentsImmutableAndNonMutating(state, args) {
  for (const arg of args) {
    if (arg.kind === "Hole") {
      continue;
    }
    if (arg.kind === "Identifier" && arg.identifier.type.kind === "Function") {
      const fnShape = state.env.getFunctionSignature(arg.identifier.type);
      if (fnShape != null) {
        return !fnShape.positionalParams.some(isKnownMutableEffect) && (fnShape.restParam == null || !isKnownMutableEffect(fnShape.restParam));
      }
    }
    const place = arg.kind === "Identifier" ? arg : arg.place;
    const kind = state.kind(place).kind;
    switch (kind) {
      case "primitive" /* Primitive */:
      case "frozen" /* Frozen */: {
        break;
      }
      default: {
        return false;
      }
    }
    const values = state.values(place);
    for (const value of values) {
      if (value.kind === "FunctionExpression" && value.loweredFunc.func.params.some((param) => {
        const place2 = param.kind === "Identifier" ? param : param.place;
        const range = place2.identifier.mutableRange;
        return range.end > range.start + 1;
      })) {
        return false;
      }
    }
  }
  return true;
}
function computeEffectsForSignature(env, signature, lvalue, receiver, args, context = [], loc) {
  var _a, _b, _c, _d, _e, _f, _g;
  if (
    // Not enough args
    signature.params.length > args.length || // Too many args and there is no rest param to hold them
    args.length > signature.params.length && signature.rest == null
  ) {
    return null;
  }
  const mutableSpreads = /* @__PURE__ */ new Set();
  const substitutions = /* @__PURE__ */ new Map();
  substitutions.set(signature.receiver, [receiver]);
  substitutions.set(signature.returns, [lvalue]);
  const params = signature.params;
  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    if (arg.kind === "Hole") {
      continue;
    } else if (params == null || i >= params.length || arg.kind === "Spread") {
      if (signature.rest == null) {
        return null;
      }
      const place = arg.kind === "Identifier" ? arg : arg.place;
      getOrInsertWith(substitutions, signature.rest, () => []).push(place);
      if (arg.kind === "Spread") {
        const mutateIterator = conditionallyMutateIterator(arg.place);
        if (mutateIterator != null) {
          mutableSpreads.add(arg.place.identifier.id);
        }
      }
    } else {
      const param = params[i];
      substitutions.set(param, [arg]);
    }
  }
  for (const operand of context) {
    substitutions.set(operand.identifier.id, [operand]);
  }
  const effects = [];
  for (const signatureTemporary of signature.temporaries) {
    const temp = createTemporaryPlace(env, receiver.loc);
    substitutions.set(signatureTemporary.identifier.id, [temp]);
  }
  for (const effect of signature.effects) {
    switch (effect.kind) {
      case "MaybeAlias":
      case "Assign":
      case "ImmutableCapture":
      case "Alias":
      case "CreateFrom":
      case "Capture": {
        const from = (_a = substitutions.get(effect.from.identifier.id)) != null ? _a : [];
        const to = (_b = substitutions.get(effect.into.identifier.id)) != null ? _b : [];
        for (const fromId of from) {
          for (const toId of to) {
            effects.push({
              kind: effect.kind,
              from: fromId,
              into: toId
            });
          }
        }
        break;
      }
      case "Impure":
      case "MutateFrozen":
      case "MutateGlobal": {
        const values = (_c = substitutions.get(effect.place.identifier.id)) != null ? _c : [];
        for (const value of values) {
          effects.push({ kind: effect.kind, place: value, error: effect.error });
        }
        break;
      }
      case "Render": {
        const values = (_d = substitutions.get(effect.place.identifier.id)) != null ? _d : [];
        for (const value of values) {
          effects.push({ kind: effect.kind, place: value });
        }
        break;
      }
      case "Mutate":
      case "MutateTransitive":
      case "MutateTransitiveConditionally":
      case "MutateConditionally": {
        const values = (_e = substitutions.get(effect.value.identifier.id)) != null ? _e : [];
        for (const id of values) {
          effects.push({ kind: effect.kind, value: id });
        }
        break;
      }
      case "Freeze": {
        const values = (_f = substitutions.get(effect.value.identifier.id)) != null ? _f : [];
        for (const value of values) {
          if (mutableSpreads.has(value.identifier.id)) {
            CompilerError.throwTodo({
              reason: "Support spread syntax for hook arguments",
              loc: value.loc
            });
          }
          effects.push({ kind: "Freeze", value, reason: effect.reason });
        }
        break;
      }
      case "Create": {
        const into = (_g = substitutions.get(effect.into.identifier.id)) != null ? _g : [];
        for (const value of into) {
          effects.push({
            kind: "Create",
            into: value,
            value: effect.value,
            reason: effect.reason
          });
        }
        break;
      }
      case "Apply": {
        const applyReceiver = substitutions.get(effect.receiver.identifier.id);
        if (applyReceiver == null || applyReceiver.length !== 1) {
          return null;
        }
        const applyFunction = substitutions.get(effect.function.identifier.id);
        if (applyFunction == null || applyFunction.length !== 1) {
          return null;
        }
        const applyInto = substitutions.get(effect.into.identifier.id);
        if (applyInto == null || applyInto.length !== 1) {
          return null;
        }
        const applyArgs = [];
        for (const arg of effect.args) {
          if (arg.kind === "Hole") {
            applyArgs.push(arg);
          } else if (arg.kind === "Identifier") {
            const applyArg = substitutions.get(arg.identifier.id);
            if (applyArg == null || applyArg.length !== 1) {
              return null;
            }
            applyArgs.push(applyArg[0]);
          } else {
            const applyArg = substitutions.get(arg.place.identifier.id);
            if (applyArg == null || applyArg.length !== 1) {
              return null;
            }
            applyArgs.push({ kind: "Spread", place: applyArg[0] });
          }
        }
        effects.push({
          kind: "Apply",
          mutatesFunction: effect.mutatesFunction,
          receiver: applyReceiver[0],
          args: applyArgs,
          function: applyFunction[0],
          into: applyInto[0],
          signature: effect.signature,
          loc
        });
        break;
      }
      case "CreateFunction": {
        CompilerError.throwTodo({
          reason: `Support CreateFrom effects in signatures`,
          loc: receiver.loc
        });
      }
      default: {
        assertExhaustive(
          effect,
          `Unexpected effect kind '${effect.kind}'`
        );
      }
    }
  }
  return effects;
}
function buildSignatureFromFunctionExpression(env, fn) {
  var _a;
  let rest = null;
  const params = [];
  for (const param of fn.loweredFunc.func.params) {
    if (param.kind === "Identifier") {
      params.push(param.identifier.id);
    } else {
      rest = param.place.identifier.id;
    }
  }
  return {
    receiver: makeIdentifierId(0),
    params,
    rest: rest != null ? rest : createTemporaryPlace(env, fn.loc).identifier.id,
    returns: fn.loweredFunc.func.returns.identifier.id,
    effects: (_a = fn.loweredFunc.func.aliasingEffects) != null ? _a : [],
    temporaries: []
  };
}
function getWriteErrorReason(abstractValue) {
  if (abstractValue.reason.has("global" /* Global */)) {
    return "Modifying a variable defined outside a component or hook is not allowed. Consider using an effect";
  } else if (abstractValue.reason.has("jsx-captured" /* JsxCaptured */)) {
    return "Modifying a value used previously in JSX is not allowed. Consider moving the modification before the JSX";
  } else if (abstractValue.reason.has("context" /* Context */)) {
    return `Modifying a value returned from 'useContext()' is not allowed.`;
  } else if (abstractValue.reason.has("known-return-signature" /* KnownReturnSignature */)) {
    return "Modifying a value returned from a function whose return value should not be mutated";
  } else if (abstractValue.reason.has("reactive-function-argument" /* ReactiveFunctionArgument */)) {
    return "Modifying component props or hook arguments is not allowed. Consider using a local variable instead";
  } else if (abstractValue.reason.has("state" /* State */)) {
    return "Modifying a value returned from 'useState()', which should not be modified directly. Use the setter function to update instead";
  } else if (abstractValue.reason.has("reducer-state" /* ReducerState */)) {
    return "Modifying a value returned from 'useReducer()', which should not be modified directly. Use the dispatch function to update instead";
  } else if (abstractValue.reason.has("effect" /* Effect */)) {
    return "Modifying a value used previously in an effect function or as an effect dependency is not allowed. Consider moving the modification before calling useEffect()";
  } else if (abstractValue.reason.has("hook-captured" /* HookCaptured */)) {
    return "Modifying a value previously passed as an argument to a hook is not allowed. Consider moving the modification before calling the hook";
  } else if (abstractValue.reason.has("hook-return" /* HookReturn */)) {
    return "Modifying a value returned from a hook is not allowed. Consider moving the modification into the hook where the value is constructed";
  } else {
    return "This modifies a variable that React considers immutable";
  }
}
function getArgumentEffect(signatureEffect, arg) {
  if (signatureEffect != null) {
    if (arg.kind === "Identifier") {
      return signatureEffect;
    } else if (signatureEffect === "mutate" /* Mutate */ || signatureEffect === "mutate?" /* ConditionallyMutate */) {
      return signatureEffect;
    } else {
      if (signatureEffect === "freeze" /* Freeze */) {
        CompilerError.throwTodo({
          reason: "Support spread syntax for hook arguments",
          loc: arg.place.loc
        });
      }
      return "mutate-iterator?" /* ConditionallyMutateIterator */;
    }
  } else {
    return "mutate?" /* ConditionallyMutate */;
  }
}
function getFunctionCallSignature(env, type) {
  if (type.kind !== "Function") {
    return null;
  }
  return env.getFunctionSignature(type);
}
function isKnownMutableEffect(effect) {
  switch (effect) {
    case "store" /* Store */:
    case "mutate?" /* ConditionallyMutate */:
    case "mutate-iterator?" /* ConditionallyMutateIterator */:
    case "mutate" /* Mutate */: {
      return true;
    }
    case "<unknown>" /* Unknown */: {
      CompilerError.invariant(false, {
        reason: "Unexpected unknown effect",
        description: null,
        loc: GeneratedSource,
        suggestions: null
      });
    }
    case "read" /* Read */:
    case "capture" /* Capture */:
    case "freeze" /* Freeze */: {
      return false;
    }
    default: {
      assertExhaustive(effect, `Unexpected effect \`${effect}\``);
    }
  }
}
function mergeValueKinds(a, b) {
  if (a === b) {
    return a;
  } else if (a === "maybefrozen" /* MaybeFrozen */ || b === "maybefrozen" /* MaybeFrozen */) {
    return "maybefrozen" /* MaybeFrozen */;
  } else if (a === "mutable" /* Mutable */ || b === "mutable" /* Mutable */) {
    if (a === "frozen" /* Frozen */ || b === "frozen" /* Frozen */) {
      return "maybefrozen" /* MaybeFrozen */;
    } else if (a === "context" /* Context */ || b === "context" /* Context */) {
      return "context" /* Context */;
    } else {
      return "mutable" /* Mutable */;
    }
  } else if (a === "context" /* Context */ || b === "context" /* Context */) {
    if (a === "frozen" /* Frozen */ || b === "frozen" /* Frozen */) {
      return "maybefrozen" /* MaybeFrozen */;
    } else {
      return "context" /* Context */;
    }
  } else if (a === "frozen" /* Frozen */ || b === "frozen" /* Frozen */) {
    return "frozen" /* Frozen */;
  } else if (a === "global" /* Global */ || b === "global" /* Global */) {
    return "global" /* Global */;
  } else {
    CompilerError.invariant(
      a === "primitive" /* Primitive */ && b == "primitive" /* Primitive */,
      {
        reason: `Unexpected value kind in mergeValues()`,
        description: `Found kinds ${a} and ${b}`,
        loc: GeneratedSource
      }
    );
    return "primitive" /* Primitive */;
  }
}

// src/ReactiveScopes/PruneNonEscapingScopes.ts
function pruneNonEscapingScopes(fn) {
  const state = new State3(fn.env);
  for (const param of fn.params) {
    if (param.kind === "Identifier") {
      state.declare(param.identifier.declarationId);
    } else {
      state.declare(param.place.identifier.declarationId);
    }
  }
  visitReactiveFunction(fn, new CollectDependenciesVisitor(fn.env, state), []);
  const memoized = computeMemoizedIdentifiers(state);
  visitReactiveFunction(fn, new PruneScopesTransform(), memoized);
}
function joinAliases(kind1, kind2) {
  if (kind1 === "Memoized" /* Memoized */ || kind2 === "Memoized" /* Memoized */) {
    return "Memoized" /* Memoized */;
  } else if (kind1 === "Conditional" /* Conditional */ || kind2 === "Conditional" /* Conditional */) {
    return "Conditional" /* Conditional */;
  } else if (kind1 === "Unmemoized" /* Unmemoized */ || kind2 === "Unmemoized" /* Unmemoized */) {
    return "Unmemoized" /* Unmemoized */;
  } else {
    return "Never" /* Never */;
  }
}
var State3 = class {
  constructor(env) {
    /*
     * Maps lvalues for LoadLocal to the identifier being loaded, to resolve indirections
     * in subsequent lvalues/rvalues.
     *
     * NOTE: this pass uses DeclarationId rather than IdentifierId because the pass is not
     * aware of control-flow, only data flow via mutation. Instead of precisely modeling
     * control flow, we analyze all values that may flow into a particular program variable,
     * and then whether that program variable may escape (if so, the values flowing in may
     * escape too). Thus we use DeclarationId to captures all values that may flow into
     * a particular program variable, regardless of control flow paths.
     *
     * In the future when we convert to HIR everywhere this pass can account for control
     * flow and use SSA ids.
     */
    this.definitions = /* @__PURE__ */ new Map();
    this.identifiers = /* @__PURE__ */ new Map();
    this.scopes = /* @__PURE__ */ new Map();
    this.escapingValues = /* @__PURE__ */ new Set();
    this.env = env;
  }
  // Declare a new identifier, used for function id and params
  declare(id) {
    this.identifiers.set(id, {
      level: "Never" /* Never */,
      memoized: false,
      dependencies: /* @__PURE__ */ new Set(),
      scopes: /* @__PURE__ */ new Set(),
      seen: false
    });
  }
  /*
   * Associates the identifier with its scope, if there is one and it is active for the given instruction id:
   * - Records the scope and its dependencies
   * - Associates the identifier with this scope
   */
  visitOperand(id, place, identifier4) {
    const scope = getPlaceScope(id, place);
    if (scope !== null) {
      let node = this.scopes.get(scope.id);
      if (node === void 0) {
        node = {
          dependencies: [...scope.dependencies].map(
            (dep) => dep.identifier.declarationId
          ),
          seen: false
        };
        this.scopes.set(scope.id, node);
      }
      const identifierNode = this.identifiers.get(identifier4);
      CompilerError.invariant(identifierNode !== void 0, {
        reason: "Expected identifier to be initialized",
        description: `[${id}] operand=${printPlace(place)} for identifier declaration ${identifier4}`,
        loc: place.loc,
        suggestions: null
      });
      identifierNode.scopes.add(scope.id);
    }
  }
};
function computeMemoizedIdentifiers(state) {
  const memoized = /* @__PURE__ */ new Set();
  function visit4(id, forceMemoize = false) {
    const node = state.identifiers.get(id);
    CompilerError.invariant(node !== void 0, {
      reason: `Expected a node for all identifiers, none found for \`${id}\``,
      description: null,
      loc: null,
      suggestions: null
    });
    if (node.seen) {
      return node.memoized;
    }
    node.seen = true;
    node.memoized = false;
    let hasMemoizedDependency = false;
    for (const dep of node.dependencies) {
      const isDepMemoized = visit4(dep);
      hasMemoizedDependency || (hasMemoizedDependency = isDepMemoized);
    }
    if (node.level === "Memoized" /* Memoized */ || node.level === "Conditional" /* Conditional */ && (hasMemoizedDependency || forceMemoize) || node.level === "Unmemoized" /* Unmemoized */ && forceMemoize) {
      node.memoized = true;
      memoized.add(id);
      for (const scope of node.scopes) {
        forceMemoizeScopeDependencies(scope);
      }
    }
    return node.memoized;
  }
  function forceMemoizeScopeDependencies(id) {
    const node = state.scopes.get(id);
    CompilerError.invariant(node !== void 0, {
      reason: "Expected a node for all scopes",
      description: null,
      loc: null,
      suggestions: null
    });
    if (node.seen) {
      return;
    }
    node.seen = true;
    for (const dep of node.dependencies) {
      visit4(dep, true);
    }
    return;
  }
  for (const value of state.escapingValues) {
    visit4(value);
  }
  return memoized;
}
function computePatternLValues(pattern) {
  const lvalues = [];
  switch (pattern.kind) {
    case "ArrayPattern": {
      for (const item of pattern.items) {
        if (item.kind === "Identifier") {
          lvalues.push({ place: item, level: "Conditional" /* Conditional */ });
        } else if (item.kind === "Spread") {
          lvalues.push({ place: item.place, level: "Memoized" /* Memoized */ });
        }
      }
      break;
    }
    case "ObjectPattern": {
      for (const property of pattern.properties) {
        if (property.kind === "ObjectProperty") {
          lvalues.push({
            place: property.place,
            level: "Conditional" /* Conditional */
          });
        } else {
          lvalues.push({
            place: property.place,
            level: "Memoized" /* Memoized */
          });
        }
      }
      break;
    }
    default: {
      assertExhaustive(
        pattern,
        `Unexpected pattern kind \`${pattern.kind}\``
      );
    }
  }
  return lvalues;
}
var CollectDependenciesVisitor = class extends ReactiveFunctionVisitor {
  constructor(env, state) {
    super();
    this.env = env;
    this.state = state;
    this.options = {
      memoizeJsxElements: !this.env.config.enableForest,
      forceMemoizePrimitives: this.env.config.enableForest
    };
  }
  /*
   * Given a value, returns a description of how it should be memoized:
   * - lvalues: optional extra places that are lvalue-like in the sense of
   *   aliasing the rvalues
   * - rvalues: places that are aliased by the instruction's lvalues.
   * - level: the level of memoization to apply to this value
   */
  computeMemoizationInputs(value, lvalue) {
    const env = this.env;
    const options = this.options;
    switch (value.kind) {
      case "ConditionalExpression": {
        return {
          // Only need to memoize if the rvalues are memoized
          lvalues: lvalue !== null ? [{ place: lvalue, level: "Conditional" /* Conditional */ }] : [],
          rvalues: [
            // Conditionals do not alias their test value.
            ...this.computeMemoizationInputs(value.consequent, null).rvalues,
            ...this.computeMemoizationInputs(value.alternate, null).rvalues
          ]
        };
      }
      case "LogicalExpression": {
        return {
          // Only need to memoize if the rvalues are memoized
          lvalues: lvalue !== null ? [{ place: lvalue, level: "Conditional" /* Conditional */ }] : [],
          rvalues: [
            ...this.computeMemoizationInputs(value.left, null).rvalues,
            ...this.computeMemoizationInputs(value.right, null).rvalues
          ]
        };
      }
      case "SequenceExpression": {
        for (const instr of value.instructions) {
          this.visitValueForMemoization(instr.id, instr.value, instr.lvalue);
        }
        return {
          // Only need to memoize if the rvalues are memoized
          lvalues: lvalue !== null ? [{ place: lvalue, level: "Conditional" /* Conditional */ }] : [],
          /*
           * Only the final value of the sequence is a true rvalue:
           * values from the sequence's instructions are evaluated
           * as separate nodes
           */
          rvalues: this.computeMemoizationInputs(value.value, null).rvalues
        };
      }
      case "JsxExpression": {
        const operands = [];
        if (value.tag.kind === "Identifier") {
          operands.push(value.tag);
        }
        for (const prop of value.props) {
          if (prop.kind === "JsxAttribute") {
            operands.push(prop.place);
          } else {
            operands.push(prop.argument);
          }
        }
        if (value.children !== null) {
          for (const child of value.children) {
            operands.push(child);
          }
        }
        const level = options.memoizeJsxElements ? "Memoized" /* Memoized */ : "Unmemoized" /* Unmemoized */;
        return {
          /*
           * JSX elements themselves are not memoized unless forced to
           * avoid breaking downstream memoization
           */
          lvalues: lvalue !== null ? [{ place: lvalue, level }] : [],
          rvalues: operands
        };
      }
      case "JsxFragment": {
        const level = options.memoizeJsxElements ? "Memoized" /* Memoized */ : "Unmemoized" /* Unmemoized */;
        return {
          /*
           * JSX elements themselves are not memoized unless forced to
           * avoid breaking downstream memoization
           */
          lvalues: lvalue !== null ? [{ place: lvalue, level }] : [],
          rvalues: value.children
        };
      }
      case "NextPropertyOf":
      case "StartMemoize":
      case "FinishMemoize":
      case "Debugger":
      case "ComputedDelete":
      case "PropertyDelete":
      case "LoadGlobal":
      case "MetaProperty":
      case "TemplateLiteral":
      case "Primitive":
      case "JSXText":
      case "BinaryExpression":
      case "UnaryExpression": {
        const level = options.forceMemoizePrimitives ? "Memoized" /* Memoized */ : "Never" /* Never */;
        return {
          // All of these instructions return a primitive value and never need to be memoized
          lvalues: lvalue !== null ? [{ place: lvalue, level }] : [],
          rvalues: []
        };
      }
      case "Await":
      case "TypeCastExpression": {
        return {
          // Indirection for the inner value, memoized if the value is
          lvalues: lvalue !== null ? [{ place: lvalue, level: "Conditional" /* Conditional */ }] : [],
          rvalues: [value.value]
        };
      }
      case "IteratorNext": {
        return {
          // Indirection for the inner value, memoized if the value is
          lvalues: lvalue !== null ? [{ place: lvalue, level: "Conditional" /* Conditional */ }] : [],
          rvalues: [value.iterator, value.collection]
        };
      }
      case "GetIterator": {
        return {
          // Indirection for the inner value, memoized if the value is
          lvalues: lvalue !== null ? [{ place: lvalue, level: "Conditional" /* Conditional */ }] : [],
          rvalues: [value.collection]
        };
      }
      case "LoadLocal": {
        return {
          // Indirection for the inner value, memoized if the value is
          lvalues: lvalue !== null ? [{ place: lvalue, level: "Conditional" /* Conditional */ }] : [],
          rvalues: [value.place]
        };
      }
      case "LoadContext": {
        return {
          // Should never be pruned
          lvalues: lvalue !== null ? [{ place: lvalue, level: "Conditional" /* Conditional */ }] : [],
          rvalues: [value.place]
        };
      }
      case "DeclareContext": {
        const lvalues = [
          { place: value.lvalue.place, level: "Memoized" /* Memoized */ }
        ];
        if (lvalue !== null) {
          lvalues.push({ place: lvalue, level: "Unmemoized" /* Unmemoized */ });
        }
        return {
          lvalues,
          rvalues: []
        };
      }
      case "DeclareLocal": {
        const lvalues = [
          { place: value.lvalue.place, level: "Unmemoized" /* Unmemoized */ }
        ];
        if (lvalue !== null) {
          lvalues.push({ place: lvalue, level: "Unmemoized" /* Unmemoized */ });
        }
        return {
          lvalues,
          rvalues: []
        };
      }
      case "PrefixUpdate":
      case "PostfixUpdate": {
        const lvalues = [
          { place: value.lvalue, level: "Conditional" /* Conditional */ }
        ];
        if (lvalue !== null) {
          lvalues.push({ place: lvalue, level: "Conditional" /* Conditional */ });
        }
        return {
          // Indirection for the inner value, memoized if the value is
          lvalues,
          rvalues: [value.value]
        };
      }
      case "StoreLocal": {
        const lvalues = [
          { place: value.lvalue.place, level: "Conditional" /* Conditional */ }
        ];
        if (lvalue !== null) {
          lvalues.push({ place: lvalue, level: "Conditional" /* Conditional */ });
        }
        return {
          // Indirection for the inner value, memoized if the value is
          lvalues,
          rvalues: [value.value]
        };
      }
      case "StoreContext": {
        const lvalues = [
          { place: value.lvalue.place, level: "Memoized" /* Memoized */ }
        ];
        if (lvalue !== null) {
          lvalues.push({ place: lvalue, level: "Conditional" /* Conditional */ });
        }
        return {
          lvalues,
          rvalues: [value.value]
        };
      }
      case "StoreGlobal": {
        const lvalues = [];
        if (lvalue !== null) {
          lvalues.push({ place: lvalue, level: "Unmemoized" /* Unmemoized */ });
        }
        return {
          lvalues,
          rvalues: [value.value]
        };
      }
      case "Destructure": {
        const lvalues = [];
        if (lvalue !== null) {
          lvalues.push({ place: lvalue, level: "Conditional" /* Conditional */ });
        }
        lvalues.push(...computePatternLValues(value.lvalue.pattern));
        return {
          lvalues,
          rvalues: [value.value]
        };
      }
      case "ComputedLoad":
      case "PropertyLoad": {
        const level = options.forceMemoizePrimitives ? "Memoized" /* Memoized */ : "Conditional" /* Conditional */;
        return {
          // Indirection for the inner value, memoized if the value is
          lvalues: lvalue !== null ? [{ place: lvalue, level }] : [],
          /*
           * Only the object is aliased to the result, and the result only needs to be
           * memoized if the object is
           */
          rvalues: [value.object]
        };
      }
      case "ComputedStore": {
        const lvalues = [
          { place: value.object, level: "Conditional" /* Conditional */ }
        ];
        if (lvalue !== null) {
          lvalues.push({ place: lvalue, level: "Conditional" /* Conditional */ });
        }
        return {
          lvalues,
          rvalues: [value.value]
        };
      }
      case "OptionalExpression": {
        const lvalues = [];
        if (lvalue !== null) {
          lvalues.push({ place: lvalue, level: "Conditional" /* Conditional */ });
        }
        return {
          lvalues,
          rvalues: [
            ...this.computeMemoizationInputs(value.value, null).rvalues
          ]
        };
      }
      case "TaggedTemplateExpression": {
        const signature = getFunctionCallSignature(
          env,
          value.tag.identifier.type
        );
        let lvalues = [];
        if (lvalue !== null) {
          lvalues.push({ place: lvalue, level: "Memoized" /* Memoized */ });
        }
        if ((signature == null ? void 0 : signature.noAlias) === true) {
          return {
            lvalues,
            rvalues: []
          };
        }
        const operands = [...eachReactiveValueOperand(value)];
        lvalues.push(
          ...operands.filter((operand) => isMutableEffect(operand.effect, operand.loc)).map((place) => ({ place, level: "Memoized" /* Memoized */ }))
        );
        return {
          lvalues,
          rvalues: operands
        };
      }
      case "CallExpression": {
        const signature = getFunctionCallSignature(
          env,
          value.callee.identifier.type
        );
        let lvalues = [];
        if (lvalue !== null) {
          lvalues.push({ place: lvalue, level: "Memoized" /* Memoized */ });
        }
        if ((signature == null ? void 0 : signature.noAlias) === true) {
          return {
            lvalues,
            rvalues: []
          };
        }
        const operands = [...eachReactiveValueOperand(value)];
        lvalues.push(
          ...operands.filter((operand) => isMutableEffect(operand.effect, operand.loc)).map((place) => ({ place, level: "Memoized" /* Memoized */ }))
        );
        return {
          lvalues,
          rvalues: operands
        };
      }
      case "MethodCall": {
        const signature = getFunctionCallSignature(
          env,
          value.property.identifier.type
        );
        let lvalues = [];
        if (lvalue !== null) {
          lvalues.push({ place: lvalue, level: "Memoized" /* Memoized */ });
        }
        if ((signature == null ? void 0 : signature.noAlias) === true) {
          return {
            lvalues,
            rvalues: []
          };
        }
        const operands = [...eachReactiveValueOperand(value)];
        lvalues.push(
          ...operands.filter((operand) => isMutableEffect(operand.effect, operand.loc)).map((place) => ({ place, level: "Memoized" /* Memoized */ }))
        );
        return {
          lvalues,
          rvalues: operands
        };
      }
      case "RegExpLiteral":
      case "ObjectMethod":
      case "FunctionExpression":
      case "ArrayExpression":
      case "NewExpression":
      case "ObjectExpression":
      case "PropertyStore": {
        const operands = [...eachReactiveValueOperand(value)];
        const lvalues = operands.filter((operand) => isMutableEffect(operand.effect, operand.loc)).map((place) => ({ place, level: "Memoized" /* Memoized */ }));
        if (lvalue !== null) {
          lvalues.push({ place: lvalue, level: "Memoized" /* Memoized */ });
        }
        return {
          lvalues,
          rvalues: operands
        };
      }
      case "UnsupportedNode": {
        const lvalues = [];
        if (lvalue !== null) {
          lvalues.push({ place: lvalue, level: "Never" /* Never */ });
        }
        return {
          lvalues,
          rvalues: []
        };
      }
      default: {
        assertExhaustive(
          value,
          `Unexpected value kind \`${value.kind}\``
        );
      }
    }
  }
  visitValueForMemoization(id, value, lvalue) {
    var _a, _b, _c;
    const state = this.state;
    const aliasing = this.computeMemoizationInputs(value, lvalue);
    for (const operand of aliasing.rvalues) {
      const operandId = (_a = state.definitions.get(operand.identifier.declarationId)) != null ? _a : operand.identifier.declarationId;
      state.visitOperand(id, operand, operandId);
    }
    for (const { place: lvalue2, level } of aliasing.lvalues) {
      const lvalueId = (_b = state.definitions.get(lvalue2.identifier.declarationId)) != null ? _b : lvalue2.identifier.declarationId;
      let node = state.identifiers.get(lvalueId);
      if (node === void 0) {
        node = {
          level: "Never" /* Never */,
          memoized: false,
          dependencies: /* @__PURE__ */ new Set(),
          scopes: /* @__PURE__ */ new Set(),
          seen: false
        };
        state.identifiers.set(lvalueId, node);
      }
      node.level = joinAliases(node.level, level);
      for (const operand of aliasing.rvalues) {
        const operandId = (_c = state.definitions.get(operand.identifier.declarationId)) != null ? _c : operand.identifier.declarationId;
        if (operandId === lvalueId) {
          continue;
        }
        node.dependencies.add(operandId);
      }
      state.visitOperand(id, lvalue2, lvalueId);
    }
    if (value.kind === "LoadLocal" && lvalue !== null) {
      state.definitions.set(
        lvalue.identifier.declarationId,
        value.place.identifier.declarationId
      );
    } else if (value.kind === "CallExpression" || value.kind === "MethodCall") {
      let callee = value.kind === "CallExpression" ? value.callee : value.property;
      if (getHookKind(state.env, callee.identifier) != null) {
        const signature = getFunctionCallSignature(
          this.env,
          callee.identifier.type
        );
        if (signature && signature.noAlias === true) {
          return;
        }
        for (const operand of value.args) {
          const place = operand.kind === "Spread" ? operand.place : operand;
          state.escapingValues.add(place.identifier.declarationId);
        }
      }
    }
  }
  visitInstruction(instruction, _scopes3) {
    this.visitValueForMemoization(
      instruction.id,
      instruction.value,
      instruction.lvalue
    );
  }
  visitTerminal(stmt, scopes) {
    this.traverseTerminal(stmt, scopes);
    if (stmt.terminal.kind === "return") {
      this.state.escapingValues.add(
        stmt.terminal.value.identifier.declarationId
      );
      const identifierNode = this.state.identifiers.get(
        stmt.terminal.value.identifier.declarationId
      );
      CompilerError.invariant(identifierNode !== void 0, {
        reason: "Expected identifier to be initialized",
        description: null,
        loc: stmt.terminal.loc,
        suggestions: null
      });
      for (const scope of scopes) {
        identifierNode.scopes.add(scope.id);
      }
    }
  }
  visitScope(scope, scopes) {
    for (const reassignment of scope.scope.reassignments) {
      const identifierNode = this.state.identifiers.get(
        reassignment.declarationId
      );
      CompilerError.invariant(identifierNode !== void 0, {
        reason: "Expected identifier to be initialized",
        description: null,
        loc: reassignment.loc,
        suggestions: null
      });
      for (const scope2 of scopes) {
        identifierNode.scopes.add(scope2.id);
      }
      identifierNode.scopes.add(scope.scope.id);
    }
    this.traverseScope(scope, [...scopes, scope.scope]);
  }
};
var PruneScopesTransform = class extends ReactiveFunctionTransform {
  constructor() {
    super(...arguments);
    this.prunedScopes = /* @__PURE__ */ new Set();
    /**
     * Track reassignments so we can correctly set `pruned` flags for
     * inlined useMemos.
     */
    this.reassignments = /* @__PURE__ */ new Map();
  }
  transformScope(scopeBlock, state) {
    this.visitScope(scopeBlock, state);
    if (scopeBlock.scope.declarations.size === 0 && scopeBlock.scope.reassignments.size === 0 || scopeBlock.scope.earlyReturnValue !== null) {
      return { kind: "keep" };
    }
    const hasMemoizedOutput = Array.from(scopeBlock.scope.declarations.values()).some(
      (decl) => state.has(decl.identifier.declarationId)
    ) || Array.from(scopeBlock.scope.reassignments).some(
      (identifier4) => state.has(identifier4.declarationId)
    );
    if (hasMemoizedOutput) {
      return { kind: "keep" };
    } else {
      this.prunedScopes.add(scopeBlock.scope.id);
      return {
        kind: "replace-many",
        value: scopeBlock.instructions
      };
    }
  }
  /**
   * If we pruned the scope for a non-escaping value, we know it doesn't
   * need to be memoized. Remove associated `Memoize` instructions so that
   * we don't report false positives on "missing" memoization of these values.
   */
  transformInstruction(instruction, state) {
    var _a;
    this.traverseInstruction(instruction, state);
    const value = instruction.value;
    if (value.kind === "StoreLocal" && value.lvalue.kind === "Reassign") {
      const ids = getOrInsertDefault(
        this.reassignments,
        value.lvalue.place.identifier.declarationId,
        /* @__PURE__ */ new Set()
      );
      ids.add(value.value.identifier);
    } else if (value.kind === "LoadLocal" && value.place.identifier.scope != null && instruction.lvalue != null && instruction.lvalue.identifier.scope == null) {
      const ids = getOrInsertDefault(
        this.reassignments,
        instruction.lvalue.identifier.declarationId,
        /* @__PURE__ */ new Set()
      );
      ids.add(value.place.identifier);
    } else if (value.kind === "FinishMemoize") {
      let decls;
      if (value.decl.identifier.scope == null) {
        decls = (_a = this.reassignments.get(value.decl.identifier.declarationId)) != null ? _a : [
          value.decl.identifier
        ];
      } else {
        decls = [value.decl.identifier];
      }
      if ([...decls].every(
        (decl) => decl.scope == null || this.prunedScopes.has(decl.scope.id)
      )) {
        value.pruned = true;
      }
    }
    return { kind: "keep" };
  }
};

// src/ReactiveScopes/CollectReactiveIdentifiers.ts
var Visitor4 = class extends ReactiveFunctionVisitor {
  /*
   * Visitors don't visit lvalues as places by default, but we want to visit all places to
   * check for reactivity
   */
  visitLValue(id, lvalue, state) {
    this.visitPlace(id, lvalue, state);
  }
  /*
   * This visitor only infers data dependencies and does not account for control dependencies
   * where a variable may be assigned a different value based on some conditional, eg via two
   * different paths of an if statement.
   */
  visitPlace(_id, place, state) {
    if (place.reactive) {
      state.add(place.identifier.id);
    }
  }
  visitPrunedScope(scopeBlock, state) {
    this.traversePrunedScope(scopeBlock, state);
    for (const [id, decl] of scopeBlock.scope.declarations) {
      if (!isPrimitiveType(decl.identifier) && !isStableRefType(decl.identifier, state)) {
        state.add(id);
      }
    }
  }
};
function isStableRefType(identifier4, reactiveIdentifiers) {
  return isUseRefType(identifier4) && !reactiveIdentifiers.has(identifier4.id);
}
function collectReactiveIdentifiers(fn) {
  const visitor = new Visitor4();
  const state = /* @__PURE__ */ new Set();
  visitReactiveFunction(fn, visitor, state);
  return state;
}

// src/ReactiveScopes/PruneNonReactiveDependencies.ts
function pruneNonReactiveDependencies(fn) {
  const reactiveIdentifiers = collectReactiveIdentifiers(fn);
  visitReactiveFunction(fn, new Visitor5(), reactiveIdentifiers);
}
var Visitor5 = class extends ReactiveFunctionVisitor {
  visitInstruction(instruction, state) {
    this.traverseInstruction(instruction, state);
    const { lvalue, value } = instruction;
    switch (value.kind) {
      case "LoadLocal": {
        if (lvalue !== null && state.has(value.place.identifier.id)) {
          state.add(lvalue.identifier.id);
        }
        break;
      }
      case "StoreLocal": {
        if (state.has(value.value.identifier.id)) {
          state.add(value.lvalue.place.identifier.id);
          if (lvalue !== null) {
            state.add(lvalue.identifier.id);
          }
        }
        break;
      }
      case "Destructure": {
        if (state.has(value.value.identifier.id)) {
          for (const lvalue2 of eachPatternOperand(value.lvalue.pattern)) {
            if (isStableType(lvalue2.identifier)) {
              continue;
            }
            state.add(lvalue2.identifier.id);
          }
          if (lvalue !== null) {
            state.add(lvalue.identifier.id);
          }
        }
        break;
      }
      case "PropertyLoad": {
        if (lvalue !== null && state.has(value.object.identifier.id) && !isStableType(lvalue.identifier)) {
          state.add(lvalue.identifier.id);
        }
        break;
      }
      case "ComputedLoad": {
        if (lvalue !== null && (state.has(value.object.identifier.id) || state.has(value.property.identifier.id))) {
          state.add(lvalue.identifier.id);
        }
        break;
      }
    }
  }
  visitScope(scopeBlock, state) {
    this.traverseScope(scopeBlock, state);
    for (const dep of scopeBlock.scope.dependencies) {
      const isReactive = state.has(dep.identifier.id);
      if (!isReactive) {
        scopeBlock.scope.dependencies.delete(dep);
      }
    }
    if (scopeBlock.scope.dependencies.size !== 0) {
      for (const [, declaration] of scopeBlock.scope.declarations) {
        state.add(declaration.identifier.id);
      }
      for (const reassignment of scopeBlock.scope.reassignments) {
        state.add(reassignment.id);
      }
    }
  }
};

// src/ReactiveScopes/PruneTemporaryLValues.ts
function pruneUnusedLValues(fn) {
  const lvalues = /* @__PURE__ */ new Map();
  visitReactiveFunction(fn, new Visitor6(), lvalues);
  for (const [, instr] of lvalues) {
    instr.lvalue = null;
  }
}
var Visitor6 = class extends ReactiveFunctionVisitor {
  visitPlace(id, place, state) {
    state.delete(place.identifier.declarationId);
  }
  visitInstruction(instruction, state) {
    this.traverseInstruction(instruction, state);
    if (instruction.lvalue !== null && instruction.lvalue.identifier.name === null) {
      state.set(instruction.lvalue.identifier.declarationId, instruction);
    }
  }
};

// src/ReactiveScopes/PruneUnusedLabels.ts
function pruneUnusedLabels(fn) {
  const labels = /* @__PURE__ */ new Set();
  visitReactiveFunction(fn, new Transform3(), labels);
}
var Transform3 = class extends ReactiveFunctionTransform {
  transformTerminal(stmt, state) {
    this.traverseTerminal(stmt, state);
    const { terminal } = stmt;
    if ((terminal.kind === "break" || terminal.kind === "continue") && terminal.targetKind === "labeled") {
      state.add(terminal.target);
    }
    const isReachableLabel = stmt.label !== null && state.has(stmt.label.id);
    if (stmt.terminal.kind === "label" && !isReachableLabel) {
      const block = [...stmt.terminal.block];
      const last = block.at(-1);
      if (last !== void 0 && last.kind === "terminal" && last.terminal.kind === "break" && last.terminal.target === null) {
        block.pop();
      }
      return { kind: "replace-many", value: block };
    } else {
      if (!isReachableLabel && stmt.label != null) {
        stmt.label.implicit = true;
      }
      return { kind: "keep" };
    }
  }
};

// src/ReactiveScopes/PruneUnusedScopes.ts
function pruneUnusedScopes(fn) {
  visitReactiveFunction(fn, new Transform4(), {
    hasReturnStatement: false
  });
}
var Transform4 = class extends ReactiveFunctionTransform {
  visitTerminal(stmt, state) {
    this.traverseTerminal(stmt, state);
    if (stmt.terminal.kind === "return") {
      state.hasReturnStatement = true;
    }
  }
  transformScope(scopeBlock, _state) {
    const scopeState = { hasReturnStatement: false };
    this.visitScope(scopeBlock, scopeState);
    if (!scopeState.hasReturnStatement && scopeBlock.scope.reassignments.size === 0 && (scopeBlock.scope.declarations.size === 0 || /*
     * Can prune scopes where all declarations bubbled up from inner
     * scopes
     */
    !hasOwnDeclaration(scopeBlock))) {
      return {
        kind: "replace",
        value: {
          kind: "pruned-scope",
          scope: scopeBlock.scope,
          instructions: scopeBlock.instructions
        }
      };
    } else {
      return { kind: "keep" };
    }
  }
};
function hasOwnDeclaration(block) {
  for (const declaration of block.scope.declarations.values()) {
    if (declaration.scope.id === block.scope.id) {
      return true;
    }
  }
  return false;
}

// src/ReactiveScopes/CollectReferencedGlobals.ts
function collectReferencedGlobals(fn) {
  const identifiers = /* @__PURE__ */ new Set();
  visitReactiveFunction(fn, new Visitor7(), identifiers);
  return identifiers;
}
var Visitor7 = class extends ReactiveFunctionVisitor {
  visitValue(id, value, state) {
    this.traverseValue(id, value, state);
    if (value.kind === "FunctionExpression" || value.kind === "ObjectMethod") {
      this.visitHirFunction(value.loweredFunc.func, state);
    } else if (value.kind === "LoadGlobal") {
      state.add(value.binding.name);
    }
  }
  visitReactiveFunctionValue(_id, _dependencies2, fn, state) {
    visitReactiveFunction(fn, this, state);
  }
};

// src/ReactiveScopes/RenameVariables.ts
function renameVariables(fn) {
  const globals = collectReferencedGlobals(fn);
  const scopes = new Scopes(globals, fn.env.programContext);
  renameVariablesImpl(fn, new Visitor8(), scopes);
  return /* @__PURE__ */ new Set([...scopes.names, ...globals]);
}
function renameVariablesImpl(fn, visitor, scopes) {
  scopes.enter(() => {
    for (const param of fn.params) {
      if (param.kind === "Identifier") {
        scopes.visit(param.identifier);
      } else {
        scopes.visit(param.place.identifier);
      }
    }
    visitReactiveFunction(fn, visitor, scopes);
  });
}
var Visitor8 = class extends ReactiveFunctionVisitor {
  visitParam(place, state) {
    state.visit(place.identifier);
  }
  visitLValue(_id, lvalue, state) {
    state.visit(lvalue.identifier);
  }
  visitPlace(id, place, state) {
    state.visit(place.identifier);
  }
  visitBlock(block, state) {
    state.enter(() => {
      this.traverseBlock(block, state);
    });
  }
  visitPrunedScope(scopeBlock, state) {
    this.traverseBlock(scopeBlock.instructions, state);
  }
  visitScope(scope, state) {
    for (const [_, declaration] of scope.scope.declarations) {
      state.visit(declaration.identifier);
    }
    this.traverseScope(scope, state);
  }
  visitValue(id, value, state) {
    this.traverseValue(id, value, state);
    if (value.kind === "FunctionExpression" || value.kind === "ObjectMethod") {
      this.visitHirFunction(value.loweredFunc.func, state);
    }
  }
  visitReactiveFunctionValue(_id, _dependencies2, _fn, _state) {
    renameVariablesImpl(_fn, this, _state);
  }
};
var _seen, _stack, _globals3, _programContext, _Scopes_instances, lookup_fn;
var Scopes = class {
  constructor(globals, programContext) {
    __privateAdd(this, _Scopes_instances);
    __privateAdd(this, _seen, /* @__PURE__ */ new Map());
    __privateAdd(this, _stack, [/* @__PURE__ */ new Map()]);
    __privateAdd(this, _globals3);
    __privateAdd(this, _programContext);
    this.names = /* @__PURE__ */ new Set();
    __privateSet(this, _globals3, globals);
    __privateSet(this, _programContext, programContext);
  }
  visit(identifier4) {
    const originalName = identifier4.name;
    if (originalName === null) {
      return;
    }
    const mappedName = __privateGet(this, _seen).get(identifier4.declarationId);
    if (mappedName !== void 0) {
      identifier4.name = mappedName;
      return;
    }
    let name = originalName.value;
    let id = 0;
    if (isPromotedTemporary(originalName.value)) {
      name = `t${id++}`;
    } else if (isPromotedJsxTemporary(originalName.value)) {
      name = `T${id++}`;
    }
    while (__privateMethod(this, _Scopes_instances, lookup_fn).call(this, name) !== null || __privateGet(this, _globals3).has(name)) {
      if (isPromotedTemporary(originalName.value)) {
        name = `t${id++}`;
      } else if (isPromotedJsxTemporary(originalName.value)) {
        name = `T${id++}`;
      } else {
        name = `${originalName.value}$${id++}`;
      }
    }
    __privateGet(this, _programContext).addNewReference(name);
    const identifierName = makeIdentifierName(name);
    identifier4.name = identifierName;
    __privateGet(this, _seen).set(identifier4.declarationId, identifierName);
    __privateGet(this, _stack).at(-1).set(identifierName.value, identifier4.declarationId);
    this.names.add(identifierName.value);
  }
  enter(fn) {
    const next = /* @__PURE__ */ new Map();
    __privateGet(this, _stack).push(next);
    fn();
    const last = __privateGet(this, _stack).pop();
    CompilerError.invariant(last === next, {
      reason: "Mismatch push/pop calls",
      description: null,
      loc: null,
      suggestions: null
    });
  }
};
_seen = new WeakMap();
_stack = new WeakMap();
_globals3 = new WeakMap();
_programContext = new WeakMap();
_Scopes_instances = new WeakSet();
lookup_fn = function(name) {
  for (let i = __privateGet(this, _stack).length - 1; i >= 0; i--) {
    const scope = __privateGet(this, _stack)[i];
    const entry = scope.get(name);
    if (entry !== void 0) {
      return entry;
    }
  }
  return null;
};

// src/ReactiveScopes/StabilizeBlockIds.ts
function stabilizeBlockIds(fn) {
  const referenced = /* @__PURE__ */ new Set();
  visitReactiveFunction(fn, new CollectReferencedLabels(), referenced);
  const mappings = /* @__PURE__ */ new Map();
  for (const blockId of referenced) {
    mappings.set(blockId, makeBlockId(mappings.size));
  }
  visitReactiveFunction(fn, new RewriteBlockIds(), mappings);
}
var CollectReferencedLabels = class extends ReactiveFunctionVisitor {
  visitScope(scope, state) {
    const { earlyReturnValue } = scope.scope;
    if (earlyReturnValue != null) {
      state.add(earlyReturnValue.label);
    }
    this.traverseScope(scope, state);
  }
  visitTerminal(stmt, state) {
    if (stmt.label != null) {
      if (!stmt.label.implicit) {
        state.add(stmt.label.id);
      }
    }
    this.traverseTerminal(stmt, state);
  }
};
var RewriteBlockIds = class extends ReactiveFunctionVisitor {
  visitScope(scope, state) {
    const { earlyReturnValue } = scope.scope;
    if (earlyReturnValue != null) {
      const rewrittenId = getOrInsertDefault(
        state,
        earlyReturnValue.label,
        state.size
      );
      earlyReturnValue.label = makeBlockId(rewrittenId);
    }
    this.traverseScope(scope, state);
  }
  visitTerminal(stmt, state) {
    if (stmt.label != null) {
      const rewrittenId = getOrInsertDefault(state, stmt.label.id, state.size);
      stmt.label.id = makeBlockId(rewrittenId);
    }
    const terminal = stmt.terminal;
    if (terminal.kind === "break" || terminal.kind === "continue") {
      const rewrittenId = getOrInsertDefault(
        state,
        terminal.target,
        state.size
      );
      terminal.target = makeBlockId(rewrittenId);
    }
    this.traverseTerminal(stmt, state);
  }
};

// src/Inference/InferMutationAliasingRanges.ts
function inferMutationAliasingRanges(fn, { isFunctionExpression }) {
  var _a, _b, _c, _d, _e, _f, _g;
  const functionEffects = [];
  const state = new AliasingState();
  const pendingPhis = /* @__PURE__ */ new Map();
  const mutations = [];
  const renders = [];
  let index = 0;
  const errors = new CompilerError();
  for (const param of [...fn.params, ...fn.context, fn.returns]) {
    const place = param.kind === "Identifier" ? param : param.place;
    state.create(place, { kind: "Object" });
  }
  const seenBlocks = /* @__PURE__ */ new Set();
  for (const block of fn.body.blocks.values()) {
    for (const phi of block.phis) {
      state.create(phi.place, { kind: "Phi" });
      for (const [pred, operand] of phi.operands) {
        if (!seenBlocks.has(pred)) {
          const blockPhis2 = getOrInsertWith(
            pendingPhis,
            pred,
            () => []
          );
          blockPhis2.push({ from: operand, into: phi.place, index: index++ });
        } else {
          state.assign(index++, operand, phi.place);
        }
      }
    }
    seenBlocks.add(block.id);
    for (const instr of block.instructions) {
      if (instr.effects == null) continue;
      for (const effect of instr.effects) {
        if (effect.kind === "Create") {
          state.create(effect.into, { kind: "Object" });
        } else if (effect.kind === "CreateFunction") {
          state.create(effect.into, {
            kind: "Function",
            function: effect.function.loweredFunc.func
          });
        } else if (effect.kind === "CreateFrom") {
          state.createFrom(index++, effect.from, effect.into);
        } else if (effect.kind === "Assign") {
          if (!state.nodes.has(effect.into.identifier)) {
            state.create(effect.into, { kind: "Object" });
          }
          state.assign(index++, effect.from, effect.into);
        } else if (effect.kind === "Alias") {
          state.assign(index++, effect.from, effect.into);
        } else if (effect.kind === "MaybeAlias") {
          state.maybeAlias(index++, effect.from, effect.into);
        } else if (effect.kind === "Capture") {
          state.capture(index++, effect.from, effect.into);
        } else if (effect.kind === "MutateTransitive" || effect.kind === "MutateTransitiveConditionally") {
          mutations.push({
            index: index++,
            id: instr.id,
            transitive: true,
            kind: effect.kind === "MutateTransitive" ? 2 /* Definite */ : 1 /* Conditional */,
            reason: null,
            place: effect.value
          });
        } else if (effect.kind === "Mutate" || effect.kind === "MutateConditionally") {
          mutations.push({
            index: index++,
            id: instr.id,
            transitive: false,
            kind: effect.kind === "Mutate" ? 2 /* Definite */ : 1 /* Conditional */,
            reason: effect.kind === "Mutate" ? (_a = effect.reason) != null ? _a : null : null,
            place: effect.value
          });
        } else if (effect.kind === "MutateFrozen" || effect.kind === "MutateGlobal" || effect.kind === "Impure") {
          errors.pushDiagnostic(effect.error);
          functionEffects.push(effect);
        } else if (effect.kind === "Render") {
          renders.push({ index: index++, place: effect.place });
          functionEffects.push(effect);
        }
      }
    }
    const blockPhis = pendingPhis.get(block.id);
    if (blockPhis != null) {
      for (const { from, into, index: index2 } of blockPhis) {
        state.assign(index2, from, into);
      }
    }
    if (block.terminal.kind === "return") {
      state.assign(index++, block.terminal.value, fn.returns);
    }
    if ((block.terminal.kind === "maybe-throw" || block.terminal.kind === "return") && block.terminal.effects != null) {
      for (const effect of block.terminal.effects) {
        if (effect.kind === "Alias") {
          state.assign(index++, effect.from, effect.into);
        } else {
          CompilerError.invariant(effect.kind === "Freeze", {
            reason: `Unexpected '${effect.kind}' effect for MaybeThrow terminal`,
            loc: block.terminal.loc
          });
        }
      }
    }
  }
  for (const mutation of mutations) {
    state.mutate(
      mutation.index,
      mutation.place.identifier,
      makeInstructionId(mutation.id + 1),
      mutation.transitive,
      mutation.kind,
      mutation.place.loc,
      mutation.reason,
      errors
    );
  }
  for (const render of renders) {
    state.render(render.index, render.place.identifier, errors);
  }
  for (const param of [...fn.context, ...fn.params]) {
    const place = param.kind === "Identifier" ? param : param.place;
    const node = state.nodes.get(place.identifier);
    if (node == null) {
      continue;
    }
    let mutated = false;
    if (node.local != null) {
      if (node.local.kind === 1 /* Conditional */) {
        mutated = true;
        functionEffects.push({
          kind: "MutateConditionally",
          value: __spreadProps(__spreadValues({}, place), { loc: node.local.loc })
        });
      } else if (node.local.kind === 2 /* Definite */) {
        mutated = true;
        functionEffects.push({
          kind: "Mutate",
          value: __spreadProps(__spreadValues({}, place), { loc: node.local.loc }),
          reason: node.mutationReason
        });
      }
    }
    if (node.transitive != null) {
      if (node.transitive.kind === 1 /* Conditional */) {
        mutated = true;
        functionEffects.push({
          kind: "MutateTransitiveConditionally",
          value: __spreadProps(__spreadValues({}, place), { loc: node.transitive.loc })
        });
      } else if (node.transitive.kind === 2 /* Definite */) {
        mutated = true;
        functionEffects.push({
          kind: "MutateTransitive",
          value: __spreadProps(__spreadValues({}, place), { loc: node.transitive.loc })
        });
      }
    }
    if (mutated) {
      place.effect = "capture" /* Capture */;
    }
  }
  for (const block of fn.body.blocks.values()) {
    for (const phi of block.phis) {
      phi.place.effect = "store" /* Store */;
      const isPhiMutatedAfterCreation = phi.place.identifier.mutableRange.end > ((_c = (_b = block.instructions.at(0)) == null ? void 0 : _b.id) != null ? _c : block.terminal.id);
      for (const operand of phi.operands.values()) {
        operand.effect = isPhiMutatedAfterCreation ? "capture" /* Capture */ : "read" /* Read */;
      }
      if (isPhiMutatedAfterCreation && phi.place.identifier.mutableRange.start === 0) {
        const firstInstructionIdOfBlock = (_e = (_d = block.instructions.at(0)) == null ? void 0 : _d.id) != null ? _e : block.terminal.id;
        phi.place.identifier.mutableRange.start = makeInstructionId(
          firstInstructionIdOfBlock - 1
        );
      }
    }
    for (const instr of block.instructions) {
      for (const lvalue of eachInstructionLValue(instr)) {
        lvalue.effect = "mutate?" /* ConditionallyMutate */;
        if (lvalue.identifier.mutableRange.start === 0) {
          lvalue.identifier.mutableRange.start = instr.id;
        }
        if (lvalue.identifier.mutableRange.end === 0) {
          lvalue.identifier.mutableRange.end = makeInstructionId(
            Math.max(instr.id + 1, lvalue.identifier.mutableRange.end)
          );
        }
      }
      for (const operand of eachInstructionValueOperand(instr.value)) {
        operand.effect = "read" /* Read */;
      }
      if (instr.effects == null) {
        continue;
      }
      const operandEffects = /* @__PURE__ */ new Map();
      for (const effect of instr.effects) {
        switch (effect.kind) {
          case "Assign":
          case "Alias":
          case "Capture":
          case "CreateFrom":
          case "MaybeAlias": {
            const isMutatedOrReassigned = effect.into.identifier.mutableRange.end > instr.id;
            if (isMutatedOrReassigned) {
              operandEffects.set(effect.from.identifier.id, "capture" /* Capture */);
              operandEffects.set(effect.into.identifier.id, "store" /* Store */);
            } else {
              operandEffects.set(effect.from.identifier.id, "read" /* Read */);
              operandEffects.set(effect.into.identifier.id, "store" /* Store */);
            }
            break;
          }
          case "CreateFunction":
          case "Create": {
            break;
          }
          case "Mutate": {
            operandEffects.set(effect.value.identifier.id, "store" /* Store */);
            break;
          }
          case "Apply": {
            CompilerError.invariant(false, {
              reason: `[AnalyzeFunctions] Expected Apply effects to be replaced with more precise effects`,
              loc: effect.function.loc
            });
          }
          case "MutateTransitive":
          case "MutateConditionally":
          case "MutateTransitiveConditionally": {
            operandEffects.set(
              effect.value.identifier.id,
              "mutate?" /* ConditionallyMutate */
            );
            break;
          }
          case "Freeze": {
            operandEffects.set(effect.value.identifier.id, "freeze" /* Freeze */);
            break;
          }
          case "ImmutableCapture": {
            break;
          }
          case "Impure":
          case "Render":
          case "MutateFrozen":
          case "MutateGlobal": {
            break;
          }
          default: {
            assertExhaustive(
              effect,
              `Unexpected effect kind ${effect.kind}`
            );
          }
        }
      }
      for (const lvalue of eachInstructionLValue(instr)) {
        const effect = (_f = operandEffects.get(lvalue.identifier.id)) != null ? _f : "mutate?" /* ConditionallyMutate */;
        lvalue.effect = effect;
      }
      for (const operand of eachInstructionValueOperand(instr.value)) {
        if (operand.identifier.mutableRange.end > instr.id && operand.identifier.mutableRange.start === 0) {
          operand.identifier.mutableRange.start = instr.id;
        }
        const effect = (_g = operandEffects.get(operand.identifier.id)) != null ? _g : "read" /* Read */;
        operand.effect = effect;
      }
      if (instr.value.kind === "StoreContext" && instr.value.value.identifier.mutableRange.end <= instr.id) {
        instr.value.value.identifier.mutableRange.end = makeInstructionId(
          instr.id + 1
        );
      }
    }
    if (block.terminal.kind === "return") {
      block.terminal.value.effect = isFunctionExpression ? "read" /* Read */ : "freeze" /* Freeze */;
    } else {
      for (const operand of eachTerminalOperand(block.terminal)) {
        operand.effect = "read" /* Read */;
      }
    }
  }
  const returns = fn.returns.identifier;
  functionEffects.push({
    kind: "Create",
    into: fn.returns,
    value: isPrimitiveType(returns) ? "primitive" /* Primitive */ : isJsxType(returns.type) ? "frozen" /* Frozen */ : "mutable" /* Mutable */,
    reason: "known-return-signature" /* KnownReturnSignature */
  });
  const tracked = [];
  const ignoredErrors = new CompilerError();
  for (const param of [...fn.params, ...fn.context, fn.returns]) {
    const place = param.kind === "Identifier" ? param : param.place;
    tracked.push(place);
  }
  for (const into of tracked) {
    const mutationIndex = index++;
    state.mutate(
      mutationIndex,
      into.identifier,
      null,
      true,
      1 /* Conditional */,
      into.loc,
      null,
      ignoredErrors
    );
    for (const from of tracked) {
      if (from.identifier.id === into.identifier.id || from.identifier.id === fn.returns.identifier.id) {
        continue;
      }
      const fromNode = state.nodes.get(from.identifier);
      CompilerError.invariant(fromNode != null, {
        reason: `Expected a node to exist for all parameters and context variables`,
        loc: into.loc
      });
      if (fromNode.lastMutated === mutationIndex) {
        if (into.identifier.id === fn.returns.identifier.id) {
          functionEffects.push({
            kind: "Alias",
            from,
            into
          });
        } else {
          functionEffects.push({
            kind: "Capture",
            from,
            into
          });
        }
      }
    }
  }
  if (errors.hasErrors() && !isFunctionExpression) {
    return Err(errors);
  }
  return Ok(functionEffects);
}
function appendFunctionErrors(errors, fn) {
  var _a;
  for (const effect of (_a = fn.aliasingEffects) != null ? _a : []) {
    switch (effect.kind) {
      case "Impure":
      case "MutateFrozen":
      case "MutateGlobal": {
        errors.pushDiagnostic(effect.error);
        break;
      }
    }
  }
}
var AliasingState = class {
  constructor() {
    this.nodes = /* @__PURE__ */ new Map();
  }
  create(place, value) {
    this.nodes.set(place.identifier, {
      id: place.identifier,
      createdFrom: /* @__PURE__ */ new Map(),
      captures: /* @__PURE__ */ new Map(),
      aliases: /* @__PURE__ */ new Map(),
      maybeAliases: /* @__PURE__ */ new Map(),
      edges: [],
      transitive: null,
      local: null,
      lastMutated: 0,
      mutationReason: null,
      value
    });
  }
  createFrom(index, from, into) {
    this.create(into, { kind: "Object" });
    const fromNode = this.nodes.get(from.identifier);
    const toNode = this.nodes.get(into.identifier);
    if (fromNode == null || toNode == null) {
      return;
    }
    fromNode.edges.push({ index, node: into.identifier, kind: "alias" });
    if (!toNode.createdFrom.has(from.identifier)) {
      toNode.createdFrom.set(from.identifier, index);
    }
  }
  capture(index, from, into) {
    const fromNode = this.nodes.get(from.identifier);
    const toNode = this.nodes.get(into.identifier);
    if (fromNode == null || toNode == null) {
      return;
    }
    fromNode.edges.push({ index, node: into.identifier, kind: "capture" });
    if (!toNode.captures.has(from.identifier)) {
      toNode.captures.set(from.identifier, index);
    }
  }
  assign(index, from, into) {
    const fromNode = this.nodes.get(from.identifier);
    const toNode = this.nodes.get(into.identifier);
    if (fromNode == null || toNode == null) {
      return;
    }
    fromNode.edges.push({ index, node: into.identifier, kind: "alias" });
    if (!toNode.aliases.has(from.identifier)) {
      toNode.aliases.set(from.identifier, index);
    }
  }
  maybeAlias(index, from, into) {
    const fromNode = this.nodes.get(from.identifier);
    const toNode = this.nodes.get(into.identifier);
    if (fromNode == null || toNode == null) {
      return;
    }
    fromNode.edges.push({ index, node: into.identifier, kind: "maybeAlias" });
    if (!toNode.maybeAliases.has(from.identifier)) {
      toNode.maybeAliases.set(from.identifier, index);
    }
  }
  render(index, start, errors) {
    const seen = /* @__PURE__ */ new Set();
    const queue = [start];
    while (queue.length !== 0) {
      const current = queue.pop();
      if (seen.has(current)) {
        continue;
      }
      seen.add(current);
      const node = this.nodes.get(current);
      if (node == null || node.transitive != null || node.local != null) {
        continue;
      }
      if (node.value.kind === "Function") {
        appendFunctionErrors(errors, node.value.function);
      }
      for (const [alias, when] of node.createdFrom) {
        if (when >= index) {
          continue;
        }
        queue.push(alias);
      }
      for (const [alias, when] of node.aliases) {
        if (when >= index) {
          continue;
        }
        queue.push(alias);
      }
      for (const [capture, when] of node.captures) {
        if (when >= index) {
          continue;
        }
        queue.push(capture);
      }
    }
  }
  mutate(index, start, end, transitive, startKind, loc, reason, errors) {
    var _a;
    const seen = /* @__PURE__ */ new Map();
    const queue = [{ place: start, transitive, direction: "backwards", kind: startKind }];
    while (queue.length !== 0) {
      const { place: current, transitive: transitive2, direction, kind } = queue.pop();
      const previousKind = seen.get(current);
      if (previousKind != null && previousKind >= kind) {
        continue;
      }
      seen.set(current, kind);
      const node = this.nodes.get(current);
      if (node == null) {
        continue;
      }
      (_a = node.mutationReason) != null ? _a : node.mutationReason = reason;
      node.lastMutated = Math.max(node.lastMutated, index);
      if (end != null) {
        node.id.mutableRange.end = makeInstructionId(
          Math.max(node.id.mutableRange.end, end)
        );
      }
      if (node.value.kind === "Function" && node.transitive == null && node.local == null) {
        appendFunctionErrors(errors, node.value.function);
      }
      if (transitive2) {
        if (node.transitive == null || node.transitive.kind < kind) {
          node.transitive = { kind, loc };
        }
      } else {
        if (node.local == null || node.local.kind < kind) {
          node.local = { kind, loc };
        }
      }
      for (const edge of node.edges) {
        if (edge.index >= index) {
          break;
        }
        queue.push({ place: edge.node, transitive: transitive2, direction: "forwards", kind });
      }
      for (const [alias, when] of node.createdFrom) {
        if (when >= index) {
          continue;
        }
        queue.push({
          place: alias,
          transitive: true,
          direction: "backwards",
          kind
        });
      }
      if (direction === "backwards" || node.value.kind !== "Phi") {
        for (const [alias, when] of node.aliases) {
          if (when >= index) {
            continue;
          }
          queue.push({ place: alias, transitive: transitive2, direction: "backwards", kind });
        }
        for (const [alias, when] of node.maybeAliases) {
          if (when >= index) {
            continue;
          }
          queue.push({
            place: alias,
            transitive: transitive2,
            direction: "backwards",
            kind: 1 /* Conditional */
          });
        }
      }
      if (transitive2) {
        for (const [capture, when] of node.captures) {
          if (when >= index) {
            continue;
          }
          queue.push({
            place: capture,
            transitive: transitive2,
            direction: "backwards",
            kind
          });
        }
      }
    }
  }
};

// src/Inference/AnalyseFunctions.ts
function analyseFunctions(func) {
  for (const [_, block] of func.body.blocks) {
    for (const instr of block.instructions) {
      switch (instr.value.kind) {
        case "ObjectMethod":
        case "FunctionExpression": {
          lowerWithMutationAliasing(instr.value.loweredFunc.func);
          for (const operand of instr.value.loweredFunc.func.context) {
            operand.identifier.mutableRange = {
              start: makeInstructionId(0),
              end: makeInstructionId(0)
            };
            operand.identifier.scope = null;
          }
          break;
        }
      }
    }
  }
}
function lowerWithMutationAliasing(fn) {
  var _a, _b;
  analyseFunctions(fn);
  inferMutationAliasingEffects(fn, { isFunctionExpression: true });
  deadCodeElimination(fn);
  const functionEffects = inferMutationAliasingRanges(fn, {
    isFunctionExpression: true
  }).unwrap();
  rewriteInstructionKindsBasedOnReassignment(fn);
  inferReactiveScopeVariables(fn);
  fn.aliasingEffects = functionEffects;
  const capturedOrMutated = /* @__PURE__ */ new Set();
  for (const effect of functionEffects) {
    switch (effect.kind) {
      case "Assign":
      case "Alias":
      case "Capture":
      case "CreateFrom":
      case "MaybeAlias": {
        capturedOrMutated.add(effect.from.identifier.id);
        break;
      }
      case "Apply": {
        CompilerError.invariant(false, {
          reason: `[AnalyzeFunctions] Expected Apply effects to be replaced with more precise effects`,
          loc: effect.function.loc
        });
      }
      case "Mutate":
      case "MutateConditionally":
      case "MutateTransitive":
      case "MutateTransitiveConditionally": {
        capturedOrMutated.add(effect.value.identifier.id);
        break;
      }
      case "Impure":
      case "Render":
      case "MutateFrozen":
      case "MutateGlobal":
      case "CreateFunction":
      case "Create":
      case "Freeze":
      case "ImmutableCapture": {
        break;
      }
      default: {
        assertExhaustive(
          effect,
          `Unexpected effect kind ${effect.kind}`
        );
      }
    }
  }
  for (const operand of fn.context) {
    if (capturedOrMutated.has(operand.identifier.id) || operand.effect === "capture" /* Capture */) {
      operand.effect = "capture" /* Capture */;
    } else {
      operand.effect = "read" /* Read */;
    }
  }
  (_b = (_a = fn.env.logger) == null ? void 0 : _a.debugLogIRs) == null ? void 0 : _b.call(_a, {
    kind: "hir",
    name: "AnalyseFunction (inner)",
    value: fn
  });
}

// src/Inference/DropManualMemoization.ts
function collectMaybeMemoDependencies(value, maybeDeps, optional) {
  var _a;
  switch (value.kind) {
    case "LoadGlobal": {
      return {
        root: {
          kind: "Global",
          identifierName: value.binding.name
        },
        path: []
      };
    }
    case "PropertyLoad": {
      const object = maybeDeps.get(value.object.identifier.id);
      if (object != null) {
        return {
          root: object.root,
          // TODO: determine if the access is optional
          path: [...object.path, { property: value.property, optional }]
        };
      }
      break;
    }
    case "LoadLocal":
    case "LoadContext": {
      const source2 = maybeDeps.get(value.place.identifier.id);
      if (source2 != null) {
        return source2;
      } else if (value.place.identifier.name != null && value.place.identifier.name.kind === "named") {
        return {
          root: {
            kind: "NamedLocal",
            value: __spreadValues({}, value.place)
          },
          path: []
        };
      }
      break;
    }
    case "StoreLocal": {
      const lvalue = value.lvalue.place.identifier;
      const rvalue = value.value.identifier.id;
      const aliased = maybeDeps.get(rvalue);
      if (aliased != null && ((_a = lvalue.name) == null ? void 0 : _a.kind) !== "named") {
        maybeDeps.set(lvalue.id, aliased);
        return aliased;
      }
      break;
    }
  }
  return null;
}
function collectTemporaries(instr, env, sidemap) {
  const { value, lvalue } = instr;
  switch (value.kind) {
    case "FunctionExpression": {
      sidemap.functions.set(
        instr.lvalue.identifier.id,
        instr
      );
      break;
    }
    case "LoadGlobal": {
      const global2 = env.getGlobalDeclaration(value.binding, value.loc);
      const hookKind = global2 !== null ? getHookKindForType(env, global2) : null;
      const lvalId = instr.lvalue.identifier.id;
      if (hookKind === "useMemo" || hookKind === "useCallback") {
        sidemap.manualMemos.set(lvalId, {
          kind: hookKind,
          loadInstr: instr
        });
      } else if (value.binding.name === "React") {
        sidemap.react.add(lvalId);
      }
      break;
    }
    case "PropertyLoad": {
      if (sidemap.react.has(value.object.identifier.id)) {
        const property = value.property;
        if (property === "useMemo" || property === "useCallback") {
          sidemap.manualMemos.set(instr.lvalue.identifier.id, {
            kind: property,
            loadInstr: instr
          });
        }
      }
      break;
    }
    case "ArrayExpression": {
      if (value.elements.every((e) => e.kind === "Identifier")) {
        sidemap.maybeDepsLists.set(
          instr.lvalue.identifier.id,
          value.elements
        );
      }
      break;
    }
  }
  const maybeDep = collectMaybeMemoDependencies(
    value,
    sidemap.maybeDeps,
    sidemap.optionals.has(lvalue.identifier.id)
  );
  if (maybeDep != null) {
    sidemap.maybeDeps.set(lvalue.identifier.id, maybeDep);
  }
}
function makeManualMemoizationMarkers(fnExpr, env, depsList, memoDecl, manualMemoId) {
  return [
    {
      id: makeInstructionId(0),
      lvalue: createTemporaryPlace(env, fnExpr.loc),
      value: {
        kind: "StartMemoize",
        manualMemoId,
        /*
         * Use deps list from source instead of inferred deps
         * as dependencies
         */
        deps: depsList,
        loc: fnExpr.loc
      },
      effects: null,
      loc: fnExpr.loc
    },
    {
      id: makeInstructionId(0),
      lvalue: createTemporaryPlace(env, fnExpr.loc),
      value: {
        kind: "FinishMemoize",
        manualMemoId,
        decl: __spreadValues({}, memoDecl),
        loc: fnExpr.loc
      },
      effects: null,
      loc: fnExpr.loc
    }
  ];
}
function getManualMemoizationReplacement(fn, loc, kind) {
  if (kind === "useMemo") {
    return {
      kind: "CallExpression",
      callee: fn,
      /*
       * Drop the args, including the deps array which DCE will remove
       * later.
       */
      args: [],
      loc
    };
  } else {
    return {
      kind: "LoadLocal",
      place: {
        kind: "Identifier",
        identifier: fn.identifier,
        effect: "<unknown>" /* Unknown */,
        reactive: false,
        loc
      },
      loc
    };
  }
}
function extractManualMemoizationArgs(instr, kind, sidemap, errors) {
  const [fnPlace, depsListPlace] = instr.value.args;
  if (fnPlace == null) {
    errors.pushDiagnostic(
      CompilerDiagnostic.create({
        category: "UseMemo" /* UseMemo */,
        severity: "InvalidReact" /* InvalidReact */,
        reason: `Expected a callback function to be passed to ${kind}`,
        description: `Expected a callback function to be passed to ${kind}`,
        suggestions: null
      }).withDetail({
        kind: "error",
        loc: instr.value.loc,
        message: `Expected a callback function to be passed to ${kind}`
      })
    );
    return { fnPlace: null, depsList: null };
  }
  if (fnPlace.kind === "Spread" || (depsListPlace == null ? void 0 : depsListPlace.kind) === "Spread") {
    errors.pushDiagnostic(
      CompilerDiagnostic.create({
        category: "UseMemo" /* UseMemo */,
        severity: "InvalidReact" /* InvalidReact */,
        reason: `Unexpected spread argument to ${kind}`,
        description: `Unexpected spread argument to ${kind}`,
        suggestions: null
      }).withDetail({
        kind: "error",
        loc: instr.value.loc,
        message: `Unexpected spread argument to ${kind}`
      })
    );
    return { fnPlace: null, depsList: null };
  }
  let depsList = null;
  if (depsListPlace != null) {
    const maybeDepsList = sidemap.maybeDepsLists.get(
      depsListPlace.identifier.id
    );
    if (maybeDepsList == null) {
      errors.pushDiagnostic(
        CompilerDiagnostic.create({
          category: "UseMemo" /* UseMemo */,
          severity: "InvalidReact" /* InvalidReact */,
          reason: `Expected the dependency list for ${kind} to be an array literal`,
          description: `Expected the dependency list for ${kind} to be an array literal`,
          suggestions: null
        }).withDetail({
          kind: "error",
          loc: depsListPlace.loc,
          message: `Expected the dependency list for ${kind} to be an array literal`
        })
      );
      return { fnPlace, depsList: null };
    }
    depsList = [];
    for (const dep of maybeDepsList) {
      const maybeDep = sidemap.maybeDeps.get(dep.identifier.id);
      if (maybeDep == null) {
        errors.pushDiagnostic(
          CompilerDiagnostic.create({
            category: "UseMemo" /* UseMemo */,
            severity: "InvalidReact" /* InvalidReact */,
            reason: `Expected the dependency list to be an array of simple expressions (e.g. \`x\`, \`x.y.z\`, \`x?.y?.z\`)`,
            description: `Expected the dependency list to be an array of simple expressions (e.g. \`x\`, \`x.y.z\`, \`x?.y?.z\`)`,
            suggestions: null
          }).withDetail({
            kind: "error",
            loc: dep.loc,
            message: `Expected the dependency list to be an array of simple expressions (e.g. \`x\`, \`x.y.z\`, \`x?.y?.z\`)`
          })
        );
      } else {
        depsList.push(maybeDep);
      }
    }
  }
  return {
    fnPlace,
    depsList
  };
}
function dropManualMemoization(func) {
  var _a;
  const errors = new CompilerError();
  const isValidationEnabled = func.env.config.validatePreserveExistingMemoizationGuarantees || func.env.config.validateNoSetStateInRender || func.env.config.enablePreserveExistingMemoizationGuarantees;
  const optionals = findOptionalPlaces(func);
  const sidemap = {
    functions: /* @__PURE__ */ new Map(),
    manualMemos: /* @__PURE__ */ new Map(),
    react: /* @__PURE__ */ new Set(),
    maybeDeps: /* @__PURE__ */ new Map(),
    maybeDepsLists: /* @__PURE__ */ new Map(),
    optionals
  };
  let nextManualMemoId = 0;
  const queuedInserts = /* @__PURE__ */ new Map();
  for (const [_, block] of func.body.blocks) {
    for (let i = 0; i < block.instructions.length; i++) {
      const instr = block.instructions[i];
      if (instr.value.kind === "CallExpression" || instr.value.kind === "MethodCall") {
        const id = instr.value.kind === "CallExpression" ? instr.value.callee.identifier.id : instr.value.property.identifier.id;
        const manualMemo = sidemap.manualMemos.get(id);
        if (manualMemo != null) {
          const { fnPlace, depsList } = extractManualMemoizationArgs(
            instr,
            manualMemo.kind,
            sidemap,
            errors
          );
          if (fnPlace == null) {
            continue;
          }
          if (func.env.config.validateNoVoidUseMemo && manualMemo.kind === "useMemo") {
            const funcToCheck = (_a = sidemap.functions.get(
              fnPlace.identifier.id
            )) == null ? void 0 : _a.value;
            if (funcToCheck !== void 0 && funcToCheck.loweredFunc.func) {
              if (!hasNonVoidReturn(funcToCheck.loweredFunc.func)) {
                errors.pushDiagnostic(
                  CompilerDiagnostic.create({
                    severity: "InvalidReact" /* InvalidReact */,
                    category: "UseMemo" /* UseMemo */,
                    reason: "useMemo() callbacks must return a value",
                    description: `This ${manualMemo.loadInstr.value.kind === "PropertyLoad" ? "React.useMemo" : "useMemo"} callback doesn't return a value. useMemo is for computing and caching values, not for arbitrary side effects.`,
                    suggestions: null
                  }).withDetail({
                    kind: "error",
                    loc: instr.value.loc,
                    message: "useMemo() callbacks must return a value"
                  })
                );
              }
            }
          }
          instr.value = getManualMemoizationReplacement(
            fnPlace,
            instr.value.loc,
            manualMemo.kind
          );
          if (isValidationEnabled) {
            if (!sidemap.functions.has(fnPlace.identifier.id)) {
              errors.pushDiagnostic(
                CompilerDiagnostic.create({
                  category: "UseMemo" /* UseMemo */,
                  severity: "InvalidReact" /* InvalidReact */,
                  reason: `Expected the first argument to be an inline function expression`,
                  description: `Expected the first argument to be an inline function expression`,
                  suggestions: []
                }).withDetail({
                  kind: "error",
                  loc: fnPlace.loc,
                  message: `Expected the first argument to be an inline function expression`
                })
              );
              continue;
            }
            const memoDecl = manualMemo.kind === "useMemo" ? instr.lvalue : {
              kind: "Identifier",
              identifier: fnPlace.identifier,
              effect: "<unknown>" /* Unknown */,
              reactive: false,
              loc: fnPlace.loc
            };
            const [startMarker, finishMarker] = makeManualMemoizationMarkers(
              fnPlace,
              func.env,
              depsList,
              memoDecl,
              nextManualMemoId++
            );
            queuedInserts.set(manualMemo.loadInstr.id, startMarker);
            queuedInserts.set(instr.id, finishMarker);
          }
        }
      } else {
        collectTemporaries(instr, func.env, sidemap);
      }
    }
  }
  if (queuedInserts.size > 0) {
    let hasChanges = false;
    for (const [_, block] of func.body.blocks) {
      let nextInstructions = null;
      for (let i = 0; i < block.instructions.length; i++) {
        const instr = block.instructions[i];
        const insertInstr = queuedInserts.get(instr.id);
        if (insertInstr != null) {
          nextInstructions = nextInstructions != null ? nextInstructions : block.instructions.slice(0, i);
          nextInstructions.push(instr);
          nextInstructions.push(insertInstr);
        } else if (nextInstructions != null) {
          nextInstructions.push(instr);
        }
      }
      if (nextInstructions !== null) {
        block.instructions = nextInstructions;
        hasChanges = true;
      }
    }
    if (hasChanges) {
      markInstructionIds(func.body);
    }
  }
  return errors.asResult();
}
function findOptionalPlaces(fn) {
  const optionals = /* @__PURE__ */ new Set();
  for (const [, block] of fn.body.blocks) {
    if (block.terminal.kind === "optional" && block.terminal.optional) {
      const optionalTerminal = block.terminal;
      let testBlock = fn.body.blocks.get(block.terminal.test);
      loop: while (true) {
        const terminal = testBlock.terminal;
        switch (terminal.kind) {
          case "branch": {
            if (terminal.fallthrough === optionalTerminal.fallthrough) {
              const consequent = fn.body.blocks.get(terminal.consequent);
              const last = consequent.instructions.at(-1);
              if (last !== void 0 && last.value.kind === "StoreLocal") {
                optionals.add(last.value.value.identifier.id);
              }
              break loop;
            } else {
              testBlock = fn.body.blocks.get(terminal.fallthrough);
            }
            break;
          }
          case "optional":
          case "logical":
          case "sequence":
          case "ternary": {
            testBlock = fn.body.blocks.get(terminal.fallthrough);
            break;
          }
          default: {
            CompilerError.invariant(false, {
              reason: `Unexpected terminal in optional`,
              loc: terminal.loc
            });
          }
        }
      }
    }
  }
  return optionals;
}
function hasNonVoidReturn(func) {
  for (const [, block] of func.body.blocks) {
    if (block.terminal.kind === "return") {
      if (block.terminal.returnVariant === "Explicit" || block.terminal.returnVariant === "Implicit") {
        return true;
      }
    }
  }
  return false;
}

// src/Inference/InferReactivePlaces.ts
var StableSidemap = class {
  constructor(env) {
    this.map = /* @__PURE__ */ new Map();
    this.env = env;
  }
  handleInstruction(instr) {
    const { value, lvalue } = instr;
    switch (value.kind) {
      case "CallExpression":
      case "MethodCall": {
        if (evaluatesToStableTypeOrContainer(this.env, instr)) {
          if (isStableType(lvalue.identifier)) {
            this.map.set(lvalue.identifier.id, {
              isStable: true
            });
          } else {
            this.map.set(lvalue.identifier.id, {
              isStable: false
            });
          }
        }
        break;
      }
      case "Destructure":
      case "PropertyLoad": {
        const source2 = value.kind === "Destructure" ? value.value.identifier.id : value.object.identifier.id;
        const entry = this.map.get(source2);
        if (entry) {
          for (const lvalue2 of eachInstructionLValue(instr)) {
            if (isStableTypeContainer(lvalue2.identifier)) {
              this.map.set(lvalue2.identifier.id, {
                isStable: false
              });
            } else if (isStableType(lvalue2.identifier)) {
              this.map.set(lvalue2.identifier.id, {
                isStable: true
              });
            }
          }
        }
        break;
      }
      case "StoreLocal": {
        const entry = this.map.get(value.value.identifier.id);
        if (entry) {
          this.map.set(lvalue.identifier.id, entry);
          this.map.set(value.lvalue.place.identifier.id, entry);
        }
        break;
      }
      case "LoadLocal": {
        const entry = this.map.get(value.place.identifier.id);
        if (entry) {
          this.map.set(lvalue.identifier.id, entry);
        }
        break;
      }
    }
  }
  isStable(id) {
    const entry = this.map.get(id);
    return entry != null ? entry.isStable : false;
  }
};
function inferReactivePlaces(fn) {
  const reactiveIdentifiers = new ReactivityMap(findDisjointMutableValues(fn));
  const stableIdentifierSources = new StableSidemap(fn.env);
  for (const param of fn.params) {
    const place = param.kind === "Identifier" ? param : param.place;
    reactiveIdentifiers.markReactive(place);
  }
  const postDominators = computePostDominatorTree(fn, {
    includeThrowsAsExitNode: false
  });
  const postDominatorFrontierCache = /* @__PURE__ */ new Map();
  function isReactiveControlledBlock(id) {
    let controlBlocks = postDominatorFrontierCache.get(id);
    if (controlBlocks === void 0) {
      controlBlocks = postDominatorFrontier(fn, postDominators, id);
      postDominatorFrontierCache.set(id, controlBlocks);
    }
    for (const blockId of controlBlocks) {
      const controlBlock = fn.body.blocks.get(blockId);
      switch (controlBlock.terminal.kind) {
        case "if":
        case "branch": {
          if (reactiveIdentifiers.isReactive(controlBlock.terminal.test)) {
            return true;
          }
          break;
        }
        case "switch": {
          if (reactiveIdentifiers.isReactive(controlBlock.terminal.test)) {
            return true;
          }
          for (const case_ of controlBlock.terminal.cases) {
            if (case_.test !== null && reactiveIdentifiers.isReactive(case_.test)) {
              return true;
            }
          }
          break;
        }
      }
    }
    return false;
  }
  do {
    for (const [, block] of fn.body.blocks) {
      let hasReactiveControl = isReactiveControlledBlock(block.id);
      for (const phi of block.phis) {
        if (reactiveIdentifiers.isReactive(phi.place)) {
          continue;
        }
        let isPhiReactive = false;
        for (const [, operand] of phi.operands) {
          if (reactiveIdentifiers.isReactive(operand)) {
            isPhiReactive = true;
            break;
          }
        }
        if (isPhiReactive) {
          reactiveIdentifiers.markReactive(phi.place);
        } else {
          for (const [pred] of phi.operands) {
            if (isReactiveControlledBlock(pred)) {
              reactiveIdentifiers.markReactive(phi.place);
              break;
            }
          }
        }
      }
      for (const instruction of block.instructions) {
        stableIdentifierSources.handleInstruction(instruction);
        const { value } = instruction;
        let hasReactiveInput = false;
        for (const operand of eachInstructionValueOperand(value)) {
          const reactive = reactiveIdentifiers.isReactive(operand);
          hasReactiveInput || (hasReactiveInput = reactive);
        }
        if (value.kind === "CallExpression" && (getHookKind(fn.env, value.callee.identifier) != null || isUseOperator(value.callee.identifier))) {
          hasReactiveInput = true;
        } else if (value.kind === "MethodCall" && (getHookKind(fn.env, value.property.identifier) != null || isUseOperator(value.property.identifier))) {
          hasReactiveInput = true;
        }
        if (hasReactiveInput) {
          for (const lvalue of eachInstructionLValue(instruction)) {
            if (stableIdentifierSources.isStable(lvalue.identifier.id)) {
              continue;
            }
            reactiveIdentifiers.markReactive(lvalue);
          }
        }
        if (hasReactiveInput || hasReactiveControl) {
          for (const operand of eachInstructionValueOperand(value)) {
            switch (operand.effect) {
              case "capture" /* Capture */:
              case "store" /* Store */:
              case "mutate?" /* ConditionallyMutate */:
              case "mutate-iterator?" /* ConditionallyMutateIterator */:
              case "mutate" /* Mutate */: {
                if (isMutable2(instruction, operand)) {
                  reactiveIdentifiers.markReactive(operand);
                }
                break;
              }
              case "freeze" /* Freeze */:
              case "read" /* Read */: {
                break;
              }
              case "<unknown>" /* Unknown */: {
                CompilerError.invariant(false, {
                  reason: "Unexpected unknown effect",
                  description: null,
                  loc: operand.loc,
                  suggestions: null
                });
              }
              default: {
                assertExhaustive(
                  operand.effect,
                  `Unexpected effect kind \`${operand.effect}\``
                );
              }
            }
          }
        }
      }
      for (const operand of eachTerminalOperand(block.terminal)) {
        reactiveIdentifiers.isReactive(operand);
      }
    }
  } while (reactiveIdentifiers.snapshot());
  function propagateReactivityToInnerFunctions(fn2, isOutermost) {
    for (const [, block] of fn2.body.blocks) {
      for (const instr of block.instructions) {
        if (!isOutermost) {
          for (const operand of eachInstructionOperand(instr)) {
            reactiveIdentifiers.isReactive(operand);
          }
        }
        if (instr.value.kind === "ObjectMethod" || instr.value.kind === "FunctionExpression") {
          propagateReactivityToInnerFunctions(
            instr.value.loweredFunc.func,
            false
          );
        }
      }
      if (!isOutermost) {
        for (const operand of eachTerminalOperand(block.terminal)) {
          reactiveIdentifiers.isReactive(operand);
        }
      }
    }
  }
  propagateReactivityToInnerFunctions(fn, true);
}
function postDominatorFrontier(fn, postDominators, targetId) {
  const visited = /* @__PURE__ */ new Set();
  const frontier = /* @__PURE__ */ new Set();
  const targetPostDominators = postDominatorsOf(fn, postDominators, targetId);
  for (const blockId of [...targetPostDominators, targetId]) {
    if (visited.has(blockId)) {
      continue;
    }
    visited.add(blockId);
    const block = fn.body.blocks.get(blockId);
    for (const pred of block.preds) {
      if (!targetPostDominators.has(pred)) {
        frontier.add(pred);
      }
    }
  }
  return frontier;
}
function postDominatorsOf(fn, postDominators, targetId) {
  var _a;
  const result = /* @__PURE__ */ new Set();
  const visited = /* @__PURE__ */ new Set();
  const queue = [targetId];
  while (queue.length) {
    const currentId = queue.shift();
    if (visited.has(currentId)) {
      continue;
    }
    visited.add(currentId);
    const current = fn.body.blocks.get(currentId);
    for (const pred of current.preds) {
      const predPostDominator = (_a = postDominators.get(pred)) != null ? _a : pred;
      if (predPostDominator === targetId || result.has(predPostDominator)) {
        result.add(pred);
      }
      queue.push(pred);
    }
  }
  return result;
}
var ReactivityMap = class {
  constructor(aliasedIdentifiers) {
    this.hasChanges = false;
    this.reactive = /* @__PURE__ */ new Set();
    this.aliasedIdentifiers = aliasedIdentifiers;
  }
  isReactive(place) {
    var _a;
    const identifier4 = (_a = this.aliasedIdentifiers.find(place.identifier)) != null ? _a : place.identifier;
    const reactive = this.reactive.has(identifier4.id);
    if (reactive) {
      place.reactive = true;
    }
    return reactive;
  }
  markReactive(place) {
    var _a;
    place.reactive = true;
    const identifier4 = (_a = this.aliasedIdentifiers.find(place.identifier)) != null ? _a : place.identifier;
    if (!this.reactive.has(identifier4.id)) {
      this.hasChanges = true;
      this.reactive.add(identifier4.id);
    }
  }
  snapshot() {
    const hasChanges = this.hasChanges;
    this.hasChanges = false;
    return hasChanges;
  }
};

// src/Inference/InlineImmediatelyInvokedFunctionExpressions.ts
function inlineImmediatelyInvokedFunctionExpressions(fn) {
  const functions = /* @__PURE__ */ new Map();
  const inlinedFunctions = /* @__PURE__ */ new Set();
  const queue = Array.from(fn.body.blocks.values());
  queue: for (const block of queue) {
    if (isStatementBlockKind(block.kind)) {
      for (let ii = 0; ii < block.instructions.length; ii++) {
        const instr = block.instructions[ii];
        switch (instr.value.kind) {
          case "FunctionExpression": {
            if (instr.lvalue.identifier.name === null) {
              functions.set(instr.lvalue.identifier.id, instr.value);
            }
            break;
          }
          case "CallExpression": {
            if (instr.value.args.length !== 0) {
              continue;
            }
            const body = functions.get(instr.value.callee.identifier.id);
            if (body === void 0) {
              continue;
            }
            if (body.loweredFunc.func.params.length > 0 || body.loweredFunc.func.async || body.loweredFunc.func.generator) {
              continue;
            }
            inlinedFunctions.add(instr.value.callee.identifier.id);
            const continuationBlockId = fn.env.nextBlockId;
            const continuationBlock = {
              id: continuationBlockId,
              instructions: block.instructions.slice(ii + 1),
              kind: block.kind,
              phis: /* @__PURE__ */ new Set(),
              preds: /* @__PURE__ */ new Set(),
              terminal: block.terminal
            };
            fn.body.blocks.set(continuationBlockId, continuationBlock);
            block.instructions.length = ii;
            if (hasSingleExitReturnTerminal(body.loweredFunc.func)) {
              block.terminal = {
                kind: "goto",
                block: body.loweredFunc.func.body.entry,
                id: block.terminal.id,
                loc: block.terminal.loc,
                variant: "Break" /* Break */
              };
              for (const block2 of body.loweredFunc.func.body.blocks.values()) {
                if (block2.terminal.kind === "return") {
                  block2.instructions.push({
                    id: makeInstructionId(0),
                    loc: block2.terminal.loc,
                    lvalue: instr.lvalue,
                    value: {
                      kind: "LoadLocal",
                      loc: block2.terminal.loc,
                      place: block2.terminal.value
                    },
                    effects: null
                  });
                  block2.terminal = {
                    kind: "goto",
                    block: continuationBlockId,
                    id: block2.terminal.id,
                    loc: block2.terminal.loc,
                    variant: "Break" /* Break */
                  };
                }
              }
              for (const [id, block2] of body.loweredFunc.func.body.blocks) {
                block2.preds.clear();
                fn.body.blocks.set(id, block2);
              }
            } else {
              const newTerminal = {
                block: body.loweredFunc.func.body.entry,
                id: makeInstructionId(0),
                kind: "label",
                fallthrough: continuationBlockId,
                loc: block.terminal.loc
              };
              block.terminal = newTerminal;
              const result = instr.lvalue;
              declareTemporary(fn.env, block, result);
              if (result.identifier.name == null) {
                promoteTemporary(result.identifier);
              }
              for (const [id, block2] of body.loweredFunc.func.body.blocks) {
                block2.preds.clear();
                rewriteBlock(fn.env, block2, continuationBlockId, result);
                fn.body.blocks.set(id, block2);
              }
            }
            queue.push(continuationBlock);
            continue queue;
          }
          default: {
            for (const place of eachInstructionValueOperand(instr.value)) {
              functions.delete(place.identifier.id);
            }
          }
        }
      }
    }
  }
  if (inlinedFunctions.size !== 0) {
    for (const block of fn.body.blocks.values()) {
      retainWhere(
        block.instructions,
        (instr) => !inlinedFunctions.has(instr.lvalue.identifier.id)
      );
    }
    reversePostorderBlocks(fn.body);
    markInstructionIds(fn.body);
    markPredecessors(fn.body);
    mergeConsecutiveBlocks(fn);
  }
}
function hasSingleExitReturnTerminal(fn) {
  let hasReturn = false;
  let exitCount = 0;
  for (const [, block] of fn.body.blocks) {
    if (block.terminal.kind === "return" || block.terminal.kind === "throw") {
      hasReturn || (hasReturn = block.terminal.kind === "return");
      exitCount++;
    }
  }
  return exitCount === 1 && hasReturn;
}
function rewriteBlock(env, block, returnTarget, returnValue) {
  const { terminal } = block;
  if (terminal.kind !== "return") {
    return;
  }
  block.instructions.push({
    id: makeInstructionId(0),
    loc: terminal.loc,
    lvalue: createTemporaryPlace(env, terminal.loc),
    value: {
      kind: "StoreLocal",
      lvalue: { kind: "Reassign" /* Reassign */, place: __spreadValues({}, returnValue) },
      value: terminal.value,
      type: null,
      loc: terminal.loc
    },
    effects: null
  });
  block.terminal = {
    kind: "goto",
    block: returnTarget,
    id: makeInstructionId(0),
    variant: "Break" /* Break */,
    loc: block.terminal.loc
  };
}
function declareTemporary(env, block, result) {
  block.instructions.push({
    id: makeInstructionId(0),
    loc: GeneratedSource,
    lvalue: createTemporaryPlace(env, result.loc),
    value: {
      kind: "DeclareLocal",
      lvalue: {
        place: result,
        kind: "Let" /* Let */
      },
      type: null,
      loc: result.loc
    },
    effects: null
  });
}

// src/HIR/CollectHoistablePropertyLoads.ts
var DEBUG_PRINT = false;
function collectHoistablePropertyLoads(fn, temporaries, hoistableFromOptionals) {
  const registry = new PropertyPathRegistry();
  const knownImmutableIdentifiers = /* @__PURE__ */ new Set();
  if (fn.fnType === "Component" || fn.fnType === "Hook") {
    for (const p of fn.params) {
      if (p.kind === "Identifier") {
        knownImmutableIdentifiers.add(p.identifier.id);
      }
    }
  }
  return collectHoistablePropertyLoadsImpl(fn, {
    temporaries,
    knownImmutableIdentifiers,
    hoistableFromOptionals,
    registry,
    nestedFnImmutableContext: null,
    assumedInvokedFns: fn.env.config.enableTreatFunctionDepsAsConditional ? /* @__PURE__ */ new Set() : getAssumedInvokedFunctions(fn)
  });
}
function collectHoistablePropertyLoadsInInnerFn(fnInstr, temporaries, hoistableFromOptionals) {
  const fn = fnInstr.value.loweredFunc.func;
  const initialContext = {
    temporaries,
    knownImmutableIdentifiers: /* @__PURE__ */ new Set(),
    hoistableFromOptionals,
    registry: new PropertyPathRegistry(),
    nestedFnImmutableContext: null,
    assumedInvokedFns: fn.env.config.enableTreatFunctionDepsAsConditional ? /* @__PURE__ */ new Set() : getAssumedInvokedFunctions(fn)
  };
  const nestedFnImmutableContext = new Set(
    fn.context.filter(
      (place) => isImmutableAtInstr(place.identifier, fnInstr.id, initialContext)
    ).map((place) => place.identifier.id)
  );
  initialContext.nestedFnImmutableContext = nestedFnImmutableContext;
  return collectHoistablePropertyLoadsImpl(fn, initialContext);
}
function collectHoistablePropertyLoadsImpl(fn, context) {
  const nodes = collectNonNullsInBlocks(fn, context);
  propagateNonNull(fn, nodes, context.registry);
  if (DEBUG_PRINT) {
    console.log("(printing hoistable nodes in blocks)");
    for (const [blockId, node] of nodes) {
      console.log(
        `bb${blockId}: ${[...node.assumedNonNullObjects].map((n) => printDependency(n.fullPath)).join(" ")}`
      );
    }
  }
  return nodes;
}
function keyByScopeId(fn, source2) {
  const keyedByScopeId = /* @__PURE__ */ new Map();
  for (const [_, block] of fn.body.blocks) {
    if (block.terminal.kind === "scope") {
      keyedByScopeId.set(
        block.terminal.scope.id,
        source2.get(block.terminal.block)
      );
    }
  }
  return keyedByScopeId;
}
var PropertyPathRegistry = class _PropertyPathRegistry {
  constructor() {
    this.roots = /* @__PURE__ */ new Map();
  }
  getOrCreateIdentifier(identifier4, reactive) {
    let rootNode = this.roots.get(identifier4.id);
    if (rootNode === void 0) {
      rootNode = {
        root: identifier4.id,
        properties: /* @__PURE__ */ new Map(),
        optionalProperties: /* @__PURE__ */ new Map(),
        fullPath: {
          identifier: identifier4,
          reactive,
          path: []
        },
        hasOptional: false,
        parent: null
      };
      this.roots.set(identifier4.id, rootNode);
    } else {
      CompilerError.invariant(reactive === rootNode.fullPath.reactive, {
        reason: "[HoistablePropertyLoads] Found inconsistencies in `reactive` flag when deduping identifier reads within the same scope",
        loc: identifier4.loc
      });
    }
    return rootNode;
  }
  static getOrCreatePropertyEntry(parent, entry) {
    const map = entry.optional ? parent.optionalProperties : parent.properties;
    let child = map.get(entry.property);
    if (child == null) {
      child = {
        properties: /* @__PURE__ */ new Map(),
        optionalProperties: /* @__PURE__ */ new Map(),
        parent,
        fullPath: {
          identifier: parent.fullPath.identifier,
          reactive: parent.fullPath.reactive,
          path: parent.fullPath.path.concat(entry)
        },
        hasOptional: parent.hasOptional || entry.optional
      };
      map.set(entry.property, child);
    }
    return child;
  }
  getOrCreateProperty(n) {
    let currNode = this.getOrCreateIdentifier(n.identifier, n.reactive);
    if (n.path.length === 0) {
      return currNode;
    }
    for (let i = 0; i < n.path.length - 1; i++) {
      currNode = _PropertyPathRegistry.getOrCreatePropertyEntry(
        currNode,
        n.path[i]
      );
    }
    return _PropertyPathRegistry.getOrCreatePropertyEntry(
      currNode,
      n.path.at(-1)
    );
  }
};
function getMaybeNonNullInInstruction(instr, context) {
  var _a, _b, _c;
  let path = null;
  if (instr.kind === "PropertyLoad") {
    path = (_a = context.temporaries.get(instr.object.identifier.id)) != null ? _a : {
      identifier: instr.object.identifier,
      reactive: instr.object.reactive,
      path: []
    };
  } else if (instr.kind === "Destructure") {
    path = (_b = context.temporaries.get(instr.value.identifier.id)) != null ? _b : null;
  } else if (instr.kind === "ComputedLoad") {
    path = (_c = context.temporaries.get(instr.object.identifier.id)) != null ? _c : null;
  }
  return path != null ? context.registry.getOrCreateProperty(path) : null;
}
function isImmutableAtInstr(identifier4, instr, context) {
  if (context.nestedFnImmutableContext != null) {
    return context.nestedFnImmutableContext.has(identifier4.id);
  } else {
    const mutableAtInstr = identifier4.mutableRange.end > identifier4.mutableRange.start + 1 && identifier4.scope != null && inRange(
      {
        id: instr
      },
      identifier4.scope.range
    );
    return !mutableAtInstr || context.knownImmutableIdentifiers.has(identifier4.id);
  }
}
function collectNonNullsInBlocks(fn, context) {
  var _a;
  const knownNonNullIdentifiers = /* @__PURE__ */ new Set();
  if (fn.fnType === "Component" && fn.params.length > 0 && fn.params[0].kind === "Identifier") {
    const identifier4 = fn.params[0].identifier;
    knownNonNullIdentifiers.add(
      context.registry.getOrCreateIdentifier(identifier4, true)
    );
  }
  const nodes = /* @__PURE__ */ new Map();
  for (const [_, block] of fn.body.blocks) {
    const assumedNonNullObjects = new Set(
      knownNonNullIdentifiers
    );
    const maybeOptionalChain = context.hoistableFromOptionals.get(block.id);
    if (maybeOptionalChain != null) {
      assumedNonNullObjects.add(
        context.registry.getOrCreateProperty(maybeOptionalChain)
      );
    }
    for (const instr of block.instructions) {
      const maybeNonNull = getMaybeNonNullInInstruction(instr.value, context);
      if (maybeNonNull != null && isImmutableAtInstr(maybeNonNull.fullPath.identifier, instr.id, context)) {
        assumedNonNullObjects.add(maybeNonNull);
      }
      if (instr.value.kind === "FunctionExpression") {
        const innerFn = instr.value.loweredFunc;
        if (context.assumedInvokedFns.has(innerFn)) {
          const innerHoistableMap = collectHoistablePropertyLoadsImpl(
            innerFn.func,
            __spreadProps(__spreadValues({}, context), {
              nestedFnImmutableContext: (_a = context.nestedFnImmutableContext) != null ? _a : new Set(
                innerFn.func.context.filter(
                  (place) => isImmutableAtInstr(place.identifier, instr.id, context)
                ).map((place) => place.identifier.id)
              )
            })
          );
          const innerHoistables = assertNonNull(
            innerHoistableMap.get(innerFn.func.body.entry)
          );
          for (const entry of innerHoistables.assumedNonNullObjects) {
            assumedNonNullObjects.add(entry);
          }
        }
      }
    }
    nodes.set(block.id, {
      block,
      assumedNonNullObjects
    });
  }
  return nodes;
}
function propagateNonNull(fn, nodes, registry) {
  const blockSuccessors = /* @__PURE__ */ new Map();
  const terminalPreds = /* @__PURE__ */ new Set();
  for (const [blockId, block] of fn.body.blocks) {
    for (const pred of block.preds) {
      getOrInsertDefault(blockSuccessors, pred, /* @__PURE__ */ new Set()).add(blockId);
    }
    if (block.terminal.kind === "throw" || block.terminal.kind === "return") {
      terminalPreds.add(blockId);
    }
  }
  function recursivelyPropagateNonNull(nodeId, direction, traversalState2) {
    var _a;
    if (traversalState2.has(nodeId)) {
      return false;
    }
    traversalState2.set(nodeId, "active");
    const node = nodes.get(nodeId);
    if (node == null) {
      CompilerError.invariant(false, {
        reason: `Bad node ${nodeId}, kind: ${direction}`,
        loc: GeneratedSource
      });
    }
    const neighbors = Array.from(
      direction === "backward" ? (_a = blockSuccessors.get(nodeId)) != null ? _a : [] : node.block.preds
    );
    let changed2 = false;
    for (const pred of neighbors) {
      if (!traversalState2.has(pred)) {
        const neighborChanged = recursivelyPropagateNonNull(
          pred,
          direction,
          traversalState2
        );
        changed2 || (changed2 = neighborChanged);
      }
    }
    const neighborAccesses = Set_intersect(
      Array.from(neighbors).filter((n) => traversalState2.get(n) === "done").map((n) => assertNonNull(nodes.get(n)).assumedNonNullObjects)
    );
    const prevObjects = assertNonNull(nodes.get(nodeId)).assumedNonNullObjects;
    const mergedObjects = Set_union(prevObjects, neighborAccesses);
    reduceMaybeOptionalChains(mergedObjects, registry);
    assertNonNull(nodes.get(nodeId)).assumedNonNullObjects = mergedObjects;
    traversalState2.set(nodeId, "done");
    changed2 || (changed2 = !Set_equal(prevObjects, mergedObjects));
    return changed2;
  }
  const traversalState = /* @__PURE__ */ new Map();
  const reversedBlocks = [...fn.body.blocks];
  reversedBlocks.reverse();
  let changed;
  let i = 0;
  do {
    CompilerError.invariant(i++ < 100, {
      reason: "[CollectHoistablePropertyLoads] fixed point iteration did not terminate after 100 loops",
      loc: GeneratedSource
    });
    changed = false;
    for (const [blockId] of fn.body.blocks) {
      const forwardChanged = recursivelyPropagateNonNull(
        blockId,
        "forward",
        traversalState
      );
      changed || (changed = forwardChanged);
    }
    traversalState.clear();
    for (const [blockId] of reversedBlocks) {
      const backwardChanged = recursivelyPropagateNonNull(
        blockId,
        "backward",
        traversalState
      );
      changed || (changed = backwardChanged);
    }
    traversalState.clear();
  } while (changed);
}
function assertNonNull(value, source2) {
  CompilerError.invariant(value != null, {
    reason: "Unexpected null",
    description: source2 != null ? `(from ${source2})` : null,
    loc: GeneratedSource
  });
  return value;
}
function reduceMaybeOptionalChains(nodes, registry) {
  let optionalChainNodes = Set_filter(nodes, (n) => n.hasOptional);
  if (optionalChainNodes.size === 0) {
    return;
  }
  let changed;
  do {
    changed = false;
    for (const original of optionalChainNodes) {
      let { identifier: identifier4, path: origPath, reactive } = original.fullPath;
      let currNode = registry.getOrCreateIdentifier(
        identifier4,
        reactive
      );
      for (let i = 0; i < origPath.length; i++) {
        const entry = origPath[i];
        const nextEntry = entry.optional && nodes.has(currNode) ? { property: entry.property, optional: false } : entry;
        currNode = PropertyPathRegistry.getOrCreatePropertyEntry(
          currNode,
          nextEntry
        );
      }
      if (currNode !== original) {
        changed = true;
        optionalChainNodes.delete(original);
        optionalChainNodes.add(currNode);
        nodes.delete(original);
        nodes.add(currNode);
      }
    }
  } while (changed);
}
function getAssumedInvokedFunctions(fn, temporaries = /* @__PURE__ */ new Map()) {
  var _a;
  const hoistableFunctions = /* @__PURE__ */ new Set();
  for (const block of fn.body.blocks.values()) {
    for (const { lvalue, value } of block.instructions) {
      if (value.kind === "FunctionExpression") {
        temporaries.set(lvalue.identifier.id, {
          fn: value.loweredFunc,
          mayInvoke: /* @__PURE__ */ new Set()
        });
      } else if (value.kind === "StoreLocal") {
        const lvalue2 = value.lvalue.place.identifier;
        const maybeLoweredFunc = temporaries.get(value.value.identifier.id);
        if (maybeLoweredFunc != null) {
          temporaries.set(lvalue2.id, maybeLoweredFunc);
        }
      } else if (value.kind === "LoadLocal") {
        const maybeLoweredFunc = temporaries.get(value.place.identifier.id);
        if (maybeLoweredFunc != null) {
          temporaries.set(lvalue.identifier.id, maybeLoweredFunc);
        }
      }
    }
  }
  for (const block of fn.body.blocks.values()) {
    for (const { lvalue, value } of block.instructions) {
      if (value.kind === "CallExpression") {
        const callee = value.callee;
        const maybeHook = getHookKind(fn.env, callee.identifier);
        const maybeLoweredFunc = temporaries.get(callee.identifier.id);
        if (maybeLoweredFunc != null) {
          hoistableFunctions.add(maybeLoweredFunc.fn);
        } else if (maybeHook != null) {
          for (const arg of value.args) {
            if (arg.kind === "Identifier") {
              const maybeLoweredFunc2 = temporaries.get(arg.identifier.id);
              if (maybeLoweredFunc2 != null) {
                hoistableFunctions.add(maybeLoweredFunc2.fn);
              }
            }
          }
        }
      } else if (value.kind === "JsxExpression") {
        for (const attr of value.props) {
          if (attr.kind === "JsxSpreadAttribute") {
            continue;
          }
          const maybeLoweredFunc = temporaries.get(attr.place.identifier.id);
          if (maybeLoweredFunc != null) {
            hoistableFunctions.add(maybeLoweredFunc.fn);
          }
        }
        for (const child of (_a = value.children) != null ? _a : []) {
          const maybeLoweredFunc = temporaries.get(child.identifier.id);
          if (maybeLoweredFunc != null) {
            hoistableFunctions.add(maybeLoweredFunc.fn);
          }
        }
      } else if (value.kind === "FunctionExpression") {
        const loweredFunc = value.loweredFunc.func;
        const lambdasCalled = getAssumedInvokedFunctions(
          loweredFunc,
          temporaries
        );
        const maybeLoweredFunc = temporaries.get(lvalue.identifier.id);
        if (maybeLoweredFunc != null) {
          for (const called of lambdasCalled) {
            maybeLoweredFunc.mayInvoke.add(called);
          }
        }
      }
    }
    if (block.terminal.kind === "return") {
      const maybeLoweredFunc = temporaries.get(
        block.terminal.value.identifier.id
      );
      if (maybeLoweredFunc != null) {
        hoistableFunctions.add(maybeLoweredFunc.fn);
      }
    }
  }
  for (const [_, { fn: fn2, mayInvoke }] of temporaries) {
    if (hoistableFunctions.has(fn2)) {
      for (const called of mayInvoke) {
        hoistableFunctions.add(called);
      }
    }
  }
  return hoistableFunctions;
}

// src/HIR/CollectOptionalChainDependencies.ts
function collectOptionalChainSidemap(fn) {
  const context = {
    currFn: fn,
    blocks: fn.body.blocks,
    seenOptionals: /* @__PURE__ */ new Set(),
    processedInstrsInOptional: /* @__PURE__ */ new Set(),
    temporariesReadInOptional: /* @__PURE__ */ new Map(),
    hoistableObjects: /* @__PURE__ */ new Map()
  };
  traverseFunction(fn, context);
  return {
    temporariesReadInOptional: context.temporariesReadInOptional,
    processedInstrsInOptional: context.processedInstrsInOptional,
    hoistableObjects: context.hoistableObjects
  };
}
function traverseFunction(fn, context) {
  for (const [_, block] of fn.body.blocks) {
    for (const instr of block.instructions) {
      if (instr.value.kind === "FunctionExpression" || instr.value.kind === "ObjectMethod") {
        traverseFunction(instr.value.loweredFunc.func, __spreadProps(__spreadValues({}, context), {
          currFn: instr.value.loweredFunc.func,
          blocks: instr.value.loweredFunc.func.body.blocks
        }));
      }
    }
    if (block.terminal.kind === "optional" && !context.seenOptionals.has(block.id)) {
      traverseOptionalBlock(
        block,
        context,
        null
      );
    }
  }
}
function matchOptionalTestBlock(terminal, blocks) {
  const consequentBlock = assertNonNull(blocks.get(terminal.consequent));
  if (consequentBlock.instructions.length === 2 && consequentBlock.instructions[0].value.kind === "PropertyLoad" && consequentBlock.instructions[1].value.kind === "StoreLocal") {
    const propertyLoad = consequentBlock.instructions[0];
    const storeLocal = consequentBlock.instructions[1].value;
    const storeLocalInstr = consequentBlock.instructions[1];
    CompilerError.invariant(
      propertyLoad.value.object.identifier.id === terminal.test.identifier.id,
      {
        reason: "[OptionalChainDeps] Inconsistent optional chaining property load",
        description: `Test=${printIdentifier(terminal.test.identifier)} PropertyLoad base=${printIdentifier(propertyLoad.value.object.identifier)}`,
        loc: propertyLoad.loc
      }
    );
    CompilerError.invariant(
      storeLocal.value.identifier.id === propertyLoad.lvalue.identifier.id,
      {
        reason: "[OptionalChainDeps] Unexpected storeLocal",
        loc: propertyLoad.loc
      }
    );
    if (consequentBlock.terminal.kind !== "goto" || consequentBlock.terminal.variant !== "Break" /* Break */) {
      return null;
    }
    const alternate = assertNonNull(blocks.get(terminal.alternate));
    CompilerError.invariant(
      alternate.instructions.length === 2 && alternate.instructions[0].value.kind === "Primitive" && alternate.instructions[1].value.kind === "StoreLocal",
      {
        reason: "Unexpected alternate structure",
        loc: terminal.loc
      }
    );
    return {
      consequentId: storeLocal.lvalue.place.identifier.id,
      property: propertyLoad.value.property,
      propertyId: propertyLoad.lvalue.identifier.id,
      storeLocalInstr,
      consequentGoto: consequentBlock.terminal.block
    };
  }
  return null;
}
function traverseOptionalBlock(optional, context, outerAlternate) {
  context.seenOptionals.add(optional.id);
  const maybeTest = context.blocks.get(optional.terminal.test);
  let test;
  let baseObject;
  if (maybeTest.terminal.kind === "branch") {
    CompilerError.invariant(optional.terminal.optional, {
      reason: "[OptionalChainDeps] Expect base case to be always optional",
      loc: optional.terminal.loc
    });
    if (maybeTest.instructions.length === 0 || maybeTest.instructions[0].value.kind !== "LoadLocal") {
      return null;
    }
    const path = [];
    for (let i = 1; i < maybeTest.instructions.length; i++) {
      const instrVal = maybeTest.instructions[i].value;
      const prevInstr = maybeTest.instructions[i - 1];
      if (instrVal.kind === "PropertyLoad" && instrVal.object.identifier.id === prevInstr.lvalue.identifier.id) {
        path.push({ property: instrVal.property, optional: false });
      } else {
        return null;
      }
    }
    CompilerError.invariant(
      maybeTest.terminal.test.identifier.id === maybeTest.instructions.at(-1).lvalue.identifier.id,
      {
        reason: "[OptionalChainDeps] Unexpected test expression",
        loc: maybeTest.terminal.loc
      }
    );
    baseObject = {
      identifier: maybeTest.instructions[0].value.place.identifier,
      reactive: maybeTest.instructions[0].value.place.reactive,
      path
    };
    test = maybeTest.terminal;
  } else if (maybeTest.terminal.kind === "optional") {
    const testBlock = context.blocks.get(maybeTest.terminal.fallthrough);
    if (testBlock.terminal.kind !== "branch") {
      CompilerError.throwTodo({
        reason: `Unexpected terminal kind \`${testBlock.terminal.kind}\` for optional fallthrough block`,
        loc: maybeTest.terminal.loc
      });
    }
    const innerOptional = traverseOptionalBlock(
      maybeTest,
      context,
      testBlock.terminal.alternate
    );
    if (innerOptional == null) {
      return null;
    }
    if (testBlock.terminal.test.identifier.id !== innerOptional) {
      return null;
    }
    if (!optional.terminal.optional) {
      context.hoistableObjects.set(
        optional.id,
        assertNonNull(context.temporariesReadInOptional.get(innerOptional))
      );
    }
    baseObject = assertNonNull(
      context.temporariesReadInOptional.get(innerOptional)
    );
    test = testBlock.terminal;
  } else {
    return null;
  }
  if (test.alternate === outerAlternate) {
    CompilerError.invariant(optional.instructions.length === 0, {
      reason: "[OptionalChainDeps] Unexpected instructions an inner optional block. This indicates that the compiler may be incorrectly concatenating two unrelated optional chains",
      loc: optional.terminal.loc
    });
  }
  const matchConsequentResult = matchOptionalTestBlock(test, context.blocks);
  if (!matchConsequentResult) {
    return null;
  }
  CompilerError.invariant(
    matchConsequentResult.consequentGoto === optional.terminal.fallthrough,
    {
      reason: "[OptionalChainDeps] Unexpected optional goto-fallthrough",
      description: `${matchConsequentResult.consequentGoto} != ${optional.terminal.fallthrough}`,
      loc: optional.terminal.loc
    }
  );
  const load = {
    identifier: baseObject.identifier,
    reactive: baseObject.reactive,
    path: [
      ...baseObject.path,
      {
        property: matchConsequentResult.property,
        optional: optional.terminal.optional
      }
    ]
  };
  context.processedInstrsInOptional.add(matchConsequentResult.storeLocalInstr);
  context.processedInstrsInOptional.add(test);
  context.temporariesReadInOptional.set(
    matchConsequentResult.consequentId,
    load
  );
  context.temporariesReadInOptional.set(matchConsequentResult.propertyId, load);
  return matchConsequentResult.consequentId;
}

// src/HIR/DeriveMinimalDependenciesHIR.ts
var _hoistableObjects, _deps, _ReactiveScopeDependencyTreeHIR_static, getOrCreateRoot_fn, debugImpl_fn;
var _ReactiveScopeDependencyTreeHIR = class _ReactiveScopeDependencyTreeHIR {
  /**
   * @param hoistableObjects a set of paths from which we can safely evaluate
   * PropertyLoads. Note that we expect these to not contain duplicates (e.g.
   * both `a?.b` and `a.b`) only because CollectHoistablePropertyLoads merges
   * duplicates when traversing the CFG.
   */
  constructor(hoistableObjects) {
    /**
     * Paths from which we can hoist PropertyLoads. If an `identifier`,
     * `identifier.path`, or `identifier?.path` is in this map, it is safe to
     * evaluate (non-optional) PropertyLoads from.
     */
    __privateAdd(this, _hoistableObjects, /* @__PURE__ */ new Map());
    __privateAdd(this, _deps, /* @__PURE__ */ new Map());
    var _a, _b;
    for (const { path, identifier: identifier4, reactive } of hoistableObjects) {
      let currNode = __privateMethod(_a = _ReactiveScopeDependencyTreeHIR, _ReactiveScopeDependencyTreeHIR_static, getOrCreateRoot_fn).call(_a, identifier4, reactive, __privateGet(this, _hoistableObjects), path.length > 0 && path[0].optional ? "Optional" : "NonNull");
      for (let i = 0; i < path.length; i++) {
        const prevAccessType = (_b = currNode.properties.get(
          path[i].property
        )) == null ? void 0 : _b.accessType;
        const accessType = i + 1 < path.length && path[i + 1].optional ? "Optional" : "NonNull";
        CompilerError.invariant(
          prevAccessType == null || prevAccessType === accessType,
          {
            reason: "Conflicting access types",
            loc: GeneratedSource
          }
        );
        let nextNode = currNode.properties.get(path[i].property);
        if (nextNode == null) {
          nextNode = {
            properties: /* @__PURE__ */ new Map(),
            accessType
          };
          currNode.properties.set(path[i].property, nextNode);
        }
        currNode = nextNode;
      }
    }
  }
  /**
   * Join a dependency with `#hoistableObjects` to record the hoistable
   * dependency. This effectively truncates @param dep to its maximal
   * safe-to-evaluate subpath
   */
  addDependency(dep) {
    var _a;
    const { identifier: identifier4, reactive, path } = dep;
    let depCursor = __privateMethod(_a = _ReactiveScopeDependencyTreeHIR, _ReactiveScopeDependencyTreeHIR_static, getOrCreateRoot_fn).call(_a, identifier4, reactive, __privateGet(this, _deps), "UnconditionalAccess" /* UnconditionalAccess */);
    let hoistableCursor = __privateGet(this, _hoistableObjects).get(identifier4);
    for (const entry of path) {
      let nextHoistableCursor;
      let nextDepCursor;
      if (entry.optional) {
        if (hoistableCursor != null) {
          nextHoistableCursor = hoistableCursor == null ? void 0 : hoistableCursor.properties.get(entry.property);
        }
        let accessType;
        if (hoistableCursor != null && hoistableCursor.accessType === "NonNull") {
          accessType = "UnconditionalAccess" /* UnconditionalAccess */;
        } else {
          accessType = "OptionalAccess" /* OptionalAccess */;
        }
        nextDepCursor = makeOrMergeProperty(
          depCursor,
          entry.property,
          accessType
        );
      } else if (hoistableCursor != null && hoistableCursor.accessType === "NonNull") {
        nextHoistableCursor = hoistableCursor.properties.get(entry.property);
        nextDepCursor = makeOrMergeProperty(
          depCursor,
          entry.property,
          "UnconditionalAccess" /* UnconditionalAccess */
        );
      } else {
        break;
      }
      depCursor = nextDepCursor;
      hoistableCursor = nextHoistableCursor;
    }
    depCursor.accessType = merge(
      depCursor.accessType,
      "OptionalDependency" /* OptionalDependency */
    );
  }
  deriveMinimalDependencies() {
    const results = /* @__PURE__ */ new Set();
    for (const [rootId, rootNode] of __privateGet(this, _deps).entries()) {
      collectMinimalDependenciesInSubtree(
        rootNode,
        rootNode.reactive,
        rootId,
        [],
        results
      );
    }
    return results;
  }
  /*
   * Prints dependency tree to string for debugging.
   * @param includeAccesses
   * @returns string representation of DependencyTree
   */
  printDeps(includeAccesses) {
    let res = [];
    for (const [rootId, rootNode] of __privateGet(this, _deps).entries()) {
      const rootResults = printSubtree(rootNode, includeAccesses).map(
        (result) => `${printIdentifier(rootId)}.${result}`
      );
      res.push(rootResults);
    }
    return res.flat().join("\n");
  }
  static debug(roots) {
    const buf = [`tree() [`];
    for (const [rootId, rootNode] of roots) {
      buf.push(`${printIdentifier(rootId)} (${rootNode.accessType}):`);
      __privateMethod(this, _ReactiveScopeDependencyTreeHIR_static, debugImpl_fn).call(this, buf, rootNode, 1);
    }
    buf.push("]");
    return buf.length > 2 ? buf.join("\n") : buf.join("");
  }
};
_hoistableObjects = new WeakMap();
_deps = new WeakMap();
_ReactiveScopeDependencyTreeHIR_static = new WeakSet();
getOrCreateRoot_fn = function(identifier4, reactive, roots, defaultAccessType) {
  let rootNode = roots.get(identifier4);
  if (rootNode === void 0) {
    rootNode = {
      properties: /* @__PURE__ */ new Map(),
      reactive,
      accessType: defaultAccessType
    };
    roots.set(identifier4, rootNode);
  } else {
    CompilerError.invariant(reactive === rootNode.reactive, {
      reason: "[DeriveMinimalDependenciesHIR] Conflicting reactive root flag",
      description: `Identifier ${printIdentifier(identifier4)}`,
      loc: GeneratedSource
    });
  }
  return rootNode;
};
debugImpl_fn = function(buf, node, depth = 0) {
  for (const [property, childNode] of node.properties) {
    buf.push(`${"  ".repeat(depth)}.${property} (${childNode.accessType}):`);
    __privateMethod(this, _ReactiveScopeDependencyTreeHIR_static, debugImpl_fn).call(this, buf, childNode, depth + 1);
  }
};
__privateAdd(_ReactiveScopeDependencyTreeHIR, _ReactiveScopeDependencyTreeHIR_static);
var ReactiveScopeDependencyTreeHIR = _ReactiveScopeDependencyTreeHIR;
function isOptional(access) {
  return access === "OptionalAccess" /* OptionalAccess */ || access === "OptionalDependency" /* OptionalDependency */;
}
function isDependency(access) {
  return access === "OptionalDependency" /* OptionalDependency */ || access === "UnconditionalDependency" /* UnconditionalDependency */;
}
function merge(access1, access2) {
  const resultIsUnconditional = !(isOptional(access1) && isOptional(access2));
  const resultIsDependency = isDependency(access1) || isDependency(access2);
  if (resultIsUnconditional) {
    if (resultIsDependency) {
      return "UnconditionalDependency" /* UnconditionalDependency */;
    } else {
      return "UnconditionalAccess" /* UnconditionalAccess */;
    }
  } else {
    if (resultIsDependency) {
      return "OptionalDependency" /* OptionalDependency */;
    } else {
      return "OptionalAccess" /* OptionalAccess */;
    }
  }
}
function collectMinimalDependenciesInSubtree(node, reactive, rootIdentifier, path, results) {
  if (isDependency(node.accessType)) {
    results.add({ identifier: rootIdentifier, reactive, path });
  } else {
    for (const [childName, childNode] of node.properties) {
      collectMinimalDependenciesInSubtree(
        childNode,
        reactive,
        rootIdentifier,
        [
          ...path,
          {
            property: childName,
            optional: isOptional(childNode.accessType)
          }
        ],
        results
      );
    }
  }
}
function printSubtree(node, includeAccesses) {
  const results = [];
  for (const [propertyName, propertyNode] of node.properties) {
    if (includeAccesses || isDependency(propertyNode.accessType)) {
      results.push(`${propertyName} (${propertyNode.accessType})`);
    }
    const propertyResults = printSubtree(propertyNode, includeAccesses);
    results.push(...propertyResults.map((result) => `${propertyName}.${result}`));
  }
  return results;
}
function makeOrMergeProperty(node, property, accessType) {
  let child = node.properties.get(property);
  if (child == null) {
    child = {
      properties: /* @__PURE__ */ new Map(),
      accessType
    };
    node.properties.set(property, child);
  } else {
    child.accessType = merge(child.accessType, accessType);
  }
  return child;
}

// src/HIR/PropagateScopeDependenciesHIR.ts
function propagateScopeDependenciesHIR(fn) {
  const usedOutsideDeclaringScope = findTemporariesUsedOutsideDeclaringScope(fn);
  const temporaries = collectTemporariesSidemap(fn, usedOutsideDeclaringScope);
  const {
    temporariesReadInOptional,
    processedInstrsInOptional,
    hoistableObjects
  } = collectOptionalChainSidemap(fn);
  const hoistablePropertyLoads = keyByScopeId(
    fn,
    collectHoistablePropertyLoads(fn, temporaries, hoistableObjects)
  );
  const scopeDeps = collectDependencies(
    fn,
    usedOutsideDeclaringScope,
    new Map([...temporaries, ...temporariesReadInOptional]),
    processedInstrsInOptional
  );
  for (const [scope, deps] of scopeDeps) {
    if (deps.length === 0) {
      continue;
    }
    const hoistables = hoistablePropertyLoads.get(scope.id);
    CompilerError.invariant(hoistables != null, {
      reason: "[PropagateScopeDependencies] Scope not found in tracked blocks",
      loc: GeneratedSource
    });
    const tree = new ReactiveScopeDependencyTreeHIR(
      [...hoistables.assumedNonNullObjects].map((o) => o.fullPath)
    );
    for (const dep of deps) {
      tree.addDependency(__spreadValues({}, dep));
    }
    const candidates = tree.deriveMinimalDependencies();
    for (const candidateDep of candidates) {
      if (!Iterable_some(
        scope.dependencies,
        (existingDep) => existingDep.identifier.declarationId === candidateDep.identifier.declarationId && areEqualPaths(existingDep.path, candidateDep.path)
      ))
        scope.dependencies.add(candidateDep);
    }
  }
}
function findTemporariesUsedOutsideDeclaringScope(fn) {
  const declarations = /* @__PURE__ */ new Map();
  const prunedScopes = /* @__PURE__ */ new Set();
  const scopeTraversal = new ScopeBlockTraversal();
  const usedOutsideDeclaringScope = /* @__PURE__ */ new Set();
  function handlePlace2(place) {
    const declaringScope = declarations.get(place.identifier.declarationId);
    if (declaringScope != null && !scopeTraversal.isScopeActive(declaringScope) && !prunedScopes.has(declaringScope)) {
      usedOutsideDeclaringScope.add(place.identifier.declarationId);
    }
  }
  function handleInstruction2(instr) {
    const scope = scopeTraversal.currentScope;
    if (scope == null || prunedScopes.has(scope)) {
      return;
    }
    switch (instr.value.kind) {
      case "LoadLocal":
      case "LoadContext":
      case "PropertyLoad": {
        declarations.set(instr.lvalue.identifier.declarationId, scope);
        break;
      }
      default: {
        break;
      }
    }
  }
  for (const [blockId, block] of fn.body.blocks) {
    scopeTraversal.recordScopes(block);
    const scopeStartInfo = scopeTraversal.blockInfos.get(blockId);
    if ((scopeStartInfo == null ? void 0 : scopeStartInfo.kind) === "begin" && scopeStartInfo.pruned) {
      prunedScopes.add(scopeStartInfo.scope.id);
    }
    for (const instr of block.instructions) {
      for (const place of eachInstructionOperand(instr)) {
        handlePlace2(place);
      }
      handleInstruction2(instr);
    }
    for (const place of eachTerminalOperand(block.terminal)) {
      handlePlace2(place);
    }
  }
  return usedOutsideDeclaringScope;
}
function collectTemporariesSidemap(fn, usedOutsideDeclaringScope) {
  const temporaries = /* @__PURE__ */ new Map();
  collectTemporariesSidemapImpl(
    fn,
    usedOutsideDeclaringScope,
    temporaries,
    null
  );
  return temporaries;
}
function isLoadContextMutable(instrValue, id) {
  if (instrValue.kind === "LoadContext") {
    return instrValue.place.identifier.scope != null && id >= instrValue.place.identifier.scope.range.end;
  }
  return false;
}
function collectTemporariesSidemapImpl(fn, usedOutsideDeclaringScope, temporaries, innerFnContext) {
  for (const [_, block] of fn.body.blocks) {
    for (const { value, lvalue, id: origInstrId } of block.instructions) {
      const instrId = innerFnContext != null ? innerFnContext.instrId : origInstrId;
      const usedOutside = usedOutsideDeclaringScope.has(
        lvalue.identifier.declarationId
      );
      if (value.kind === "PropertyLoad" && !usedOutside) {
        if (innerFnContext == null || temporaries.has(value.object.identifier.id)) {
          const property = getProperty(
            value.object,
            value.property,
            false,
            temporaries
          );
          temporaries.set(lvalue.identifier.id, property);
        }
      } else if ((value.kind === "LoadLocal" || isLoadContextMutable(value, instrId)) && lvalue.identifier.name == null && value.place.identifier.name !== null && !usedOutside) {
        if (innerFnContext == null || fn.context.some(
          (context) => context.identifier.id === value.place.identifier.id
        )) {
          temporaries.set(lvalue.identifier.id, {
            identifier: value.place.identifier,
            reactive: value.place.reactive,
            path: []
          });
        }
      } else if (value.kind === "FunctionExpression" || value.kind === "ObjectMethod") {
        collectTemporariesSidemapImpl(
          value.loweredFunc.func,
          usedOutsideDeclaringScope,
          temporaries,
          innerFnContext != null ? innerFnContext : { instrId }
        );
      }
    }
  }
}
function getProperty(object, propertyName, optional, temporaries) {
  const resolvedDependency = temporaries.get(object.identifier.id);
  let property;
  if (resolvedDependency == null) {
    property = {
      identifier: object.identifier,
      reactive: object.reactive,
      path: [{ property: propertyName, optional }]
    };
  } else {
    property = {
      identifier: resolvedDependency.identifier,
      reactive: resolvedDependency.reactive,
      path: [...resolvedDependency.path, { property: propertyName, optional }]
    };
  }
  return property;
}
var _declarations2, _reassignments, _scopes2, _dependencies, _temporaries, _temporariesUsedOutsideScope, _processedInstrsInOptional, _innerFnContext, _DependencyCollectionContext_instances, checkValidDependency_fn, isScopeActive_fn;
var DependencyCollectionContext = class {
  constructor(temporariesUsedOutsideScope, temporaries, processedInstrsInOptional) {
    __privateAdd(this, _DependencyCollectionContext_instances);
    __privateAdd(this, _declarations2, /* @__PURE__ */ new Map());
    __privateAdd(this, _reassignments, /* @__PURE__ */ new Map());
    __privateAdd(this, _scopes2, empty());
    // Reactive dependencies used in the current reactive scope.
    __privateAdd(this, _dependencies, empty());
    this.deps = /* @__PURE__ */ new Map();
    __privateAdd(this, _temporaries);
    __privateAdd(this, _temporariesUsedOutsideScope);
    __privateAdd(this, _processedInstrsInOptional);
    /**
     * Tracks the traversal state. See Context.declare for explanation of why this
     * is needed.
     */
    __privateAdd(this, _innerFnContext, null);
    __privateSet(this, _temporariesUsedOutsideScope, temporariesUsedOutsideScope);
    __privateSet(this, _temporaries, temporaries);
    __privateSet(this, _processedInstrsInOptional, processedInstrsInOptional);
  }
  enterScope(scope) {
    __privateSet(this, _dependencies, __privateGet(this, _dependencies).push([]));
    __privateSet(this, _scopes2, __privateGet(this, _scopes2).push(scope));
  }
  exitScope(scope, pruned) {
    var _a;
    const scopedDependencies = __privateGet(this, _dependencies).value;
    CompilerError.invariant(scopedDependencies != null, {
      reason: "[PropagateScopeDeps]: Unexpected scope mismatch",
      loc: scope.loc
    });
    __privateSet(this, _scopes2, __privateGet(this, _scopes2).pop());
    __privateSet(this, _dependencies, __privateGet(this, _dependencies).pop());
    for (const dep of scopedDependencies) {
      if (__privateMethod(this, _DependencyCollectionContext_instances, checkValidDependency_fn).call(this, dep)) {
        (_a = __privateGet(this, _dependencies).value) == null ? void 0 : _a.push(dep);
      }
    }
    if (!pruned) {
      this.deps.set(scope, scopedDependencies);
    }
  }
  isUsedOutsideDeclaringScope(place) {
    return __privateGet(this, _temporariesUsedOutsideScope).has(
      place.identifier.declarationId
    );
  }
  /*
   * Records where a value was declared, and optionally, the scope where the
   * value originated from. This is later used to determine if a dependency
   * should be added to a scope; if the current scope we are visiting is the
   * same scope where the value originates, it can't be a dependency on itself.
   *
   * Note that we do not track declarations or reassignments within inner
   * functions for the following reasons:
   *   - inner functions cannot be split by scope boundaries and are guaranteed
   *     to consume their own declarations
   *   - reassignments within inner functions are tracked as context variables,
   *     which already have extended mutable ranges to account for reassignments
   *   - *most importantly* it's currently simply incorrect to compare inner
   *     function instruction ids (tracked by `decl`) with outer ones (as stored
   *     by root identifier mutable ranges).
   */
  declare(identifier4, decl) {
    if (__privateGet(this, _innerFnContext) != null) return;
    if (!__privateGet(this, _declarations2).has(identifier4.declarationId)) {
      __privateGet(this, _declarations2).set(identifier4.declarationId, decl);
    }
    __privateGet(this, _reassignments).set(identifier4, decl);
  }
  hasDeclared(identifier4) {
    return __privateGet(this, _declarations2).has(identifier4.declarationId);
  }
  get currentScope() {
    return __privateGet(this, _scopes2);
  }
  visitOperand(place) {
    var _a;
    this.visitDependency(
      (_a = __privateGet(this, _temporaries).get(place.identifier.id)) != null ? _a : {
        identifier: place.identifier,
        reactive: place.reactive,
        path: []
      }
    );
  }
  visitProperty(object, property, optional) {
    const nextDependency = getProperty(
      object,
      property,
      optional,
      __privateGet(this, _temporaries)
    );
    this.visitDependency(nextDependency);
  }
  visitDependency(maybeDependency) {
    var _a;
    const originalDeclaration = __privateGet(this, _declarations2).get(
      maybeDependency.identifier.declarationId
    );
    if (originalDeclaration !== void 0 && originalDeclaration.scope.value !== null) {
      originalDeclaration.scope.each((scope) => {
        if (!__privateMethod(this, _DependencyCollectionContext_instances, isScopeActive_fn).call(this, scope) && !Iterable_some(
          scope.declarations.values(),
          (decl) => decl.identifier.declarationId === maybeDependency.identifier.declarationId
        )) {
          scope.declarations.set(maybeDependency.identifier.id, {
            identifier: maybeDependency.identifier,
            scope: originalDeclaration.scope.value
          });
        }
      });
    }
    if (isUseRefType(maybeDependency.identifier) && ((_a = maybeDependency.path.at(0)) == null ? void 0 : _a.property) === "current") {
      maybeDependency = {
        identifier: maybeDependency.identifier,
        reactive: maybeDependency.reactive,
        path: []
      };
    }
    if (__privateMethod(this, _DependencyCollectionContext_instances, checkValidDependency_fn).call(this, maybeDependency)) {
      __privateGet(this, _dependencies).value.push(maybeDependency);
    }
  }
  /*
   * Record a variable that is declared in some other scope and that is being reassigned in the
   * current one as a {@link ReactiveScope.reassignments}
   */
  visitReassignment(place) {
    const currentScope = this.currentScope.value;
    if (currentScope != null && !Iterable_some(
      currentScope.reassignments,
      (identifier4) => identifier4.declarationId === place.identifier.declarationId
    ) && __privateMethod(this, _DependencyCollectionContext_instances, checkValidDependency_fn).call(this, {
      identifier: place.identifier,
      reactive: place.reactive,
      path: []
    })) {
      currentScope.reassignments.add(place.identifier);
    }
  }
  enterInnerFn(innerFn, cb) {
    var _a;
    const prevContext = __privateGet(this, _innerFnContext);
    __privateSet(this, _innerFnContext, (_a = __privateGet(this, _innerFnContext)) != null ? _a : { outerInstrId: innerFn.id });
    const result = cb();
    __privateSet(this, _innerFnContext, prevContext);
    return result;
  }
  /**
   * Skip dependencies that are subexpressions of other dependencies. e.g. if a
   * dependency is tracked in the temporaries sidemap, it can be added at
   * site-of-use
   */
  isDeferredDependency(instr) {
    return __privateGet(this, _processedInstrsInOptional).has(instr.value) || instr.kind === 1 /* Instruction */ && __privateGet(this, _temporaries).has(instr.value.lvalue.identifier.id);
  }
};
_declarations2 = new WeakMap();
_reassignments = new WeakMap();
_scopes2 = new WeakMap();
_dependencies = new WeakMap();
_temporaries = new WeakMap();
_temporariesUsedOutsideScope = new WeakMap();
_processedInstrsInOptional = new WeakMap();
_innerFnContext = new WeakMap();
_DependencyCollectionContext_instances = new WeakSet();
// Checks if identifier is a valid dependency in the current scope
checkValidDependency_fn = function(maybeDependency) {
  var _a;
  if (isRefValueType(maybeDependency.identifier)) {
    return false;
  }
  if (isObjectMethodType(maybeDependency.identifier)) {
    return false;
  }
  const identifier4 = maybeDependency.identifier;
  const currentDeclaration = (_a = __privateGet(this, _reassignments).get(identifier4)) != null ? _a : __privateGet(this, _declarations2).get(identifier4.declarationId);
  const currentScope = this.currentScope.value;
  return currentScope != null && currentDeclaration !== void 0 && currentDeclaration.id < currentScope.range.start;
};
isScopeActive_fn = function(scope) {
  if (__privateGet(this, _scopes2) === null) {
    return false;
  }
  return __privateGet(this, _scopes2).find((state) => state === scope);
};
function handleInstruction(instr, context) {
  const { id, value, lvalue } = instr;
  context.declare(lvalue.identifier, {
    id,
    scope: context.currentScope
  });
  if (context.isDeferredDependency({ kind: 1 /* Instruction */, value: instr })) {
    return;
  }
  if (value.kind === "PropertyLoad") {
    context.visitProperty(value.object, value.property, false);
  } else if (value.kind === "StoreLocal") {
    context.visitOperand(value.value);
    if (value.lvalue.kind === "Reassign" /* Reassign */) {
      context.visitReassignment(value.lvalue.place);
    }
    context.declare(value.lvalue.place.identifier, {
      id,
      scope: context.currentScope
    });
  } else if (value.kind === "DeclareLocal" || value.kind === "DeclareContext") {
    if (convertHoistedLValueKind(value.lvalue.kind) === null) {
      context.declare(value.lvalue.place.identifier, {
        id,
        scope: context.currentScope
      });
    }
  } else if (value.kind === "Destructure") {
    context.visitOperand(value.value);
    for (const place of eachPatternOperand(value.lvalue.pattern)) {
      if (value.lvalue.kind === "Reassign" /* Reassign */) {
        context.visitReassignment(place);
      }
      context.declare(place.identifier, {
        id,
        scope: context.currentScope
      });
    }
  } else if (value.kind === "StoreContext") {
    if (!context.hasDeclared(value.lvalue.place.identifier) || value.lvalue.kind !== "Reassign" /* Reassign */) {
      context.declare(value.lvalue.place.identifier, {
        id,
        scope: context.currentScope
      });
    }
    for (const operand of eachInstructionValueOperand(value)) {
      context.visitOperand(operand);
    }
  } else {
    for (const operand of eachInstructionValueOperand(value)) {
      context.visitOperand(operand);
    }
  }
}
function collectDependencies(fn, usedOutsideDeclaringScope, temporaries, processedInstrsInOptional) {
  const context = new DependencyCollectionContext(
    usedOutsideDeclaringScope,
    temporaries,
    processedInstrsInOptional
  );
  for (const param of fn.params) {
    if (param.kind === "Identifier") {
      context.declare(param.identifier, {
        id: makeInstructionId(0),
        scope: empty()
      });
    } else {
      context.declare(param.place.identifier, {
        id: makeInstructionId(0),
        scope: empty()
      });
    }
  }
  const scopeTraversal = new ScopeBlockTraversal();
  const handleFunction = (fn2) => {
    for (const [blockId, block] of fn2.body.blocks) {
      scopeTraversal.recordScopes(block);
      const scopeBlockInfo = scopeTraversal.blockInfos.get(blockId);
      if ((scopeBlockInfo == null ? void 0 : scopeBlockInfo.kind) === "begin") {
        context.enterScope(scopeBlockInfo.scope);
      } else if ((scopeBlockInfo == null ? void 0 : scopeBlockInfo.kind) === "end") {
        context.exitScope(scopeBlockInfo.scope, scopeBlockInfo.pruned);
      }
      for (const phi of block.phis) {
        for (const operand of phi.operands) {
          const maybeOptionalChain = temporaries.get(operand[1].identifier.id);
          if (maybeOptionalChain) {
            context.visitDependency(maybeOptionalChain);
          }
        }
      }
      for (const instr of block.instructions) {
        if (instr.value.kind === "FunctionExpression" || instr.value.kind === "ObjectMethod") {
          context.declare(instr.lvalue.identifier, {
            id: instr.id,
            scope: context.currentScope
          });
          const innerFn = instr.value.loweredFunc.func;
          context.enterInnerFn(
            instr,
            () => {
              handleFunction(innerFn);
            }
          );
        } else {
          handleInstruction(instr, context);
        }
      }
      if (!context.isDeferredDependency({
        kind: 2 /* Terminal */,
        value: block.terminal
      })) {
        for (const place of eachTerminalOperand(block.terminal)) {
          context.visitOperand(place);
        }
      }
    }
  };
  handleFunction(fn);
  return context.deps;
}

// src/HIR/ScopeDependencyUtils.ts
function buildDependencyInstructions(dep, env) {
  const builder = new HIRBuilder(env, {
    entryBlockKind: "value"
  });
  let dependencyValue;
  if (dep.path.every((path) => !path.optional)) {
    dependencyValue = writeNonOptionalDependency(dep, env, builder);
  } else {
    dependencyValue = writeOptionalDependency(dep, builder, null);
  }
  const exitBlockId = builder.terminate(
    {
      kind: "unsupported",
      loc: GeneratedSource,
      id: makeInstructionId(0)
    },
    null
  );
  return {
    place: {
      kind: "Identifier",
      identifier: dependencyValue,
      effect: "freeze" /* Freeze */,
      reactive: dep.reactive,
      loc: GeneratedSource
    },
    value: builder.build(),
    exitBlockId
  };
}
function writeNonOptionalDependency(dep, env, builder) {
  const loc = dep.identifier.loc;
  let curr = makeTemporaryIdentifier(env.nextIdentifierId, loc);
  builder.push({
    lvalue: {
      identifier: curr,
      kind: "Identifier",
      effect: "mutate" /* Mutate */,
      reactive: dep.reactive,
      loc
    },
    value: {
      kind: "LoadLocal",
      place: {
        identifier: dep.identifier,
        kind: "Identifier",
        effect: "freeze" /* Freeze */,
        reactive: dep.reactive,
        loc
      },
      loc
    },
    id: makeInstructionId(1),
    loc,
    effects: null
  });
  for (const path of dep.path) {
    const next = makeTemporaryIdentifier(env.nextIdentifierId, loc);
    builder.push({
      lvalue: {
        identifier: next,
        kind: "Identifier",
        effect: "mutate" /* Mutate */,
        reactive: dep.reactive,
        loc
      },
      value: {
        kind: "PropertyLoad",
        object: {
          identifier: curr,
          kind: "Identifier",
          effect: "freeze" /* Freeze */,
          reactive: dep.reactive,
          loc
        },
        property: path.property,
        loc
      },
      id: makeInstructionId(1),
      loc,
      effects: null
    });
    curr = next;
  }
  return curr;
}
function writeOptionalDependency(dep, builder, parentAlternate) {
  const env = builder.environment;
  const dependencyValue = {
    kind: "Identifier",
    identifier: makeTemporaryIdentifier(env.nextIdentifierId, GeneratedSource),
    effect: "mutate" /* Mutate */,
    reactive: dep.reactive,
    loc: GeneratedSource
  };
  const continuationBlock = builder.reserve(builder.currentBlockKind());
  let alternate;
  if (parentAlternate != null) {
    alternate = parentAlternate;
  } else {
    alternate = builder.enter("value", () => {
      const temp = lowerValueToTemporary(builder, {
        kind: "Primitive",
        value: void 0,
        loc: GeneratedSource
      });
      lowerValueToTemporary(builder, {
        kind: "StoreLocal",
        lvalue: { kind: "Const" /* Const */, place: __spreadValues({}, dependencyValue) },
        value: __spreadValues({}, temp),
        type: null,
        loc: GeneratedSource
      });
      return {
        kind: "goto",
        variant: "Break" /* Break */,
        block: continuationBlock.id,
        id: makeInstructionId(0),
        loc: GeneratedSource
      };
    });
  }
  const consequent = builder.reserve("value");
  let testIdentifier = null;
  const testBlock = builder.enter("value", () => {
    const testDependency = __spreadProps(__spreadValues({}, dep), {
      path: dep.path.slice(0, dep.path.length - 1)
    });
    const firstOptional = dep.path.findIndex((path) => path.optional);
    CompilerError.invariant(firstOptional !== -1, {
      reason: "[ScopeDependencyUtils] Internal invariant broken: expected optional path",
      loc: dep.identifier.loc,
      description: null,
      suggestions: null
    });
    if (firstOptional === dep.path.length - 1) {
      testIdentifier = writeNonOptionalDependency(testDependency, env, builder);
    } else {
      testIdentifier = writeOptionalDependency(
        testDependency,
        builder,
        alternate
      );
    }
    return {
      kind: "branch",
      test: {
        identifier: testIdentifier,
        effect: "freeze" /* Freeze */,
        kind: "Identifier",
        loc: GeneratedSource,
        reactive: dep.reactive
      },
      consequent: consequent.id,
      alternate,
      id: makeInstructionId(0),
      loc: GeneratedSource,
      fallthrough: continuationBlock.id
    };
  });
  builder.enterReserved(consequent, () => {
    CompilerError.invariant(testIdentifier !== null, {
      reason: "Satisfy type checker",
      description: null,
      loc: null,
      suggestions: null
    });
    lowerValueToTemporary(builder, {
      kind: "StoreLocal",
      lvalue: { kind: "Const" /* Const */, place: __spreadValues({}, dependencyValue) },
      value: lowerValueToTemporary(builder, {
        kind: "PropertyLoad",
        object: {
          identifier: testIdentifier,
          kind: "Identifier",
          effect: "freeze" /* Freeze */,
          reactive: dep.reactive,
          loc: GeneratedSource
        },
        property: dep.path.at(-1).property,
        loc: GeneratedSource
      }),
      type: null,
      loc: GeneratedSource
    });
    return {
      kind: "goto",
      variant: "Break" /* Break */,
      block: continuationBlock.id,
      id: makeInstructionId(0),
      loc: GeneratedSource
    };
  });
  builder.terminateWithContinuation(
    {
      kind: "optional",
      optional: dep.path.at(-1).optional,
      test: testBlock,
      fallthrough: continuationBlock.id,
      id: makeInstructionId(0),
      loc: GeneratedSource
    },
    continuationBlock
  );
  return dependencyValue.identifier;
}

// src/Inference/InferEffectDependencies.ts
function inferEffectDependencies(fn) {
  var _a, _b;
  const fnExpressions = /* @__PURE__ */ new Map();
  const autodepFnConfigs = /* @__PURE__ */ new Map();
  for (const effectTarget of fn.env.config.inferEffectDependencies) {
    const moduleTargets = getOrInsertWith(
      autodepFnConfigs,
      effectTarget.function.source,
      () => /* @__PURE__ */ new Map()
    );
    moduleTargets.set(
      effectTarget.function.importSpecifierName,
      effectTarget.autodepsIndex
    );
  }
  const autodepFnLoads = /* @__PURE__ */ new Map();
  const autodepModuleLoads = /* @__PURE__ */ new Map();
  const scopeInfos = /* @__PURE__ */ new Map();
  const loadGlobals = /* @__PURE__ */ new Set();
  const reactiveIds = inferReactiveIdentifiers(fn);
  const rewriteBlocks = [];
  for (const [, block] of fn.body.blocks) {
    if (block.terminal.kind === "scope") {
      const scopeBlock = fn.body.blocks.get(block.terminal.block);
      if (scopeBlock.instructions.length === 1 && scopeBlock.terminal.kind === "goto" && scopeBlock.terminal.block === block.terminal.fallthrough) {
        scopeInfos.set(
          block.terminal.scope.id,
          block.terminal.scope.dependencies
        );
      }
    }
    const rewriteInstrs = [];
    for (const instr of block.instructions) {
      const { value, lvalue } = instr;
      if (value.kind === "FunctionExpression") {
        fnExpressions.set(
          lvalue.identifier.id,
          instr
        );
      } else if (value.kind === "PropertyLoad") {
        if (typeof value.property === "string" && autodepModuleLoads.has(value.object.identifier.id)) {
          const moduleTargets = autodepModuleLoads.get(
            value.object.identifier.id
          );
          const propertyName = value.property;
          const numRequiredArgs = moduleTargets.get(propertyName);
          if (numRequiredArgs != null) {
            autodepFnLoads.set(lvalue.identifier.id, numRequiredArgs);
          }
        }
      } else if (value.kind === "LoadGlobal") {
        loadGlobals.add(lvalue.identifier.id);
        if (value.binding.kind === "ImportNamespace") {
          const moduleTargets = autodepFnConfigs.get(value.binding.module);
          if (moduleTargets != null) {
            autodepModuleLoads.set(lvalue.identifier.id, moduleTargets);
          }
        }
        if (value.binding.kind === "ImportSpecifier" || value.binding.kind === "ImportDefault") {
          const moduleTargets = autodepFnConfigs.get(value.binding.module);
          if (moduleTargets != null) {
            const importSpecifierName = value.binding.kind === "ImportSpecifier" ? value.binding.imported : DEFAULT_EXPORT;
            const numRequiredArgs = moduleTargets.get(importSpecifierName);
            if (numRequiredArgs != null) {
              autodepFnLoads.set(lvalue.identifier.id, numRequiredArgs);
            }
          }
        }
      } else if (value.kind === "CallExpression" || value.kind === "MethodCall") {
        const callee = value.kind === "CallExpression" ? value.callee : value.property;
        const autodepsArgIndex = value.args.findIndex(
          (arg) => arg.kind === "Identifier" && arg.identifier.type.kind === "Object" && arg.identifier.type.shapeId === BuiltInAutodepsId
        );
        const autodepsArgExpectedIndex = autodepFnLoads.get(
          callee.identifier.id
        );
        if (value.args.length > 0 && autodepsArgExpectedIndex != null && autodepsArgIndex === autodepsArgExpectedIndex && autodepFnLoads.has(callee.identifier.id) && value.args[0].kind === "Identifier") {
          const effectDeps = [];
          const deps = {
            kind: "ArrayExpression",
            elements: effectDeps,
            loc: GeneratedSource
          };
          const depsPlace = createTemporaryPlace(fn.env, GeneratedSource);
          depsPlace.effect = "read" /* Read */;
          const fnExpr = fnExpressions.get(value.args[0].identifier.id);
          if (fnExpr != null) {
            const scopeInfo = fnExpr.lvalue.identifier.scope != null ? scopeInfos.get(fnExpr.lvalue.identifier.scope.id) : null;
            let minimalDeps;
            if (scopeInfo != null) {
              minimalDeps = new Set(scopeInfo);
            } else {
              minimalDeps = inferMinimalDependencies(fnExpr);
            }
            const usedDeps = [];
            for (const maybeDep of minimalDeps) {
              if ((isUseRefType(maybeDep.identifier) || isSetStateType(maybeDep.identifier)) && !reactiveIds.has(maybeDep.identifier.id) || isFireFunctionType(maybeDep.identifier) || isEffectEventFunctionType(maybeDep.identifier)) {
                continue;
              }
              const dep = truncateDepAtCurrent(maybeDep);
              const { place, value: value2, exitBlockId } = buildDependencyInstructions(
                dep,
                fn.env
              );
              rewriteInstrs.push({
                kind: "block",
                location: instr.id,
                value: value2,
                exitBlockId
              });
              effectDeps.push(place);
              usedDeps.push(dep);
            }
            const decorations = [];
            for (const loc of collectDepUsages(usedDeps, fnExpr.value)) {
              if (typeof loc === "symbol") {
                continue;
              }
              decorations.push(loc);
            }
            if (typeof value.loc !== "symbol") {
              (_a = fn.env.logger) == null ? void 0 : _a.logEvent(fn.env.filename, {
                kind: "AutoDepsDecorations",
                fnLoc: value.loc,
                decorations
              });
            }
            rewriteInstrs.push({
              kind: "instr",
              location: instr.id,
              value: {
                id: makeInstructionId(0),
                loc: GeneratedSource,
                lvalue: __spreadProps(__spreadValues({}, depsPlace), { effect: "mutate" /* Mutate */ }),
                value: deps,
                effects: null
              }
            });
            value.args[autodepsArgIndex] = __spreadProps(__spreadValues({}, depsPlace), {
              effect: "freeze" /* Freeze */
            });
            fn.env.inferredEffectLocations.add(callee.loc);
          } else if (loadGlobals.has(value.args[0].identifier.id)) {
            rewriteInstrs.push({
              kind: "instr",
              location: instr.id,
              value: {
                id: makeInstructionId(0),
                loc: GeneratedSource,
                lvalue: __spreadProps(__spreadValues({}, depsPlace), { effect: "mutate" /* Mutate */ }),
                value: deps,
                effects: null
              }
            });
            value.args[autodepsArgIndex] = __spreadProps(__spreadValues({}, depsPlace), {
              effect: "freeze" /* Freeze */
            });
            fn.env.inferredEffectLocations.add(callee.loc);
          }
        } else if (value.args.length >= 2 && value.args.length - 1 === autodepFnLoads.get(callee.identifier.id) && value.args[0] != null && value.args[0].kind === "Identifier") {
          const penultimateArg = value.args[value.args.length - 2];
          const depArrayArg = value.args[value.args.length - 1];
          if (depArrayArg.kind !== "Spread" && penultimateArg.kind !== "Spread" && typeof depArrayArg.loc !== "symbol" && typeof penultimateArg.loc !== "symbol" && typeof value.loc !== "symbol") {
            (_b = fn.env.logger) == null ? void 0 : _b.logEvent(fn.env.filename, {
              kind: "AutoDepsEligible",
              fnLoc: value.loc,
              depArrayLoc: __spreadProps(__spreadValues({}, depArrayArg.loc), {
                start: penultimateArg.loc.end,
                end: depArrayArg.loc.end
              })
            });
          }
        }
      }
    }
    rewriteSplices(block, rewriteInstrs, rewriteBlocks);
  }
  if (rewriteBlocks.length > 0) {
    for (const block of rewriteBlocks) {
      fn.body.blocks.set(block.id, block);
    }
    reversePostorderBlocks(fn.body);
    markPredecessors(fn.body);
    markInstructionIds(fn.body);
    fixScopeAndIdentifierRanges(fn.body);
    deadCodeElimination(fn);
    fn.env.hasInferredEffect = true;
  }
}
function truncateDepAtCurrent(dep) {
  const idx = dep.path.findIndex((path) => path.property === "current");
  if (idx === -1) {
    return dep;
  } else {
    return __spreadProps(__spreadValues({}, dep), { path: dep.path.slice(0, idx) });
  }
}
function rewriteSplices(originalBlock, splices, rewriteBlocks) {
  if (splices.length === 0) {
    return;
  }
  const originalInstrs = originalBlock.instructions;
  let currBlock = __spreadProps(__spreadValues({}, originalBlock), { instructions: [] });
  rewriteBlocks.push(currBlock);
  let cursor = 0;
  for (const rewrite of splices) {
    while (originalInstrs[cursor].id < rewrite.location) {
      CompilerError.invariant(
        originalInstrs[cursor].id < originalInstrs[cursor + 1].id,
        {
          reason: "[InferEffectDependencies] Internal invariant broken: expected block instructions to be sorted",
          loc: originalInstrs[cursor].loc
        }
      );
      currBlock.instructions.push(originalInstrs[cursor]);
      cursor++;
    }
    CompilerError.invariant(originalInstrs[cursor].id === rewrite.location, {
      reason: "[InferEffectDependencies] Internal invariant broken: splice location not found",
      loc: originalInstrs[cursor].loc
    });
    if (rewrite.kind === "instr") {
      currBlock.instructions.push(rewrite.value);
    } else if (rewrite.kind === "block") {
      const { entry, blocks } = rewrite.value;
      const entryBlock = blocks.get(entry);
      currBlock.instructions.push(...entryBlock.instructions);
      if (blocks.size > 1) {
        CompilerError.invariant(
          terminalFallthrough(entryBlock.terminal) === rewrite.exitBlockId,
          {
            reason: "[InferEffectDependencies] Internal invariant broken: expected entry block to have a fallthrough",
            loc: entryBlock.terminal.loc
          }
        );
        const originalTerminal = currBlock.terminal;
        currBlock.terminal = entryBlock.terminal;
        for (const [id, block] of blocks) {
          if (id === entry) {
            continue;
          }
          if (id === rewrite.exitBlockId) {
            block.terminal = originalTerminal;
            currBlock = block;
          }
          rewriteBlocks.push(block);
        }
      }
    }
  }
  currBlock.instructions.push(...originalInstrs.slice(cursor));
}
function inferReactiveIdentifiers(fn) {
  const reactiveIds = /* @__PURE__ */ new Set();
  for (const [, block] of fn.body.blocks) {
    for (const instr of block.instructions) {
      for (const place of eachInstructionOperand(instr)) {
        if (place.reactive) {
          reactiveIds.add(place.identifier.id);
        }
      }
    }
    for (const place of eachTerminalOperand(block.terminal)) {
      if (place.reactive) {
        reactiveIds.add(place.identifier.id);
      }
    }
  }
  return reactiveIds;
}
function collectDepUsages(deps, fnExpr) {
  const identifiers = /* @__PURE__ */ new Map();
  const loadedDeps = /* @__PURE__ */ new Set();
  const sourceLocations = [];
  for (const dep of deps) {
    identifiers.set(dep.identifier.id, dep);
  }
  for (const [, block] of fnExpr.loweredFunc.func.body.blocks) {
    for (const instr of block.instructions) {
      if (instr.value.kind === "LoadLocal" && identifiers.has(instr.value.place.identifier.id)) {
        loadedDeps.add(instr.lvalue.identifier.id);
      }
      for (const place of eachInstructionOperand(instr)) {
        if (loadedDeps.has(place.identifier.id)) {
          sourceLocations.push(place.identifier.loc);
        }
      }
    }
  }
  return sourceLocations;
}
function inferMinimalDependencies(fnInstr) {
  const fn = fnInstr.value.loweredFunc.func;
  const temporaries = collectTemporariesSidemap(fn, /* @__PURE__ */ new Set());
  const {
    hoistableObjects,
    processedInstrsInOptional,
    temporariesReadInOptional
  } = collectOptionalChainSidemap(fn);
  const hoistablePropertyLoads = collectHoistablePropertyLoadsInInnerFn(
    fnInstr,
    temporaries,
    hoistableObjects
  );
  const hoistableToFnEntry = hoistablePropertyLoads.get(fn.body.entry);
  CompilerError.invariant(hoistableToFnEntry != null, {
    reason: "[InferEffectDependencies] Internal invariant broken: missing entry block",
    loc: fnInstr.loc
  });
  const dependencies = inferDependencies(
    fnInstr,
    new Map([...temporaries, ...temporariesReadInOptional]),
    processedInstrsInOptional
  );
  const tree = new ReactiveScopeDependencyTreeHIR(
    [...hoistableToFnEntry.assumedNonNullObjects].map((o) => o.fullPath)
  );
  for (const dep of dependencies) {
    tree.addDependency(__spreadValues({}, dep));
  }
  return tree.deriveMinimalDependencies();
}
function inferDependencies(fnInstr, temporaries, processedInstrsInOptional) {
  const fn = fnInstr.value.loweredFunc.func;
  const context = new DependencyCollectionContext(
    /* @__PURE__ */ new Set(),
    temporaries,
    processedInstrsInOptional
  );
  for (const dep of fn.context) {
    context.declare(dep.identifier, {
      id: makeInstructionId(0),
      scope: empty()
    });
  }
  const placeholderScope = {
    id: makeScopeId(0),
    range: {
      start: fnInstr.id,
      end: makeInstructionId(fnInstr.id + 1)
    },
    dependencies: /* @__PURE__ */ new Set(),
    reassignments: /* @__PURE__ */ new Set(),
    declarations: /* @__PURE__ */ new Map(),
    earlyReturnValue: null,
    merged: /* @__PURE__ */ new Set(),
    loc: GeneratedSource
  };
  context.enterScope(placeholderScope);
  inferDependenciesInFn(fn, context, temporaries);
  context.exitScope(placeholderScope, false);
  const resultUnfiltered = context.deps.get(placeholderScope);
  CompilerError.invariant(resultUnfiltered != null, {
    reason: "[InferEffectDependencies] Internal invariant broken: missing scope dependencies",
    loc: fn.loc
  });
  const fnContext = new Set(fn.context.map((dep) => dep.identifier.id));
  const result = /* @__PURE__ */ new Set();
  for (const dep of resultUnfiltered) {
    if (fnContext.has(dep.identifier.id)) {
      result.add(dep);
    }
  }
  return result;
}
function inferDependenciesInFn(fn, context, temporaries) {
  for (const [, block] of fn.body.blocks) {
    for (const phi of block.phis) {
      for (const operand of phi.operands) {
        const maybeOptionalChain = temporaries.get(operand[1].identifier.id);
        if (maybeOptionalChain) {
          context.visitDependency(maybeOptionalChain);
        }
      }
    }
    for (const instr of block.instructions) {
      if (instr.value.kind === "FunctionExpression" || instr.value.kind === "ObjectMethod") {
        context.declare(instr.lvalue.identifier, {
          id: instr.id,
          scope: context.currentScope
        });
        const innerFn = instr.value.loweredFunc.func;
        context.enterInnerFn(instr, () => {
          inferDependenciesInFn(innerFn, context, temporaries);
        });
      } else {
        handleInstruction(instr, context);
      }
    }
  }
}

// src/Optimization/InstructionReordering.ts
function instructionReordering(fn) {
  var _a;
  const shared = /* @__PURE__ */ new Map();
  const references = findReferencedRangeOfTemporaries(fn);
  for (const [, block] of fn.body.blocks) {
    reorderBlock(fn.env, block, shared, references);
  }
  CompilerError.invariant(shared.size === 0, {
    reason: `InstructionReordering: expected all reorderable nodes to have been emitted`,
    loc: (_a = [...shared.values()].map((node) => {
      var _a2;
      return (_a2 = node.instruction) == null ? void 0 : _a2.loc;
    }).filter((loc) => loc != null)[0]) != null ? _a : GeneratedSource
  });
  markInstructionIds(fn.body);
}
var DEBUG4 = false;
function findReferencedRangeOfTemporaries(fn) {
  const singleUseIdentifiers = /* @__PURE__ */ new Map();
  const lastAssignments = /* @__PURE__ */ new Map();
  function reference(instr, place, kind) {
    var _a;
    if (place.identifier.name !== null && place.identifier.name.kind === "named") {
      if (kind === 1 /* Write */) {
        const name = place.identifier.name.value;
        const previous = lastAssignments.get(name);
        if (previous === void 0) {
          lastAssignments.set(name, instr);
        } else {
          lastAssignments.set(
            name,
            makeInstructionId(Math.max(previous, instr))
          );
        }
      }
      return;
    } else if (kind === 0 /* Read */) {
      const previousCount = (_a = singleUseIdentifiers.get(place.identifier.id)) != null ? _a : 0;
      singleUseIdentifiers.set(place.identifier.id, previousCount + 1);
    }
  }
  for (const [, block] of fn.body.blocks) {
    for (const instr of block.instructions) {
      for (const operand of eachInstructionValueLValue(instr.value)) {
        reference(instr.id, operand, 0 /* Read */);
      }
      for (const lvalue of eachInstructionLValue(instr)) {
        reference(instr.id, lvalue, 1 /* Write */);
      }
    }
    for (const operand of eachTerminalOperand(block.terminal)) {
      reference(block.terminal.id, operand, 0 /* Read */);
    }
  }
  return {
    singleUseIdentifiers: new Set(
      [...singleUseIdentifiers].filter(([, count]) => count === 1).map(([id]) => id)
    ),
    lastAssignments
  };
}
function reorderBlock(env, block, shared, references) {
  var _a, _b;
  const locals = /* @__PURE__ */ new Map();
  const named = /* @__PURE__ */ new Map();
  let previous = null;
  for (const instr of block.instructions) {
    const { lvalue, value } = instr;
    const reorderability = getReorderability(instr, references);
    const node = getOrInsertWith(
      locals,
      lvalue.identifier.id,
      () => ({
        instruction: instr,
        dependencies: /* @__PURE__ */ new Set(),
        reorderability,
        depth: null
      })
    );
    if (reorderability === 1 /* Nonreorderable */) {
      if (previous !== null) {
        node.dependencies.add(previous);
      }
      previous = lvalue.identifier.id;
    }
    for (const operand of eachInstructionValueOperand(value)) {
      const { name, id } = operand.identifier;
      if (name !== null && name.kind === "named") {
        const previous2 = named.get(name.value);
        if (previous2 !== void 0) {
          node.dependencies.add(previous2);
        }
        named.set(name.value, lvalue.identifier.id);
      } else if (locals.has(id) || shared.has(id)) {
        node.dependencies.add(id);
      }
    }
    for (const lvalueOperand of eachInstructionValueLValue(value)) {
      const lvalueNode = getOrInsertWith(
        locals,
        lvalueOperand.identifier.id,
        () => ({
          instruction: null,
          dependencies: /* @__PURE__ */ new Set(),
          depth: null
        })
      );
      lvalueNode.dependencies.add(lvalue.identifier.id);
      const name = lvalueOperand.identifier.name;
      if (name !== null && name.kind === "named") {
        const previous2 = named.get(name.value);
        if (previous2 !== void 0) {
          node.dependencies.add(previous2);
        }
        named.set(name.value, lvalue.identifier.id);
      }
    }
  }
  const nextInstructions = [];
  const seen = /* @__PURE__ */ new Set();
  DEBUG4 && console.log(`bb${block.id}`);
  if (isExpressionBlockKind(block.kind)) {
    if (previous !== null) {
      DEBUG4 && console.log(`(last non-reorderable instruction)`);
      DEBUG4 && print(env, locals, shared, seen, previous);
      emit(env, locals, shared, nextInstructions, previous);
    }
    if (block.instructions.length !== 0) {
      DEBUG4 && console.log(`(block value)`);
      DEBUG4 && print(
        env,
        locals,
        shared,
        seen,
        block.instructions.at(-1).lvalue.identifier.id
      );
      emit(
        env,
        locals,
        shared,
        nextInstructions,
        block.instructions.at(-1).lvalue.identifier.id
      );
    }
    for (const operand of eachTerminalOperand(block.terminal)) {
      DEBUG4 && console.log(`(terminal operand)`);
      DEBUG4 && print(env, locals, shared, seen, operand.identifier.id);
      emit(env, locals, shared, nextInstructions, operand.identifier.id);
    }
    for (const [id, node] of locals) {
      if (node.instruction == null) {
        continue;
      }
      CompilerError.invariant(
        node.reorderability === 0 /* Reorderable */,
        {
          reason: `Expected all remaining instructions to be reorderable`,
          loc: (_b = (_a = node.instruction) == null ? void 0 : _a.loc) != null ? _b : block.terminal.loc,
          description: node.instruction != null ? `Instruction [${node.instruction.id}] was not emitted yet but is not reorderable` : `Lvalue $${id} was not emitted yet but is not reorderable`
        }
      );
      DEBUG4 && console.log(`save shared: $${id}`);
      shared.set(id, node);
    }
  } else {
    for (const operand of eachTerminalOperand(block.terminal)) {
      DEBUG4 && console.log(`(terminal operand)`);
      DEBUG4 && print(env, locals, shared, seen, operand.identifier.id);
      emit(env, locals, shared, nextInstructions, operand.identifier.id);
    }
    for (const id of Array.from(locals.keys()).reverse()) {
      const node = locals.get(id);
      if (node === void 0) {
        continue;
      }
      if (node.reorderability === 0 /* Reorderable */) {
        DEBUG4 && console.log(`save shared: $${id}`);
        shared.set(id, node);
      } else {
        DEBUG4 && console.log("leftover");
        DEBUG4 && print(env, locals, shared, seen, id);
        emit(env, locals, shared, nextInstructions, id);
      }
    }
  }
  block.instructions = nextInstructions;
  DEBUG4 && console.log();
}
function getDepth(env, nodes, id) {
  const node = nodes.get(id);
  if (node == null) {
    return 0;
  }
  if (node.depth != null) {
    return node.depth;
  }
  node.depth = 0;
  let depth = node.reorderability === 0 /* Reorderable */ ? 1 : 10;
  for (const dep of node.dependencies) {
    depth += getDepth(env, nodes, dep);
  }
  node.depth = depth;
  return depth;
}
function print(env, locals, shared, seen, id, depth = 0) {
  var _a;
  if (seen.has(id)) {
    DEBUG4 && console.log(`${"|   ".repeat(depth)}$${id} <skipped>`);
    return;
  }
  seen.add(id);
  const node = (_a = locals.get(id)) != null ? _a : shared.get(id);
  if (node == null) {
    return;
  }
  const deps = [...node.dependencies];
  deps.sort((a, b) => {
    const aDepth = getDepth(env, locals, a);
    const bDepth = getDepth(env, locals, b);
    return bDepth - aDepth;
  });
  for (const dep of deps) {
    print(env, locals, shared, seen, dep, depth + 1);
  }
  DEBUG4 && console.log(
    `${"|   ".repeat(depth)}$${id} ${printNode(node)} deps=[${deps.map((x) => `$${x}`).join(", ")}] depth=${node.depth}`
  );
}
function printNode(node) {
  const { instruction } = node;
  if (instruction === null) {
    return "<lvalue-only>";
  }
  switch (instruction.value.kind) {
    case "FunctionExpression":
    case "ObjectMethod": {
      return `[${instruction.id}] ${instruction.value.kind}`;
    }
    default: {
      return printInstruction(instruction);
    }
  }
}
function emit(env, locals, shared, instructions, id) {
  var _a;
  const node = (_a = locals.get(id)) != null ? _a : shared.get(id);
  if (node == null) {
    return;
  }
  locals.delete(id);
  shared.delete(id);
  const deps = [...node.dependencies];
  deps.sort((a, b) => {
    const aDepth = getDepth(env, locals, a);
    const bDepth = getDepth(env, locals, b);
    return bDepth - aDepth;
  });
  for (const dep of deps) {
    emit(env, locals, shared, instructions, dep);
  }
  if (node.instruction !== null) {
    instructions.push(node.instruction);
  }
}
function getReorderability(instr, references) {
  switch (instr.value.kind) {
    case "JsxExpression":
    case "JsxFragment":
    case "JSXText":
    case "LoadGlobal":
    case "Primitive":
    case "TemplateLiteral":
    case "BinaryExpression":
    case "UnaryExpression": {
      return 0 /* Reorderable */;
    }
    case "LoadLocal": {
      const name = instr.value.place.identifier.name;
      if (name !== null && name.kind === "named") {
        const lastAssignment = references.lastAssignments.get(name.value);
        if (lastAssignment !== void 0 && lastAssignment < instr.id && references.singleUseIdentifiers.has(instr.lvalue.identifier.id)) {
          return 0 /* Reorderable */;
        }
      }
      return 1 /* Nonreorderable */;
    }
    default: {
      return 1 /* Nonreorderable */;
    }
  }
}

// src/ReactiveScopes/AlignMethodCallScopes.ts
function alignMethodCallScopes(fn) {
  const scopeMapping = /* @__PURE__ */ new Map();
  const mergedScopes = new DisjointSet();
  for (const [, block] of fn.body.blocks) {
    for (const instr of block.instructions) {
      const { lvalue, value } = instr;
      if (value.kind === "MethodCall") {
        const lvalueScope = lvalue.identifier.scope;
        const propertyScope = value.property.identifier.scope;
        if (lvalueScope !== null) {
          if (propertyScope !== null) {
            mergedScopes.union([lvalueScope, propertyScope]);
          } else {
            scopeMapping.set(value.property.identifier.id, lvalueScope);
          }
        } else if (propertyScope !== null) {
          scopeMapping.set(value.property.identifier.id, null);
        }
      } else if (value.kind === "FunctionExpression" || value.kind === "ObjectMethod") {
        alignMethodCallScopes(value.loweredFunc.func);
      }
    }
  }
  mergedScopes.forEach((scope, root2) => {
    if (scope === root2) {
      return;
    }
    root2.range.start = makeInstructionId(
      Math.min(scope.range.start, root2.range.start)
    );
    root2.range.end = makeInstructionId(
      Math.max(scope.range.end, root2.range.end)
    );
  });
  for (const [, block] of fn.body.blocks) {
    for (const instr of block.instructions) {
      const mappedScope = scopeMapping.get(instr.lvalue.identifier.id);
      if (mappedScope !== void 0) {
        instr.lvalue.identifier.scope = mappedScope;
      } else if (instr.lvalue.identifier.scope !== null) {
        const mergedScope = mergedScopes.find(instr.lvalue.identifier.scope);
        if (mergedScope != null) {
          instr.lvalue.identifier.scope = mergedScope;
        }
      }
    }
  }
}

// src/ReactiveScopes/AlignReactiveScopesToBlockScopesHIR.ts
function alignReactiveScopesToBlockScopesHIR(fn) {
  var _a, _b, _c, _d, _e;
  const activeBlockFallthroughRanges = [];
  const activeScopes = /* @__PURE__ */ new Set();
  const seen = /* @__PURE__ */ new Set();
  const valueBlockNodes = /* @__PURE__ */ new Map();
  const placeScopes = /* @__PURE__ */ new Map();
  function recordPlace(id, place, node) {
    if (place.identifier.scope !== null) {
      placeScopes.set(place, place.identifier.scope);
    }
    const scope = getPlaceScope(id, place);
    if (scope == null) {
      return;
    }
    activeScopes.add(scope);
    node == null ? void 0 : node.children.push({ kind: "scope", scope, id });
    if (seen.has(scope)) {
      return;
    }
    seen.add(scope);
    if (node != null && node.valueRange !== null) {
      scope.range.start = makeInstructionId(
        Math.min(node.valueRange.start, scope.range.start)
      );
      scope.range.end = makeInstructionId(
        Math.max(node.valueRange.end, scope.range.end)
      );
    }
  }
  for (const [, block] of fn.body.blocks) {
    const startingId = (_b = (_a = block.instructions[0]) == null ? void 0 : _a.id) != null ? _b : block.terminal.id;
    retainWhere_Set(activeScopes, (scope) => scope.range.end > startingId);
    const top = activeBlockFallthroughRanges.at(-1);
    if ((top == null ? void 0 : top.fallthrough) === block.id) {
      activeBlockFallthroughRanges.pop();
      for (const scope of activeScopes) {
        scope.range.start = makeInstructionId(
          Math.min(scope.range.start, top.range.start)
        );
      }
    }
    const { instructions, terminal } = block;
    const node = (_c = valueBlockNodes.get(block.id)) != null ? _c : null;
    for (const instr of instructions) {
      for (const lvalue of eachInstructionLValue(instr)) {
        recordPlace(instr.id, lvalue, node);
      }
      for (const operand of eachInstructionValueOperand(instr.value)) {
        recordPlace(instr.id, operand, node);
      }
    }
    for (const operand of eachTerminalOperand(terminal)) {
      recordPlace(terminal.id, operand, node);
    }
    const fallthrough = terminalFallthrough(terminal);
    if (fallthrough !== null && terminal.kind !== "branch") {
      const fallthroughBlock = fn.body.blocks.get(fallthrough);
      const nextId = (_e = (_d = fallthroughBlock.instructions[0]) == null ? void 0 : _d.id) != null ? _e : fallthroughBlock.terminal.id;
      for (const scope of activeScopes) {
        if (scope.range.end > terminal.id) {
          scope.range.end = makeInstructionId(
            Math.max(scope.range.end, nextId)
          );
        }
      }
      activeBlockFallthroughRanges.push({
        fallthrough,
        range: {
          start: terminal.id,
          end: nextId
        }
      });
      CompilerError.invariant(!valueBlockNodes.has(fallthrough), {
        reason: "Expect hir blocks to have unique fallthroughs",
        loc: terminal.loc
      });
      if (node != null) {
        valueBlockNodes.set(fallthrough, node);
      }
    }
    mapTerminalSuccessors(terminal, (successor) => {
      var _a2, _b2;
      if (valueBlockNodes.has(successor)) {
        return successor;
      }
      const successorBlock = fn.body.blocks.get(successor);
      if (successorBlock.kind === "block" || successorBlock.kind === "catch") {
      } else if (node == null || terminal.kind === "ternary" || terminal.kind === "logical" || terminal.kind === "optional") {
        let valueRange;
        if (node == null) {
          CompilerError.invariant(fallthrough !== null, {
            reason: `Expected a fallthrough for value block`,
            loc: terminal.loc
          });
          const fallthroughBlock = fn.body.blocks.get(fallthrough);
          const nextId = (_b2 = (_a2 = fallthroughBlock.instructions[0]) == null ? void 0 : _a2.id) != null ? _b2 : fallthroughBlock.terminal.id;
          valueRange = {
            start: terminal.id,
            end: nextId
          };
        } else {
          valueRange = node.valueRange;
        }
        const childNode = {
          kind: "node",
          id: terminal.id,
          children: [],
          valueRange
        };
        node == null ? void 0 : node.children.push(childNode);
        valueBlockNodes.set(successor, childNode);
      } else {
        valueBlockNodes.set(successor, node);
      }
      return successor;
    });
  }
}

// src/ReactiveScopes/FlattenReactiveLoopsHIR.ts
function flattenReactiveLoopsHIR(fn) {
  const activeLoops = Array();
  for (const [, block] of fn.body.blocks) {
    retainWhere(activeLoops, (id) => id !== block.id);
    const { terminal } = block;
    switch (terminal.kind) {
      case "do-while":
      case "for":
      case "for-in":
      case "for-of":
      case "while": {
        activeLoops.push(terminal.fallthrough);
        break;
      }
      case "scope": {
        if (activeLoops.length !== 0) {
          block.terminal = {
            kind: "pruned-scope",
            block: terminal.block,
            fallthrough: terminal.fallthrough,
            id: terminal.id,
            loc: terminal.loc,
            scope: terminal.scope
          };
        }
        break;
      }
      case "branch":
      case "goto":
      case "if":
      case "label":
      case "logical":
      case "maybe-throw":
      case "optional":
      case "pruned-scope":
      case "return":
      case "sequence":
      case "switch":
      case "ternary":
      case "throw":
      case "try":
      case "unreachable":
      case "unsupported": {
        break;
      }
      default: {
        assertExhaustive(
          terminal,
          `Unexpected terminal kind \`${terminal.kind}\``
        );
      }
    }
  }
}

// src/ReactiveScopes/FlattenScopesWithHooksOrUseHIR.ts
function flattenScopesWithHooksOrUseHIR(fn) {
  const activeScopes = [];
  const prune = [];
  for (const [, block] of fn.body.blocks) {
    retainWhere(activeScopes, (current) => current.fallthrough !== block.id);
    for (const instr of block.instructions) {
      const { value } = instr;
      switch (value.kind) {
        case "MethodCall":
        case "CallExpression": {
          const callee = value.kind === "MethodCall" ? value.property : value.callee;
          if (getHookKind(fn.env, callee.identifier) != null || isUseOperator(callee.identifier)) {
            prune.push(...activeScopes.map((entry) => entry.block));
            activeScopes.length = 0;
          }
        }
      }
    }
    if (block.terminal.kind === "scope") {
      activeScopes.push({
        block: block.id,
        fallthrough: block.terminal.fallthrough
      });
    }
  }
  for (const id of prune) {
    const block = fn.body.blocks.get(id);
    const terminal = block.terminal;
    CompilerError.invariant(terminal.kind === "scope", {
      reason: `Expected block to have a scope terminal`,
      description: `Expected block bb${block.id} to end in a scope terminal`,
      loc: terminal.loc
    });
    const body = fn.body.blocks.get(terminal.block);
    if (body.instructions.length === 1 && body.terminal.kind === "goto" && body.terminal.block === terminal.fallthrough) {
      block.terminal = {
        kind: "label",
        block: terminal.block,
        fallthrough: terminal.fallthrough,
        id: terminal.id,
        loc: terminal.loc
      };
      continue;
    }
    block.terminal = {
      kind: "pruned-scope",
      block: terminal.block,
      fallthrough: terminal.fallthrough,
      id: terminal.id,
      loc: terminal.loc,
      scope: terminal.scope
    };
  }
}

// src/ReactiveScopes/PruneAlwaysInvalidatingScopes.ts
function pruneAlwaysInvalidatingScopes(fn) {
  visitReactiveFunction(fn, new Transform5(), false);
}
var Transform5 = class extends ReactiveFunctionTransform {
  constructor() {
    super(...arguments);
    this.alwaysInvalidatingValues = /* @__PURE__ */ new Set();
    this.unmemoizedValues = /* @__PURE__ */ new Set();
  }
  transformInstruction(instruction, withinScope) {
    this.visitInstruction(instruction, withinScope);
    const { lvalue, value } = instruction;
    switch (value.kind) {
      case "ArrayExpression":
      case "ObjectExpression":
      case "JsxExpression":
      case "JsxFragment":
      case "NewExpression": {
        if (lvalue !== null) {
          this.alwaysInvalidatingValues.add(lvalue.identifier);
          if (!withinScope) {
            this.unmemoizedValues.add(lvalue.identifier);
          }
        }
        break;
      }
      case "StoreLocal": {
        if (this.alwaysInvalidatingValues.has(value.value.identifier)) {
          this.alwaysInvalidatingValues.add(value.lvalue.place.identifier);
        }
        if (this.unmemoizedValues.has(value.value.identifier)) {
          this.unmemoizedValues.add(value.lvalue.place.identifier);
        }
        break;
      }
      case "LoadLocal": {
        if (lvalue !== null && this.alwaysInvalidatingValues.has(value.place.identifier)) {
          this.alwaysInvalidatingValues.add(lvalue.identifier);
        }
        if (lvalue !== null && this.unmemoizedValues.has(value.place.identifier)) {
          this.unmemoizedValues.add(lvalue.identifier);
        }
        break;
      }
    }
    return { kind: "keep" };
  }
  transformScope(scopeBlock, _withinScope) {
    this.visitScope(scopeBlock, true);
    for (const dep of scopeBlock.scope.dependencies) {
      if (this.unmemoizedValues.has(dep.identifier)) {
        for (const [_, decl] of scopeBlock.scope.declarations) {
          if (this.alwaysInvalidatingValues.has(decl.identifier)) {
            this.unmemoizedValues.add(decl.identifier);
          }
        }
        for (const identifier4 of scopeBlock.scope.reassignments) {
          if (this.alwaysInvalidatingValues.has(identifier4)) {
            this.unmemoizedValues.add(identifier4);
          }
        }
        return {
          kind: "replace",
          value: {
            kind: "pruned-scope",
            scope: scopeBlock.scope,
            instructions: scopeBlock.instructions
          }
        };
      }
    }
    return { kind: "keep" };
  }
};

// src/ReactiveScopes/PruneInitializationDependencies.ts
var Visitor9 = class extends ReactiveFunctionVisitor {
  constructor(env, aliases, paths) {
    super();
    this.map = /* @__PURE__ */ new Map();
    this.aliases = aliases;
    this.paths = paths;
    this.env = env;
  }
  join(values) {
    function join2(l, r) {
      if (l === "Update" || r === "Update") {
        return "Update";
      } else if (l === "Create" || r === "Create") {
        return "Create";
      } else if (l === "Unknown" || r === "Unknown") {
        return "Unknown";
      }
      assertExhaustive(r, `Unhandled variable kind ${r}`);
    }
    return values.reduce(join2, "Unknown");
  }
  isCreateOnlyHook(id) {
    return isUseStateType(id) || isUseRefType(id);
  }
  visitPlace(_, place, state) {
    var _a;
    this.map.set(
      place.identifier.id,
      this.join([state, (_a = this.map.get(place.identifier.id)) != null ? _a : "Unknown"])
    );
  }
  visitBlock(block, state) {
    super.visitBlock([...block].reverse(), state);
  }
  visitInstruction(instruction) {
    const state = this.join(
      [...eachInstructionLValue(instruction)].map(
        (operand) => {
          var _a;
          return (_a = this.map.get(operand.identifier.id)) != null ? _a : "Unknown";
        }
      )
    );
    const visitCallOrMethodNonArgs = () => {
      switch (instruction.value.kind) {
        case "CallExpression": {
          this.visitPlace(instruction.id, instruction.value.callee, state);
          break;
        }
        case "MethodCall": {
          this.visitPlace(instruction.id, instruction.value.property, state);
          this.visitPlace(instruction.id, instruction.value.receiver, state);
          break;
        }
      }
    };
    const isHook2 = () => {
      let callee = null;
      switch (instruction.value.kind) {
        case "CallExpression": {
          callee = instruction.value.callee.identifier;
          break;
        }
        case "MethodCall": {
          callee = instruction.value.property.identifier;
          break;
        }
      }
      return callee != null && getHookKind(this.env, callee) != null;
    };
    switch (instruction.value.kind) {
      case "CallExpression":
      case "MethodCall": {
        if (instruction.lvalue && this.isCreateOnlyHook(instruction.lvalue.identifier)) {
          [...eachCallArgument(instruction.value.args)].forEach(
            (operand) => this.visitPlace(instruction.id, operand, "Create")
          );
          visitCallOrMethodNonArgs();
        } else {
          this.traverseInstruction(instruction, isHook2() ? "Update" : state);
        }
        break;
      }
      default: {
        this.traverseInstruction(instruction, state);
      }
    }
  }
  visitScope(scope) {
    const state = this.join(
      [
        ...scope.scope.declarations.keys(),
        ...[...scope.scope.reassignments.values()].map((ident) => ident.id)
      ].map((id) => {
        var _a;
        return (_a = this.map.get(id)) != null ? _a : "Unknown";
      })
    );
    super.visitScope(scope, state);
    [...scope.scope.dependencies].forEach((ident) => {
      var _a;
      let target = (_a = this.aliases.find(ident.identifier.id)) != null ? _a : ident.identifier.id;
      ident.path.forEach((token2) => {
        var _a2;
        target && (target = (_a2 = this.paths.get(target)) == null ? void 0 : _a2.get(token2.property));
      });
      if (target && this.map.get(target) === "Create") {
        scope.scope.dependencies.delete(ident);
      }
    });
  }
  visitTerminal(stmt, state) {
    CompilerError.invariant(state !== "Create", {
      reason: "Visiting a terminal statement with state 'Create'",
      loc: stmt.terminal.loc
    });
    super.visitTerminal(stmt, state);
  }
  visitReactiveFunctionValue(_id, _dependencies2, fn, state) {
    visitReactiveFunction(fn, this, state);
  }
};
function pruneInitializationDependencies(fn) {
  const [aliases, paths] = getAliases(fn);
  visitReactiveFunction(fn, new Visitor9(fn.env, aliases, paths), "Update");
}
function update(map, key2, path, value) {
  var _a;
  const inner = (_a = map.get(key2)) != null ? _a : /* @__PURE__ */ new Map();
  inner.set(path, value);
  map.set(key2, inner);
}
var AliasVisitor = class extends ReactiveFunctionVisitor {
  constructor() {
    super(...arguments);
    this.scopeIdentifiers = new DisjointSet();
    this.scopePaths = /* @__PURE__ */ new Map();
  }
  visitInstruction(instr) {
    if (instr.value.kind === "StoreLocal" || instr.value.kind === "StoreContext") {
      this.scopeIdentifiers.union([
        instr.value.lvalue.place.identifier.id,
        instr.value.value.identifier.id
      ]);
    } else if (instr.value.kind === "LoadLocal" || instr.value.kind === "LoadContext") {
      instr.lvalue && this.scopeIdentifiers.union([
        instr.lvalue.identifier.id,
        instr.value.place.identifier.id
      ]);
    } else if (instr.value.kind === "PropertyLoad") {
      instr.lvalue && update(
        this.scopePaths,
        instr.value.object.identifier.id,
        instr.value.property,
        instr.lvalue.identifier.id
      );
    } else if (instr.value.kind === "PropertyStore") {
      update(
        this.scopePaths,
        instr.value.object.identifier.id,
        instr.value.property,
        instr.value.value.identifier.id
      );
    }
  }
};
function getAliases(fn) {
  var _a, _b;
  const visitor = new AliasVisitor();
  visitReactiveFunction(fn, visitor, null);
  let disjoint = visitor.scopeIdentifiers;
  let scopePaths = /* @__PURE__ */ new Map();
  for (const [key2, value] of visitor.scopePaths) {
    for (const [path, id] of value) {
      update(
        scopePaths,
        (_a = disjoint.find(key2)) != null ? _a : key2,
        path,
        (_b = disjoint.find(id)) != null ? _b : id
      );
    }
  }
  return [disjoint, scopePaths];
}

// src/TypeInference/InferTypes.ts
function isPrimitiveBinaryOp(op) {
  switch (op) {
    case "+":
    case "-":
    case "/":
    case "%":
    case "*":
    case "**":
    case "&":
    case "|":
    case ">>":
    case "<<":
    case "^":
    case ">":
    case "<":
    case ">=":
    case "<=":
    case "|>":
      return true;
    default:
      return false;
  }
}
function inferTypes(func) {
  const unifier = new Unifier(func.env);
  for (const e of generate(func)) {
    unifier.unify(e.left, e.right);
  }
  apply(func, unifier);
}
function apply(func, unifier) {
  for (const [_, block] of func.body.blocks) {
    for (const phi of block.phis) {
      phi.place.identifier.type = unifier.get(phi.place.identifier.type);
    }
    for (const instr of block.instructions) {
      for (const operand of eachInstructionLValue(instr)) {
        operand.identifier.type = unifier.get(operand.identifier.type);
      }
      for (const place of eachInstructionOperand(instr)) {
        place.identifier.type = unifier.get(place.identifier.type);
      }
      const { lvalue, value } = instr;
      lvalue.identifier.type = unifier.get(lvalue.identifier.type);
      if (value.kind === "FunctionExpression" || value.kind === "ObjectMethod") {
        apply(value.loweredFunc.func, unifier);
      }
    }
  }
  const returns = func.returns.identifier;
  returns.type = unifier.get(returns.type);
}
function equation(left, right) {
  return {
    left,
    right
  };
}
function* generate(func) {
  if (func.fnType === "Component") {
    const [props, ref] = func.params;
    if (props && props.kind === "Identifier") {
      yield equation(props.identifier.type, {
        kind: "Object",
        shapeId: BuiltInPropsId
      });
    }
    if (ref && ref.kind === "Identifier") {
      yield equation(ref.identifier.type, {
        kind: "Object",
        shapeId: BuiltInUseRefId
      });
    }
  }
  const names = /* @__PURE__ */ new Map();
  const returnTypes = [];
  for (const [_, block] of func.body.blocks) {
    for (const phi of block.phis) {
      yield equation(phi.place.identifier.type, {
        kind: "Phi",
        operands: [...phi.operands.values()].map((id) => id.identifier.type)
      });
    }
    for (const instr of block.instructions) {
      yield* __yieldStar(generateInstructionTypes(func.env, names, instr));
    }
    const terminal = block.terminal;
    if (terminal.kind === "return") {
      returnTypes.push(terminal.value.identifier.type);
    }
  }
  if (returnTypes.length > 1) {
    yield equation(func.returns.identifier.type, {
      kind: "Phi",
      operands: returnTypes
    });
  } else if (returnTypes.length === 1) {
    yield equation(func.returns.identifier.type, returnTypes[0]);
  }
}
function setName(names, id, name) {
  var _a;
  if (((_a = name.name) == null ? void 0 : _a.kind) === "named") {
    names.set(id, name.name.value);
  }
}
function getName(names, id) {
  var _a;
  return (_a = names.get(id)) != null ? _a : "";
}
function* generateInstructionTypes(env, names, instr) {
  const { lvalue, value } = instr;
  const left = lvalue.identifier.type;
  switch (value.kind) {
    case "TemplateLiteral":
    case "JSXText":
    case "Primitive": {
      yield equation(left, { kind: "Primitive" });
      break;
    }
    case "UnaryExpression": {
      yield equation(left, { kind: "Primitive" });
      break;
    }
    case "LoadLocal": {
      setName(names, lvalue.identifier.id, value.place.identifier);
      yield equation(left, value.place.identifier.type);
      break;
    }
    // We intentionally do not infer types for most context variables
    case "DeclareContext":
    case "LoadContext": {
      break;
    }
    case "StoreContext": {
      if (value.lvalue.kind === "Const" /* Const */) {
        yield equation(
          value.lvalue.place.identifier.type,
          value.value.identifier.type
        );
      }
      break;
    }
    case "StoreLocal": {
      if (env.config.enableUseTypeAnnotations) {
        yield equation(
          value.lvalue.place.identifier.type,
          value.value.identifier.type
        );
        const valueType = value.type === null ? makeType() : lowerType(value.type);
        yield equation(valueType, value.lvalue.place.identifier.type);
        yield equation(left, valueType);
      } else {
        yield equation(left, value.value.identifier.type);
        yield equation(
          value.lvalue.place.identifier.type,
          value.value.identifier.type
        );
      }
      break;
    }
    case "StoreGlobal": {
      yield equation(left, value.value.identifier.type);
      break;
    }
    case "BinaryExpression": {
      if (isPrimitiveBinaryOp(value.operator)) {
        yield equation(value.left.identifier.type, { kind: "Primitive" });
        yield equation(value.right.identifier.type, { kind: "Primitive" });
      }
      yield equation(left, { kind: "Primitive" });
      break;
    }
    case "PostfixUpdate":
    case "PrefixUpdate": {
      yield equation(value.value.identifier.type, { kind: "Primitive" });
      yield equation(value.lvalue.identifier.type, { kind: "Primitive" });
      yield equation(left, { kind: "Primitive" });
      break;
    }
    case "LoadGlobal": {
      const globalType = env.getGlobalDeclaration(value.binding, value.loc);
      if (globalType) {
        yield equation(left, globalType);
      }
      break;
    }
    case "CallExpression": {
      const returnType = makeType();
      yield equation(value.callee.identifier.type, {
        kind: "Function",
        shapeId: null,
        return: returnType,
        isConstructor: false
      });
      yield equation(left, returnType);
      break;
    }
    case "TaggedTemplateExpression": {
      const returnType = makeType();
      yield equation(value.tag.identifier.type, {
        kind: "Function",
        shapeId: null,
        return: returnType,
        isConstructor: false
      });
      yield equation(left, returnType);
      break;
    }
    case "ObjectExpression": {
      for (const property of value.properties) {
        if (property.kind === "ObjectProperty" && property.key.kind === "computed") {
          yield equation(property.key.name.identifier.type, {
            kind: "Primitive"
          });
        }
      }
      yield equation(left, { kind: "Object", shapeId: BuiltInObjectId });
      break;
    }
    case "ArrayExpression": {
      yield equation(left, { kind: "Object", shapeId: BuiltInArrayId });
      break;
    }
    case "PropertyLoad": {
      yield equation(left, {
        kind: "Property",
        objectType: value.object.identifier.type,
        objectName: getName(names, value.object.identifier.id),
        propertyName: {
          kind: "literal",
          value: value.property
        }
      });
      break;
    }
    case "ComputedLoad": {
      yield equation(left, {
        kind: "Property",
        objectType: value.object.identifier.type,
        objectName: getName(names, value.object.identifier.id),
        propertyName: {
          kind: "computed",
          value: value.property.identifier.type
        }
      });
      break;
    }
    case "MethodCall": {
      const returnType = makeType();
      yield equation(value.property.identifier.type, {
        kind: "Function",
        return: returnType,
        shapeId: null,
        isConstructor: false
      });
      yield equation(left, returnType);
      break;
    }
    case "Destructure": {
      const pattern = value.lvalue.pattern;
      if (pattern.kind === "ArrayPattern") {
        for (let i = 0; i < pattern.items.length; i++) {
          const item = pattern.items[i];
          if (item.kind === "Identifier") {
            const propertyName = String(i);
            yield equation(item.identifier.type, {
              kind: "Property",
              objectType: value.value.identifier.type,
              objectName: getName(names, value.value.identifier.id),
              propertyName: {
                kind: "literal",
                value: makePropertyLiteral(propertyName)
              }
            });
          } else if (item.kind === "Spread") {
            yield equation(item.place.identifier.type, {
              kind: "Object",
              shapeId: BuiltInArrayId
            });
          } else {
            break;
          }
        }
      } else {
        for (const property of pattern.properties) {
          if (property.kind === "ObjectProperty") {
            if (property.key.kind === "identifier" || property.key.kind === "string") {
              yield equation(property.place.identifier.type, {
                kind: "Property",
                objectType: value.value.identifier.type,
                objectName: getName(names, value.value.identifier.id),
                propertyName: {
                  kind: "literal",
                  value: makePropertyLiteral(property.key.name)
                }
              });
            }
          }
        }
      }
      break;
    }
    case "TypeCastExpression": {
      if (env.config.enableUseTypeAnnotations) {
        yield equation(value.type, value.value.identifier.type);
        yield equation(left, value.type);
      } else {
        yield equation(left, value.value.identifier.type);
      }
      break;
    }
    case "PropertyDelete":
    case "ComputedDelete": {
      yield equation(left, { kind: "Primitive" });
      break;
    }
    case "FunctionExpression": {
      yield* __yieldStar(generate(value.loweredFunc.func));
      yield equation(left, {
        kind: "Function",
        shapeId: BuiltInFunctionId,
        return: value.loweredFunc.func.returns.identifier.type,
        isConstructor: false
      });
      break;
    }
    case "NextPropertyOf": {
      yield equation(left, { kind: "Primitive" });
      break;
    }
    case "ObjectMethod": {
      yield* __yieldStar(generate(value.loweredFunc.func));
      yield equation(left, { kind: "ObjectMethod" });
      break;
    }
    case "JsxExpression":
    case "JsxFragment": {
      if (env.config.enableTreatRefLikeIdentifiersAsRefs) {
        if (value.kind === "JsxExpression") {
          for (const prop of value.props) {
            if (prop.kind === "JsxAttribute" && prop.name === "ref") {
              yield equation(prop.place.identifier.type, {
                kind: "Object",
                shapeId: BuiltInUseRefId
              });
            }
          }
        }
      }
      yield equation(left, { kind: "Object", shapeId: BuiltInJsxId });
      break;
    }
    case "NewExpression": {
      const returnType = makeType();
      yield equation(value.callee.identifier.type, {
        kind: "Function",
        return: returnType,
        shapeId: null,
        isConstructor: true
      });
      yield equation(left, returnType);
      break;
    }
    case "PropertyStore": {
      yield equation(
        /**
         * Our property type declarations are best-effort and we haven't tested
         * using them to drive inference of rvalues from lvalues. We want to emit
         * a Property type in order to infer refs from `.current` accesses, but
         * stay conservative by not otherwise inferring anything about rvalues.
         * So we use a dummy type here.
         *
         * TODO: consider using the rvalue type here
         */
        makeType(),
        // unify() only handles properties in the second position
        {
          kind: "Property",
          objectType: value.object.identifier.type,
          objectName: getName(names, value.object.identifier.id),
          propertyName: {
            kind: "literal",
            value: value.property
          }
        }
      );
      break;
    }
    case "DeclareLocal":
    case "RegExpLiteral":
    case "MetaProperty":
    case "ComputedStore":
    case "Await":
    case "GetIterator":
    case "IteratorNext":
    case "UnsupportedNode":
    case "Debugger":
    case "FinishMemoize":
    case "StartMemoize": {
      break;
    }
    default:
      assertExhaustive(
        value,
        `Unhandled instruction value kind: ${value.kind}`
      );
  }
}
var Unifier = class {
  constructor(env) {
    this.substitutions = /* @__PURE__ */ new Map();
    this.env = env;
  }
  unify(tA, tB) {
    if (tB.kind === "Property") {
      if (this.env.config.enableTreatRefLikeIdentifiersAsRefs && isRefLikeName(tB)) {
        this.unify(tB.objectType, {
          kind: "Object",
          shapeId: BuiltInUseRefId
        });
        this.unify(tA, {
          kind: "Object",
          shapeId: BuiltInRefValueId
        });
        return;
      }
      const objectType2 = this.get(tB.objectType);
      const propertyType = tB.propertyName.kind === "literal" ? this.env.getPropertyType(objectType2, tB.propertyName.value) : this.env.getFallthroughPropertyType(
        objectType2,
        tB.propertyName.value
      );
      if (propertyType !== null) {
        this.unify(tA, propertyType);
      }
      return;
    }
    if (typeEquals(tA, tB)) {
      return;
    }
    if (tA.kind === "Type") {
      this.bindVariableTo(tA, tB);
      return;
    }
    if (tB.kind === "Type") {
      this.bindVariableTo(tB, tA);
      return;
    }
    if (tB.kind === "Function" && tA.kind === "Function" && tA.isConstructor === tB.isConstructor) {
      this.unify(tA.return, tB.return);
      return;
    }
  }
  bindVariableTo(v, type) {
    if (type.kind === "Poly") {
      return;
    }
    if (this.substitutions.has(v.id)) {
      this.unify(this.substitutions.get(v.id), type);
      return;
    }
    if (type.kind === "Type" && this.substitutions.has(type.id)) {
      this.unify(v, this.substitutions.get(type.id));
      return;
    }
    if (type.kind === "Phi") {
      CompilerError.invariant(type.operands.length > 0, {
        reason: "there should be at least one operand",
        description: null,
        loc: null,
        suggestions: null
      });
      let candidateType = null;
      for (const operand of type.operands) {
        const resolved = this.get(operand);
        if (candidateType === null) {
          candidateType = resolved;
        } else if (!typeEquals(resolved, candidateType)) {
          const unionType2 = tryUnionTypes(resolved, candidateType);
          if (unionType2 === null) {
            candidateType = null;
            break;
          } else {
            candidateType = unionType2;
          }
        }
      }
      if (candidateType !== null) {
        this.unify(v, candidateType);
        return;
      }
    }
    if (this.occursCheck(v, type)) {
      const resolvedType = this.tryResolveType(v, type);
      if (resolvedType !== null) {
        this.substitutions.set(v.id, resolvedType);
        return;
      }
      throw new Error("cycle detected");
    }
    this.substitutions.set(v.id, type);
  }
  tryResolveType(v, type) {
    switch (type.kind) {
      case "Phi": {
        const operands = [];
        for (const operand of type.operands) {
          if (operand.kind === "Type" && operand.id === v.id) {
            continue;
          }
          const resolved = this.tryResolveType(v, operand);
          if (resolved === null) {
            return null;
          }
          operands.push(resolved);
        }
        return { kind: "Phi", operands };
      }
      case "Type": {
        const substitution = this.get(type);
        if (substitution !== type) {
          const resolved = this.tryResolveType(v, substitution);
          if (resolved !== null) {
            this.substitutions.set(type.id, resolved);
          }
          return resolved;
        }
        return type;
      }
      case "Property": {
        const objectType2 = this.tryResolveType(v, this.get(type.objectType));
        if (objectType2 === null) {
          return null;
        }
        return {
          kind: "Property",
          objectName: type.objectName,
          objectType: objectType2,
          propertyName: type.propertyName
        };
      }
      case "Function": {
        const returnType = this.tryResolveType(v, this.get(type.return));
        if (returnType === null) {
          return null;
        }
        return {
          kind: "Function",
          return: returnType,
          shapeId: type.shapeId,
          isConstructor: type.isConstructor
        };
      }
      case "ObjectMethod":
      case "Object":
      case "Primitive":
      case "Poly": {
        return type;
      }
      default: {
        assertExhaustive(type, `Unexpected type kind '${type.kind}'`);
      }
    }
  }
  occursCheck(v, type) {
    if (typeEquals(v, type)) return true;
    if (type.kind === "Type" && this.substitutions.has(type.id)) {
      return this.occursCheck(v, this.substitutions.get(type.id));
    }
    if (type.kind === "Phi") {
      return type.operands.some((o) => this.occursCheck(v, o));
    }
    if (type.kind === "Function") {
      return this.occursCheck(v, type.return);
    }
    return false;
  }
  get(type) {
    if (type.kind === "Type") {
      if (this.substitutions.has(type.id)) {
        return this.get(this.substitutions.get(type.id));
      }
    }
    if (type.kind === "Phi") {
      return { kind: "Phi", operands: type.operands.map((o) => this.get(o)) };
    }
    if (type.kind === "Function") {
      return {
        kind: "Function",
        isConstructor: type.isConstructor,
        shapeId: type.shapeId,
        return: this.get(type.return)
      };
    }
    return type;
  }
};
var RefLikeNameRE = /^(?:[a-zA-Z$_][a-zA-Z$_0-9]*)Ref$|^ref$/;
function isRefLikeName(t6) {
  return t6.propertyName.kind === "literal" && RefLikeNameRE.test(t6.objectName) && t6.propertyName.value === "current";
}
function tryUnionTypes(ty1, ty2) {
  let readonlyType;
  let otherType;
  if (ty1.kind === "Object" && ty1.shapeId === BuiltInMixedReadonlyId) {
    readonlyType = ty1;
    otherType = ty2;
  } else if (ty2.kind === "Object" && ty2.shapeId === BuiltInMixedReadonlyId) {
    readonlyType = ty2;
    otherType = ty1;
  } else {
    return null;
  }
  if (otherType.kind === "Primitive") {
    return readonlyType;
  } else if (otherType.kind === "Object" && otherType.shapeId === BuiltInArrayId) {
    return otherType;
  }
  return null;
}

// src/Validation/ValidateContextVariableLValues.ts
function validateContextVariableLValues(fn) {
  const identifierKinds = /* @__PURE__ */ new Map();
  validateContextVariableLValuesImpl(fn, identifierKinds);
}
function validateContextVariableLValuesImpl(fn, identifierKinds) {
  for (const [, block] of fn.body.blocks) {
    for (const instr of block.instructions) {
      const { value } = instr;
      switch (value.kind) {
        case "DeclareContext":
        case "StoreContext": {
          visit3(identifierKinds, value.lvalue.place, "context");
          break;
        }
        case "LoadContext": {
          visit3(identifierKinds, value.place, "context");
          break;
        }
        case "StoreLocal":
        case "DeclareLocal": {
          visit3(identifierKinds, value.lvalue.place, "local");
          break;
        }
        case "LoadLocal": {
          visit3(identifierKinds, value.place, "local");
          break;
        }
        case "PostfixUpdate":
        case "PrefixUpdate": {
          visit3(identifierKinds, value.lvalue, "local");
          break;
        }
        case "Destructure": {
          for (const lvalue of eachPatternOperand(value.lvalue.pattern)) {
            visit3(identifierKinds, lvalue, "destructure");
          }
          break;
        }
        case "ObjectMethod":
        case "FunctionExpression": {
          validateContextVariableLValuesImpl(
            value.loweredFunc.func,
            identifierKinds
          );
          break;
        }
        default: {
          for (const _ of eachInstructionValueLValue(value)) {
            CompilerError.throwTodo({
              reason: "ValidateContextVariableLValues: unhandled instruction variant",
              loc: value.loc,
              description: `Handle '${value.kind} lvalues`,
              suggestions: null
            });
          }
        }
      }
    }
  }
}
function visit3(identifiers, place, kind) {
  const prev = identifiers.get(place.identifier.id);
  if (prev !== void 0) {
    const wasContext = prev.kind === "context";
    const isContext = kind === "context";
    if (wasContext !== isContext) {
      if (prev.kind === "destructure" || kind === "destructure") {
        CompilerError.throwTodo({
          reason: `Support destructuring of context variables`,
          loc: kind === "destructure" ? place.loc : prev.place.loc,
          description: null,
          suggestions: null
        });
      }
      CompilerError.invariant(false, {
        reason: `Expected all references to a variable to be consistently local or context references`,
        loc: place.loc,
        description: `Identifier ${printPlace(
          place
        )} is referenced as a ${kind} variable, but was previously referenced as a ${prev} variable`,
        suggestions: null
      });
    }
  }
  identifiers.set(place.identifier.id, { place, kind });
}

// src/HIR/ComputeUnconditionalBlocks.ts
function computeUnconditionalBlocks(fn) {
  const unconditionalBlocks = /* @__PURE__ */ new Set();
  const dominators = computePostDominatorTree(fn, {
    /*
     * Hooks must only be in a consistent order for executions that return normally,
     * so we opt-in to viewing throw as a non-exit node.
     */
    includeThrowsAsExitNode: false
  });
  const exit = dominators.exit;
  let current = fn.body.entry;
  while (current !== null && current !== exit) {
    CompilerError.invariant(!unconditionalBlocks.has(current), {
      reason: "Internal error: non-terminating loop in ComputeUnconditionalBlocks",
      loc: null,
      suggestions: null
    });
    unconditionalBlocks.add(current);
    current = dominators.get(current);
  }
  return unconditionalBlocks;
}

// src/Validation/ValidateHooksUsage.ts
function joinKinds(a, b) {
  if (a === "Error" /* Error */ || b === "Error" /* Error */) {
    return "Error" /* Error */;
  } else if (a === "KnownHook" /* KnownHook */ || b === "KnownHook" /* KnownHook */) {
    return "KnownHook" /* KnownHook */;
  } else if (a === "PotentialHook" /* PotentialHook */ || b === "PotentialHook" /* PotentialHook */) {
    return "PotentialHook" /* PotentialHook */;
  } else if (a === "Global" /* Global */ || b === "Global" /* Global */) {
    return "Global" /* Global */;
  } else {
    return "Local" /* Local */;
  }
}
function validateHooksUsage(fn) {
  const unconditionalBlocks = computeUnconditionalBlocks(fn);
  const errors = new CompilerError();
  const errorsByPlace = /* @__PURE__ */ new Map();
  function recordError(loc, errorDetail) {
    if (typeof loc === "symbol") {
      errors.pushErrorDetail(errorDetail);
    } else {
      errorsByPlace.set(loc, errorDetail);
    }
  }
  function recordConditionalHookError(place) {
    setKind(place, "Error" /* Error */);
    const reason = "Hooks must always be called in a consistent order, and may not be called conditionally. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning)";
    const previousError = typeof place.loc !== "symbol" ? errorsByPlace.get(place.loc) : void 0;
    if (previousError === void 0 || previousError.reason !== reason) {
      recordError(
        place.loc,
        new CompilerErrorDetail({
          category: "Hooks" /* Hooks */,
          description: null,
          reason,
          loc: place.loc,
          severity: "InvalidReact" /* InvalidReact */,
          suggestions: null
        })
      );
    }
  }
  function recordInvalidHookUsageError(place) {
    const previousError = typeof place.loc !== "symbol" ? errorsByPlace.get(place.loc) : void 0;
    if (previousError === void 0) {
      recordError(
        place.loc,
        new CompilerErrorDetail({
          category: "Hooks" /* Hooks */,
          description: null,
          reason: "Hooks may not be referenced as normal values, they must be called. See https://react.dev/reference/rules/react-calls-components-and-hooks#never-pass-around-hooks-as-regular-values",
          loc: place.loc,
          severity: "InvalidReact" /* InvalidReact */,
          suggestions: null
        })
      );
    }
  }
  function recordDynamicHookUsageError(place) {
    const previousError = typeof place.loc !== "symbol" ? errorsByPlace.get(place.loc) : void 0;
    if (previousError === void 0) {
      recordError(
        place.loc,
        new CompilerErrorDetail({
          category: "Hooks" /* Hooks */,
          description: null,
          reason: "Hooks must be the same function on every render, but this value may change over time to a different function. See https://react.dev/reference/rules/react-calls-components-and-hooks#dont-dynamically-use-hooks",
          loc: place.loc,
          severity: "InvalidReact" /* InvalidReact */,
          suggestions: null
        })
      );
    }
  }
  const valueKinds = /* @__PURE__ */ new Map();
  function getKindForPlace(place) {
    const knownKind = valueKinds.get(place.identifier.id);
    if (place.identifier.name !== null && isHookName(place.identifier.name.value)) {
      return joinKinds(knownKind != null ? knownKind : "Local" /* Local */, "PotentialHook" /* PotentialHook */);
    } else {
      return knownKind != null ? knownKind : "Local" /* Local */;
    }
  }
  function visitPlace2(place) {
    const kind = valueKinds.get(place.identifier.id);
    if (kind === "KnownHook" /* KnownHook */) {
      recordInvalidHookUsageError(place);
    }
  }
  function setKind(place, kind) {
    valueKinds.set(place.identifier.id, kind);
  }
  for (const param of fn.params) {
    const place = param.kind === "Identifier" ? param : param.place;
    const kind = getKindForPlace(place);
    setKind(place, kind);
  }
  for (const [, block] of fn.body.blocks) {
    for (const phi of block.phis) {
      let kind = phi.place.identifier.name !== null && isHookName(phi.place.identifier.name.value) ? "PotentialHook" /* PotentialHook */ : "Local" /* Local */;
      for (const [, operand] of phi.operands) {
        const operandKind = valueKinds.get(operand.identifier.id);
        if (operandKind !== void 0) {
          kind = joinKinds(kind, operandKind);
        }
      }
      valueKinds.set(phi.place.identifier.id, kind);
    }
    for (const instr of block.instructions) {
      switch (instr.value.kind) {
        case "LoadGlobal": {
          if (getHookKind(fn.env, instr.lvalue.identifier) != null) {
            setKind(instr.lvalue, "KnownHook" /* KnownHook */);
          } else {
            setKind(instr.lvalue, "Global" /* Global */);
          }
          break;
        }
        case "LoadContext":
        case "LoadLocal": {
          visitPlace2(instr.value.place);
          const kind = getKindForPlace(instr.value.place);
          setKind(instr.lvalue, kind);
          break;
        }
        case "StoreLocal":
        case "StoreContext": {
          visitPlace2(instr.value.value);
          const kind = joinKinds(
            getKindForPlace(instr.value.value),
            getKindForPlace(instr.value.lvalue.place)
          );
          setKind(instr.value.lvalue.place, kind);
          setKind(instr.lvalue, kind);
          break;
        }
        case "ComputedLoad": {
          visitPlace2(instr.value.object);
          const kind = getKindForPlace(instr.value.object);
          setKind(instr.lvalue, joinKinds(getKindForPlace(instr.lvalue), kind));
          break;
        }
        case "PropertyLoad": {
          const objectKind = getKindForPlace(instr.value.object);
          const isHookProperty = typeof instr.value.property === "string" && isHookName(instr.value.property);
          let kind;
          switch (objectKind) {
            case "Error" /* Error */: {
              kind = "Error" /* Error */;
              break;
            }
            case "KnownHook" /* KnownHook */: {
              kind = isHookProperty ? "KnownHook" /* KnownHook */ : "Local" /* Local */;
              break;
            }
            case "PotentialHook" /* PotentialHook */: {
              kind = "PotentialHook" /* PotentialHook */;
              break;
            }
            case "Global" /* Global */: {
              kind = isHookProperty ? "KnownHook" /* KnownHook */ : "Global" /* Global */;
              break;
            }
            case "Local" /* Local */: {
              kind = isHookProperty ? "PotentialHook" /* PotentialHook */ : "Local" /* Local */;
              break;
            }
            default: {
              assertExhaustive(objectKind, `Unexpected kind \`${objectKind}\``);
            }
          }
          setKind(instr.lvalue, kind);
          break;
        }
        case "CallExpression": {
          const calleeKind = getKindForPlace(instr.value.callee);
          const isHookCallee = calleeKind === "KnownHook" /* KnownHook */ || calleeKind === "PotentialHook" /* PotentialHook */;
          if (isHookCallee && !unconditionalBlocks.has(block.id)) {
            recordConditionalHookError(instr.value.callee);
          } else if (calleeKind === "PotentialHook" /* PotentialHook */) {
            recordDynamicHookUsageError(instr.value.callee);
          }
          for (const operand of eachInstructionOperand(instr)) {
            if (operand === instr.value.callee) {
              continue;
            }
            visitPlace2(operand);
          }
          break;
        }
        case "MethodCall": {
          const calleeKind = getKindForPlace(instr.value.property);
          const isHookCallee = calleeKind === "KnownHook" /* KnownHook */ || calleeKind === "PotentialHook" /* PotentialHook */;
          if (isHookCallee && !unconditionalBlocks.has(block.id)) {
            recordConditionalHookError(instr.value.property);
          } else if (calleeKind === "PotentialHook" /* PotentialHook */) {
            recordDynamicHookUsageError(instr.value.property);
          }
          for (const operand of eachInstructionOperand(instr)) {
            if (operand === instr.value.property) {
              continue;
            }
            visitPlace2(operand);
          }
          break;
        }
        case "Destructure": {
          visitPlace2(instr.value.value);
          const objectKind = getKindForPlace(instr.value.value);
          for (const lvalue of eachInstructionLValue(instr)) {
            const isHookProperty = lvalue.identifier.name !== null && isHookName(lvalue.identifier.name.value);
            let kind;
            switch (objectKind) {
              case "Error" /* Error */: {
                kind = "Error" /* Error */;
                break;
              }
              case "KnownHook" /* KnownHook */: {
                kind = "KnownHook" /* KnownHook */;
                break;
              }
              case "PotentialHook" /* PotentialHook */: {
                kind = "PotentialHook" /* PotentialHook */;
                break;
              }
              case "Global" /* Global */: {
                kind = isHookProperty ? "KnownHook" /* KnownHook */ : "Global" /* Global */;
                break;
              }
              case "Local" /* Local */: {
                kind = isHookProperty ? "PotentialHook" /* PotentialHook */ : "Local" /* Local */;
                break;
              }
              default: {
                assertExhaustive(
                  objectKind,
                  `Unexpected kind \`${objectKind}\``
                );
              }
            }
            setKind(lvalue, kind);
          }
          break;
        }
        case "ObjectMethod":
        case "FunctionExpression": {
          visitFunctionExpression(errors, instr.value.loweredFunc.func);
          break;
        }
        default: {
          for (const operand of eachInstructionOperand(instr)) {
            visitPlace2(operand);
          }
          for (const lvalue of eachInstructionLValue(instr)) {
            const kind = getKindForPlace(lvalue);
            setKind(lvalue, kind);
          }
        }
      }
    }
    for (const operand of eachTerminalOperand(block.terminal)) {
      visitPlace2(operand);
    }
  }
  for (const [, error] of errorsByPlace) {
    errors.pushErrorDetail(error);
  }
  return errors.asResult();
}
function visitFunctionExpression(errors, fn) {
  for (const [, block] of fn.body.blocks) {
    for (const instr of block.instructions) {
      switch (instr.value.kind) {
        case "ObjectMethod":
        case "FunctionExpression": {
          visitFunctionExpression(errors, instr.value.loweredFunc.func);
          break;
        }
        case "MethodCall":
        case "CallExpression": {
          const callee = instr.value.kind === "CallExpression" ? instr.value.callee : instr.value.property;
          const hookKind = getHookKind(fn.env, callee.identifier);
          if (hookKind != null) {
            errors.pushErrorDetail(
              new CompilerErrorDetail({
                category: "Hooks" /* Hooks */,
                severity: "InvalidReact" /* InvalidReact */,
                reason: "Hooks must be called at the top level in the body of a function component or custom hook, and may not be called within function expressions. See the Rules of Hooks (https://react.dev/warnings/invalid-hook-call-warning)",
                loc: callee.loc,
                description: `Cannot call ${hookKind === "Custom" ? "hook" : hookKind} within a function expression`,
                suggestions: null
              })
            );
          }
          break;
        }
      }
    }
  }
}

// src/Validation/ValidateMemoizedEffectDependencies.ts
function validateMemoizedEffectDependencies(fn) {
  const errors = new CompilerError();
  visitReactiveFunction(fn, new Visitor10(), errors);
  return errors.asResult();
}
var Visitor10 = class extends ReactiveFunctionVisitor {
  constructor() {
    super(...arguments);
    this.scopes = /* @__PURE__ */ new Set();
  }
  visitScope(scopeBlock, state) {
    this.traverseScope(scopeBlock, state);
    let areDependenciesMemoized = true;
    for (const dep of scopeBlock.scope.dependencies) {
      if (isUnmemoized(dep.identifier, this.scopes)) {
        areDependenciesMemoized = false;
        break;
      }
    }
    if (areDependenciesMemoized) {
      this.scopes.add(scopeBlock.scope.id);
      for (const id of scopeBlock.scope.merged) {
        this.scopes.add(id);
      }
    }
  }
  visitInstruction(instruction, state) {
    this.traverseInstruction(instruction, state);
    if (instruction.value.kind === "CallExpression" && isEffectHook(instruction.value.callee.identifier) && instruction.value.args.length >= 2) {
      const deps = instruction.value.args[1];
      if (deps.kind === "Identifier" && /*
       * TODO: isMutable is not safe to call here as it relies on identifier mutableRange which is no longer valid at this point
       * in the pipeline
       */
      (isMutable2(instruction, deps) || isUnmemoized(deps.identifier, this.scopes))) {
        state.push({
          category: "EffectDependencies" /* EffectDependencies */,
          reason: "React Compiler has skipped optimizing this component because the effect dependencies could not be memoized. Unmemoized effect dependencies can trigger an infinite loop or other unexpected behavior",
          description: null,
          severity: "CannotPreserveMemoization" /* CannotPreserveMemoization */,
          loc: typeof instruction.loc !== "symbol" ? instruction.loc : null,
          suggestions: null
        });
      }
    }
  }
};
function isUnmemoized(operand, scopes) {
  return operand.scope != null && !scopes.has(operand.scope.id);
}
function isEffectHook(identifier4) {
  return isUseEffectHookType(identifier4) || isUseLayoutEffectHookType(identifier4) || isUseInsertionEffectHookType(identifier4);
}

// src/Validation/ValidateNoCapitalizedCalls.ts
function validateNoCapitalizedCalls(fn) {
  var _a;
  const envConfig = fn.env.config;
  const ALLOW_LIST = /* @__PURE__ */ new Set([
    ...DEFAULT_GLOBALS.keys(),
    ...(_a = envConfig.validateNoCapitalizedCalls) != null ? _a : []
  ]);
  const hookPattern = envConfig.hookPattern != null ? new RegExp(envConfig.hookPattern) : null;
  const isAllowed = (name) => {
    return ALLOW_LIST.has(name) || hookPattern != null && hookPattern.test(name);
  };
  const errors = new CompilerError();
  const capitalLoadGlobals = /* @__PURE__ */ new Map();
  const capitalizedProperties = /* @__PURE__ */ new Map();
  const reason = "Capitalized functions are reserved for components, which must be invoked with JSX. If this is a component, render it with JSX. Otherwise, ensure that it has no hook calls and rename it to begin with a lowercase letter. Alternatively, if you know for a fact that this function is not a component, you can allowlist it via the compiler config";
  for (const [, block] of fn.body.blocks) {
    for (const { lvalue, value } of block.instructions) {
      switch (value.kind) {
        case "LoadGlobal": {
          if (value.binding.name != "" && /^[A-Z]/.test(value.binding.name) && // We don't want to flag CONSTANTS()
          !(value.binding.name.toUpperCase() === value.binding.name) && !isAllowed(value.binding.name)) {
            capitalLoadGlobals.set(lvalue.identifier.id, value.binding.name);
          }
          break;
        }
        case "CallExpression": {
          const calleeIdentifier = value.callee.identifier.id;
          const calleeName = capitalLoadGlobals.get(calleeIdentifier);
          if (calleeName != null) {
            CompilerError.throwInvalidReact({
              category: "CapitalizedCalls" /* CapitalizedCalls */,
              reason,
              description: `${calleeName} may be a component.`,
              loc: value.loc,
              suggestions: null
            });
          }
          break;
        }
        case "PropertyLoad": {
          if (typeof value.property === "string" && /^[A-Z]/.test(value.property)) {
            capitalizedProperties.set(lvalue.identifier.id, value.property);
          }
          break;
        }
        case "MethodCall": {
          const propertyIdentifier = value.property.identifier.id;
          const propertyName = capitalizedProperties.get(propertyIdentifier);
          if (propertyName != null) {
            errors.push({
              category: "CapitalizedCalls" /* CapitalizedCalls */,
              severity: "InvalidReact" /* InvalidReact */,
              reason,
              description: `${propertyName} may be a component.`,
              loc: value.loc,
              suggestions: null
            });
          }
          break;
        }
      }
    }
  }
  return errors.asResult();
}

// src/Validation/ValidateNoRefAccessInRender.ts
var opaqueRefId = Symbol();
function makeRefId(id) {
  CompilerError.invariant(id >= 0 && Number.isInteger(id), {
    reason: "Expected identifier id to be a non-negative integer",
    description: null,
    loc: null,
    suggestions: null
  });
  return id;
}
var _refId = 0;
function nextRefId() {
  return makeRefId(_refId++);
}
var _changed, _data, _temporaries2;
var Env = class {
  constructor() {
    __privateAdd(this, _changed, false);
    __privateAdd(this, _data, /* @__PURE__ */ new Map());
    __privateAdd(this, _temporaries2, /* @__PURE__ */ new Map());
  }
  lookup(place) {
    var _a;
    return (_a = __privateGet(this, _temporaries2).get(place.identifier.id)) != null ? _a : place;
  }
  define(place, value) {
    __privateGet(this, _temporaries2).set(place.identifier.id, value);
  }
  resetChanged() {
    __privateSet(this, _changed, false);
  }
  hasChanged() {
    return __privateGet(this, _changed);
  }
  get(key2) {
    var _a, _b;
    const operandId = (_b = (_a = __privateGet(this, _temporaries2).get(key2)) == null ? void 0 : _a.identifier.id) != null ? _b : key2;
    return __privateGet(this, _data).get(operandId);
  }
  set(key2, value) {
    var _a, _b;
    const operandId = (_b = (_a = __privateGet(this, _temporaries2).get(key2)) == null ? void 0 : _a.identifier.id) != null ? _b : key2;
    const cur = __privateGet(this, _data).get(operandId);
    const widenedValue = joinRefAccessTypes(value, cur != null ? cur : { kind: "None" });
    if (!(cur == null && widenedValue.kind === "None") && (cur == null || !tyEqual(cur, widenedValue))) {
      __privateSet(this, _changed, true);
    }
    __privateGet(this, _data).set(operandId, widenedValue);
    return this;
  }
};
_changed = new WeakMap();
_data = new WeakMap();
_temporaries2 = new WeakMap();
function validateNoRefAccessInRender(fn) {
  const env = new Env();
  collectTemporariesSidemap2(fn, env);
  return validateNoRefAccessInRenderImpl(fn, env).map((_) => void 0);
}
function collectTemporariesSidemap2(fn, env) {
  for (const block of fn.body.blocks.values()) {
    for (const instr of block.instructions) {
      const { lvalue, value } = instr;
      switch (value.kind) {
        case "LoadLocal": {
          const temp = env.lookup(value.place);
          if (temp != null) {
            env.define(lvalue, temp);
          }
          break;
        }
        case "StoreLocal": {
          const temp = env.lookup(value.value);
          if (temp != null) {
            env.define(lvalue, temp);
            env.define(value.lvalue.place, temp);
          }
          break;
        }
        case "PropertyLoad": {
          if (isUseRefType(value.object.identifier) && value.property === "current") {
            continue;
          }
          const temp = env.lookup(value.object);
          if (temp != null) {
            env.define(lvalue, temp);
          }
          break;
        }
      }
    }
  }
}
function refTypeOfType(place) {
  if (isRefValueType(place.identifier)) {
    return { kind: "RefValue" };
  } else if (isUseRefType(place.identifier)) {
    return { kind: "Ref", refId: nextRefId() };
  } else {
    return { kind: "None" };
  }
}
function tyEqual(a, b) {
  if (a.kind !== b.kind) {
    return false;
  }
  switch (a.kind) {
    case "None":
      return true;
    case "Ref":
      return true;
    case "Nullable":
      return true;
    case "Guard":
      CompilerError.invariant(b.kind === "Guard", {
        reason: "Expected ref value",
        loc: null
      });
      return a.refId === b.refId;
    case "RefValue":
      CompilerError.invariant(b.kind === "RefValue", {
        reason: "Expected ref value",
        loc: null
      });
      return a.loc == b.loc;
    case "Structure": {
      CompilerError.invariant(b.kind === "Structure", {
        reason: "Expected structure",
        loc: null
      });
      const fnTypesEqual = a.fn === null && b.fn === null || a.fn !== null && b.fn !== null && a.fn.readRefEffect === b.fn.readRefEffect && tyEqual(a.fn.returnType, b.fn.returnType);
      return fnTypesEqual && (a.value === b.value || a.value !== null && b.value !== null && tyEqual(a.value, b.value));
    }
  }
}
function joinRefAccessTypes(...types) {
  function joinRefAccessRefTypes(a, b) {
    if (a.kind === "RefValue") {
      if (b.kind === "RefValue" && a.refId === b.refId) {
        return a;
      }
      return { kind: "RefValue" };
    } else if (b.kind === "RefValue") {
      return b;
    } else if (a.kind === "Ref" || b.kind === "Ref") {
      if (a.kind === "Ref" && b.kind === "Ref" && a.refId === b.refId) {
        return a;
      }
      return { kind: "Ref", refId: nextRefId() };
    } else {
      CompilerError.invariant(
        a.kind === "Structure" && b.kind === "Structure",
        {
          reason: "Expected structure",
          loc: null
        }
      );
      const fn = a.fn === null ? b.fn : b.fn === null ? a.fn : {
        readRefEffect: a.fn.readRefEffect || b.fn.readRefEffect,
        returnType: joinRefAccessTypes(
          a.fn.returnType,
          b.fn.returnType
        )
      };
      const value = a.value === null ? b.value : b.value === null ? a.value : joinRefAccessRefTypes(a.value, b.value);
      return {
        kind: "Structure",
        fn,
        value
      };
    }
  }
  return types.reduce(
    (a, b) => {
      if (a.kind === "None") {
        return b;
      } else if (b.kind === "None") {
        return a;
      } else if (a.kind === "Guard") {
        if (b.kind === "Guard" && a.refId === b.refId) {
          return a;
        } else if (b.kind === "Nullable" || b.kind === "Guard") {
          return { kind: "None" };
        } else {
          return b;
        }
      } else if (b.kind === "Guard") {
        if (a.kind === "Nullable") {
          return { kind: "None" };
        } else {
          return b;
        }
      } else if (a.kind === "Nullable") {
        return b;
      } else if (b.kind === "Nullable") {
        return a;
      } else {
        return joinRefAccessRefTypes(a, b);
      }
    },
    { kind: "None" }
  );
}
function validateNoRefAccessInRenderImpl(fn, env) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i;
  let returnValues = [];
  let place;
  for (const param of fn.params) {
    if (param.kind === "Identifier") {
      place = param;
    } else {
      place = param.place;
    }
    const type = refTypeOfType(place);
    env.set(place.identifier.id, type);
  }
  const interpolatedAsJsx = /* @__PURE__ */ new Set();
  for (const block of fn.body.blocks.values()) {
    for (const instr of block.instructions) {
      const { value } = instr;
      if (value.kind === "JsxExpression" || value.kind === "JsxFragment") {
        if (value.children != null) {
          for (const child of value.children) {
            interpolatedAsJsx.add(child.identifier.id);
          }
        }
      }
    }
  }
  for (let i = 0; (i == 0 || env.hasChanged()) && i < 10; i++) {
    env.resetChanged();
    returnValues = [];
    const safeBlocks = [];
    const errors = new CompilerError();
    for (const [, block] of fn.body.blocks) {
      retainWhere(safeBlocks, (entry) => entry.block !== block.id);
      for (const phi of block.phis) {
        env.set(
          phi.place.identifier.id,
          joinRefAccessTypes(
            ...Array(...phi.operands.values()).map(
              (operand) => {
                var _a2;
                return (_a2 = env.get(operand.identifier.id)) != null ? _a2 : { kind: "None" };
              }
            )
          )
        );
      }
      for (const instr of block.instructions) {
        switch (instr.value.kind) {
          case "JsxExpression":
          case "JsxFragment": {
            for (const operand of eachInstructionValueOperand(instr.value)) {
              validateNoDirectRefValueAccess(errors, operand, env);
            }
            break;
          }
          case "ComputedLoad":
          case "PropertyLoad": {
            if (instr.value.kind === "ComputedLoad") {
              validateNoDirectRefValueAccess(errors, instr.value.property, env);
            }
            const objType = env.get(instr.value.object.identifier.id);
            let lookupType = null;
            if ((objType == null ? void 0 : objType.kind) === "Structure") {
              lookupType = objType.value;
            } else if ((objType == null ? void 0 : objType.kind) === "Ref") {
              lookupType = {
                kind: "RefValue",
                loc: instr.loc,
                refId: objType.refId
              };
            }
            env.set(
              instr.lvalue.identifier.id,
              lookupType != null ? lookupType : refTypeOfType(instr.lvalue)
            );
            break;
          }
          case "TypeCastExpression": {
            env.set(
              instr.lvalue.identifier.id,
              (_a = env.get(instr.value.value.identifier.id)) != null ? _a : refTypeOfType(instr.lvalue)
            );
            break;
          }
          case "LoadContext":
          case "LoadLocal": {
            env.set(
              instr.lvalue.identifier.id,
              (_b = env.get(instr.value.place.identifier.id)) != null ? _b : refTypeOfType(instr.lvalue)
            );
            break;
          }
          case "StoreContext":
          case "StoreLocal": {
            env.set(
              instr.value.lvalue.place.identifier.id,
              (_c = env.get(instr.value.value.identifier.id)) != null ? _c : refTypeOfType(instr.value.lvalue.place)
            );
            env.set(
              instr.lvalue.identifier.id,
              (_d = env.get(instr.value.value.identifier.id)) != null ? _d : refTypeOfType(instr.lvalue)
            );
            break;
          }
          case "Destructure": {
            const objType = env.get(instr.value.value.identifier.id);
            let lookupType = null;
            if ((objType == null ? void 0 : objType.kind) === "Structure") {
              lookupType = objType.value;
            }
            env.set(
              instr.lvalue.identifier.id,
              lookupType != null ? lookupType : refTypeOfType(instr.lvalue)
            );
            for (const lval of eachPatternOperand(instr.value.lvalue.pattern)) {
              env.set(lval.identifier.id, lookupType != null ? lookupType : refTypeOfType(lval));
            }
            break;
          }
          case "ObjectMethod":
          case "FunctionExpression": {
            let returnType = { kind: "None" };
            let readRefEffect = false;
            const result = validateNoRefAccessInRenderImpl(
              instr.value.loweredFunc.func,
              env
            );
            if (result.isOk()) {
              returnType = result.unwrap();
            } else if (result.isErr()) {
              readRefEffect = true;
            }
            env.set(instr.lvalue.identifier.id, {
              kind: "Structure",
              fn: {
                readRefEffect,
                returnType
              },
              value: null
            });
            break;
          }
          case "MethodCall":
          case "CallExpression": {
            const callee = instr.value.kind === "CallExpression" ? instr.value.callee : instr.value.property;
            const hookKind = getHookKindForType(fn.env, callee.identifier.type);
            let returnType = { kind: "None" };
            const fnType = env.get(callee.identifier.id);
            let didError = false;
            if ((fnType == null ? void 0 : fnType.kind) === "Structure" && fnType.fn !== null) {
              returnType = fnType.fn.returnType;
              if (fnType.fn.readRefEffect) {
                didError = true;
                errors.pushDiagnostic(
                  CompilerDiagnostic.create({
                    category: "Refs" /* Refs */,
                    severity: "InvalidReact" /* InvalidReact */,
                    reason: "Cannot access refs during render",
                    description: ERROR_DESCRIPTION
                  }).withDetail({
                    kind: "error",
                    loc: callee.loc,
                    message: `This function accesses a ref value`
                  })
                );
              }
            }
            if (!didError) {
              const isRefLValue = isUseRefType(instr.lvalue.identifier);
              for (const operand of eachInstructionValueOperand(instr.value)) {
                if (isRefLValue || hookKind != null && hookKind !== "useState" && hookKind !== "useReducer") {
                  validateNoDirectRefValueAccess(errors, operand, env);
                } else if (interpolatedAsJsx.has(instr.lvalue.identifier.id)) {
                  validateNoRefValueAccess(errors, env, operand);
                } else {
                  validateNoRefPassedToFunction(
                    errors,
                    env,
                    operand,
                    operand.loc
                  );
                }
              }
            }
            env.set(instr.lvalue.identifier.id, returnType);
            break;
          }
          case "ObjectExpression":
          case "ArrayExpression": {
            const types = [];
            for (const operand of eachInstructionValueOperand(instr.value)) {
              validateNoDirectRefValueAccess(errors, operand, env);
              types.push((_e = env.get(operand.identifier.id)) != null ? _e : { kind: "None" });
            }
            const value = joinRefAccessTypes(...types);
            if (value.kind === "None" || value.kind === "Guard" || value.kind === "Nullable") {
              env.set(instr.lvalue.identifier.id, { kind: "None" });
            } else {
              env.set(instr.lvalue.identifier.id, {
                kind: "Structure",
                value,
                fn: null
              });
            }
            break;
          }
          case "PropertyDelete":
          case "PropertyStore":
          case "ComputedDelete":
          case "ComputedStore": {
            const target = env.get(instr.value.object.identifier.id);
            let safe = null;
            if (instr.value.kind === "PropertyStore" && target != null && target.kind === "Ref") {
              safe = safeBlocks.find((entry) => entry.ref === target.refId);
            }
            if (safe != null) {
              retainWhere(safeBlocks, (entry) => entry !== safe);
            } else {
              validateNoRefUpdate(errors, env, instr.value.object, instr.loc);
            }
            if (instr.value.kind === "ComputedDelete" || instr.value.kind === "ComputedStore") {
              validateNoRefValueAccess(errors, env, instr.value.property);
            }
            if (instr.value.kind === "ComputedStore" || instr.value.kind === "PropertyStore") {
              validateNoDirectRefValueAccess(errors, instr.value.value, env);
              const type = env.get(instr.value.value.identifier.id);
              if (type != null && type.kind === "Structure") {
                let objectType2 = type;
                if (target != null) {
                  objectType2 = joinRefAccessTypes(objectType2, target);
                }
                env.set(instr.value.object.identifier.id, objectType2);
              }
            }
            break;
          }
          case "StartMemoize":
          case "FinishMemoize":
            break;
          case "Primitive": {
            if (instr.value.value == null) {
              env.set(instr.lvalue.identifier.id, { kind: "Nullable" });
            }
            break;
          }
          case "BinaryExpression": {
            const left = env.get(instr.value.left.identifier.id);
            const right = env.get(instr.value.right.identifier.id);
            let nullish = false;
            let refId = null;
            if ((left == null ? void 0 : left.kind) === "RefValue" && left.refId != null) {
              refId = left.refId;
            } else if ((right == null ? void 0 : right.kind) === "RefValue" && right.refId != null) {
              refId = right.refId;
            }
            if ((left == null ? void 0 : left.kind) === "Nullable") {
              nullish = true;
            } else if ((right == null ? void 0 : right.kind) === "Nullable") {
              nullish = true;
            }
            if (refId !== null && nullish) {
              env.set(instr.lvalue.identifier.id, { kind: "Guard", refId });
            } else {
              for (const operand of eachInstructionValueOperand(instr.value)) {
                validateNoRefValueAccess(errors, env, operand);
              }
            }
            break;
          }
          default: {
            for (const operand of eachInstructionValueOperand(instr.value)) {
              validateNoRefValueAccess(errors, env, operand);
            }
            break;
          }
        }
        for (const operand of eachInstructionOperand(instr)) {
          guardCheck(errors, operand, env);
        }
        if (isUseRefType(instr.lvalue.identifier) && ((_f = env.get(instr.lvalue.identifier.id)) == null ? void 0 : _f.kind) !== "Ref") {
          env.set(
            instr.lvalue.identifier.id,
            joinRefAccessTypes(
              (_g = env.get(instr.lvalue.identifier.id)) != null ? _g : { kind: "None" },
              { kind: "Ref", refId: nextRefId() }
            )
          );
        }
        if (isRefValueType(instr.lvalue.identifier) && ((_h = env.get(instr.lvalue.identifier.id)) == null ? void 0 : _h.kind) !== "RefValue") {
          env.set(
            instr.lvalue.identifier.id,
            joinRefAccessTypes(
              (_i = env.get(instr.lvalue.identifier.id)) != null ? _i : { kind: "None" },
              { kind: "RefValue", loc: instr.loc }
            )
          );
        }
      }
      if (block.terminal.kind === "if") {
        const test = env.get(block.terminal.test.identifier.id);
        if ((test == null ? void 0 : test.kind) === "Guard" && safeBlocks.find((entry) => entry.ref === test.refId) == null) {
          safeBlocks.push({ block: block.terminal.fallthrough, ref: test.refId });
        }
      }
      for (const operand of eachTerminalOperand(block.terminal)) {
        if (block.terminal.kind !== "return") {
          validateNoRefValueAccess(errors, env, operand);
          if (block.terminal.kind !== "if") {
            guardCheck(errors, operand, env);
          }
        } else {
          validateNoDirectRefValueAccess(errors, operand, env);
          guardCheck(errors, operand, env);
          returnValues.push(env.get(operand.identifier.id));
        }
      }
    }
    if (errors.hasErrors()) {
      return Err(errors);
    }
  }
  CompilerError.invariant(!env.hasChanged(), {
    reason: "Ref type environment did not converge",
    loc: null
  });
  return Ok(
    joinRefAccessTypes(
      ...returnValues.filter((env2) => env2 !== void 0)
    )
  );
}
function destructure(type) {
  if ((type == null ? void 0 : type.kind) === "Structure" && type.value !== null) {
    return destructure(type.value);
  }
  return type;
}
function guardCheck(errors, operand, env) {
  var _a;
  if (((_a = env.get(operand.identifier.id)) == null ? void 0 : _a.kind) === "Guard") {
    errors.pushDiagnostic(
      CompilerDiagnostic.create({
        category: "Refs" /* Refs */,
        severity: "InvalidReact" /* InvalidReact */,
        reason: "Cannot access refs during render",
        description: ERROR_DESCRIPTION
      }).withDetail({
        kind: "error",
        loc: operand.loc,
        message: `Cannot access ref value during render`
      })
    );
  }
}
function validateNoRefValueAccess(errors, env, operand) {
  var _a;
  const type = destructure(env.get(operand.identifier.id));
  if ((type == null ? void 0 : type.kind) === "RefValue" || (type == null ? void 0 : type.kind) === "Structure" && ((_a = type.fn) == null ? void 0 : _a.readRefEffect)) {
    errors.pushDiagnostic(
      CompilerDiagnostic.create({
        category: "Refs" /* Refs */,
        severity: "InvalidReact" /* InvalidReact */,
        reason: "Cannot access refs during render",
        description: ERROR_DESCRIPTION
      }).withDetail({
        kind: "error",
        loc: type.kind === "RefValue" && type.loc || operand.loc,
        message: `Cannot access ref value during render`
      })
    );
  }
}
function validateNoRefPassedToFunction(errors, env, operand, loc) {
  var _a;
  const type = destructure(env.get(operand.identifier.id));
  if ((type == null ? void 0 : type.kind) === "Ref" || (type == null ? void 0 : type.kind) === "RefValue" || (type == null ? void 0 : type.kind) === "Structure" && ((_a = type.fn) == null ? void 0 : _a.readRefEffect)) {
    errors.pushDiagnostic(
      CompilerDiagnostic.create({
        category: "Refs" /* Refs */,
        severity: "InvalidReact" /* InvalidReact */,
        reason: "Cannot access refs during render",
        description: ERROR_DESCRIPTION
      }).withDetail({
        kind: "error",
        loc: type.kind === "RefValue" && type.loc || loc,
        message: `Passing a ref to a function may read its value during render`
      })
    );
  }
}
function validateNoRefUpdate(errors, env, operand, loc) {
  const type = destructure(env.get(operand.identifier.id));
  if ((type == null ? void 0 : type.kind) === "Ref" || (type == null ? void 0 : type.kind) === "RefValue") {
    errors.pushDiagnostic(
      CompilerDiagnostic.create({
        category: "Refs" /* Refs */,
        severity: "InvalidReact" /* InvalidReact */,
        reason: "Cannot access refs during render",
        description: ERROR_DESCRIPTION
      }).withDetail({
        kind: "error",
        loc: type.kind === "RefValue" && type.loc || loc,
        message: `Cannot update ref during render`
      })
    );
  }
}
function validateNoDirectRefValueAccess(errors, operand, env) {
  var _a;
  const type = destructure(env.get(operand.identifier.id));
  if ((type == null ? void 0 : type.kind) === "RefValue") {
    errors.pushDiagnostic(
      CompilerDiagnostic.create({
        category: "Refs" /* Refs */,
        severity: "InvalidReact" /* InvalidReact */,
        reason: "Cannot access refs during render",
        description: ERROR_DESCRIPTION
      }).withDetail({
        kind: "error",
        loc: (_a = type.loc) != null ? _a : operand.loc,
        message: `Cannot access ref value during render`
      })
    );
  }
}
var ERROR_DESCRIPTION = "React refs are values that are not needed for rendering. Refs should only be accessed outside of render, such as in event handlers or effects. Accessing a ref value (the `current` property) during render can cause your component not to update as expected (https://react.dev/reference/react/useRef)";

// src/Validation/ValidateNoSetStateInRender.ts
function validateNoSetStateInRender(fn) {
  const unconditionalSetStateFunctions = /* @__PURE__ */ new Set();
  return validateNoSetStateInRenderImpl(fn, unconditionalSetStateFunctions);
}
function validateNoSetStateInRenderImpl(fn, unconditionalSetStateFunctions) {
  const unconditionalBlocks = computeUnconditionalBlocks(fn);
  let activeManualMemoId = null;
  const errors = new CompilerError();
  for (const [, block] of fn.body.blocks) {
    for (const instr of block.instructions) {
      switch (instr.value.kind) {
        case "LoadLocal": {
          if (unconditionalSetStateFunctions.has(instr.value.place.identifier.id)) {
            unconditionalSetStateFunctions.add(instr.lvalue.identifier.id);
          }
          break;
        }
        case "StoreLocal": {
          if (unconditionalSetStateFunctions.has(instr.value.value.identifier.id)) {
            unconditionalSetStateFunctions.add(
              instr.value.lvalue.place.identifier.id
            );
            unconditionalSetStateFunctions.add(instr.lvalue.identifier.id);
          }
          break;
        }
        case "ObjectMethod":
        case "FunctionExpression": {
          if (
            // faster-path to check if the function expression references a setState
            [...eachInstructionValueOperand(instr.value)].some(
              (operand) => isSetStateType(operand.identifier) || unconditionalSetStateFunctions.has(operand.identifier.id)
            ) && // if yes, does it unconditonally call it?
            validateNoSetStateInRenderImpl(
              instr.value.loweredFunc.func,
              unconditionalSetStateFunctions
            ).isErr()
          ) {
            unconditionalSetStateFunctions.add(instr.lvalue.identifier.id);
          }
          break;
        }
        case "StartMemoize": {
          CompilerError.invariant(activeManualMemoId === null, {
            reason: "Unexpected nested StartMemoize instructions",
            loc: instr.value.loc
          });
          activeManualMemoId = instr.value.manualMemoId;
          break;
        }
        case "FinishMemoize": {
          CompilerError.invariant(
            activeManualMemoId === instr.value.manualMemoId,
            {
              reason: "Expected FinishMemoize to align with previous StartMemoize instruction",
              loc: instr.value.loc
            }
          );
          activeManualMemoId = null;
          break;
        }
        case "CallExpression": {
          const callee = instr.value.callee;
          if (isSetStateType(callee.identifier) || unconditionalSetStateFunctions.has(callee.identifier.id)) {
            if (activeManualMemoId !== null) {
              errors.pushDiagnostic(
                CompilerDiagnostic.create({
                  category: "RenderSetState" /* RenderSetState */,
                  reason: "Calling setState from useMemo may trigger an infinite loop",
                  description: "Each time the memo callback is evaluated it will change state. This can cause a memoization dependency to change, running the memo function again and causing an infinite loop. Instead of setting state in useMemo(), prefer deriving the value during render. (https://react.dev/reference/react/useState)",
                  severity: "InvalidReact" /* InvalidReact */,
                  suggestions: null
                }).withDetail({
                  kind: "error",
                  loc: callee.loc,
                  message: "Found setState() within useMemo()"
                })
              );
            } else if (unconditionalBlocks.has(block.id)) {
              errors.pushDiagnostic(
                CompilerDiagnostic.create({
                  category: "RenderSetState" /* RenderSetState */,
                  reason: "Calling setState during render may trigger an infinite loop",
                  description: "Calling setState during render will trigger another render, and can lead to infinite loops. (https://react.dev/reference/react/useState)",
                  severity: "InvalidReact" /* InvalidReact */,
                  suggestions: null
                }).withDetail({
                  kind: "error",
                  loc: callee.loc,
                  message: "Found setState() in render"
                })
              );
            }
          }
          break;
        }
      }
    }
  }
  return errors.asResult();
}

// src/Validation/ValidatePreservedManualMemoization.ts
function validatePreservedManualMemoization(fn) {
  const state = {
    errors: new CompilerError(),
    manualMemoState: null
  };
  visitReactiveFunction(fn, new Visitor11(), state);
  return state.errors.asResult();
}
var DEBUG5 = false;
function prettyPrintScopeDependency(val) {
  var _a;
  let rootStr;
  if (((_a = val.identifier.name) == null ? void 0 : _a.kind) === "named") {
    rootStr = val.identifier.name.value;
  } else {
    rootStr = "[unnamed]";
  }
  return `${rootStr}${val.path.map((v) => `${v.optional ? "?." : "."}${v.property}`).join("")}`;
}
function merge2(a, b) {
  return Math.max(a, b);
}
function getCompareDependencyResultDescription(result) {
  switch (result) {
    case 0 /* Ok */:
      return "Dependencies equal";
    case 1 /* RootDifference */:
    case 2 /* PathDifference */:
      return "Inferred different dependency than source";
    case 4 /* RefAccessDifference */:
      return "Differences in ref.current access";
    case 3 /* Subpath */:
      return "Inferred less specific property than source";
  }
}
function compareDeps(inferred, source2) {
  const rootsEqual = inferred.root.kind === "Global" && source2.root.kind === "Global" && inferred.root.identifierName === source2.root.identifierName || inferred.root.kind === "NamedLocal" && source2.root.kind === "NamedLocal" && inferred.root.value.identifier.id === source2.root.value.identifier.id;
  if (!rootsEqual) {
    return 1 /* RootDifference */;
  }
  let isSubpath = true;
  for (let i = 0; i < Math.min(inferred.path.length, source2.path.length); i++) {
    if (inferred.path[i].property !== source2.path[i].property) {
      isSubpath = false;
      break;
    } else if (inferred.path[i].optional !== source2.path[i].optional) {
      return 2 /* PathDifference */;
    }
  }
  if (isSubpath && (source2.path.length === inferred.path.length || inferred.path.length >= source2.path.length && !inferred.path.some((token2) => token2.property === "current"))) {
    return 0 /* Ok */;
  } else {
    if (isSubpath) {
      if (source2.path.some((token2) => token2.property === "current") || inferred.path.some((token2) => token2.property === "current")) {
        return 4 /* RefAccessDifference */;
      } else {
        return 3 /* Subpath */;
      }
    } else {
      return 2 /* PathDifference */;
    }
  }
}
function validateInferredDep(dep, temporaries, declsWithinMemoBlock, validDepsInMemoBlock, errorState, memoLocation) {
  var _a;
  let normalizedDep;
  const maybeNormalizedRoot = temporaries.get(dep.identifier.id);
  if (maybeNormalizedRoot != null) {
    normalizedDep = {
      root: maybeNormalizedRoot.root,
      path: [...maybeNormalizedRoot.path, ...dep.path]
    };
  } else {
    CompilerError.invariant(((_a = dep.identifier.name) == null ? void 0 : _a.kind) === "named", {
      reason: "ValidatePreservedManualMemoization: expected scope dependency to be named",
      loc: GeneratedSource,
      suggestions: null
    });
    normalizedDep = {
      root: {
        kind: "NamedLocal",
        value: {
          kind: "Identifier",
          identifier: dep.identifier,
          loc: GeneratedSource,
          effect: "read" /* Read */,
          reactive: false
        }
      },
      path: [...dep.path]
    };
  }
  for (const decl of declsWithinMemoBlock) {
    if (normalizedDep.root.kind === "NamedLocal" && decl === normalizedDep.root.value.identifier.declarationId) {
      return;
    }
  }
  let errorDiagnostic = null;
  for (const originalDep of validDepsInMemoBlock) {
    const compareResult = compareDeps(normalizedDep, originalDep);
    if (compareResult === 0 /* Ok */) {
      return;
    } else {
      errorDiagnostic = merge2(errorDiagnostic != null ? errorDiagnostic : compareResult, compareResult);
    }
  }
  errorState.pushDiagnostic(
    CompilerDiagnostic.create({
      category: "PreserveManualMemo" /* PreserveManualMemo */,
      severity: "CannotPreserveMemoization" /* CannotPreserveMemoization */,
      reason: "Compilation skipped because existing memoization could not be preserved",
      description: [
        "React Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. ",
        "The inferred dependencies did not match the manually specified dependencies, which could cause the value to change more or less frequently than expected. ",
        DEBUG5 || // If the dependency is a named variable then we can report it. Otherwise only print in debug mode
        dep.identifier.name != null && dep.identifier.name.kind === "named" ? `The inferred dependency was \`${prettyPrintScopeDependency(
          dep
        )}\`, but the source dependencies were [${validDepsInMemoBlock.map((dep2) => printManualMemoDependency(dep2, true)).join(", ")}]. ${errorDiagnostic ? getCompareDependencyResultDescription(errorDiagnostic) : "Inferred dependency not present in source"}.` : ""
      ].join("").trim(),
      suggestions: null
    }).withDetail({
      kind: "error",
      loc: memoLocation,
      message: "Could not preserve existing manual memoization"
    })
  );
}
var Visitor11 = class extends ReactiveFunctionVisitor {
  constructor() {
    super(...arguments);
    /**
     * Records all completed scopes (regardless of transitive memoization
     * of scope dependencies)
     *
     * Both @scopes and @prunedScopes are live sets. We rely on iterating
     * the reactive-ir in evaluation order, as they are used to determine
     * whether scope dependencies / declarations have completed mutation.
     */
    this.scopes = /* @__PURE__ */ new Set();
    this.prunedScopes = /* @__PURE__ */ new Set();
    this.temporaries = /* @__PURE__ */ new Map();
  }
  /**
   * Recursively visit values and instructions to collect declarations
   * and property loads.
   * @returns a @{ManualMemoDependency} representing the variable +
   * property reads represented by @value
   */
  recordDepsInValue(value, state) {
    var _a, _b;
    switch (value.kind) {
      case "SequenceExpression": {
        for (const instr of value.instructions) {
          this.visitInstruction(instr, state);
        }
        const result = this.recordDepsInValue(value.value, state);
        return result;
      }
      case "OptionalExpression": {
        return this.recordDepsInValue(value.value, state);
      }
      case "ConditionalExpression": {
        this.recordDepsInValue(value.test, state);
        this.recordDepsInValue(value.consequent, state);
        this.recordDepsInValue(value.alternate, state);
        return null;
      }
      case "LogicalExpression": {
        this.recordDepsInValue(value.left, state);
        this.recordDepsInValue(value.right, state);
        return null;
      }
      default: {
        const dep = collectMaybeMemoDependencies(
          value,
          this.temporaries,
          false
        );
        if (value.kind === "StoreLocal" || value.kind === "StoreContext") {
          const storeTarget = value.lvalue.place;
          (_a = state.manualMemoState) == null ? void 0 : _a.decls.add(
            storeTarget.identifier.declarationId
          );
          if (((_b = storeTarget.identifier.name) == null ? void 0 : _b.kind) === "named" && dep == null) {
            const dep2 = {
              root: {
                kind: "NamedLocal",
                value: storeTarget
              },
              path: []
            };
            this.temporaries.set(storeTarget.identifier.id, dep2);
            return dep2;
          }
        }
        return dep;
      }
    }
  }
  recordTemporaries(instr, state) {
    var _a;
    const temporaries = this.temporaries;
    const { lvalue, value } = instr;
    const lvalId = lvalue == null ? void 0 : lvalue.identifier.id;
    if (lvalId != null && temporaries.has(lvalId)) {
      return;
    }
    const isNamedLocal = ((_a = lvalue == null ? void 0 : lvalue.identifier.name) == null ? void 0 : _a.kind) === "named";
    if (lvalue !== null && isNamedLocal && state.manualMemoState != null) {
      state.manualMemoState.decls.add(lvalue.identifier.declarationId);
    }
    const maybeDep = this.recordDepsInValue(value, state);
    if (lvalId != null) {
      if (maybeDep != null) {
        temporaries.set(lvalId, maybeDep);
      } else if (isNamedLocal) {
        temporaries.set(lvalId, {
          root: {
            kind: "NamedLocal",
            value: __spreadValues({}, instr.lvalue)
          },
          path: []
        });
      }
    }
  }
  visitScope(scopeBlock, state) {
    this.traverseScope(scopeBlock, state);
    if (state.manualMemoState != null && state.manualMemoState.depsFromSource != null) {
      for (const dep of scopeBlock.scope.dependencies) {
        validateInferredDep(
          dep,
          this.temporaries,
          state.manualMemoState.decls,
          state.manualMemoState.depsFromSource,
          state.errors,
          state.manualMemoState.loc
        );
      }
    }
    this.scopes.add(scopeBlock.scope.id);
    for (const id of scopeBlock.scope.merged) {
      this.scopes.add(id);
    }
  }
  visitPrunedScope(scopeBlock, state) {
    this.traversePrunedScope(scopeBlock, state);
    this.prunedScopes.add(scopeBlock.scope.id);
  }
  visitInstruction(instruction, state) {
    var _a, _b, _c;
    this.recordTemporaries(instruction, state);
    const value = instruction.value;
    if (value.kind === "StoreLocal" && value.lvalue.kind === "Reassign" && state.manualMemoState != null) {
      const ids = getOrInsertDefault(
        state.manualMemoState.reassignments,
        value.lvalue.place.identifier.declarationId,
        /* @__PURE__ */ new Set()
      );
      ids.add(value.value.identifier);
    }
    if (value.kind === "LoadLocal" && value.place.identifier.scope != null && instruction.lvalue != null && instruction.lvalue.identifier.scope == null && state.manualMemoState != null) {
      const ids = getOrInsertDefault(
        state.manualMemoState.reassignments,
        instruction.lvalue.identifier.declarationId,
        /* @__PURE__ */ new Set()
      );
      ids.add(value.place.identifier);
    }
    if (value.kind === "StartMemoize") {
      let depsFromSource = null;
      if (value.deps != null) {
        depsFromSource = value.deps;
      }
      CompilerError.invariant(state.manualMemoState == null, {
        reason: "Unexpected nested StartMemoize instructions",
        description: `Bad manual memoization ids: ${(_a = state.manualMemoState) == null ? void 0 : _a.manualMemoId}, ${value.manualMemoId}`,
        loc: value.loc,
        suggestions: null
      });
      state.manualMemoState = {
        loc: instruction.loc,
        decls: /* @__PURE__ */ new Set(),
        depsFromSource,
        manualMemoId: value.manualMemoId,
        reassignments: /* @__PURE__ */ new Map()
      };
      for (const { identifier: identifier4, loc } of eachInstructionValueOperand(
        value
      )) {
        if (identifier4.scope != null && !this.scopes.has(identifier4.scope.id) && !this.prunedScopes.has(identifier4.scope.id)) {
          state.errors.pushDiagnostic(
            CompilerDiagnostic.create({
              category: "PreserveManualMemo" /* PreserveManualMemo */,
              severity: "CannotPreserveMemoization" /* CannotPreserveMemoization */,
              reason: "Compilation skipped because existing memoization could not be preserved",
              description: [
                "React Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. ",
                "This dependency may be mutated later, which could cause the value to change unexpectedly."
              ].join("")
            }).withDetail({
              kind: "error",
              loc,
              message: "This dependency may be modified later"
            })
          );
        }
      }
    }
    if (value.kind === "FinishMemoize") {
      CompilerError.invariant(
        state.manualMemoState != null && state.manualMemoState.manualMemoId === value.manualMemoId,
        {
          reason: "Unexpected mismatch between StartMemoize and FinishMemoize",
          description: `Encountered StartMemoize id=${(_b = state.manualMemoState) == null ? void 0 : _b.manualMemoId} followed by FinishMemoize id=${value.manualMemoId}`,
          loc: value.loc,
          suggestions: null
        }
      );
      const reassignments = state.manualMemoState.reassignments;
      state.manualMemoState = null;
      if (!value.pruned) {
        for (const { identifier: identifier4, loc } of eachInstructionValueOperand(
          value
        )) {
          let decls;
          if (identifier4.scope == null) {
            decls = (_c = reassignments.get(identifier4.declarationId)) != null ? _c : [identifier4];
          } else {
            decls = [identifier4];
          }
          for (const identifier5 of decls) {
            if (isUnmemoized2(identifier5, this.scopes)) {
              state.errors.pushDiagnostic(
                CompilerDiagnostic.create({
                  category: "PreserveManualMemo" /* PreserveManualMemo */,
                  severity: "CannotPreserveMemoization" /* CannotPreserveMemoization */,
                  reason: "Compilation skipped because existing memoization could not be preserved",
                  description: [
                    "React Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. This value was memoized in source but not in compilation output. ",
                    DEBUG5 ? `${printIdentifier(identifier5)} was not memoized.` : ""
                  ].join("").trim()
                }).withDetail({
                  kind: "error",
                  loc,
                  message: "Could not preserve existing memoization"
                })
              );
            }
          }
        }
      }
    }
  }
};
function isUnmemoized2(operand, scopes) {
  return operand.scope != null && !scopes.has(operand.scope.id);
}

// src/Validation/ValidateUseMemo.ts
function validateUseMemo(fn) {
  const errors = new CompilerError();
  const useMemos = /* @__PURE__ */ new Set();
  const react = /* @__PURE__ */ new Set();
  const functions = /* @__PURE__ */ new Map();
  for (const [, block] of fn.body.blocks) {
    for (const { lvalue, value } of block.instructions) {
      switch (value.kind) {
        case "LoadGlobal": {
          if (value.binding.name === "useMemo") {
            useMemos.add(lvalue.identifier.id);
          } else if (value.binding.name === "React") {
            react.add(lvalue.identifier.id);
          }
          break;
        }
        case "PropertyLoad": {
          if (react.has(value.object.identifier.id)) {
            if (value.property === "useMemo") {
              useMemos.add(lvalue.identifier.id);
            }
          }
          break;
        }
        case "FunctionExpression": {
          functions.set(lvalue.identifier.id, value);
          break;
        }
        case "MethodCall":
        case "CallExpression": {
          const callee = value.kind === "CallExpression" ? value.callee.identifier.id : value.property.identifier.id;
          const isUseMemo = useMemos.has(callee);
          if (!isUseMemo || value.args.length === 0) {
            continue;
          }
          const [arg] = value.args;
          if (arg.kind !== "Identifier") {
            continue;
          }
          const body = functions.get(arg.identifier.id);
          if (body === void 0) {
            continue;
          }
          if (body.loweredFunc.func.params.length > 0) {
            const firstParam = body.loweredFunc.func.params[0];
            const loc = firstParam.kind === "Identifier" ? firstParam.loc : firstParam.place.loc;
            errors.pushDiagnostic(
              CompilerDiagnostic.create({
                category: "UseMemo" /* UseMemo */,
                severity: "InvalidReact" /* InvalidReact */,
                reason: "useMemo() callbacks may not accept parameters",
                description: "useMemo() callbacks are called by React to cache calculations across re-renders. They should not take parameters. Instead, directly reference the props, state, or local variables needed for the computation.",
                suggestions: null
              }).withDetail({
                kind: "error",
                loc,
                message: "Callbacks with parameters are not supported"
              })
            );
          }
          if (body.loweredFunc.func.async || body.loweredFunc.func.generator) {
            errors.pushDiagnostic(
              CompilerDiagnostic.create({
                category: "UseMemo" /* UseMemo */,
                severity: "InvalidReact" /* InvalidReact */,
                reason: "useMemo() callbacks may not be async or generator functions",
                description: "useMemo() callbacks are called once and must synchronously return a value.",
                suggestions: null
              }).withDetail({
                kind: "error",
                loc: body.loc,
                message: "Async and generator functions are not supported"
              })
            );
          }
          break;
        }
      }
    }
  }
  return errors.asResult();
}

// src/Validation/ValidateLocalsNotReassignedAfterRender.ts
function validateLocalsNotReassignedAfterRender(fn) {
  const contextVariables = /* @__PURE__ */ new Set();
  const reassignment = getContextReassignment(
    fn,
    contextVariables,
    false,
    false
  );
  if (reassignment !== null) {
    const errors = new CompilerError();
    const variable = reassignment.identifier.name != null && reassignment.identifier.name.kind === "named" ? `\`${reassignment.identifier.name.value}\`` : "variable";
    errors.pushDiagnostic(
      CompilerDiagnostic.create({
        category: "Immutability" /* Immutability */,
        severity: "InvalidReact" /* InvalidReact */,
        reason: "Cannot reassign variable after render completes",
        description: `Reassigning ${variable} after render has completed can cause inconsistent behavior on subsequent renders. Consider using state instead.`
      }).withDetail({
        kind: "error",
        loc: reassignment.loc,
        message: `Cannot reassign ${variable} after render completes`
      })
    );
    throw errors;
  }
}
function getContextReassignment(fn, contextVariables, isFunctionExpression, isAsync2) {
  const reassigningFunctions = /* @__PURE__ */ new Map();
  for (const [, block] of fn.body.blocks) {
    for (const instr of block.instructions) {
      const { lvalue, value } = instr;
      switch (value.kind) {
        case "FunctionExpression":
        case "ObjectMethod": {
          let reassignment = getContextReassignment(
            value.loweredFunc.func,
            contextVariables,
            true,
            isAsync2 || value.loweredFunc.func.async
          );
          if (reassignment === null) {
            for (const operand of eachInstructionValueOperand(value)) {
              const reassignmentFromOperand = reassigningFunctions.get(
                operand.identifier.id
              );
              if (reassignmentFromOperand !== void 0) {
                reassignment = reassignmentFromOperand;
                break;
              }
            }
          }
          if (reassignment !== null) {
            if (isAsync2 || value.loweredFunc.func.async) {
              const errors = new CompilerError();
              const variable = reassignment.identifier.name !== null && reassignment.identifier.name.kind === "named" ? `\`${reassignment.identifier.name.value}\`` : "variable";
              errors.pushDiagnostic(
                CompilerDiagnostic.create({
                  category: "Immutability" /* Immutability */,
                  severity: "InvalidReact" /* InvalidReact */,
                  reason: "Cannot reassign variable in async function",
                  description: "Reassigning a variable in an async function can cause inconsistent behavior on subsequent renders. Consider using state instead"
                }).withDetail({
                  kind: "error",
                  loc: reassignment.loc,
                  message: `Cannot reassign ${variable}`
                })
              );
              throw errors;
            }
            reassigningFunctions.set(lvalue.identifier.id, reassignment);
          }
          break;
        }
        case "StoreLocal": {
          const reassignment = reassigningFunctions.get(
            value.value.identifier.id
          );
          if (reassignment !== void 0) {
            reassigningFunctions.set(
              value.lvalue.place.identifier.id,
              reassignment
            );
            reassigningFunctions.set(lvalue.identifier.id, reassignment);
          }
          break;
        }
        case "LoadLocal": {
          const reassignment = reassigningFunctions.get(
            value.place.identifier.id
          );
          if (reassignment !== void 0) {
            reassigningFunctions.set(lvalue.identifier.id, reassignment);
          }
          break;
        }
        case "DeclareContext": {
          if (!isFunctionExpression) {
            contextVariables.add(value.lvalue.place.identifier.id);
          }
          break;
        }
        case "StoreContext": {
          if (isFunctionExpression) {
            if (contextVariables.has(value.lvalue.place.identifier.id)) {
              return value.lvalue.place;
            }
          } else {
            contextVariables.add(value.lvalue.place.identifier.id);
          }
          const reassignment = reassigningFunctions.get(
            value.value.identifier.id
          );
          if (reassignment !== void 0) {
            reassigningFunctions.set(
              value.lvalue.place.identifier.id,
              reassignment
            );
            reassigningFunctions.set(lvalue.identifier.id, reassignment);
          }
          break;
        }
        default: {
          let operands = eachInstructionValueOperand(value);
          if (value.kind === "CallExpression") {
            const signature = getFunctionCallSignature(
              fn.env,
              value.callee.identifier.type
            );
            if (signature == null ? void 0 : signature.noAlias) {
              operands = [value.callee];
            }
          } else if (value.kind === "MethodCall") {
            const signature = getFunctionCallSignature(
              fn.env,
              value.property.identifier.type
            );
            if (signature == null ? void 0 : signature.noAlias) {
              operands = [value.receiver, value.property];
            }
          } else if (value.kind === "TaggedTemplateExpression") {
            const signature = getFunctionCallSignature(
              fn.env,
              value.tag.identifier.type
            );
            if (signature == null ? void 0 : signature.noAlias) {
              operands = [value.tag];
            }
          }
          for (const operand of operands) {
            CompilerError.invariant(operand.effect !== "<unknown>" /* Unknown */, {
              reason: `Expected effects to be inferred prior to ValidateLocalsNotReassignedAfterRender`,
              loc: operand.loc
            });
            const reassignment = reassigningFunctions.get(
              operand.identifier.id
            );
            if (reassignment !== void 0) {
              if (operand.effect === "freeze" /* Freeze */) {
                return reassignment;
              } else {
                for (const lval of eachInstructionLValue(instr)) {
                  reassigningFunctions.set(lval.identifier.id, reassignment);
                }
              }
            }
          }
          break;
        }
      }
    }
    for (const operand of eachTerminalOperand(block.terminal)) {
      const reassignment = reassigningFunctions.get(operand.identifier.id);
      if (reassignment !== void 0) {
        return reassignment;
      }
    }
  }
  return null;
}

// src/Optimization/OutlineFunctions.ts
function outlineFunctions(fn, fbtOperands) {
  for (const [, block] of fn.body.blocks) {
    for (const instr of block.instructions) {
      const { value, lvalue } = instr;
      if (value.kind === "FunctionExpression" || value.kind === "ObjectMethod") {
        outlineFunctions(value.loweredFunc.func, fbtOperands);
      }
      if (value.kind === "FunctionExpression" && value.loweredFunc.func.context.length === 0 && // TODO: handle outlining named functions
      value.loweredFunc.func.id === null && !fbtOperands.has(lvalue.identifier.id)) {
        const loweredFunc = value.loweredFunc.func;
        const id = fn.env.generateGloballyUniqueIdentifierName(loweredFunc.id);
        loweredFunc.id = id.value;
        fn.env.outlineFunction(loweredFunc, null);
        instr.value = {
          kind: "LoadGlobal",
          binding: {
            kind: "Global",
            name: id.value
          },
          loc: value.loc
        };
      }
    }
  }
}

// src/Optimization/LowerContextAccess.ts
function lowerContextAccess(fn, loweredContextCalleeConfig) {
  const contextAccess = /* @__PURE__ */ new Map();
  const contextKeys = /* @__PURE__ */ new Map();
  for (const [, block] of fn.body.blocks) {
    for (const instr of block.instructions) {
      const { value, lvalue } = instr;
      if (value.kind === "CallExpression" && isUseContextHookType(value.callee.identifier)) {
        contextAccess.set(lvalue.identifier.id, value);
        continue;
      }
      if (value.kind !== "Destructure") {
        continue;
      }
      const destructureId = value.value.identifier.id;
      if (!contextAccess.has(destructureId)) {
        continue;
      }
      const keys = getContextKeys(value);
      if (keys === null) {
        return;
      }
      if (contextKeys.has(destructureId)) {
        return;
      } else {
        contextKeys.set(destructureId, keys);
      }
    }
  }
  let importLoweredContextCallee = null;
  if (contextAccess.size > 0 && contextKeys.size > 0) {
    for (const [, block] of fn.body.blocks) {
      let nextInstructions = null;
      for (let i = 0; i < block.instructions.length; i++) {
        const instr = block.instructions[i];
        const { lvalue, value } = instr;
        if (value.kind === "CallExpression" && isUseContextHookType(value.callee.identifier) && contextKeys.has(lvalue.identifier.id)) {
          importLoweredContextCallee != null ? importLoweredContextCallee : importLoweredContextCallee = fn.env.programContext.addImportSpecifier(
            loweredContextCalleeConfig
          );
          const loweredContextCalleeInstr = emitLoadLoweredContextCallee(
            fn.env,
            importLoweredContextCallee
          );
          if (nextInstructions === null) {
            nextInstructions = block.instructions.slice(0, i);
          }
          nextInstructions.push(loweredContextCalleeInstr);
          const keys = contextKeys.get(lvalue.identifier.id);
          const selectorFnInstr = emitSelectorFn(fn.env, keys);
          nextInstructions.push(selectorFnInstr);
          const lowerContextCallId = loweredContextCalleeInstr.lvalue;
          value.callee = lowerContextCallId;
          const selectorFn = selectorFnInstr.lvalue;
          value.args.push(selectorFn);
        }
        if (nextInstructions) {
          nextInstructions.push(instr);
        }
      }
      if (nextInstructions) {
        block.instructions = nextInstructions;
      }
    }
    markInstructionIds(fn.body);
    inferTypes(fn);
  }
}
function emitLoadLoweredContextCallee(env, importedLowerContextCallee) {
  const loadGlobal = {
    kind: "LoadGlobal",
    binding: __spreadValues({}, importedLowerContextCallee),
    loc: GeneratedSource
  };
  return {
    id: makeInstructionId(0),
    loc: GeneratedSource,
    lvalue: createTemporaryPlace(env, GeneratedSource),
    effects: null,
    value: loadGlobal
  };
}
function getContextKeys(value) {
  const keys = [];
  const pattern = value.lvalue.pattern;
  switch (pattern.kind) {
    case "ArrayPattern": {
      return null;
    }
    case "ObjectPattern": {
      for (const place of pattern.properties) {
        if (place.kind !== "ObjectProperty" || place.type !== "property" || place.key.kind !== "identifier" || place.place.identifier.name === null || place.place.identifier.name.kind !== "named") {
          return null;
        }
        keys.push(place.key.name);
      }
      return keys;
    }
  }
}
function emitPropertyLoad(env, obj, property) {
  const loadObj = {
    kind: "LoadLocal",
    place: obj,
    loc: GeneratedSource
  };
  const object = createTemporaryPlace(env, GeneratedSource);
  const loadLocalInstr = {
    lvalue: object,
    value: loadObj,
    id: makeInstructionId(0),
    effects: null,
    loc: GeneratedSource
  };
  const loadProp = {
    kind: "PropertyLoad",
    object,
    property: makePropertyLiteral(property),
    loc: GeneratedSource
  };
  const element = createTemporaryPlace(env, GeneratedSource);
  const loadPropInstr = {
    lvalue: element,
    value: loadProp,
    id: makeInstructionId(0),
    effects: null,
    loc: GeneratedSource
  };
  return {
    instructions: [loadLocalInstr, loadPropInstr],
    element
  };
}
function emitSelectorFn(env, keys) {
  const obj = createTemporaryPlace(env, GeneratedSource);
  promoteTemporary(obj.identifier);
  const instr = [];
  const elements = [];
  for (const key2 of keys) {
    const { instructions, element: prop } = emitPropertyLoad(env, obj, key2);
    instr.push(...instructions);
    elements.push(prop);
  }
  const arrayInstr = emitArrayInstr(elements, env);
  instr.push(arrayInstr);
  const block = {
    kind: "block",
    id: makeBlockId(0),
    instructions: instr,
    terminal: {
      id: makeInstructionId(0),
      kind: "return",
      returnVariant: "Explicit",
      loc: GeneratedSource,
      value: arrayInstr.lvalue,
      effects: null
    },
    preds: /* @__PURE__ */ new Set(),
    phis: /* @__PURE__ */ new Set()
  };
  const fn = {
    loc: GeneratedSource,
    id: null,
    fnType: "Other",
    env,
    params: [obj],
    returnTypeAnnotation: null,
    returns: createTemporaryPlace(env, GeneratedSource),
    context: [],
    body: {
      entry: block.id,
      blocks: /* @__PURE__ */ new Map([[block.id, block]])
    },
    generator: false,
    async: false,
    directives: [],
    aliasingEffects: []
  };
  reversePostorderBlocks(fn.body);
  markInstructionIds(fn.body);
  enterSSA(fn);
  inferTypes(fn);
  const fnInstr = {
    id: makeInstructionId(0),
    value: {
      kind: "FunctionExpression",
      name: null,
      loweredFunc: {
        func: fn
      },
      type: "ArrowFunctionExpression",
      loc: GeneratedSource
    },
    lvalue: createTemporaryPlace(env, GeneratedSource),
    effects: null,
    loc: GeneratedSource
  };
  return fnInstr;
}
function emitArrayInstr(elements, env) {
  const array = {
    kind: "ArrayExpression",
    elements,
    loc: GeneratedSource
  };
  const arrayLvalue = createTemporaryPlace(env, GeneratedSource);
  const arrayInstr = {
    id: makeInstructionId(0),
    value: array,
    lvalue: arrayLvalue,
    effects: null,
    loc: GeneratedSource
  };
  return arrayInstr;
}

// src/Validation/ValidateNoSetStateInEffects.ts
function validateNoSetStateInEffects(fn) {
  const setStateFunctions = /* @__PURE__ */ new Map();
  const errors = new CompilerError();
  for (const [, block] of fn.body.blocks) {
    for (const instr of block.instructions) {
      switch (instr.value.kind) {
        case "LoadLocal": {
          if (setStateFunctions.has(instr.value.place.identifier.id)) {
            setStateFunctions.set(
              instr.lvalue.identifier.id,
              instr.value.place
            );
          }
          break;
        }
        case "StoreLocal": {
          if (setStateFunctions.has(instr.value.value.identifier.id)) {
            setStateFunctions.set(
              instr.value.lvalue.place.identifier.id,
              instr.value.value
            );
            setStateFunctions.set(
              instr.lvalue.identifier.id,
              instr.value.value
            );
          }
          break;
        }
        case "FunctionExpression": {
          if (
            // faster-path to check if the function expression references a setState
            [...eachInstructionValueOperand(instr.value)].some(
              (operand) => isSetStateType(operand.identifier) || setStateFunctions.has(operand.identifier.id)
            )
          ) {
            const callee = getSetStateCall(
              instr.value.loweredFunc.func,
              setStateFunctions
            );
            if (callee !== null) {
              setStateFunctions.set(instr.lvalue.identifier.id, callee);
            }
          }
          break;
        }
        case "MethodCall":
        case "CallExpression": {
          const callee = instr.value.kind === "MethodCall" ? instr.value.receiver : instr.value.callee;
          if (isUseEffectHookType(callee.identifier) || isUseLayoutEffectHookType(callee.identifier) || isUseInsertionEffectHookType(callee.identifier)) {
            const arg = instr.value.args[0];
            if (arg !== void 0 && arg.kind === "Identifier") {
              const setState = setStateFunctions.get(arg.identifier.id);
              if (setState !== void 0) {
                errors.pushDiagnostic(
                  CompilerDiagnostic.create({
                    category: "EffectSetState" /* EffectSetState */,
                    reason: "Calling setState synchronously within an effect can trigger cascading renders",
                    description: "Effects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect)",
                    severity: "InvalidReact" /* InvalidReact */,
                    suggestions: null
                  }).withDetail({
                    kind: "error",
                    loc: setState.loc,
                    message: "Avoid calling setState() directly within an effect"
                  })
                );
              }
            }
          }
          break;
        }
      }
    }
  }
  return errors.asResult();
}
function getSetStateCall(fn, setStateFunctions) {
  for (const [, block] of fn.body.blocks) {
    for (const instr of block.instructions) {
      switch (instr.value.kind) {
        case "LoadLocal": {
          if (setStateFunctions.has(instr.value.place.identifier.id)) {
            setStateFunctions.set(
              instr.lvalue.identifier.id,
              instr.value.place
            );
          }
          break;
        }
        case "StoreLocal": {
          if (setStateFunctions.has(instr.value.value.identifier.id)) {
            setStateFunctions.set(
              instr.value.lvalue.place.identifier.id,
              instr.value.value
            );
            setStateFunctions.set(
              instr.lvalue.identifier.id,
              instr.value.value
            );
          }
          break;
        }
        case "CallExpression": {
          const callee = instr.value.callee;
          if (isSetStateType(callee.identifier) || setStateFunctions.has(callee.identifier.id)) {
            return callee;
          }
        }
      }
    }
  }
  return null;
}

// src/Validation/ValidateNoJSXInTryStatement.ts
function validateNoJSXInTryStatement(fn) {
  const activeTryBlocks = [];
  const errors = new CompilerError();
  for (const [, block] of fn.body.blocks) {
    retainWhere(activeTryBlocks, (id) => id !== block.id);
    if (activeTryBlocks.length !== 0) {
      for (const instr of block.instructions) {
        const { value } = instr;
        switch (value.kind) {
          case "JsxExpression":
          case "JsxFragment": {
            errors.pushDiagnostic(
              CompilerDiagnostic.create({
                category: "ErrorBoundaries" /* ErrorBoundaries */,
                severity: "InvalidReact" /* InvalidReact */,
                reason: "Avoid constructing JSX within try/catch",
                description: `React does not immediately render components when JSX is rendered, so any errors from this component will not be caught by the try/catch. To catch errors in rendering a given component, wrap that component in an error boundary. (https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary)`
              }).withDetail({
                kind: "error",
                loc: value.loc,
                message: "Avoid constructing JSX within try/catch"
              })
            );
            break;
          }
        }
      }
    }
    if (block.terminal.kind === "try") {
      activeTryBlocks.push(block.terminal.handler);
    }
  }
  return errors.asResult();
}

// src/Optimization/OutlineJsx.ts
var import_invariant3 = __toESM(require_invariant());
function outlineJSX(fn) {
  const outlinedFns = [];
  outlineJsxImpl(fn, outlinedFns);
  for (const outlinedFn of outlinedFns) {
    fn.env.outlineFunction(outlinedFn, "Component");
  }
}
function outlineJsxImpl(fn, outlinedFns) {
  const globals = /* @__PURE__ */ new Map();
  function processAndOutlineJSX(state, rewriteInstr) {
    if (state.jsx.length <= 1) {
      return;
    }
    const result = process2(
      fn,
      [...state.jsx].sort((a, b) => a.id - b.id),
      globals
    );
    if (result) {
      outlinedFns.push(result.fn);
      rewriteInstr.set(state.jsx.at(0).id, result.instrs);
    }
  }
  for (const [, block] of fn.body.blocks) {
    const rewriteInstr = /* @__PURE__ */ new Map();
    let state = {
      jsx: [],
      children: /* @__PURE__ */ new Set()
    };
    for (let i = block.instructions.length - 1; i >= 0; i--) {
      const instr = block.instructions[i];
      const { value, lvalue } = instr;
      switch (value.kind) {
        case "LoadGlobal": {
          globals.set(lvalue.identifier.id, instr);
          break;
        }
        case "FunctionExpression": {
          outlineJsxImpl(value.loweredFunc.func, outlinedFns);
          break;
        }
        case "JsxExpression": {
          if (!state.children.has(lvalue.identifier.id)) {
            processAndOutlineJSX(state, rewriteInstr);
            state = {
              jsx: [],
              children: /* @__PURE__ */ new Set()
            };
          }
          state.jsx.push(instr);
          if (value.children) {
            for (const child of value.children) {
              state.children.add(child.identifier.id);
            }
          }
          break;
        }
        case "ArrayExpression":
        case "Await":
        case "BinaryExpression":
        case "CallExpression":
        case "ComputedDelete":
        case "ComputedLoad":
        case "ComputedStore":
        case "Debugger":
        case "DeclareContext":
        case "DeclareLocal":
        case "Destructure":
        case "FinishMemoize":
        case "GetIterator":
        case "IteratorNext":
        case "JSXText":
        case "JsxFragment":
        case "LoadContext":
        case "LoadLocal":
        case "MetaProperty":
        case "MethodCall":
        case "NewExpression":
        case "NextPropertyOf":
        case "ObjectExpression":
        case "ObjectMethod":
        case "PostfixUpdate":
        case "PrefixUpdate":
        case "Primitive":
        case "PropertyDelete":
        case "PropertyLoad":
        case "PropertyStore":
        case "RegExpLiteral":
        case "StartMemoize":
        case "StoreContext":
        case "StoreGlobal":
        case "StoreLocal":
        case "TaggedTemplateExpression":
        case "TemplateLiteral":
        case "TypeCastExpression":
        case "UnsupportedNode":
        case "UnaryExpression": {
          break;
        }
        default: {
          assertExhaustive(value, `Unexpected instruction: ${value}`);
        }
      }
    }
    processAndOutlineJSX(state, rewriteInstr);
    if (rewriteInstr.size > 0) {
      const newInstrs = [];
      for (let i = 0; i < block.instructions.length; i++) {
        const id = i + 1;
        if (rewriteInstr.has(id)) {
          const instrs = rewriteInstr.get(id);
          newInstrs.push(...instrs);
        } else {
          newInstrs.push(block.instructions[i]);
        }
      }
      block.instructions = newInstrs;
    }
    deadCodeElimination(fn);
  }
}
function process2(fn, jsx, globals) {
  if (fn.fnType === "Component") {
    return null;
  }
  const props = collectProps(fn.env, jsx);
  if (!props) return null;
  const outlinedTag = fn.env.generateGloballyUniqueIdentifierName(null).value;
  const newInstrs = emitOutlinedJsx(fn.env, jsx, props, outlinedTag);
  if (!newInstrs) return null;
  const outlinedFn = emitOutlinedFn(fn.env, jsx, props, globals);
  if (!outlinedFn) return null;
  outlinedFn.id = outlinedTag;
  return { instrs: newInstrs, fn: outlinedFn };
}
function collectProps(env, instructions) {
  let id = 1;
  function generateName(oldName) {
    let newName = oldName;
    while (seen.has(newName)) {
      newName = `${oldName}${id++}`;
    }
    seen.add(newName);
    env.programContext.addNewReference(newName);
    return newName;
  }
  const attributes = [];
  const jsxIds = new Set(instructions.map((i) => i.lvalue.identifier.id));
  const seen = /* @__PURE__ */ new Set();
  for (const instr of instructions) {
    const { value } = instr;
    for (const at of value.props) {
      if (at.kind === "JsxSpreadAttribute") {
        return null;
      }
      if (at.kind === "JsxAttribute") {
        const newName = generateName(at.name);
        attributes.push({
          originalName: at.name,
          newName,
          place: at.place
        });
      }
    }
    if (value.children) {
      for (const child of value.children) {
        if (jsxIds.has(child.identifier.id)) {
          continue;
        }
        promoteTemporary(child.identifier);
        const newName = generateName("t");
        attributes.push({
          originalName: child.identifier.name.value,
          newName,
          place: child
        });
      }
    }
  }
  return attributes;
}
function emitOutlinedJsx(env, instructions, outlinedProps, outlinedTag) {
  const props = outlinedProps.map((p) => ({
    kind: "JsxAttribute",
    name: p.newName,
    place: p.place
  }));
  const loadJsx = {
    id: makeInstructionId(0),
    loc: GeneratedSource,
    lvalue: createTemporaryPlace(env, GeneratedSource),
    value: {
      kind: "LoadGlobal",
      binding: {
        kind: "ModuleLocal",
        name: outlinedTag
      },
      loc: GeneratedSource
    },
    effects: null
  };
  promoteTemporaryJsxTag(loadJsx.lvalue.identifier);
  const jsxExpr = {
    id: makeInstructionId(0),
    loc: GeneratedSource,
    lvalue: instructions.at(-1).lvalue,
    value: {
      kind: "JsxExpression",
      tag: __spreadValues({}, loadJsx.lvalue),
      props,
      children: null,
      loc: GeneratedSource,
      openingLoc: GeneratedSource,
      closingLoc: GeneratedSource
    },
    effects: null
  };
  return [loadJsx, jsxExpr];
}
function emitOutlinedFn(env, jsx, oldProps, globals) {
  const instructions = [];
  const oldToNewProps = createOldToNewPropsMapping(env, oldProps);
  const propsObj = createTemporaryPlace(env, GeneratedSource);
  promoteTemporary(propsObj.identifier);
  const destructurePropsInstr = emitDestructureProps(
    env,
    propsObj,
    oldToNewProps
  );
  instructions.push(destructurePropsInstr);
  const updatedJsxInstructions = emitUpdatedJsx(jsx, oldToNewProps);
  const loadGlobalInstrs = emitLoadGlobals(jsx, globals);
  if (!loadGlobalInstrs) {
    return null;
  }
  instructions.push(...loadGlobalInstrs);
  instructions.push(...updatedJsxInstructions);
  const block = {
    kind: "block",
    id: makeBlockId(0),
    instructions,
    terminal: {
      id: makeInstructionId(0),
      kind: "return",
      returnVariant: "Explicit",
      loc: GeneratedSource,
      value: instructions.at(-1).lvalue,
      effects: null
    },
    preds: /* @__PURE__ */ new Set(),
    phis: /* @__PURE__ */ new Set()
  };
  const fn = {
    loc: GeneratedSource,
    id: null,
    fnType: "Other",
    env,
    params: [propsObj],
    returnTypeAnnotation: null,
    returns: createTemporaryPlace(env, GeneratedSource),
    context: [],
    body: {
      entry: block.id,
      blocks: /* @__PURE__ */ new Map([[block.id, block]])
    },
    generator: false,
    async: false,
    directives: [],
    aliasingEffects: []
  };
  return fn;
}
function emitLoadGlobals(jsx, globals) {
  const instructions = [];
  for (const { value } of jsx) {
    if (value.tag.kind === "Identifier") {
      const loadGlobalInstr = globals.get(value.tag.identifier.id);
      if (!loadGlobalInstr) {
        return null;
      }
      instructions.push(loadGlobalInstr);
    }
  }
  return instructions;
}
function emitUpdatedJsx(jsx, oldToNewProps) {
  const newInstrs = [];
  const jsxIds = new Set(jsx.map((i) => i.lvalue.identifier.id));
  for (const instr of jsx) {
    const { value } = instr;
    const newProps = [];
    for (const prop of value.props) {
      (0, import_invariant3.default)(
        prop.kind === "JsxAttribute",
        `Expected only attributes but found ${prop.kind}`
      );
      if (prop.name === "key") {
        continue;
      }
      const newProp = oldToNewProps.get(prop.place.identifier.id);
      (0, import_invariant3.default)(
        newProp !== void 0,
        `Expected a new property for ${printIdentifier(prop.place.identifier)}`
      );
      newProps.push({
        kind: "JsxAttribute",
        name: newProp.originalName,
        place: newProp.place
      });
    }
    let newChildren = null;
    if (value.children) {
      newChildren = [];
      for (const child of value.children) {
        if (jsxIds.has(child.identifier.id)) {
          newChildren.push(__spreadValues({}, child));
          continue;
        }
        const newChild = oldToNewProps.get(child.identifier.id);
        (0, import_invariant3.default)(
          newChild !== void 0,
          `Expected a new prop for ${printIdentifier(child.identifier)}`
        );
        newChildren.push(__spreadValues({}, newChild.place));
      }
    }
    newInstrs.push(__spreadProps(__spreadValues({}, instr), {
      value: __spreadProps(__spreadValues({}, value), {
        props: newProps,
        children: newChildren
      })
    }));
  }
  return newInstrs;
}
function createOldToNewPropsMapping(env, oldProps) {
  const oldToNewProps = /* @__PURE__ */ new Map();
  for (const oldProp of oldProps) {
    if (oldProp.originalName === "key") {
      continue;
    }
    const newProp = __spreadProps(__spreadValues({}, oldProp), {
      place: createTemporaryPlace(env, GeneratedSource)
    });
    newProp.place.identifier.name = makeIdentifierName(oldProp.newName);
    oldToNewProps.set(oldProp.place.identifier.id, newProp);
  }
  return oldToNewProps;
}
function emitDestructureProps(env, propsObj, oldToNewProps) {
  const properties = [];
  for (const [_, prop] of oldToNewProps) {
    properties.push({
      kind: "ObjectProperty",
      key: {
        kind: "string",
        name: prop.newName
      },
      type: "property",
      place: prop.place
    });
  }
  const destructurePropsInstr = {
    id: makeInstructionId(0),
    lvalue: createTemporaryPlace(env, GeneratedSource),
    loc: GeneratedSource,
    value: {
      kind: "Destructure",
      lvalue: {
        pattern: {
          kind: "ObjectPattern",
          properties
        },
        kind: "Let" /* Let */
      },
      loc: GeneratedSource,
      value: propsObj
    },
    effects: null
  };
  return destructurePropsInstr;
}

// src/Optimization/OptimizePropsMethodCalls.ts
function optimizePropsMethodCalls(fn) {
  for (const [, block] of fn.body.blocks) {
    for (let i = 0; i < block.instructions.length; i++) {
      const instr = block.instructions[i];
      if (instr.value.kind === "MethodCall" && isPropsType(instr.value.receiver.identifier)) {
        instr.value = {
          kind: "CallExpression",
          callee: instr.value.property,
          args: instr.value.args,
          loc: instr.value.loc
        };
      }
    }
  }
}

// src/Transform/TransformFire.ts
var CANNOT_COMPILE_FIRE = "Cannot compile `fire`";
function transformFire(fn) {
  const context = new Context4(fn.env);
  replaceFireFunctions(fn, context);
  if (!context.hasErrors()) {
    ensureNoMoreFireUses(fn, context);
  }
  context.throwIfErrorsFound();
}
function replaceFireFunctions(fn, context) {
  let importedUseFire = null;
  let hasRewrite = false;
  for (const [, block] of fn.body.blocks) {
    const rewriteInstrs = /* @__PURE__ */ new Map();
    const deleteInstrs = /* @__PURE__ */ new Set();
    for (const instr of block.instructions) {
      const { value, lvalue } = instr;
      if (value.kind === "CallExpression" && isUseEffectHookType(value.callee.identifier) && value.args.length > 0 && value.args[0].kind === "Identifier") {
        const lambda = context.getFunctionExpression(
          value.args[0].identifier.id
        );
        if (lambda != null) {
          const capturedCallees = visitFunctionExpressionAndPropagateFireDependencies(
            lambda,
            context,
            true
          );
          const newInstrs = [];
          for (const [
            fireCalleePlace,
            fireCalleeInfo
          ] of capturedCallees.entries()) {
            if (!context.hasCalleeWithInsertedFire(fireCalleePlace)) {
              context.addCalleeWithInsertedFire(fireCalleePlace);
              importedUseFire != null ? importedUseFire : importedUseFire = fn.env.programContext.addImportSpecifier({
                source: fn.env.programContext.reactRuntimeModule,
                importSpecifierName: USE_FIRE_FUNCTION_NAME
              });
              const loadUseFireInstr = makeLoadUseFireInstruction(
                fn.env,
                importedUseFire
              );
              const loadFireCalleeInstr = makeLoadFireCalleeInstruction(
                fn.env,
                fireCalleeInfo.capturedCalleeIdentifier
              );
              const callUseFireInstr = makeCallUseFireInstruction(
                fn.env,
                loadUseFireInstr.lvalue,
                loadFireCalleeInstr.lvalue
              );
              const storeUseFireInstr = makeStoreUseFireInstruction(
                fn.env,
                callUseFireInstr.lvalue,
                fireCalleeInfo.fireFunctionBinding
              );
              newInstrs.push(
                loadUseFireInstr,
                loadFireCalleeInstr,
                callUseFireInstr,
                storeUseFireInstr
              );
              const loadUseEffectInstrId = context.getLoadGlobalInstrId(
                value.callee.identifier.id
              );
              if (loadUseEffectInstrId == null) {
                context.pushError({
                  loc: value.loc,
                  description: null,
                  severity: "Invariant" /* Invariant */,
                  category: "Invariant" /* Invariant */,
                  reason: "[InsertFire] No LoadGlobal found for useEffect call",
                  suggestions: null
                });
                continue;
              }
              rewriteInstrs.set(loadUseEffectInstrId, newInstrs);
            }
          }
          ensureNoRemainingCalleeCaptures(
            lambda.loweredFunc.func,
            context,
            capturedCallees
          );
          if (value.args.length > 1 && value.args[1] != null && value.args[1].kind === "Identifier") {
            const depArray = value.args[1];
            const depArrayExpression = context.getArrayExpression(
              depArray.identifier.id
            );
            if (depArrayExpression != null) {
              for (const dependency of depArrayExpression.elements) {
                if (dependency.kind === "Identifier") {
                  const loadOfDependency = context.getLoadLocalInstr(
                    dependency.identifier.id
                  );
                  if (loadOfDependency != null) {
                    const replacedDepArrayItem = capturedCallees.get(
                      loadOfDependency.place.identifier.id
                    );
                    if (replacedDepArrayItem != null) {
                      loadOfDependency.place = replacedDepArrayItem.fireFunctionBinding;
                    }
                  }
                }
              }
            } else {
              context.pushError({
                loc: value.args[1].loc,
                description: "You must use an array literal for an effect dependency array when that effect uses `fire()`",
                severity: "Invariant" /* Invariant */,
                category: "Fire" /* Fire */,
                reason: CANNOT_COMPILE_FIRE,
                suggestions: null
              });
            }
          } else if (value.args.length > 1 && value.args[1].kind === "Spread") {
            context.pushError({
              loc: value.args[1].place.loc,
              description: "You must use an array literal for an effect dependency array when that effect uses `fire()`",
              severity: "Invariant" /* Invariant */,
              category: "Fire" /* Fire */,
              reason: CANNOT_COMPILE_FIRE,
              suggestions: null
            });
          }
        }
      } else if (value.kind === "CallExpression" && value.callee.identifier.type.kind === "Function" && value.callee.identifier.type.shapeId === BuiltInFireId && context.inUseEffectLambda()) {
        if (value.args.length === 1 && value.args[0].kind === "Identifier") {
          const callExpr = context.getCallExpression(
            value.args[0].identifier.id
          );
          if (callExpr != null) {
            const calleeId = callExpr.callee.identifier.id;
            const loadLocal = context.getLoadLocalInstr(calleeId);
            if (loadLocal == null) {
              context.pushError({
                loc: value.loc,
                description: null,
                severity: "Invariant" /* Invariant */,
                category: "Invariant" /* Invariant */,
                reason: "[InsertFire] No loadLocal found for fire call argument",
                suggestions: null
              });
              continue;
            }
            const fireFunctionBinding = context.getOrGenerateFireFunctionBinding(
              loadLocal.place,
              value.loc
            );
            loadLocal.place = __spreadValues({}, fireFunctionBinding);
            deleteInstrs.add(instr.id);
          } else {
            context.pushError({
              loc: value.loc,
              description: "`fire()` can only receive a function call such as `fire(fn(a,b)). Method calls and other expressions are not allowed",
              severity: "InvalidReact" /* InvalidReact */,
              category: "Fire" /* Fire */,
              reason: CANNOT_COMPILE_FIRE,
              suggestions: null
            });
          }
        } else {
          let description = "fire() can only take in a single call expression as an argument";
          if (value.args.length === 0) {
            description += " but received none";
          } else if (value.args.length > 1) {
            description += " but received multiple arguments";
          } else if (value.args[0].kind === "Spread") {
            description += " but received a spread argument";
          }
          context.pushError({
            loc: value.loc,
            description,
            severity: "InvalidReact" /* InvalidReact */,
            category: "Fire" /* Fire */,
            reason: CANNOT_COMPILE_FIRE,
            suggestions: null
          });
        }
      } else if (value.kind === "CallExpression") {
        context.addCallExpression(lvalue.identifier.id, value);
      } else if (value.kind === "FunctionExpression" && context.inUseEffectLambda()) {
        visitFunctionExpressionAndPropagateFireDependencies(
          value,
          context,
          false
        );
      } else if (value.kind === "FunctionExpression") {
        context.addFunctionExpression(lvalue.identifier.id, value);
      } else if (value.kind === "LoadLocal") {
        context.addLoadLocalInstr(lvalue.identifier.id, value);
      } else if (value.kind === "LoadGlobal" && value.binding.kind === "ImportSpecifier" && value.binding.module === "react" && value.binding.imported === "fire" && context.inUseEffectLambda()) {
        deleteInstrs.add(instr.id);
      } else if (value.kind === "LoadGlobal") {
        context.addLoadGlobalInstrId(lvalue.identifier.id, instr.id);
      } else if (value.kind === "ArrayExpression") {
        context.addArrayExpression(lvalue.identifier.id, value);
      }
    }
    block.instructions = rewriteInstructions(rewriteInstrs, block.instructions);
    block.instructions = deleteInstructions(deleteInstrs, block.instructions);
    if (rewriteInstrs.size > 0 || deleteInstrs.size > 0) {
      hasRewrite = true;
      fn.env.hasFireRewrite = true;
    }
  }
  if (hasRewrite) {
    markInstructionIds(fn.body);
  }
}
function visitFunctionExpressionAndPropagateFireDependencies(fnExpr, context, enteringUseEffect) {
  let withScope = enteringUseEffect ? context.withUseEffectLambdaScope.bind(context) : context.withFunctionScope.bind(context);
  const calleesCapturedByFnExpression = withScope(
    () => replaceFireFunctions(fnExpr.loweredFunc.func, context)
  );
  for (let contextIdx = 0; contextIdx < fnExpr.loweredFunc.func.context.length; contextIdx++) {
    const contextItem = fnExpr.loweredFunc.func.context[contextIdx];
    const replacedCallee = calleesCapturedByFnExpression.get(
      contextItem.identifier.id
    );
    if (replacedCallee != null) {
      fnExpr.loweredFunc.func.context[contextIdx] = __spreadValues({}, replacedCallee.fireFunctionBinding);
    }
  }
  context.mergeCalleesFromInnerScope(calleesCapturedByFnExpression);
  return calleesCapturedByFnExpression;
}
function* eachReachablePlace(fn) {
  for (const [, block] of fn.body.blocks) {
    for (const instr of block.instructions) {
      if (instr.value.kind === "FunctionExpression" || instr.value.kind === "ObjectMethod") {
        yield* __yieldStar(eachReachablePlace(instr.value.loweredFunc.func));
      } else {
        yield* __yieldStar(eachInstructionOperand(instr));
      }
    }
  }
}
function ensureNoRemainingCalleeCaptures(fn, context, capturedCallees) {
  var _a;
  for (const place of eachReachablePlace(fn)) {
    const calleeInfo = capturedCallees.get(place.identifier.id);
    if (calleeInfo != null) {
      const calleeName = ((_a = calleeInfo.capturedCalleeIdentifier.name) == null ? void 0 : _a.kind) === "named" ? calleeInfo.capturedCalleeIdentifier.name.value : "<unknown>";
      context.pushError({
        loc: place.loc,
        description: `All uses of ${calleeName} must be either used with a fire() call in this effect or not used with a fire() call at all. ${calleeName} was used with fire() on line ${printSourceLocationLine(calleeInfo.fireLoc)} in this effect`,
        severity: "InvalidReact" /* InvalidReact */,
        category: "Fire" /* Fire */,
        reason: CANNOT_COMPILE_FIRE,
        suggestions: null
      });
    }
  }
}
function ensureNoMoreFireUses(fn, context) {
  for (const place of eachReachablePlace(fn)) {
    if (place.identifier.type.kind === "Function" && place.identifier.type.shapeId === BuiltInFireId) {
      context.pushError({
        loc: place.identifier.loc,
        description: "Cannot use `fire` outside of a useEffect function",
        category: "Fire" /* Fire */,
        severity: "Invariant" /* Invariant */,
        reason: CANNOT_COMPILE_FIRE,
        suggestions: null
      });
    }
  }
}
function makeLoadUseFireInstruction(env, importedLoadUseFire) {
  const useFirePlace = createTemporaryPlace(env, GeneratedSource);
  useFirePlace.effect = "read" /* Read */;
  useFirePlace.identifier.type = DefaultNonmutatingHook;
  const instrValue = {
    kind: "LoadGlobal",
    binding: __spreadValues({}, importedLoadUseFire),
    loc: GeneratedSource
  };
  return {
    id: makeInstructionId(0),
    value: instrValue,
    lvalue: __spreadValues({}, useFirePlace),
    loc: GeneratedSource,
    effects: null
  };
}
function makeLoadFireCalleeInstruction(env, fireCalleeIdentifier) {
  const loadedFireCallee = createTemporaryPlace(env, GeneratedSource);
  const fireCallee = {
    kind: "Identifier",
    identifier: fireCalleeIdentifier,
    reactive: false,
    effect: "<unknown>" /* Unknown */,
    loc: fireCalleeIdentifier.loc
  };
  return {
    id: makeInstructionId(0),
    value: {
      kind: "LoadLocal",
      loc: GeneratedSource,
      place: __spreadValues({}, fireCallee)
    },
    lvalue: __spreadValues({}, loadedFireCallee),
    loc: GeneratedSource,
    effects: null
  };
}
function makeCallUseFireInstruction(env, useFirePlace, argPlace) {
  const useFireCallResultPlace = createTemporaryPlace(env, GeneratedSource);
  useFireCallResultPlace.effect = "read" /* Read */;
  const useFireCall = {
    kind: "CallExpression",
    callee: __spreadValues({}, useFirePlace),
    args: [argPlace],
    loc: GeneratedSource
  };
  return {
    id: makeInstructionId(0),
    value: useFireCall,
    lvalue: __spreadValues({}, useFireCallResultPlace),
    loc: GeneratedSource,
    effects: null
  };
}
function makeStoreUseFireInstruction(env, useFireCallResultPlace, fireFunctionBindingPlace) {
  promoteTemporary(fireFunctionBindingPlace.identifier);
  const fireFunctionBindingLValuePlace = createTemporaryPlace(
    env,
    GeneratedSource
  );
  return {
    id: makeInstructionId(0),
    value: {
      kind: "StoreLocal",
      lvalue: {
        kind: "Const" /* Const */,
        place: __spreadValues({}, fireFunctionBindingPlace)
      },
      value: __spreadValues({}, useFireCallResultPlace),
      type: null,
      loc: GeneratedSource
    },
    lvalue: fireFunctionBindingLValuePlace,
    loc: GeneratedSource,
    effects: null
  };
}
var _env3, _errors, _callExpressions, _functionExpressions, _loadLocals, _fireCalleesToFireFunctions, _calleesWithInsertedFire, _capturedCalleeIdentifierIds, _inUseEffectLambda, _loadGlobalInstructionIds, _arrayExpressions;
var Context4 = class {
  constructor(env) {
    __privateAdd(this, _env3);
    __privateAdd(this, _errors, new CompilerError());
    /*
     * Used to look up the call expression passed to a `fire(callExpr())`. Gives back
     * the `callExpr()`.
     */
    __privateAdd(this, _callExpressions, /* @__PURE__ */ new Map());
    /*
     * We keep track of function expressions so that we can traverse them when
     * we encounter a lambda passed to a useEffect call
     */
    __privateAdd(this, _functionExpressions, /* @__PURE__ */ new Map());
    /*
     * Mapping from lvalue ids to the LoadLocal for it. Allows us to replace dependency LoadLocals.
     */
    __privateAdd(this, _loadLocals, /* @__PURE__ */ new Map());
    /*
     * Maps all of the fire callees found in a component/hook to the generated fire function places
     * we create for them. Allows us to reuse already-inserted useFire results
     */
    __privateAdd(this, _fireCalleesToFireFunctions, /* @__PURE__ */ new Map());
    /*
     * The callees for which we have already created fire bindings. Used to skip inserting a new
     * useFire call for a fire callee if one has already been created.
     */
    __privateAdd(this, _calleesWithInsertedFire, /* @__PURE__ */ new Set());
    /*
     * A mapping from fire callees to the created fire function bindings that are reachable from this
     * scope.
     *
     * We additionally keep track of the captured callee identifier so that we can properly reference
     * it in the place where we LoadLocal the callee as an argument to useFire.
     */
    __privateAdd(this, _capturedCalleeIdentifierIds, /* @__PURE__ */ new Map());
    /*
     * We only transform fire calls if we're syntactically within a useEffect lambda (for now)
     */
    __privateAdd(this, _inUseEffectLambda, false);
    /*
     * Mapping from useEffect callee identifier ids to the instruction id of the
     * load global instruction for the useEffect call. We use this to insert the
     * useFire calls before the useEffect call
     */
    __privateAdd(this, _loadGlobalInstructionIds, /* @__PURE__ */ new Map());
    /*
     * We keep track of array expressions so we can rewrite dependency arrays passed to useEffect
     * to use the fire functions
     */
    __privateAdd(this, _arrayExpressions, /* @__PURE__ */ new Map());
    __privateSet(this, _env3, env);
  }
  pushError(error) {
    __privateGet(this, _errors).push(error);
  }
  withFunctionScope(fn) {
    fn();
    return __privateGet(this, _capturedCalleeIdentifierIds);
  }
  withUseEffectLambdaScope(fn) {
    const capturedCalleeIdentifierIds = __privateGet(this, _capturedCalleeIdentifierIds);
    const inUseEffectLambda = __privateGet(this, _inUseEffectLambda);
    __privateSet(this, _capturedCalleeIdentifierIds, /* @__PURE__ */ new Map());
    __privateSet(this, _inUseEffectLambda, true);
    const resultCapturedCalleeIdentifierIds = this.withFunctionScope(fn);
    __privateSet(this, _capturedCalleeIdentifierIds, capturedCalleeIdentifierIds);
    __privateSet(this, _inUseEffectLambda, inUseEffectLambda);
    return resultCapturedCalleeIdentifierIds;
  }
  addCallExpression(id, callExpr) {
    __privateGet(this, _callExpressions).set(id, callExpr);
  }
  getCallExpression(id) {
    return __privateGet(this, _callExpressions).get(id);
  }
  addLoadLocalInstr(id, loadLocal) {
    __privateGet(this, _loadLocals).set(id, loadLocal);
  }
  getLoadLocalInstr(id) {
    return __privateGet(this, _loadLocals).get(id);
  }
  getOrGenerateFireFunctionBinding(callee, fireLoc) {
    const fireFunctionBinding = getOrInsertWith(
      __privateGet(this, _fireCalleesToFireFunctions),
      callee.identifier.id,
      () => createTemporaryPlace(__privateGet(this, _env3), GeneratedSource)
    );
    fireFunctionBinding.identifier.type = {
      kind: "Function",
      shapeId: BuiltInFireFunctionId,
      return: { kind: "Poly" },
      isConstructor: false
    };
    __privateGet(this, _capturedCalleeIdentifierIds).set(callee.identifier.id, {
      fireFunctionBinding,
      capturedCalleeIdentifier: callee.identifier,
      fireLoc
    });
    return fireFunctionBinding;
  }
  mergeCalleesFromInnerScope(innerCallees) {
    for (const [id, calleeInfo] of innerCallees.entries()) {
      __privateGet(this, _capturedCalleeIdentifierIds).set(id, calleeInfo);
    }
  }
  addCalleeWithInsertedFire(id) {
    __privateGet(this, _calleesWithInsertedFire).add(id);
  }
  hasCalleeWithInsertedFire(id) {
    return __privateGet(this, _calleesWithInsertedFire).has(id);
  }
  inUseEffectLambda() {
    return __privateGet(this, _inUseEffectLambda);
  }
  addFunctionExpression(id, fn) {
    __privateGet(this, _functionExpressions).set(id, fn);
  }
  getFunctionExpression(id) {
    return __privateGet(this, _functionExpressions).get(id);
  }
  addLoadGlobalInstrId(id, instrId) {
    __privateGet(this, _loadGlobalInstructionIds).set(id, instrId);
  }
  getLoadGlobalInstrId(id) {
    return __privateGet(this, _loadGlobalInstructionIds).get(id);
  }
  addArrayExpression(id, array) {
    __privateGet(this, _arrayExpressions).set(id, array);
  }
  getArrayExpression(id) {
    return __privateGet(this, _arrayExpressions).get(id);
  }
  hasErrors() {
    return __privateGet(this, _errors).hasErrors();
  }
  throwIfErrorsFound() {
    if (this.hasErrors()) throw __privateGet(this, _errors);
  }
};
_env3 = new WeakMap();
_errors = new WeakMap();
_callExpressions = new WeakMap();
_functionExpressions = new WeakMap();
_loadLocals = new WeakMap();
_fireCalleesToFireFunctions = new WeakMap();
_calleesWithInsertedFire = new WeakMap();
_capturedCalleeIdentifierIds = new WeakMap();
_inUseEffectLambda = new WeakMap();
_loadGlobalInstructionIds = new WeakMap();
_arrayExpressions = new WeakMap();
function deleteInstructions(deleteInstrs, instructions) {
  if (deleteInstrs.size > 0) {
    const newInstrs = instructions.filter((instr) => !deleteInstrs.has(instr.id));
    return newInstrs;
  }
  return instructions;
}
function rewriteInstructions(rewriteInstrs, instructions) {
  if (rewriteInstrs.size > 0) {
    const newInstrs = [];
    for (const instr of instructions) {
      const newInstrsAtId = rewriteInstrs.get(instr.id);
      if (newInstrsAtId != null) {
        newInstrs.push(...newInstrsAtId, instr);
      } else {
        newInstrs.push(instr);
      }
    }
    return newInstrs;
  }
  return instructions;
}

// src/Validation/ValidateNoImpureFunctionsInRender.ts
function validateNoImpureFunctionsInRender(fn) {
  const errors = new CompilerError();
  for (const [, block] of fn.body.blocks) {
    for (const instr of block.instructions) {
      const value = instr.value;
      if (value.kind === "MethodCall" || value.kind == "CallExpression") {
        const callee = value.kind === "MethodCall" ? value.property : value.callee;
        const signature = getFunctionCallSignature(
          fn.env,
          callee.identifier.type
        );
        if (signature != null && signature.impure === true) {
          errors.pushDiagnostic(
            CompilerDiagnostic.create({
              category: "Purity" /* Purity */,
              reason: "Cannot call impure function during render",
              description: (signature.canonicalName != null ? `\`${signature.canonicalName}\` is an impure function. ` : "") + "Calling an impure function can produce unstable results that update unpredictably when the component happens to re-render. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#components-and-hooks-must-be-idempotent)",
              severity: "InvalidReact" /* InvalidReact */,
              suggestions: null
            }).withDetail({
              kind: "error",
              loc: callee.loc,
              message: "Cannot call impure function"
            })
          );
        }
      }
    }
  }
  return errors.asResult();
}

// src/Validation/ValidateStaticComponents.ts
function validateStaticComponents(fn) {
  const error = new CompilerError();
  const knownDynamicComponents = /* @__PURE__ */ new Map();
  for (const block of fn.body.blocks.values()) {
    phis: for (const phi of block.phis) {
      for (const operand of phi.operands.values()) {
        const loc = knownDynamicComponents.get(operand.identifier.id);
        if (loc != null) {
          knownDynamicComponents.set(phi.place.identifier.id, loc);
          continue phis;
        }
      }
    }
    for (const instr of block.instructions) {
      const { lvalue, value } = instr;
      switch (value.kind) {
        case "FunctionExpression":
        case "NewExpression":
        case "MethodCall":
        case "CallExpression": {
          knownDynamicComponents.set(lvalue.identifier.id, value.loc);
          break;
        }
        case "LoadLocal": {
          const loc = knownDynamicComponents.get(value.place.identifier.id);
          if (loc != null) {
            knownDynamicComponents.set(lvalue.identifier.id, loc);
          }
          break;
        }
        case "StoreLocal": {
          const loc = knownDynamicComponents.get(value.value.identifier.id);
          if (loc != null) {
            knownDynamicComponents.set(lvalue.identifier.id, loc);
            knownDynamicComponents.set(value.lvalue.place.identifier.id, loc);
          }
          break;
        }
        case "JsxExpression": {
          if (value.tag.kind === "Identifier") {
            const location = knownDynamicComponents.get(
              value.tag.identifier.id
            );
            if (location != null) {
              error.pushDiagnostic(
                CompilerDiagnostic.create({
                  category: "StaticComponents" /* StaticComponents */,
                  severity: "InvalidReact" /* InvalidReact */,
                  reason: "Cannot create components during render",
                  description: `Components created during render will reset their state each time they are created. Declare components outside of render. `
                }).withDetail({
                  kind: "error",
                  loc: value.tag.loc,
                  message: "This component is created during render"
                }).withDetail({
                  kind: "error",
                  loc: location,
                  message: "The component is created during render here"
                })
              );
            }
          }
        }
      }
    }
  }
  return error.asResult();
}

// src/Validation/ValidateNoFreezingKnownMutableFunctions.ts
function validateNoFreezingKnownMutableFunctions(fn) {
  const errors = new CompilerError();
  const contextMutationEffects = /* @__PURE__ */ new Map();
  function visitOperand(operand) {
    if (operand.effect === "freeze" /* Freeze */) {
      const effect = contextMutationEffects.get(operand.identifier.id);
      if (effect != null) {
        const place = effect.value;
        const variable = place != null && place.identifier.name != null && place.identifier.name.kind === "named" ? `\`${place.identifier.name.value}\`` : "a local variable";
        errors.pushDiagnostic(
          CompilerDiagnostic.create({
            category: "Immutability" /* Immutability */,
            severity: "InvalidReact" /* InvalidReact */,
            reason: "Cannot modify local variables after render completes",
            description: `This argument is a function which may reassign or mutate ${variable} after render, which can cause inconsistent behavior on subsequent renders. Consider using state instead.`
          }).withDetail({
            kind: "error",
            loc: operand.loc,
            message: `This function may (indirectly) reassign or modify ${variable} after render`
          }).withDetail({
            kind: "error",
            loc: effect.value.loc,
            message: `This modifies ${variable}`
          })
        );
      }
    }
  }
  for (const block of fn.body.blocks.values()) {
    for (const instr of block.instructions) {
      const { lvalue, value } = instr;
      switch (value.kind) {
        case "LoadLocal": {
          const effect = contextMutationEffects.get(value.place.identifier.id);
          if (effect != null) {
            contextMutationEffects.set(lvalue.identifier.id, effect);
          }
          break;
        }
        case "StoreLocal": {
          const effect = contextMutationEffects.get(value.value.identifier.id);
          if (effect != null) {
            contextMutationEffects.set(lvalue.identifier.id, effect);
            contextMutationEffects.set(
              value.lvalue.place.identifier.id,
              effect
            );
          }
          break;
        }
        case "FunctionExpression": {
          if (value.loweredFunc.func.aliasingEffects != null) {
            const context = new Set(
              value.loweredFunc.func.context.map((p) => p.identifier.id)
            );
            effects: for (const effect of value.loweredFunc.func.aliasingEffects) {
              switch (effect.kind) {
                case "Mutate":
                case "MutateTransitive": {
                  const knownMutation = contextMutationEffects.get(
                    effect.value.identifier.id
                  );
                  if (knownMutation != null) {
                    contextMutationEffects.set(
                      lvalue.identifier.id,
                      knownMutation
                    );
                  } else if (context.has(effect.value.identifier.id) && !isRefOrRefLikeMutableType(effect.value.identifier.type)) {
                    contextMutationEffects.set(lvalue.identifier.id, effect);
                    break effects;
                  }
                  break;
                }
                case "MutateConditionally":
                case "MutateTransitiveConditionally": {
                  const knownMutation = contextMutationEffects.get(
                    effect.value.identifier.id
                  );
                  if (knownMutation != null) {
                    contextMutationEffects.set(
                      lvalue.identifier.id,
                      knownMutation
                    );
                  }
                  break;
                }
              }
            }
          }
          break;
        }
        default: {
          for (const operand of eachInstructionValueOperand(value)) {
            visitOperand(operand);
          }
        }
      }
    }
    for (const operand of eachTerminalOperand(block.terminal)) {
      visitOperand(operand);
    }
  }
  return errors.asResult();
}

// src/Validation/ValidateNoDerivedComputationsInEffects.ts
function validateNoDerivedComputationsInEffects(fn) {
  const candidateDependencies = /* @__PURE__ */ new Map();
  const functions = /* @__PURE__ */ new Map();
  const locals = /* @__PURE__ */ new Map();
  const errors = new CompilerError();
  for (const block of fn.body.blocks.values()) {
    for (const instr of block.instructions) {
      const { lvalue, value } = instr;
      if (value.kind === "LoadLocal") {
        locals.set(lvalue.identifier.id, value.place.identifier.id);
      } else if (value.kind === "ArrayExpression") {
        candidateDependencies.set(lvalue.identifier.id, value);
      } else if (value.kind === "FunctionExpression") {
        functions.set(lvalue.identifier.id, value);
      } else if (value.kind === "CallExpression" || value.kind === "MethodCall") {
        const callee = value.kind === "CallExpression" ? value.callee : value.property;
        if (isUseEffectHookType(callee.identifier) && value.args.length === 2 && value.args[0].kind === "Identifier" && value.args[1].kind === "Identifier") {
          const effectFunction = functions.get(value.args[0].identifier.id);
          const deps = candidateDependencies.get(value.args[1].identifier.id);
          if (effectFunction != null && deps != null && deps.elements.length !== 0 && deps.elements.every((element) => element.kind === "Identifier")) {
            const dependencies = deps.elements.map((dep) => {
              var _a;
              CompilerError.invariant(dep.kind === "Identifier", {
                reason: `Dependency is checked as a place above`,
                loc: value.loc
              });
              return (_a = locals.get(dep.identifier.id)) != null ? _a : dep.identifier.id;
            });
            validateEffect(
              effectFunction.loweredFunc.func,
              dependencies,
              errors
            );
          }
        }
      }
    }
  }
  if (errors.hasErrors()) {
    throw errors;
  }
}
function validateEffect(effectFunction, effectDeps, errors) {
  for (const operand of effectFunction.context) {
    if (isSetStateType(operand.identifier)) {
      continue;
    } else if (effectDeps.find((dep) => dep === operand.identifier.id) != null) {
      continue;
    } else {
      return;
    }
  }
  for (const dep of effectDeps) {
    if (effectFunction.context.find((operand) => operand.identifier.id === dep) == null) {
      return;
    }
  }
  const seenBlocks = /* @__PURE__ */ new Set();
  const values = /* @__PURE__ */ new Map();
  for (const dep of effectDeps) {
    values.set(dep, [dep]);
  }
  const setStateLocations = [];
  for (const block of effectFunction.body.blocks.values()) {
    for (const pred of block.preds) {
      if (!seenBlocks.has(pred)) {
        return;
      }
    }
    for (const phi of block.phis) {
      const aggregateDeps = /* @__PURE__ */ new Set();
      for (const operand of phi.operands.values()) {
        const deps = values.get(operand.identifier.id);
        if (deps != null) {
          for (const dep of deps) {
            aggregateDeps.add(dep);
          }
        }
      }
      if (aggregateDeps.size !== 0) {
        values.set(phi.place.identifier.id, Array.from(aggregateDeps));
      }
    }
    for (const instr of block.instructions) {
      switch (instr.value.kind) {
        case "Primitive":
        case "JSXText":
        case "LoadGlobal": {
          break;
        }
        case "LoadLocal": {
          const deps = values.get(instr.value.place.identifier.id);
          if (deps != null) {
            values.set(instr.lvalue.identifier.id, deps);
          }
          break;
        }
        case "ComputedLoad":
        case "PropertyLoad":
        case "BinaryExpression":
        case "TemplateLiteral":
        case "CallExpression":
        case "MethodCall": {
          const aggregateDeps = /* @__PURE__ */ new Set();
          for (const operand of eachInstructionValueOperand(instr.value)) {
            const deps = values.get(operand.identifier.id);
            if (deps != null) {
              for (const dep of deps) {
                aggregateDeps.add(dep);
              }
            }
          }
          if (aggregateDeps.size !== 0) {
            values.set(instr.lvalue.identifier.id, Array.from(aggregateDeps));
          }
          if (instr.value.kind === "CallExpression" && isSetStateType(instr.value.callee.identifier) && instr.value.args.length === 1 && instr.value.args[0].kind === "Identifier") {
            const deps = values.get(instr.value.args[0].identifier.id);
            if (deps != null && new Set(deps).size === effectDeps.length) {
              setStateLocations.push(instr.value.callee.loc);
            } else {
              return;
            }
          }
          break;
        }
        default: {
          return;
        }
      }
    }
    for (const operand of eachTerminalOperand(block.terminal)) {
      if (values.has(operand.identifier.id)) {
        return;
      }
    }
    seenBlocks.add(block.id);
  }
  for (const loc of setStateLocations) {
    errors.push({
      category: "EffectDerivationsOfState" /* EffectDerivationsOfState */,
      reason: "Values derived from props and state should be calculated during render, not in an effect. (https://react.dev/learn/you-might-not-need-an-effect#updating-state-based-on-props-or-state)",
      description: null,
      severity: "InvalidReact" /* InvalidReact */,
      loc,
      suggestions: null
    });
  }
}

// src/Entrypoint/Pipeline.ts
function run(func, config, fnType, mode, programContext, logger, filename, code) {
  var _a, _b;
  const contextIdentifiers = findContextIdentifiers(func);
  const env = new Environment2(
    func.scope,
    fnType,
    mode,
    config,
    contextIdentifiers,
    func,
    logger,
    filename,
    code,
    programContext
  );
  (_b = (_a = env.logger) == null ? void 0 : _a.debugLogIRs) == null ? void 0 : _b.call(_a, {
    kind: "debug",
    name: "EnvironmentConfig",
    value: (0, import_pretty_format3.default)(env.config)
  });
  return runWithEnvironment(func, env);
}
function runWithEnvironment(func, env) {
  const log2 = (value) => {
    var _a, _b;
    (_b = (_a = env.logger) == null ? void 0 : _a.debugLogIRs) == null ? void 0 : _b.call(_a, value);
  };
  const hir = lower(func, env).unwrap();
  log2({ kind: "hir", name: "HIR", value: hir });
  pruneMaybeThrows(hir);
  log2({ kind: "hir", name: "PruneMaybeThrows", value: hir });
  validateContextVariableLValues(hir);
  validateUseMemo(hir).unwrap();
  if (env.isInferredMemoEnabled && !env.config.enablePreserveExistingManualUseMemo && !env.config.disableMemoizationForDebugging && !env.config.enableChangeDetectionForDebugging) {
    dropManualMemoization(hir).unwrap();
    log2({ kind: "hir", name: "DropManualMemoization", value: hir });
  }
  inlineImmediatelyInvokedFunctionExpressions(hir);
  log2({
    kind: "hir",
    name: "InlineImmediatelyInvokedFunctionExpressions",
    value: hir
  });
  mergeConsecutiveBlocks(hir);
  log2({ kind: "hir", name: "MergeConsecutiveBlocks", value: hir });
  assertConsistentIdentifiers(hir);
  assertTerminalSuccessorsExist(hir);
  enterSSA(hir);
  log2({ kind: "hir", name: "SSA", value: hir });
  eliminateRedundantPhi(hir);
  log2({ kind: "hir", name: "EliminateRedundantPhi", value: hir });
  assertConsistentIdentifiers(hir);
  constantPropagation(hir);
  log2({ kind: "hir", name: "ConstantPropagation", value: hir });
  inferTypes(hir);
  log2({ kind: "hir", name: "InferTypes", value: hir });
  if (env.isInferredMemoEnabled) {
    if (env.config.validateHooksUsage) {
      validateHooksUsage(hir).unwrap();
    }
    if (env.config.validateNoCapitalizedCalls) {
      validateNoCapitalizedCalls(hir).unwrap();
    }
  }
  if (env.config.enableFire) {
    transformFire(hir);
    log2({ kind: "hir", name: "TransformFire", value: hir });
  }
  if (env.config.lowerContextAccess) {
    lowerContextAccess(hir, env.config.lowerContextAccess);
  }
  optimizePropsMethodCalls(hir);
  log2({ kind: "hir", name: "OptimizePropsMethodCalls", value: hir });
  analyseFunctions(hir);
  log2({ kind: "hir", name: "AnalyseFunctions", value: hir });
  const mutabilityAliasingErrors = inferMutationAliasingEffects(hir);
  log2({ kind: "hir", name: "InferMutationAliasingEffects", value: hir });
  if (env.isInferredMemoEnabled) {
    if (mutabilityAliasingErrors.isErr()) {
      throw mutabilityAliasingErrors.unwrapErr();
    }
  }
  deadCodeElimination(hir);
  log2({ kind: "hir", name: "DeadCodeElimination", value: hir });
  if (env.config.enableInstructionReordering) {
    instructionReordering(hir);
    log2({ kind: "hir", name: "InstructionReordering", value: hir });
  }
  pruneMaybeThrows(hir);
  log2({ kind: "hir", name: "PruneMaybeThrows", value: hir });
  const mutabilityAliasingRangeErrors = inferMutationAliasingRanges(hir, {
    isFunctionExpression: false
  });
  log2({ kind: "hir", name: "InferMutationAliasingRanges", value: hir });
  if (env.isInferredMemoEnabled) {
    if (mutabilityAliasingRangeErrors.isErr()) {
      throw mutabilityAliasingRangeErrors.unwrapErr();
    }
    validateLocalsNotReassignedAfterRender(hir);
  }
  if (env.isInferredMemoEnabled) {
    if (env.config.assertValidMutableRanges) {
      assertValidMutableRanges(hir);
    }
    if (env.config.validateRefAccessDuringRender) {
      validateNoRefAccessInRender(hir).unwrap();
    }
    if (env.config.validateNoSetStateInRender) {
      validateNoSetStateInRender(hir).unwrap();
    }
    if (env.config.validateNoDerivedComputationsInEffects) {
      validateNoDerivedComputationsInEffects(hir);
    }
    if (env.config.validateNoSetStateInEffects) {
      env.logErrors(validateNoSetStateInEffects(hir));
    }
    if (env.config.validateNoJSXInTryStatements) {
      env.logErrors(validateNoJSXInTryStatement(hir));
    }
    if (env.config.validateNoImpureFunctionsInRender) {
      validateNoImpureFunctionsInRender(hir).unwrap();
    }
    validateNoFreezingKnownMutableFunctions(hir).unwrap();
  }
  inferReactivePlaces(hir);
  log2({ kind: "hir", name: "InferReactivePlaces", value: hir });
  rewriteInstructionKindsBasedOnReassignment(hir);
  log2({
    kind: "hir",
    name: "RewriteInstructionKindsBasedOnReassignment",
    value: hir
  });
  if (env.isInferredMemoEnabled) {
    if (env.config.validateStaticComponents) {
      env.logErrors(validateStaticComponents(hir));
    }
    inferReactiveScopeVariables(hir);
    log2({ kind: "hir", name: "InferReactiveScopeVariables", value: hir });
  }
  const fbtOperands = memoizeFbtAndMacroOperandsInSameScope(hir);
  log2({
    kind: "hir",
    name: "MemoizeFbtAndMacroOperandsInSameScope",
    value: hir
  });
  if (env.config.enableJsxOutlining) {
    outlineJSX(hir);
  }
  if (env.config.enableFunctionOutlining) {
    outlineFunctions(hir, fbtOperands);
    log2({ kind: "hir", name: "OutlineFunctions", value: hir });
  }
  alignMethodCallScopes(hir);
  log2({
    kind: "hir",
    name: "AlignMethodCallScopes",
    value: hir
  });
  alignObjectMethodScopes(hir);
  log2({
    kind: "hir",
    name: "AlignObjectMethodScopes",
    value: hir
  });
  pruneUnusedLabelsHIR(hir);
  log2({
    kind: "hir",
    name: "PruneUnusedLabelsHIR",
    value: hir
  });
  alignReactiveScopesToBlockScopesHIR(hir);
  log2({
    kind: "hir",
    name: "AlignReactiveScopesToBlockScopesHIR",
    value: hir
  });
  mergeOverlappingReactiveScopesHIR(hir);
  log2({
    kind: "hir",
    name: "MergeOverlappingReactiveScopesHIR",
    value: hir
  });
  assertValidBlockNesting(hir);
  buildReactiveScopeTerminalsHIR(hir);
  log2({
    kind: "hir",
    name: "BuildReactiveScopeTerminalsHIR",
    value: hir
  });
  assertValidBlockNesting(hir);
  flattenReactiveLoopsHIR(hir);
  log2({
    kind: "hir",
    name: "FlattenReactiveLoopsHIR",
    value: hir
  });
  flattenScopesWithHooksOrUseHIR(hir);
  log2({
    kind: "hir",
    name: "FlattenScopesWithHooksOrUseHIR",
    value: hir
  });
  assertTerminalSuccessorsExist(hir);
  assertTerminalPredsExist(hir);
  propagateScopeDependenciesHIR(hir);
  log2({
    kind: "hir",
    name: "PropagateScopeDependenciesHIR",
    value: hir
  });
  if (env.config.inferEffectDependencies) {
    inferEffectDependencies(hir);
    log2({
      kind: "hir",
      name: "InferEffectDependencies",
      value: hir
    });
  }
  if (env.config.inlineJsxTransform) {
    inlineJsxTransform(hir, env.config.inlineJsxTransform);
    log2({
      kind: "hir",
      name: "inlineJsxTransform",
      value: hir
    });
  }
  const reactiveFunction = buildReactiveFunction(hir);
  log2({
    kind: "reactive",
    name: "BuildReactiveFunction",
    value: reactiveFunction
  });
  assertWellFormedBreakTargets(reactiveFunction);
  pruneUnusedLabels(reactiveFunction);
  log2({
    kind: "reactive",
    name: "PruneUnusedLabels",
    value: reactiveFunction
  });
  assertScopeInstructionsWithinScopes(reactiveFunction);
  pruneNonEscapingScopes(reactiveFunction);
  log2({
    kind: "reactive",
    name: "PruneNonEscapingScopes",
    value: reactiveFunction
  });
  pruneNonReactiveDependencies(reactiveFunction);
  log2({
    kind: "reactive",
    name: "PruneNonReactiveDependencies",
    value: reactiveFunction
  });
  pruneUnusedScopes(reactiveFunction);
  log2({
    kind: "reactive",
    name: "PruneUnusedScopes",
    value: reactiveFunction
  });
  mergeReactiveScopesThatInvalidateTogether(reactiveFunction);
  log2({
    kind: "reactive",
    name: "MergeReactiveScopesThatInvalidateTogether",
    value: reactiveFunction
  });
  pruneAlwaysInvalidatingScopes(reactiveFunction);
  log2({
    kind: "reactive",
    name: "PruneAlwaysInvalidatingScopes",
    value: reactiveFunction
  });
  if (env.config.enableChangeDetectionForDebugging != null) {
    pruneInitializationDependencies(reactiveFunction);
    log2({
      kind: "reactive",
      name: "PruneInitializationDependencies",
      value: reactiveFunction
    });
  }
  propagateEarlyReturns(reactiveFunction);
  log2({
    kind: "reactive",
    name: "PropagateEarlyReturns",
    value: reactiveFunction
  });
  pruneUnusedLValues(reactiveFunction);
  log2({
    kind: "reactive",
    name: "PruneUnusedLValues",
    value: reactiveFunction
  });
  promoteUsedTemporaries(reactiveFunction);
  log2({
    kind: "reactive",
    name: "PromoteUsedTemporaries",
    value: reactiveFunction
  });
  extractScopeDeclarationsFromDestructuring(reactiveFunction);
  log2({
    kind: "reactive",
    name: "ExtractScopeDeclarationsFromDestructuring",
    value: reactiveFunction
  });
  stabilizeBlockIds(reactiveFunction);
  log2({
    kind: "reactive",
    name: "StabilizeBlockIds",
    value: reactiveFunction
  });
  const uniqueIdentifiers = renameVariables(reactiveFunction);
  log2({
    kind: "reactive",
    name: "RenameVariables",
    value: reactiveFunction
  });
  pruneHoistedContexts(reactiveFunction);
  log2({
    kind: "reactive",
    name: "PruneHoistedContexts",
    value: reactiveFunction
  });
  if (env.config.validateMemoizedEffectDependencies) {
    validateMemoizedEffectDependencies(reactiveFunction).unwrap();
  }
  if (env.config.enablePreserveExistingMemoizationGuarantees || env.config.validatePreserveExistingMemoizationGuarantees) {
    validatePreservedManualMemoization(reactiveFunction).unwrap();
  }
  const ast = codegenFunction(reactiveFunction, {
    uniqueIdentifiers,
    fbtOperands
  }).unwrap();
  log2({ kind: "ast", name: "Codegen", value: ast });
  for (const outlined of ast.outlined) {
    log2({ kind: "ast", name: "Codegen (outlined)", value: outlined.fn });
  }
  if (env.config.throwUnknownException__testonly) {
    throw new Error("unexpected error");
  }
  return ast;
}
function compileFn(func, config, fnType, mode, programContext, logger, filename, code) {
  return run(
    func,
    config,
    fnType,
    mode,
    programContext,
    logger,
    filename,
    code
  );
}

// src/Entrypoint/Suppression.ts
function filterSuppressionsThatAffectFunction(suppressionRanges, fn) {
  const suppressionsInScope = [];
  const fnNode = fn.node;
  for (const suppressionRange of suppressionRanges) {
    if (suppressionRange.disableComment.start == null || fnNode.start == null || fnNode.end == null) {
      continue;
    }
    if (suppressionRange.disableComment.start > fnNode.start && // If there is no matching enable, the rest of the file has potential violations
    (suppressionRange.enableComment === null || suppressionRange.enableComment.end != null && suppressionRange.enableComment.end < fnNode.end)) {
      suppressionsInScope.push(suppressionRange);
    }
    if (suppressionRange.disableComment.start < fnNode.start && // If there is no matching enable, the rest of the file has potential violations
    (suppressionRange.enableComment === null || suppressionRange.enableComment.end != null && suppressionRange.enableComment.end > fnNode.end)) {
      suppressionsInScope.push(suppressionRange);
    }
  }
  return suppressionsInScope;
}
function findProgramSuppressions(programComments, ruleNames, flowSuppressions) {
  const suppressionRanges = [];
  let disableComment = null;
  let enableComment = null;
  let source2 = null;
  const rulePattern = `(${ruleNames.join("|")})`;
  const disableNextLinePattern = new RegExp(
    `eslint-disable-next-line ${rulePattern}`
  );
  const disablePattern = new RegExp(`eslint-disable ${rulePattern}`);
  const enablePattern = new RegExp(`eslint-enable ${rulePattern}`);
  const flowSuppressionPattern = new RegExp(
    "\\$(FlowFixMe\\w*|FlowExpectedError|FlowIssue)\\[react\\-rule"
  );
  for (const comment of programComments) {
    if (comment.start == null || comment.end == null) {
      continue;
    }
    if (
      /*
       * If we're already within a CommentBlock, we should not restart the range prematurely for a
       * CommentLine within the block.
       */
      disableComment == null && disableNextLinePattern.test(comment.value)
    ) {
      disableComment = comment;
      enableComment = comment;
      source2 = "Eslint";
    }
    if (flowSuppressions && disableComment == null && flowSuppressionPattern.test(comment.value)) {
      disableComment = comment;
      enableComment = comment;
      source2 = "Flow";
    }
    if (disablePattern.test(comment.value)) {
      disableComment = comment;
      source2 = "Eslint";
    }
    if (enablePattern.test(comment.value) && source2 === "Eslint") {
      enableComment = comment;
    }
    if (disableComment != null && source2 != null) {
      suppressionRanges.push({
        disableComment,
        enableComment,
        source: source2
      });
      disableComment = null;
      enableComment = null;
      source2 = null;
    }
  }
  return suppressionRanges;
}
function suppressionsToCompilerError(suppressionRanges) {
  var _a;
  CompilerError.invariant(suppressionRanges.length !== 0, {
    reason: `Expected at least suppression comment source range`,
    loc: GeneratedSource
  });
  const error = new CompilerError();
  for (const suppressionRange of suppressionRanges) {
    if (suppressionRange.disableComment.start == null || suppressionRange.disableComment.end == null) {
      continue;
    }
    let reason, suggestion;
    switch (suppressionRange.source) {
      case "Eslint":
        reason = "React Compiler has skipped optimizing this component because one or more React ESLint rules were disabled";
        suggestion = "Remove the ESLint suppression and address the React error";
        break;
      case "Flow":
        reason = "React Compiler has skipped optimizing this component because one or more React rule violations were reported by Flow";
        suggestion = "Remove the Flow suppression and address the React error";
        break;
      default:
        assertExhaustive(
          suppressionRange.source,
          "Unhandled suppression source"
        );
    }
    error.pushDiagnostic(
      CompilerDiagnostic.create({
        reason,
        description: `React Compiler only works when your components follow all the rules of React, disabling them may result in unexpected or incorrect behavior. Found suppression \`${suppressionRange.disableComment.value.trim()}\``,
        severity: "InvalidReact" /* InvalidReact */,
        category: "Suppression" /* Suppression */,
        suggestions: [
          {
            description: suggestion,
            range: [
              suppressionRange.disableComment.start,
              suppressionRange.disableComment.end
            ],
            op: 2 /* Remove */
          }
        ]
      }).withDetail({
        kind: "error",
        loc: (_a = suppressionRange.disableComment.loc) != null ? _a : null,
        message: "Found React rule suppression"
      })
    );
  }
  return error;
}

// src/Entrypoint/Program.ts
var OPT_IN_DIRECTIVES = /* @__PURE__ */ new Set(["use forget", "use memo"]);
var OPT_OUT_DIRECTIVES = /* @__PURE__ */ new Set(["use no forget", "use no memo"]);
var DYNAMIC_GATING_DIRECTIVE = new RegExp("^use memo if\\(([^\\)]*)\\)$");
function tryFindDirectiveEnablingMemoization(directives, opts) {
  var _a, _b;
  const optIn = directives.find(
    (directive2) => OPT_IN_DIRECTIVES.has(directive2.value.value)
  );
  if (optIn != null) {
    return Ok(optIn);
  }
  const dynamicGating = findDirectivesDynamicGating(directives, opts);
  if (dynamicGating.isOk()) {
    return Ok((_b = (_a = dynamicGating.unwrap()) == null ? void 0 : _a.directive) != null ? _b : null);
  } else {
    return Err(dynamicGating.unwrapErr());
  }
}
function findDirectiveDisablingMemoization(directives, { customOptOutDirectives }) {
  var _a, _b;
  if (customOptOutDirectives != null) {
    return (_a = directives.find(
      (directive2) => customOptOutDirectives.indexOf(directive2.value.value) !== -1
    )) != null ? _a : null;
  }
  return (_b = directives.find(
    (directive2) => OPT_OUT_DIRECTIVES.has(directive2.value.value)
  )) != null ? _b : null;
}
function findDirectivesDynamicGating(directives, opts) {
  var _a, _b;
  if (opts.dynamicGating === null) {
    return Ok(null);
  }
  const errors = new CompilerError();
  const result = [];
  for (const directive2 of directives) {
    const maybeMatch = DYNAMIC_GATING_DIRECTIVE.exec(directive2.value.value);
    if (maybeMatch != null && maybeMatch[1] != null) {
      if (t4.isValidIdentifier(maybeMatch[1])) {
        result.push({ directive: directive2, match: maybeMatch[1] });
      } else {
        errors.push({
          reason: `Dynamic gating directive is not a valid JavaScript identifier`,
          description: `Found '${directive2.value.value}'`,
          severity: "InvalidReact" /* InvalidReact */,
          category: "Gating" /* Gating */,
          loc: (_a = directive2.loc) != null ? _a : null,
          suggestions: null
        });
      }
    }
  }
  if (errors.hasErrors()) {
    return Err(errors);
  } else if (result.length > 1) {
    const error = new CompilerError();
    error.push({
      reason: `Multiple dynamic gating directives found`,
      description: `Expected a single directive but found [${result.map((r) => r.directive.value.value).join(", ")}]`,
      severity: "InvalidReact" /* InvalidReact */,
      category: "Gating" /* Gating */,
      loc: (_b = result[0].directive.loc) != null ? _b : null,
      suggestions: null
    });
    return Err(error);
  } else if (result.length === 1) {
    return Ok({
      gating: {
        source: opts.dynamicGating.source,
        importSpecifierName: result[0].match
      },
      directive: result[0].directive
    });
  } else {
    return Ok(null);
  }
}
function isCriticalError(err) {
  return !(err instanceof CompilerError) || err.isCritical();
}
function isConfigError(err) {
  if (err instanceof CompilerError) {
    return err.details.some(
      (detail) => detail.severity === "InvalidConfig" /* InvalidConfig */
    );
  }
  return false;
}
function logError(err, context, fnLoc) {
  var _a, _b;
  if (context.opts.logger) {
    if (err instanceof CompilerError) {
      for (const detail of err.details) {
        context.opts.logger.logEvent(context.filename, {
          kind: "CompileError",
          fnLoc,
          detail
        });
      }
    } else {
      let stringifiedError;
      if (err instanceof Error) {
        stringifiedError = (_a = err.stack) != null ? _a : err.message;
      } else {
        stringifiedError = (_b = err == null ? void 0 : err.toString()) != null ? _b : "[ null ]";
      }
      context.opts.logger.logEvent(context.filename, {
        kind: "PipelineError",
        fnLoc,
        data: stringifiedError
      });
    }
  }
}
function handleError(err, context, fnLoc) {
  logError(err, context, fnLoc);
  if (context.opts.panicThreshold === "all_errors" || context.opts.panicThreshold === "critical_errors" && isCriticalError(err) || isConfigError(err)) {
    throw err;
  }
}
function createNewFunctionNode(originalFn, compiledFn) {
  var _a, _b, _c;
  let transformedFn;
  switch (originalFn.node.type) {
    case "FunctionDeclaration": {
      const fn = {
        type: "FunctionDeclaration",
        id: compiledFn.id,
        loc: (_a = originalFn.node.loc) != null ? _a : null,
        async: compiledFn.async,
        generator: compiledFn.generator,
        params: compiledFn.params,
        body: compiledFn.body
      };
      transformedFn = fn;
      break;
    }
    case "ArrowFunctionExpression": {
      const fn = {
        type: "ArrowFunctionExpression",
        loc: (_b = originalFn.node.loc) != null ? _b : null,
        async: compiledFn.async,
        generator: compiledFn.generator,
        params: compiledFn.params,
        expression: originalFn.node.expression,
        body: compiledFn.body
      };
      transformedFn = fn;
      break;
    }
    case "FunctionExpression": {
      const fn = {
        type: "FunctionExpression",
        id: compiledFn.id,
        loc: (_c = originalFn.node.loc) != null ? _c : null,
        async: compiledFn.async,
        generator: compiledFn.generator,
        params: compiledFn.params,
        body: compiledFn.body
      };
      transformedFn = fn;
      break;
    }
    default: {
      assertExhaustive(
        originalFn.node,
        `Creating unhandled function: ${originalFn.node}`
      );
    }
  }
  return transformedFn;
}
function insertNewOutlinedFunctionNode(program, originalFn, compiledFn) {
  var _a, _b, _c;
  switch (originalFn.type) {
    case "FunctionDeclaration": {
      return originalFn.insertAfter(
        createNewFunctionNode(originalFn, compiledFn)
      )[0];
    }
    /**
     * We can't just append the outlined function as a sibling of the original function if it is an
     * (Arrow)FunctionExpression parented by a VariableDeclaration, as this would cause its parent
     * to become a SequenceExpression instead which breaks a bunch of assumptions elsewhere in the
     * plugin.
     *
     * To get around this, we always synthesize a new FunctionDeclaration for the outlined function
     * and insert it as a true sibling to the original function.
     */
    case "ArrowFunctionExpression":
    case "FunctionExpression": {
      const fn = {
        type: "FunctionDeclaration",
        id: compiledFn.id,
        loc: (_a = originalFn.node.loc) != null ? _a : null,
        async: compiledFn.async,
        generator: compiledFn.generator,
        params: compiledFn.params,
        body: compiledFn.body
      };
      const insertedFuncDecl = program.pushContainer("body", [fn])[0];
      CompilerError.invariant(insertedFuncDecl.isFunctionDeclaration(), {
        reason: "Expected inserted function declaration",
        description: `Got: ${insertedFuncDecl}`,
        loc: (_c = (_b = insertedFuncDecl.node) == null ? void 0 : _b.loc) != null ? _c : null
      });
      return insertedFuncDecl;
    }
    default: {
      assertExhaustive(
        originalFn,
        `Inserting unhandled function: ${originalFn}`
      );
    }
  }
}
var DEFAULT_ESLINT_SUPPRESSIONS = [
  "react-hooks/exhaustive-deps",
  "react-hooks/rules-of-hooks"
];
function isFilePartOfSources(sources, filename) {
  if (typeof sources === "function") {
    return sources(filename);
  }
  for (const prefix of sources) {
    if (filename.indexOf(prefix) !== -1) {
      return true;
    }
  }
  return false;
}
function compileProgram(program, pass) {
  var _a;
  if (shouldSkipCompilation(program, pass)) {
    return null;
  }
  const restrictedImportsErr = validateRestrictedImports(
    program,
    pass.opts.environment
  );
  if (restrictedImportsErr) {
    handleError(restrictedImportsErr, pass, null);
    return null;
  }
  const suppressions = findProgramSuppressions(
    pass.comments,
    (_a = pass.opts.eslintSuppressionRules) != null ? _a : DEFAULT_ESLINT_SUPPRESSIONS,
    pass.opts.flowSuppressions
  );
  const programContext = new ProgramContext({
    program,
    opts: pass.opts,
    filename: pass.filename,
    code: pass.code,
    suppressions,
    hasModuleScopeOptOut: findDirectiveDisablingMemoization(program.node.directives, pass.opts) != null
  });
  const queue = findFunctionsToCompile(
    program,
    pass,
    programContext
  );
  const compiledFns = [];
  while (queue.length !== 0) {
    const current = queue.shift();
    const compiled = processFn(current.fn, current.fnType, programContext);
    if (compiled != null) {
      for (const outlined of compiled.outlined) {
        CompilerError.invariant(outlined.fn.outlined.length === 0, {
          reason: "Unexpected nested outlined functions",
          loc: outlined.fn.loc
        });
        const fn = insertNewOutlinedFunctionNode(
          program,
          current.fn,
          outlined.fn
        );
        fn.skip();
        programContext.alreadyCompiled.add(fn.node);
        if (outlined.type !== null) {
          queue.push({
            kind: "outlined",
            fn,
            fnType: outlined.type
          });
        }
      }
      compiledFns.push({
        kind: current.kind,
        originalFn: current.fn,
        compiledFn: compiled
      });
    }
  }
  if (programContext.hasModuleScopeOptOut) {
    if (compiledFns.length > 0) {
      const error = new CompilerError();
      error.pushErrorDetail(
        new CompilerErrorDetail({
          reason: "Unexpected compiled functions when module scope opt-out is present",
          severity: "Invariant" /* Invariant */,
          category: "Invariant" /* Invariant */,
          loc: null
        })
      );
      handleError(error, programContext, null);
    }
    return null;
  }
  applyCompiledFunctions(program, compiledFns, pass, programContext);
  return {
    retryErrors: programContext.retryErrors,
    inferredEffectLocations: programContext.inferredEffectLocations
  };
}
function findFunctionsToCompile(program, pass, programContext) {
  var _a;
  const queue = [];
  const traverseFunction2 = (fn, pass2) => {
    if (pass2.opts.compilationMode === "all" && fn.scope.getProgramParent() !== fn.scope.parent) {
      return;
    }
    const fnType = getReactFunctionType(fn, pass2);
    if (pass2.opts.environment.validateNoDynamicallyCreatedComponentsOrHooks) {
      validateNoDynamicallyCreatedComponentsOrHooks(fn, pass2, programContext);
    }
    if (fnType === null || programContext.alreadyCompiled.has(fn.node)) {
      return;
    }
    programContext.alreadyCompiled.add(fn.node);
    fn.skip();
    queue.push({ kind: "original", fn, fnType });
  };
  program.traverse(
    {
      ClassDeclaration(node) {
        node.skip();
      },
      ClassExpression(node) {
        node.skip();
      },
      FunctionDeclaration: traverseFunction2,
      FunctionExpression: traverseFunction2,
      ArrowFunctionExpression: traverseFunction2
    },
    __spreadProps(__spreadValues({}, pass), {
      opts: __spreadValues(__spreadValues({}, pass.opts), pass.opts),
      filename: (_a = pass.filename) != null ? _a : null
    })
  );
  return queue;
}
function processFn(fn, fnType, programContext) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  let directives;
  if (fn.node.body.type !== "BlockStatement") {
    directives = {
      optIn: null,
      optOut: null
    };
  } else {
    const optIn = tryFindDirectiveEnablingMemoization(
      fn.node.body.directives,
      programContext.opts
    );
    if (optIn.isErr()) {
      handleError(optIn.unwrapErr(), programContext, (_a = fn.node.loc) != null ? _a : null);
      return null;
    }
    directives = {
      optIn: optIn.unwrapOr(null),
      optOut: findDirectiveDisablingMemoization(
        fn.node.body.directives,
        programContext.opts
      )
    };
  }
  let compiledFn;
  const compileResult = tryCompileFunction(fn, fnType, programContext);
  if (compileResult.kind === "error") {
    if (directives.optOut != null) {
      logError(compileResult.error, programContext, (_b = fn.node.loc) != null ? _b : null);
    } else {
      handleError(compileResult.error, programContext, (_c = fn.node.loc) != null ? _c : null);
    }
    const retryResult = retryCompileFunction(fn, fnType, programContext);
    if (retryResult == null) {
      return null;
    }
    compiledFn = retryResult;
  } else {
    compiledFn = compileResult.compiledFn;
  }
  if (programContext.opts.ignoreUseNoForget === false && directives.optOut != null) {
    programContext.logEvent({
      kind: "CompileSkip",
      fnLoc: (_d = fn.node.body.loc) != null ? _d : null,
      reason: `Skipped due to '${directives.optOut.value}' directive.`,
      loc: (_e = directives.optOut.loc) != null ? _e : null
    });
    return null;
  }
  programContext.logEvent({
    kind: "CompileSuccess",
    fnLoc: (_f = fn.node.loc) != null ? _f : null,
    fnName: (_h = (_g = compiledFn.id) == null ? void 0 : _g.name) != null ? _h : null,
    memoSlots: compiledFn.memoSlotsUsed,
    memoBlocks: compiledFn.memoBlocks,
    memoValues: compiledFn.memoValues,
    prunedMemoBlocks: compiledFn.prunedMemoBlocks,
    prunedMemoValues: compiledFn.prunedMemoValues
  });
  if (programContext.hasModuleScopeOptOut) {
    return null;
  } else if (programContext.opts.noEmit) {
    for (const loc of compiledFn.inferredEffectLocations) {
      if (loc !== GeneratedSource) {
        programContext.inferredEffectLocations.add(loc);
      }
    }
    return null;
  } else if (programContext.opts.compilationMode === "annotation" && directives.optIn == null) {
    return null;
  } else {
    return compiledFn;
  }
}
function tryCompileFunction(fn, fnType, programContext) {
  const suppressionsInFunction = filterSuppressionsThatAffectFunction(
    programContext.suppressions,
    fn
  );
  if (suppressionsInFunction.length > 0) {
    return {
      kind: "error",
      error: suppressionsToCompilerError(suppressionsInFunction)
    };
  }
  try {
    return {
      kind: "compile",
      compiledFn: compileFn(
        fn,
        programContext.opts.environment,
        fnType,
        "all_features",
        programContext,
        programContext.opts.logger,
        programContext.filename,
        programContext.code
      )
    };
  } catch (err) {
    return { kind: "error", error: err };
  }
}
function retryCompileFunction(fn, fnType, programContext) {
  const environment = programContext.opts.environment;
  if (!(environment.enableFire || environment.inferEffectDependencies != null)) {
    return null;
  }
  try {
    const retryResult = compileFn(
      fn,
      environment,
      fnType,
      "no_inferred_memo",
      programContext,
      programContext.opts.logger,
      programContext.filename,
      programContext.code
    );
    if (!retryResult.hasFireRewrite && !retryResult.hasInferredEffect) {
      return null;
    }
    return retryResult;
  } catch (err) {
    if (err instanceof CompilerError) {
      programContext.retryErrors.push({ fn, error: err });
    }
    return null;
  }
}
function applyCompiledFunctions(program, compiledFns, pass, programContext) {
  var _a, _b;
  let referencedBeforeDeclared = null;
  for (const result of compiledFns) {
    const { kind, originalFn, compiledFn } = result;
    const transformedFn = createNewFunctionNode(originalFn, compiledFn);
    programContext.alreadyCompiled.add(transformedFn);
    let dynamicGating = null;
    if (originalFn.node.body.type === "BlockStatement") {
      const result2 = findDirectivesDynamicGating(
        originalFn.node.body.directives,
        pass.opts
      );
      if (result2.isOk()) {
        dynamicGating = (_b = (_a = result2.unwrap()) == null ? void 0 : _a.gating) != null ? _b : null;
      }
    }
    const functionGating = dynamicGating != null ? dynamicGating : pass.opts.gating;
    if (kind === "original" && functionGating != null) {
      referencedBeforeDeclared != null ? referencedBeforeDeclared : referencedBeforeDeclared = getFunctionReferencedBeforeDeclarationAtTopLevel(program, compiledFns);
      insertGatedFunctionDeclaration(
        originalFn,
        transformedFn,
        programContext,
        functionGating,
        referencedBeforeDeclared.has(result)
      );
    } else {
      originalFn.replaceWith(transformedFn);
    }
  }
  if (compiledFns.length > 0) {
    addImportsToProgram(program, programContext);
  }
}
function shouldSkipCompilation(program, pass) {
  if (pass.opts.sources) {
    if (pass.filename === null) {
      const error = new CompilerError();
      error.pushErrorDetail(
        new CompilerErrorDetail({
          reason: `Expected a filename but found none.`,
          description: "When the 'sources' config options is specified, the React compiler will only compile files with a name",
          severity: "InvalidConfig" /* InvalidConfig */,
          category: "Config" /* Config */,
          loc: null
        })
      );
      handleError(error, pass, null);
      return true;
    }
    if (!isFilePartOfSources(pass.opts.sources, pass.filename)) {
      return true;
    }
  }
  if (hasMemoCacheFunctionImport(
    program,
    getReactCompilerRuntimeModule(pass.opts.target)
  )) {
    return true;
  }
  return false;
}
function validateNoDynamicallyCreatedComponentsOrHooks(fn, pass, programContext) {
  const parentNameExpr = getFunctionName2(fn);
  const parentName = parentNameExpr !== null && parentNameExpr.isIdentifier() ? parentNameExpr.node.name : "<anonymous>";
  const validateNestedFunction = (nestedFn) => {
    var _a, _b, _c, _d;
    if (nestedFn.node === fn.node || programContext.alreadyCompiled.has(nestedFn.node)) {
      return;
    }
    if (nestedFn.scope.getProgramParent() !== nestedFn.scope.parent) {
      const nestedFnType = getReactFunctionType(nestedFn, pass);
      const nestedFnNameExpr = getFunctionName2(nestedFn);
      const nestedName = nestedFnNameExpr !== null && nestedFnNameExpr.isIdentifier() ? nestedFnNameExpr.node.name : "<anonymous>";
      if (nestedFnType === "Component" || nestedFnType === "Hook") {
        CompilerError.throwDiagnostic({
          category: "Factories" /* Factories */,
          severity: "InvalidReact" /* InvalidReact */,
          reason: `Components and hooks cannot be created dynamically`,
          description: `The function \`${nestedName}\` appears to be a React ${nestedFnType.toLowerCase()}, but it's defined inside \`${parentName}\`. Components and Hooks should always be declared at module scope`,
          details: [
            {
              kind: "error",
              message: "this function dynamically created a component/hook",
              loc: (_b = (_a = parentNameExpr == null ? void 0 : parentNameExpr.node.loc) != null ? _a : fn.node.loc) != null ? _b : null
            },
            {
              kind: "error",
              message: "the component is created here",
              loc: (_d = (_c = nestedFnNameExpr == null ? void 0 : nestedFnNameExpr.node.loc) != null ? _c : nestedFn.node.loc) != null ? _d : null
            }
          ]
        });
      }
    }
    nestedFn.skip();
  };
  fn.traverse({
    FunctionDeclaration: validateNestedFunction,
    FunctionExpression: validateNestedFunction,
    ArrowFunctionExpression: validateNestedFunction
  });
}
function getReactFunctionType(fn, pass) {
  var _a, _b;
  const hookPattern = pass.opts.environment.hookPattern;
  if (fn.node.body.type === "BlockStatement") {
    const optInDirectives = tryFindDirectiveEnablingMemoization(
      fn.node.body.directives,
      pass.opts
    );
    if (optInDirectives.unwrapOr(null) != null) {
      return (_a = getComponentOrHookLike(fn, hookPattern)) != null ? _a : "Other";
    }
  }
  let componentSyntaxType = null;
  if (fn.isFunctionDeclaration()) {
    if (isComponentDeclaration(fn.node)) {
      componentSyntaxType = "Component";
    } else if (isHookDeclaration(fn.node)) {
      componentSyntaxType = "Hook";
    }
  }
  switch (pass.opts.compilationMode) {
    case "annotation": {
      return null;
    }
    case "infer": {
      return componentSyntaxType != null ? componentSyntaxType : getComponentOrHookLike(fn, hookPattern);
    }
    case "syntax": {
      return componentSyntaxType;
    }
    case "all": {
      return (_b = getComponentOrHookLike(fn, hookPattern)) != null ? _b : "Other";
    }
    default: {
      assertExhaustive(
        pass.opts.compilationMode,
        `Unexpected compilationMode \`${pass.opts.compilationMode}\``
      );
    }
  }
}
function hasMemoCacheFunctionImport(program, moduleName) {
  let hasUseMemoCache = false;
  program.traverse({
    ImportSpecifier(path) {
      const imported = path.get("imported");
      let importedName = null;
      if (imported.isIdentifier()) {
        importedName = imported.node.name;
      } else if (imported.isStringLiteral()) {
        importedName = imported.node.value;
      }
      if (importedName === "c" && path.parentPath.isImportDeclaration() && path.parentPath.get("source").node.value === moduleName) {
        hasUseMemoCache = true;
      }
    }
  });
  return hasUseMemoCache;
}
function isHookName2(s, hookPattern) {
  if (hookPattern !== null) {
    return new RegExp(hookPattern).test(s);
  }
  return /^use[A-Z0-9]/.test(s);
}
function isHook(path, hookPattern) {
  if (path.isIdentifier()) {
    return isHookName2(path.node.name, hookPattern);
  } else if (path.isMemberExpression() && !path.node.computed && isHook(path.get("property"), hookPattern)) {
    const obj = path.get("object").node;
    const isPascalCaseNameSpace = /^[A-Z].*/;
    return obj.type === "Identifier" && isPascalCaseNameSpace.test(obj.name);
  } else {
    return false;
  }
}
function isComponentName(path) {
  return path.isIdentifier() && /^[A-Z]/.test(path.node.name);
}
function isReactAPI(path, functionName) {
  const node = path.node;
  return node.type === "Identifier" && node.name === functionName || node.type === "MemberExpression" && node.object.type === "Identifier" && node.object.name === "React" && node.property.type === "Identifier" && node.property.name === functionName;
}
function isForwardRefCallback(path) {
  return !!(path.parentPath.isCallExpression() && path.parentPath.get("callee").isExpression() && isReactAPI(path.parentPath.get("callee"), "forwardRef"));
}
function isMemoCallback(path) {
  return path.parentPath.isCallExpression() && path.parentPath.get("callee").isExpression() && isReactAPI(path.parentPath.get("callee"), "memo");
}
function isValidPropsAnnotation(annot) {
  if (annot == null) {
    return true;
  } else if (annot.type === "TSTypeAnnotation") {
    switch (annot.typeAnnotation.type) {
      case "TSArrayType":
      case "TSBigIntKeyword":
      case "TSBooleanKeyword":
      case "TSConstructorType":
      case "TSFunctionType":
      case "TSLiteralType":
      case "TSNeverKeyword":
      case "TSNumberKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSTupleType":
        return false;
    }
    return true;
  } else if (annot.type === "TypeAnnotation") {
    switch (annot.typeAnnotation.type) {
      case "ArrayTypeAnnotation":
      case "BooleanLiteralTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "FunctionTypeAnnotation":
      case "NumberLiteralTypeAnnotation":
      case "NumberTypeAnnotation":
      case "StringLiteralTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "TupleTypeAnnotation":
        return false;
    }
    return true;
  } else if (annot.type === "Noop") {
    return true;
  } else {
    assertExhaustive(annot, `Unexpected annotation node \`${annot}\``);
  }
}
function isValidComponentParams(params) {
  if (params.length === 0) {
    return true;
  } else if (params.length > 0 && params.length <= 2) {
    if (!isValidPropsAnnotation(params[0].node.typeAnnotation)) {
      return false;
    }
    if (params.length === 1) {
      return !params[0].isRestElement();
    } else if (params[1].isIdentifier()) {
      const { name } = params[1].node;
      return name.includes("ref") || name.includes("Ref");
    } else {
      return false;
    }
  }
  return false;
}
function getComponentOrHookLike(node, hookPattern) {
  const functionName = getFunctionName2(node);
  if (functionName !== null && isComponentName(functionName)) {
    let isComponent = callsHooksOrCreatesJsx(node, hookPattern) && isValidComponentParams(node.get("params")) && !returnsNonNode(node);
    return isComponent ? "Component" : null;
  } else if (functionName !== null && isHook(functionName, hookPattern)) {
    return callsHooksOrCreatesJsx(node, hookPattern) ? "Hook" : null;
  }
  if (node.isFunctionExpression() || node.isArrowFunctionExpression()) {
    if (isForwardRefCallback(node) || isMemoCallback(node)) {
      return callsHooksOrCreatesJsx(node, hookPattern) ? "Component" : null;
    }
  }
  return null;
}
function skipNestedFunctions(node) {
  return (fn) => {
    if (fn.node !== node.node) {
      fn.skip();
    }
  };
}
function callsHooksOrCreatesJsx(node, hookPattern) {
  let invokesHooks = false;
  let createsJsx = false;
  node.traverse({
    JSX() {
      createsJsx = true;
    },
    CallExpression(call) {
      const callee = call.get("callee");
      if (callee.isExpression() && isHook(callee, hookPattern)) {
        invokesHooks = true;
      }
    },
    ArrowFunctionExpression: skipNestedFunctions(node),
    FunctionExpression: skipNestedFunctions(node),
    FunctionDeclaration: skipNestedFunctions(node)
  });
  return invokesHooks || createsJsx;
}
function isNonNode(node) {
  if (!node) {
    return true;
  }
  switch (node.type) {
    case "ObjectExpression":
    case "ArrowFunctionExpression":
    case "FunctionExpression":
    case "BigIntLiteral":
    case "ClassExpression":
    case "NewExpression":
      return true;
  }
  return false;
}
function returnsNonNode(node) {
  let returnsNonNode2 = false;
  if (
    // node.traverse#ArrowFunctionExpression isn't called for the root node
    node.type === "ArrowFunctionExpression" && node.node.body.type !== "BlockStatement"
  ) {
    returnsNonNode2 = isNonNode(node.node.body);
  }
  node.traverse({
    ReturnStatement(ret) {
      returnsNonNode2 = isNonNode(ret.node.argument);
    },
    // Skip traversing all nested functions and their return statements
    ArrowFunctionExpression: skipNestedFunctions(node),
    FunctionExpression: skipNestedFunctions(node),
    FunctionDeclaration: skipNestedFunctions(node),
    ObjectMethod: (node2) => node2.skip()
  });
  return returnsNonNode2;
}
function getFunctionName2(path) {
  if (path.isFunctionDeclaration()) {
    const id2 = path.get("id");
    if (id2.isIdentifier()) {
      return id2;
    }
    return null;
  }
  let id = null;
  const parent = path.parentPath;
  if (parent.isVariableDeclarator() && parent.get("init").node === path.node) {
    id = parent.get("id");
  } else if (parent.isAssignmentExpression() && parent.get("right").node === path.node && parent.get("operator") === "=") {
    id = parent.get("left");
  } else if (parent.isProperty() && parent.get("value").node === path.node && !parent.get("computed") && parent.get("key").isLVal()) {
    id = parent.get("key");
  } else if (parent.isAssignmentPattern() && parent.get("right").node === path.node && !parent.get("computed")) {
    id = parent.get("left");
  }
  if (id !== null && (id.isIdentifier() || id.isMemberExpression())) {
    return id;
  } else {
    return null;
  }
}
function getFunctionReferencedBeforeDeclarationAtTopLevel(program, fns) {
  const fnNames = new Map(
    fns.map((fn) => [
      getFunctionName2(fn.originalFn),
      fn
    ]).filter(
      (entry) => !!entry[0] && entry[0].isIdentifier()
    ).map((entry) => [entry[0].node.name, { id: entry[0].node, fn: entry[1] }])
  );
  const referencedBeforeDeclaration = /* @__PURE__ */ new Set();
  program.traverse({
    TypeAnnotation(path) {
      path.skip();
    },
    TSTypeAnnotation(path) {
      path.skip();
    },
    TypeAlias(path) {
      path.skip();
    },
    TSTypeAliasDeclaration(path) {
      path.skip();
    },
    Identifier(id) {
      const fn = fnNames.get(id.node.name);
      if (!fn) {
        return;
      }
      if (id.node === fn.id) {
        fnNames.delete(id.node.name);
        return;
      }
      const scope = id.scope.getFunctionParent();
      if (scope === null && id.isReferencedIdentifier()) {
        referencedBeforeDeclaration.add(fn.fn);
      }
    }
  });
  return referencedBeforeDeclaration;
}
function getReactCompilerRuntimeModule(target) {
  if (target === "19") {
    return "react/compiler-runtime";
  } else if (target === "17" || target === "18") {
    return "react-compiler-runtime";
  } else {
    CompilerError.invariant(
      target != null && target.kind === "donotuse_meta_internal" && typeof target.runtimeModule === "string",
      {
        reason: "Expected target to already be validated",
        description: null,
        loc: null,
        suggestions: null
      }
    );
    return target.runtimeModule;
  }
}

// src/Entrypoint/Imports.ts
function validateRestrictedImports(path, { validateBlocklistedImports }) {
  if (validateBlocklistedImports == null || validateBlocklistedImports.length === 0) {
    return null;
  }
  const error = new CompilerError();
  const restrictedImports = new Set(validateBlocklistedImports);
  path.traverse({
    ImportDeclaration(importDeclPath) {
      var _a;
      if (restrictedImports.has(importDeclPath.node.source.value)) {
        error.push({
          category: "Todo" /* Todo */,
          severity: "Todo" /* Todo */,
          reason: "Bailing out due to blocklisted import",
          description: `Import from module ${importDeclPath.node.source.value}`,
          loc: (_a = importDeclPath.node.loc) != null ? _a : null
        });
      }
    }
  });
  if (error.hasErrors()) {
    return error;
  } else {
    return null;
  }
}
var ProgramContext = class {
  constructor({
    program,
    suppressions,
    opts,
    filename,
    code,
    hasModuleScopeOptOut
  }) {
    /*
     * This is a hack to work around what seems to be a Babel bug. Babel doesn't
     * consistently respect the `skip()` function to avoid revisiting a node within
     * a pass, so we use this set to track nodes that we have compiled.
     */
    this.alreadyCompiled = new (WeakSet != null ? WeakSet : Set)();
    // known generated or referenced identifiers in the program
    this.knownReferencedNames = /* @__PURE__ */ new Set();
    // generated imports
    this.imports = /* @__PURE__ */ new Map();
    /**
     * Metadata from compilation
     */
    this.retryErrors = [];
    this.inferredEffectLocations = /* @__PURE__ */ new Set();
    this.scope = program.scope;
    this.opts = opts;
    this.filename = filename;
    this.code = code;
    this.reactRuntimeModule = getReactCompilerRuntimeModule(opts.target);
    this.suppressions = suppressions;
    this.hasModuleScopeOptOut = hasModuleScopeOptOut;
  }
  isHookName(name) {
    if (this.opts.environment.hookPattern == null) {
      return isHookName(name);
    } else {
      const match = new RegExp(this.opts.environment.hookPattern).exec(name);
      return match != null && typeof match[1] === "string" && isHookName(match[1]);
    }
  }
  hasReference(name) {
    return this.knownReferencedNames.has(name) || this.scope.hasBinding(name) || this.scope.hasGlobal(name) || this.scope.hasReference(name);
  }
  newUid(name) {
    let uid;
    if (this.isHookName(name)) {
      uid = name;
      let i = 0;
      while (this.hasReference(uid)) {
        this.knownReferencedNames.add(uid);
        uid = `${name}_${i++}`;
      }
    } else if (!this.hasReference(name)) {
      uid = name;
    } else {
      uid = this.scope.generateUid(name);
    }
    this.knownReferencedNames.add(uid);
    return uid;
  }
  addMemoCacheImport() {
    return this.addImportSpecifier(
      {
        source: this.reactRuntimeModule,
        importSpecifierName: "c"
      },
      "_c"
    );
  }
  /**
   *
   * @param externalFunction
   * @param nameHint if defined, will be used as the name of the import specifier
   * @returns
   */
  addImportSpecifier({ source: module2, importSpecifierName: specifier }, nameHint) {
    var _a;
    const maybeBinding = (_a = this.imports.get(module2)) == null ? void 0 : _a.get(specifier);
    if (maybeBinding != null) {
      return __spreadValues({}, maybeBinding);
    }
    const binding = {
      kind: "ImportSpecifier",
      name: this.newUid(nameHint != null ? nameHint : specifier),
      module: module2,
      imported: specifier
    };
    getOrInsertWith(this.imports, module2, () => /* @__PURE__ */ new Map()).set(specifier, __spreadValues({}, binding));
    return binding;
  }
  addNewReference(name) {
    this.knownReferencedNames.add(name);
  }
  assertGlobalBinding(name, localScope) {
    var _a, _b;
    const scope = localScope != null ? localScope : this.scope;
    if (!scope.hasReference(name) && !scope.hasBinding(name)) {
      return Ok(void 0);
    }
    const error = new CompilerError();
    error.push({
      category: "Todo" /* Todo */,
      severity: "Todo" /* Todo */,
      reason: "Encountered conflicting global in generated program",
      description: `Conflict from local binding ${name}`,
      loc: (_b = (_a = scope.getBinding(name)) == null ? void 0 : _a.path.node.loc) != null ? _b : null,
      suggestions: null
    });
    return Err(error);
  }
  logEvent(event) {
    if (this.opts.logger != null) {
      this.opts.logger.logEvent(this.filename, event);
    }
  }
};
function getExistingImports(program) {
  const existingImports = /* @__PURE__ */ new Map();
  program.traverse({
    ImportDeclaration(path) {
      if (isNonNamespacedImport(path)) {
        existingImports.set(path.node.source.value, path);
      }
    }
  });
  return existingImports;
}
function addImportsToProgram(path, programContext) {
  const existingImports = getExistingImports(path);
  const stmts = [];
  const sortedModules = [...programContext.imports.entries()].sort(
    ([a], [b]) => a.localeCompare(b)
  );
  for (const [moduleName, importsMap] of sortedModules) {
    for (const [specifierName, loweredImport] of importsMap) {
      CompilerError.invariant(
        path.scope.getBinding(loweredImport.name) == null,
        {
          reason: "Encountered conflicting import specifiers in generated program",
          description: `Conflict from import ${loweredImport.module}:(${loweredImport.imported} as ${loweredImport.name}).`,
          loc: GeneratedSource,
          suggestions: null
        }
      );
      CompilerError.invariant(
        loweredImport.module === moduleName && loweredImport.imported === specifierName,
        {
          reason: "Found inconsistent import specifier. This is an internal bug.",
          description: `Expected import ${moduleName}:${specifierName} but found ${loweredImport.module}:${loweredImport.imported}`,
          loc: GeneratedSource
        }
      );
    }
    const sortedImport = [
      ...importsMap.values()
    ].sort(({ imported: a }, { imported: b }) => a.localeCompare(b));
    const importSpecifiers = sortedImport.map((specifier) => {
      return t5.importSpecifier(
        t5.identifier(specifier.name),
        t5.identifier(specifier.imported)
      );
    });
    const maybeExistingImports = existingImports.get(moduleName);
    if (maybeExistingImports != null) {
      maybeExistingImports.pushContainer("specifiers", importSpecifiers);
    } else {
      stmts.push(
        t5.importDeclaration(importSpecifiers, t5.stringLiteral(moduleName))
      );
    }
  }
  path.unshiftContainer("body", stmts);
}
function isNonNamespacedImport(importDeclPath) {
  return importDeclPath.get("specifiers").every((specifier) => specifier.isImportSpecifier()) && importDeclPath.node.importKind !== "type" && importDeclPath.node.importKind !== "typeof";
}

// src/Entrypoint/Options.ts
var PanicThresholdOptionsSchema = z.enum([
  /*
   * Any errors will panic the compiler by throwing an exception, which will
   * bubble up to the nearest exception handler above the Forget transform.
   * If Forget is invoked through `BabelPluginReactCompiler`, this will at the least
   * skip Forget compilation for the rest of current file.
   */
  "all_errors",
  /*
   * Panic by throwing an exception only on critical or unrecognized errors.
   * For all other errors, skip the erroring function without inserting
   * a Forget-compiled version (i.e. same behavior as noEmit).
   */
  "critical_errors",
  // Never panic by throwing an exception.
  "none"
]);
var DynamicGatingOptionsSchema = z.object({
  source: z.string()
});
var CustomOptOutDirectiveSchema = z.nullable(z.array(z.string())).default(null);
var CompilerReactTargetSchema = z.union([
  z.literal("17"),
  z.literal("18"),
  z.literal("19"),
  /**
   * Used exclusively for Meta apps which are guaranteed to have compatible
   * react runtime and compiler versions. Note that only the FB-internal bundles
   * re-export useMemoCache (see
   * https://github.com/facebook/react/blob/5b0ef217ef32333a8e56f39be04327c89efa346f/packages/react/index.fb.js#L68-L70),
   * so this option is invalid / creates runtime errors for open-source users.
   */
  z.object({
    kind: z.literal("donotuse_meta_internal"),
    runtimeModule: z.string().default("react")
  })
]);
var CompilationModeSchema = z.enum([
  /*
   * Compiles functions annotated with "use forget" or component/hook-like functions.
   * This latter includes:
   * * Components declared with component syntax.
   * * Functions which can be inferred to be a component or hook:
   *   - Be named like a hook or component. This logic matches the ESLint rule.
   *   - *and* create JSX and/or call a hook. This is an additional check to help prevent
   *     false positives, since compilation has a greater impact than linting.
   * This is the default mode
   */
  "infer",
  // Compile only components using Flow component syntax and hooks using hook syntax.
  "syntax",
  // Compile only functions which are explicitly annotated with "use forget"
  "annotation",
  // Compile all top-level functions
  "all"
]);
var defaultOptions = {
  compilationMode: "infer",
  panicThreshold: "none",
  environment: parseEnvironmentConfig({}).unwrap(),
  logger: null,
  gating: null,
  noEmit: false,
  dynamicGating: null,
  eslintSuppressionRules: null,
  flowSuppressions: true,
  ignoreUseNoForget: false,
  sources: (filename) => {
    return filename.indexOf("node_modules") === -1;
  },
  enableReanimatedCheck: true,
  customOptOutDirectives: null,
  target: "19"
};
function parsePluginOptions(obj) {
  if (obj == null || typeof obj !== "object") {
    return defaultOptions;
  }
  const parsedOptions = /* @__PURE__ */ Object.create(null);
  for (let [key2, value] of Object.entries(obj)) {
    if (typeof value === "string") {
      value = value.toLowerCase();
    }
    if (isCompilerFlag(key2)) {
      switch (key2) {
        case "environment": {
          const environmentResult = parseEnvironmentConfig(value);
          if (environmentResult.isErr()) {
            CompilerError.throwInvalidConfig({
              reason: "Error in validating environment config. This is an advanced setting and not meant to be used directly",
              description: environmentResult.unwrapErr().toString(),
              suggestions: null,
              loc: null
            });
          }
          parsedOptions[key2] = environmentResult.unwrap();
          break;
        }
        case "target": {
          parsedOptions[key2] = parseTargetConfig(value);
          break;
        }
        case "gating": {
          if (value == null) {
            parsedOptions[key2] = null;
          } else {
            parsedOptions[key2] = tryParseExternalFunction(value);
          }
          break;
        }
        case "dynamicGating": {
          if (value == null) {
            parsedOptions[key2] = null;
          } else {
            const result = DynamicGatingOptionsSchema.safeParse(value);
            if (result.success) {
              parsedOptions[key2] = result.data;
            } else {
              CompilerError.throwInvalidConfig({
                reason: "Could not parse dynamic gating. Update React Compiler config to fix the error",
                description: `${fromZodError(result.error)}`,
                loc: null,
                suggestions: null
              });
            }
          }
          break;
        }
        case "customOptOutDirectives": {
          const result = CustomOptOutDirectiveSchema.safeParse(value);
          if (result.success) {
            parsedOptions[key2] = result.data;
          } else {
            CompilerError.throwInvalidConfig({
              reason: "Could not parse custom opt out directives. Update React Compiler config to fix the error",
              description: `${fromZodError(result.error)}`,
              loc: null,
              suggestions: null
            });
          }
          break;
        }
        default: {
          parsedOptions[key2] = value;
        }
      }
    }
  }
  return __spreadValues(__spreadValues({}, defaultOptions), parsedOptions);
}
function parseTargetConfig(value) {
  const parsed = CompilerReactTargetSchema.safeParse(value);
  if (parsed.success) {
    return parsed.data;
  } else {
    CompilerError.throwInvalidConfig({
      reason: "Not a valid target",
      description: `${fromZodError(parsed.error)}`,
      suggestions: null,
      loc: null
    });
  }
}
function isCompilerFlag(s) {
  return hasOwnProperty2(defaultOptions, s);
}

// src/Entrypoint/Reanimated.ts
function hasModule(name) {
  if (typeof require === "undefined") {
    return false;
  }
  try {
    return !!require.resolve(name);
  } catch (error) {
    if (error.code === "MODULE_NOT_FOUND" && error.message.indexOf(name) !== -1) {
      return false;
    }
    throw error;
  }
}
function pipelineUsesReanimatedPlugin(plugins) {
  if (Array.isArray(plugins)) {
    for (const plugin of plugins) {
      if (hasOwnProperty2(plugin, "key")) {
        const key2 = plugin.key;
        if (typeof key2 === "string" && key2.indexOf("react-native-reanimated") !== -1) {
          return true;
        }
      }
    }
  }
  return hasModule("react-native-reanimated");
}
function injectReanimatedFlag(options) {
  return __spreadProps(__spreadValues({}, options), {
    environment: __spreadProps(__spreadValues({}, options.environment), {
      enableCustomTypeDefinitionForReanimated: true
    })
  });
}

// src/Entrypoint/ValidateNoUntransformedReferences.ts
function throwInvalidReact(options, { logger, filename }) {
  const detail = __spreadValues({
    severity: "InvalidReact" /* InvalidReact */
  }, options);
  logger == null ? void 0 : logger.logEvent(filename, {
    kind: "CompileError",
    fnLoc: null,
    detail: new CompilerDiagnostic(detail)
  });
  CompilerError.throwDiagnostic(detail);
}
function isAutodepsSigil(arg) {
  if (arg.isIdentifier() && arg.node.name === "AUTODEPS") {
    const binding = arg.scope.getBinding(arg.node.name);
    if (binding && binding.path.isImportSpecifier()) {
      const importSpecifier2 = binding.path.node;
      if (importSpecifier2.imported.type === "Identifier") {
        return importSpecifier2.imported.name === "AUTODEPS";
      }
    }
    return false;
  }
  if (arg.isMemberExpression() && !arg.node.computed) {
    const object = arg.get("object");
    const property = arg.get("property");
    if (object.isIdentifier() && object.node.name === "React" && property.isIdentifier() && property.node.name === "AUTODEPS") {
      return true;
    }
  }
  return false;
}
function assertValidEffectImportReference(autodepsIndex, paths, context) {
  var _a;
  for (const path of paths) {
    const parent = path.parentPath;
    if (parent != null && parent.isCallExpression()) {
      const args = parent.get("arguments");
      const maybeCalleeLoc = path.node.loc;
      const hasInferredEffect = maybeCalleeLoc != null && context.inferredEffectLocations.has(maybeCalleeLoc);
      const hasAutodepsArg = args.some(isAutodepsSigil);
      if (hasAutodepsArg && !hasInferredEffect) {
        const maybeErrorDiagnostic = matchCompilerDiagnostic(
          path,
          context.transformErrors
        );
        throwInvalidReact(
          {
            category: "AutomaticEffectDependencies" /* AutomaticEffectDependencies */,
            reason: "Cannot infer dependencies of this effect. This will break your build!",
            description: "To resolve, either pass a dependency array or fix reported compiler bailout diagnostics." + (maybeErrorDiagnostic ? ` ${maybeErrorDiagnostic}` : ""),
            details: [
              {
                kind: "error",
                message: "Cannot infer dependencies",
                loc: (_a = parent.node.loc) != null ? _a : GeneratedSource
              }
            ]
          },
          context
        );
      }
    }
  }
}
function assertValidFireImportReference(paths, context) {
  var _a;
  if (paths.length > 0) {
    const maybeErrorDiagnostic = matchCompilerDiagnostic(
      paths[0],
      context.transformErrors
    );
    throwInvalidReact(
      {
        category: "Fire" /* Fire */,
        reason: "[Fire] Untransformed reference to compiler-required feature.",
        description: "Either remove this `fire` call or ensure it is successfully transformed by the compiler" + maybeErrorDiagnostic ? ` ${maybeErrorDiagnostic}` : "",
        details: [
          {
            kind: "error",
            message: "Untransformed `fire` call",
            loc: (_a = paths[0].node.loc) != null ? _a : GeneratedSource
          }
        ]
      },
      context
    );
  }
}
function validateNoUntransformedReferences(path, filename, logger, env, compileResult) {
  const moduleLoadChecks = /* @__PURE__ */ new Map();
  if (env.enableFire) {
    for (const module2 of Environment2.knownReactModules) {
      const react = getOrInsertWith(moduleLoadChecks, module2, () => /* @__PURE__ */ new Map());
      react.set("fire", assertValidFireImportReference);
    }
  }
  if (env.inferEffectDependencies) {
    for (const {
      function: { source: source2, importSpecifierName },
      autodepsIndex
    } of env.inferEffectDependencies) {
      const module2 = getOrInsertWith(moduleLoadChecks, source2, () => /* @__PURE__ */ new Map());
      module2.set(
        importSpecifierName,
        assertValidEffectImportReference.bind(null, autodepsIndex)
      );
    }
  }
  if (moduleLoadChecks.size > 0) {
    transformProgram(path, moduleLoadChecks, filename, logger, compileResult);
  }
}
function validateImportSpecifier(specifier, importSpecifierChecks, state) {
  var _a;
  const imported = specifier.get("imported");
  const specifierName = imported.node.type === "Identifier" ? imported.node.name : imported.node.value;
  const checkFn = importSpecifierChecks.get(specifierName);
  if (checkFn == null) {
    return;
  }
  if (state.shouldInvalidateScopes) {
    state.shouldInvalidateScopes = false;
    state.program.scope.crawl();
  }
  const local = specifier.get("local");
  const binding = local.scope.getBinding(local.node.name);
  CompilerError.invariant(binding != null, {
    reason: "Expected binding to be found for import specifier",
    loc: (_a = local.node.loc) != null ? _a : null
  });
  checkFn(binding.referencePaths, state);
}
function validateNamespacedImport(specifier, importSpecifierChecks, state) {
  var _a;
  if (state.shouldInvalidateScopes) {
    state.shouldInvalidateScopes = false;
    state.program.scope.crawl();
  }
  const local = specifier.get("local");
  const binding = local.scope.getBinding(local.node.name);
  const defaultCheckFn = importSpecifierChecks.get(DEFAULT_EXPORT);
  CompilerError.invariant(binding != null, {
    reason: "Expected binding to be found for import specifier",
    loc: (_a = local.node.loc) != null ? _a : null
  });
  const filteredReferences = /* @__PURE__ */ new Map();
  for (const reference of binding.referencePaths) {
    if (defaultCheckFn != null) {
      getOrInsertWith(filteredReferences, defaultCheckFn, () => []).push(
        reference
      );
    }
    const parent = reference.parentPath;
    if (parent != null && parent.isMemberExpression() && parent.get("object") === reference) {
      if (parent.node.computed || parent.node.property.type !== "Identifier") {
        continue;
      }
      const checkFn = importSpecifierChecks.get(parent.node.property.name);
      if (checkFn != null) {
        getOrInsertWith(filteredReferences, checkFn, () => []).push(parent);
      }
    }
  }
  for (const [checkFn, references] of filteredReferences) {
    checkFn(references, state);
  }
}
function transformProgram(path, moduleLoadChecks, filename, logger, compileResult) {
  var _a, _b;
  const traversalState = {
    shouldInvalidateScopes: true,
    program: path,
    filename,
    logger,
    transformErrors: (_a = compileResult == null ? void 0 : compileResult.retryErrors) != null ? _a : [],
    inferredEffectLocations: (_b = compileResult == null ? void 0 : compileResult.inferredEffectLocations) != null ? _b : /* @__PURE__ */ new Set()
  };
  path.traverse({
    ImportDeclaration(path2) {
      const importSpecifierChecks = moduleLoadChecks.get(
        path2.node.source.value
      );
      if (importSpecifierChecks == null) {
        return;
      }
      const specifiers = path2.get("specifiers");
      for (const specifier of specifiers) {
        if (specifier.isImportSpecifier()) {
          validateImportSpecifier(
            specifier,
            importSpecifierChecks,
            traversalState
          );
        } else {
          validateNamespacedImport(
            specifier,
            importSpecifierChecks,
            traversalState
          );
        }
      }
    }
  });
}
function matchCompilerDiagnostic(badReference, transformErrors) {
  for (const { fn, error } of transformErrors) {
    if (fn.isAncestor(badReference)) {
      return error.toString();
    }
  }
  return null;
}

// src/Babel/BabelPlugin.ts
var ENABLE_REACT_COMPILER_TIMINGS = process.env["ENABLE_REACT_COMPILER_TIMINGS"] === "1";
function BabelPluginReactCompiler(_babel) {
  return {
    name: "react-forget",
    visitor: {
      /*
       * Note: Babel does some "smart" merging of visitors across plugins, so even if A is inserted
       * prior to B, if A does not have a Program visitor and B does, B will run first. We always
       * want Forget to run true to source as possible.
       */
      Program: {
        enter(prog, pass) {
          var _a, _b, _c, _d;
          try {
            const filename = (_a = pass.filename) != null ? _a : "unknown";
            if (ENABLE_REACT_COMPILER_TIMINGS === true) {
              performance.mark(`${filename}:start`, {
                detail: "BabelPlugin:Program:start"
              });
            }
            let opts = parsePluginOptions(pass.opts);
            const isDev = typeof __DEV__ !== "undefined" && __DEV__ === true || process.env["NODE_ENV"] === "development";
            if (opts.enableReanimatedCheck === true && pipelineUsesReanimatedPlugin(pass.file.opts.plugins)) {
              opts = injectReanimatedFlag(opts);
            }
            if (opts.environment.enableResetCacheOnSourceFileChanges !== false && isDev) {
              opts = __spreadProps(__spreadValues({}, opts), {
                environment: __spreadProps(__spreadValues({}, opts.environment), {
                  enableResetCacheOnSourceFileChanges: true
                })
              });
            }
            const result = compileProgram(prog, {
              opts,
              filename: (_b = pass.filename) != null ? _b : null,
              comments: (_c = pass.file.ast.comments) != null ? _c : [],
              code: pass.file.code
            });
            validateNoUntransformedReferences(
              prog,
              (_d = pass.filename) != null ? _d : null,
              opts.logger,
              opts.environment,
              result
            );
            if (ENABLE_REACT_COMPILER_TIMINGS === true) {
              performance.mark(`${filename}:end`, {
                detail: "BabelPlugin:Program:end"
              });
            }
          } catch (e) {
            if (e instanceof CompilerError) {
              throw e.withPrintedMessage(pass.file.code, { eslint: false });
            }
            throw e;
          }
        },
        exit(_, pass) {
          var _a;
          if (ENABLE_REACT_COMPILER_TIMINGS === true) {
            const filename = (_a = pass.filename) != null ? _a : "unknown";
            const measurement = performance.measure(filename, {
              start: `${filename}:start`,
              end: `${filename}:end`,
              detail: "BabelPlugin:Program"
            });
            if ("logger" in pass.opts && pass.opts.logger != null) {
              const logger = pass.opts.logger;
              logger.logEvent(filename, {
                kind: "Timing",
                measurement
              });
            }
          }
        }
      }
    }
  };
}

// src/Babel/RunReactCompilerBabelPlugin.ts
function runBabelPluginReactCompiler(text, file, language, options, includeAst = false) {
  const ast = BabelParser.parse(text, {
    sourceFilename: file,
    plugins: [language, "jsx"],
    sourceType: "module"
  });
  const result = (0, import_core.transformFromAstSync)(ast, text, {
    ast: includeAst,
    filename: file,
    highlightCode: false,
    retainLines: true,
    plugins: [
      [BabelPluginReactCompiler, options],
      "babel-plugin-fbt",
      "babel-plugin-fbt-runtime"
    ],
    sourceType: "module",
    configFile: false,
    babelrc: false
  });
  (0, import_invariant4.default)(
    (result == null ? void 0 : result.code) != null,
    `Expected BabelPluginReactForget to codegen successfully, got: ${result}`
  );
  return result;
}

// src/Utils/TestUtils.ts
function tryParseTestPragmaValue(val) {
  try {
    let parsedVal;
    const stringMatch = /^"([^"]*)"$/.exec(val);
    if (stringMatch && stringMatch.length > 1) {
      parsedVal = stringMatch[1];
    } else {
      parsedVal = JSON.parse(val);
    }
    return Ok(parsedVal);
  } catch (e) {
    return Err(e);
  }
}
var testComplexConfigDefaults = {
  validateNoCapitalizedCalls: [],
  enableChangeDetectionForDebugging: {
    source: "react-compiler-runtime",
    importSpecifierName: "$structuralCheck"
  },
  enableEmitFreeze: {
    source: "react-compiler-runtime",
    importSpecifierName: "makeReadOnly"
  },
  enableEmitInstrumentForget: {
    fn: {
      source: "react-compiler-runtime",
      importSpecifierName: "useRenderCounter"
    },
    gating: {
      source: "react-compiler-runtime",
      importSpecifierName: "shouldInstrument"
    },
    globalGating: "DEV"
  },
  enableEmitHookGuards: {
    source: "react-compiler-runtime",
    importSpecifierName: "$dispatcherGuard"
  },
  inlineJsxTransform: {
    elementSymbol: "react.transitional.element",
    globalDevVar: "DEV"
  },
  lowerContextAccess: {
    source: "react-compiler-runtime",
    importSpecifierName: "useContext_withSelector"
  },
  inferEffectDependencies: [
    {
      function: {
        source: "react",
        importSpecifierName: "useEffect"
      },
      autodepsIndex: 1
    },
    {
      function: {
        source: "shared-runtime",
        importSpecifierName: "useSpecialEffect"
      },
      autodepsIndex: 2
    },
    {
      function: {
        source: "useEffectWrapper",
        importSpecifierName: "default"
      },
      autodepsIndex: 1
    }
  ]
};
function* splitPragma(pragma) {
  for (const entry of pragma.split("@")) {
    const keyVal = entry.trim();
    const valIdx = keyVal.indexOf(":");
    if (valIdx === -1) {
      yield { key: keyVal.split(" ", 1)[0], value: null };
    } else {
      yield { key: keyVal.slice(0, valIdx), value: keyVal.slice(valIdx + 1) };
    }
  }
}
function parseConfigPragmaEnvironmentForTest(pragma, defaultConfig) {
  EnvironmentConfigSchema.parse(defaultConfig);
  const maybeConfig = defaultConfig;
  for (const { key: key2, value: val } of splitPragma(pragma)) {
    if (!hasOwnProperty2(EnvironmentConfigSchema.shape, key2)) {
      continue;
    }
    const isSet = val == null || val === "true";
    if (isSet && key2 in testComplexConfigDefaults) {
      maybeConfig[key2] = testComplexConfigDefaults[key2];
    } else if (isSet) {
      maybeConfig[key2] = true;
    } else if (val === "false") {
      maybeConfig[key2] = false;
    } else if (val) {
      const parsedVal = tryParseTestPragmaValue(val).unwrap();
      if (key2 === "customMacros" && typeof parsedVal === "string") {
        const valSplit = parsedVal.split(".");
        const props = [];
        for (const elt of valSplit.slice(1)) {
          if (elt === "*") {
            props.push({ type: "wildcard" });
          } else if (elt.length > 0) {
            props.push({ type: "name", name: elt });
          }
        }
        maybeConfig[key2] = [[valSplit[0], props]];
        continue;
      }
      maybeConfig[key2] = parsedVal;
    }
  }
  const config = EnvironmentConfigSchema.safeParse(maybeConfig);
  if (config.success) {
    if (config.data.enableResetCacheOnSourceFileChanges == null) {
      config.data.enableResetCacheOnSourceFileChanges = false;
    }
    return config.data;
  }
  CompilerError.invariant(false, {
    reason: "Internal error, could not parse config from pragma string",
    description: `${fromZodError(config.error)}`,
    loc: null,
    suggestions: null
  });
}
var testComplexPluginOptionDefaults = {
  gating: {
    source: "ReactForgetFeatureFlag",
    importSpecifierName: "isForgetEnabled_Fixtures"
  }
};
function parseConfigPragmaForTests(pragma, defaults) {
  var _a;
  const overridePragma = parseConfigPragmaAsString(pragma);
  if (overridePragma !== "") {
    return parseConfigStringAsJS(overridePragma, defaults);
  }
  const environment = parseConfigPragmaEnvironmentForTest(
    pragma,
    (_a = defaults.environment) != null ? _a : {}
  );
  const options = __spreadProps(__spreadValues({}, defaultOptions), {
    panicThreshold: "all_errors",
    compilationMode: defaults.compilationMode,
    environment
  });
  for (const { key: key2, value: val } of splitPragma(pragma)) {
    if (!hasOwnProperty2(defaultOptions, key2)) {
      continue;
    }
    const isSet = val == null || val === "true";
    if (isSet && key2 in testComplexPluginOptionDefaults) {
      options[key2] = testComplexPluginOptionDefaults[key2];
    } else if (isSet) {
      options[key2] = true;
    } else if (val === "false") {
      options[key2] = false;
    } else if (val != null) {
      const parsedVal = tryParseTestPragmaValue(val).unwrap();
      if (key2 === "target" && parsedVal === "donotuse_meta_internal") {
        options[key2] = {
          kind: parsedVal,
          runtimeModule: "react"
        };
      } else {
        options[key2] = parsedVal;
      }
    }
  }
  return parsePluginOptions(options);
}
function parseConfigPragmaAsString(pragma) {
  for (const { key: key2, value: val } of splitPragma(pragma)) {
    if (key2 === "OVERRIDE" && val != null) {
      return val;
    }
  }
  return "";
}
function parseConfigStringAsJS(configString, defaults) {
  var _a;
  let parsedConfig;
  try {
    parsedConfig = new Function(`return ${configString}`)();
  } catch (error) {
    CompilerError.invariant(false, {
      reason: "Failed to parse config pragma as JavaScript object",
      description: `Could not parse: ${configString}. Error: ${error}`,
      loc: null,
      suggestions: null
    });
  }
  console.log("OVERRIDE:", parsedConfig);
  const options = __spreadProps(__spreadValues({}, defaultOptions), {
    panicThreshold: "all_errors",
    compilationMode: defaults.compilationMode,
    environment: (_a = defaults.environment) != null ? _a : defaultOptions.environment
  });
  if (parsedConfig.environment) {
    const mergedEnvironment = __spreadValues(__spreadValues({}, options.environment), parsedConfig.environment);
    const environmentConfig = {};
    for (const [key2, value] of Object.entries(mergedEnvironment)) {
      if (hasOwnProperty2(EnvironmentConfigSchema.shape, key2)) {
        if (value === true && key2 in testComplexConfigDefaults) {
          environmentConfig[key2] = testComplexConfigDefaults[key2];
        } else {
          environmentConfig[key2] = value;
        }
      }
    }
    const validatedEnvironment = EnvironmentConfigSchema.safeParse(environmentConfig);
    if (!validatedEnvironment.success) {
      CompilerError.invariant(false, {
        reason: "Invalid environment configuration in config pragma",
        description: `${fromZodError(validatedEnvironment.error)}`,
        loc: null,
        suggestions: null
      });
    }
    if (validatedEnvironment.data.enableResetCacheOnSourceFileChanges == null) {
      validatedEnvironment.data.enableResetCacheOnSourceFileChanges = false;
    }
    options.environment = validatedEnvironment.data;
  }
  for (const [key2, value] of Object.entries(parsedConfig)) {
    if (key2 === "environment") {
      continue;
    }
    if (hasOwnProperty2(defaultOptions, key2)) {
      if (value === true && key2 in testComplexPluginOptionDefaults) {
        options[key2] = testComplexPluginOptionDefaults[key2];
      } else if (key2 === "target" && value === "donotuse_meta_internal") {
        options[key2] = {
          kind: value,
          runtimeModule: "react"
        };
      } else {
        options[key2] = value;
      }
    }
  }
  return parsePluginOptions(options);
}

// src/index.ts
var index_default = BabelPluginReactCompiler;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  CompilerDiagnostic,
  CompilerError,
  CompilerErrorDetail,
  CompilerSuggestionOperation,
  Effect,
  ErrorSeverity,
  LintRules,
  OPT_IN_DIRECTIVES,
  OPT_OUT_DIRECTIVES,
  ProgramContext,
  ValueKind,
  ValueReason,
  compile,
  compileProgram,
  findDirectiveDisablingMemoization,
  findDirectiveEnablingMemoization,
  parseConfigPragmaAsString,
  parseConfigPragmaForTests,
  parsePluginOptions,
  printFunctionWithOutlined,
  printHIR,
  printReactiveFunction,
  printReactiveFunctionWithOutlined,
  runBabelPluginReactCompiler,
  validateEnvironmentConfig
});
/*! Bundled license information:

react-is/cjs/react-is.production.min.js:
  (** @license React v16.13.1
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-is/cjs/react-is.development.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
